---
title: Redis LFU内存淘汰算法详解
description: 深入分析Redis LFU（Least Frequently Used）算法的实现原理及应用
date: 2024-01-01
category:
  - 数据库
  - Redis
tag:
  - Redis
  - LFU
  - 内存淘汰
  - 算法原理
---

**内存淘汰算法-LFU**

最不频繁淘汰算法，优先淘汰活跃最低、使用频率最低的

**为什么 4.0 引入 LFU**

LRU 能解决大部分场景，但是一下场景

- mart 会被淘汰

![...](images\内存淘汰算法-LFU.001.png)

**LFU**

回顾一下 redisObject 结构

![...](images\内存淘汰算法-LFU.002.png)

LFU 和 LRU 不会同时开启，因此LFU 会复用 lru 这个字段来统计访问情况

- lru 原本 24 位，LFU 将其拆成高16 + 低 8
- 高 16：存 ldt（Last Decrement Time）
- 低 8：存 logc（Logistic Counter）

key 是否活跃，由这两个字段综合决定

![...](images\内存淘汰算法-LFU.003.png)

- 高 16 位保存上次访问的时间戳，比原来少了 8 位，因此 LFU 下时间精度是 1 分钟
- 👁️2^16 = 65536，如果用秒作为精度，范围太小。用分钟可以表示 1092 小时，范围大点
- 后 8 位存储访问计数

访问计数的 8 bits

- 如果上一次访问时间很久，那么访问计数就会衰减
- 为什么要衰减，因为只是简单的增加访可计数的方法并不完美，访问的热度一直在变，比如一个key,他原来是255,夸张一点，一年没访问了，不该归零么。
- 而本身访问，会增加访问计数。
- 当然，最后起作用的就是访问计数。

**源码分析**

**LFU 数据更新**

![...](images\内存淘汰算法-LFU.004.png)

**第一步，计算次数衰减**

![...](images\内存淘汰算法-LFU.005.png)

**第二步，一定概率增加访问次数**

![...](images\内存淘汰算法-LFU.006.png)

**第三步，更新**

当前时间更新到高16位，次数更新到低8位

