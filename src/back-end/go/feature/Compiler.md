---
# 这是文章的标题
title: Go大致编译过程
# 你可以自定义封面图片
cover: 
# 这是页面的图标
icon: 
# 这是侧边栏的顺序
order: 2
# 设置作者
author: kryiea
# 设置写作时间
date: 2024-11-27
# 一个页面可以有多个分类
category:
  - Go
# 一个页面可以有多个标签
tag:
  - 编译器
# 此页面会在文章列表置顶
sticky: false
# 此页面会出现在星标文章中
star: 
# 你可以自定义页脚
footer: 
# 你可以自定义版权信息
copyright: 
---

了解Go语言的编译大致过程。

<!-- more -->

## Go 编译器
`.go`为后缀的`UTF-8`格式的`Go文本文件`，`.go`最终能被编译成特定机器上的`可执行文件`，离不开**Go语言编译器**的复杂工作。
### 一般编译器

- 一般将编译器分为：编译器前端、优化器、编译器后端。这种编译器被称为三阶段编译器（three-phase compiler）

![1707147903867](http://images.kryiea.cn/img/1707147903867.jpg)

- **编译器前端**：主要专注于理解源程序、扫描解析源程序并进行精准的语义表达。
- **编译器的中间阶段 （Intermediate Representation，IR）**：可能有多个，编译器会使用多个IR阶段、多种数据结构表示代码，并在中间阶段对代码进行多次优化。例如，识别冗余代码、识别内存逃逸等。编译器的中间阶段离不开编译器前端记录的细节。
- **编译器后端**：专注于生成特定目标机器上的程序，这种程序可能是可执行文件，也可能是需要进一步处理的中间形态obj文件、汇编语言等。
### Go 编译器

- Go语言编译器一般缩写为小写的**gc（go compiler）**，需要和大写的**GC（垃圾回收）**进行区分。
- Go语言的编译器遵循了主流编译器采用的经典策略及相似的处理流程和优化规则（例如经典的递归下降的语法解析、抽象语法树的构建）。
- 另外，Go语言编译器有一些特殊的设计，如内存的逃逸等
> 编译器执行流程

![1707147895527](http://images.kryiea.cn/img/1707147895527.jpg)

> 编译器相关源代码位置

Go 语言编译器有关的代码主要位于 `go/src/cmd/compile/internal` 目录下：
![20240205233832](http://images.kryiea.cn/img/20240205233832.png)
## 第一阶段：词法分析和语法分析

- `cmd/compile/internal/syntax`（词法分析器，解析器，语法树）

- 在编译的第一阶段，源代码被 token 化（词法分析），解析（语法分析），并为每个源构造语法树文件。
- 每个语法树都是相应源文件的精确表示，对应于源的各种元素的节点，如表达式，声明和陈述。
- 语法树还包括位置信息用于错误报告和调试信息的创建。
## 第二阶段：语义分析

- `cmd/compile/internal/gc`（类型检查，AST变换）

- **对 AST 进行类型检查**：第一步是名称解析和类型推断，它们确定哪个对象属于哪个标识符，以及每个表达式具有的类型。类型检查包括某些额外的检查，例如 “声明和未使用” 以及确定函数是否终止。
- **在 AST 上也进行了某些转换**：一些节点基于类型信息被细化，死代码消除，函数调用内联和转义分析。
- **语义分析的过程中包含几个重要的操作**：逃逸分析、变量捕获、函数内联、闭包处理。
## 第三阶段：SSA 生成

- `cmd/compile/internal/gc` (转换为SSA)
- `cmd/compile/internal/ssa`(SSA 传递与规则)

- 在此阶段，**抽象语法树（AST）会被转换成静态单赋值（SSA）形式**。**SSA是一种低级别的中间表示法，具有便于实施优化和生成机器代码的特性。**
- 在转换过程中，编译器能够识别并将代码中的特定函数替换为高效的代码片段。
-  在AST转换为SSA的过程中，一些节点会简化为更基本的元素，以便编译器的其他部分可以更容易地使用。例如，内置的复制操作会被替换为内存移动操作，而范围循环则被改写成for循环。
- 接下来，会执行一系列与具体机器无关的优化步骤和规则。这些步骤和规则不特定于任何一种计算机架构，因此它们适用于所有的GOARCH变体。
- 这些通用优化过程包括移除死代码、消除不必要的零值检查、以及删除未使用的代码分支。通用的重写规则主要关注表达式，比如用常数替换特定表达式，优化乘法和浮点运算。
## 第四阶段：机器码生成

- `cmd/compile/internal/ssa` (底层SSA和架构特定的传递)
- `cmd/internal/obj` (生成机器码)

- 编译器的机器相关阶段从“底层”传递开始，此过程将通用值转换成特定于机器的形式。例如，在amd64架构中，可以合并多个加载和存储操作，因为其内存操作数具有这样的能力。
- 需要注意的是，这一底层阶段执行了所有针对特定机器的重写规则，同时也实施了大量的优化措施。
- 当SSA被“降低”至更贴近目标体系结构后，便会启动**最终的代码优化过程**。这个过程包括进行另一轮的死代码消除、将值移动至更接近其使用点的位置、删除从未被读取的局部变量，以及进行寄存器分配。
- 此阶段的其他重要任务包括堆栈框架的布局，这一步骤为局部变量分配堆栈偏移量，并进行指针活动分析，计算每个垃圾收集（GC）安全点上的堆栈指针情况。
- **在SSA生成阶段完成时**，Go函数已被转换成一系列的obj.Prog指令。这些指令随后被传递给装载器`cmd/internal/obj`，**装载器将它们转换为机器代码，并生成最终的目标文件**。目标文件除了包含机器代码外，还包括反射数据、导出数据和调试信息。
