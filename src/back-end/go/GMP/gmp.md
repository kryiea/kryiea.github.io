---
# 这是文章的标题
title: GMP模型
# 你可以自定义封面图片
cover: 
# 这是页面的图标
icon: 
# 这是侧边栏的顺序
order: 1
# 设置作者
author: kryiea
# 设置写作时间
date: 2024-01-01
# 一个页面可以有多个分类
category:
  - Go
  - 并发
# 一个页面可以有多个标签
tag:
  - GMP
  - Go
  - 并发模型
# 此页面会在文章列表置顶
sticky: false
# 此页面会出现在星标文章中
star: 
# 你可以自定义页脚
footer: 
# 你可以自定义版权信息
copyright: 
---

本文详细介绍GMP模型的基本概念及其在Go语言运行时中的作用。

<!-- more -->

## 1. Go 的协程 - goroutine
- Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。
- 虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。
- goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。
- 最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。

## 2. 旧：GM模型
### 2.1 GM符号概念
![20240131144616](http://images.kryiea.cn/img/20240131144616.png)

### 2.2 废弃的调度器模型 GM 是如何实现的
![20240131144658](http://images.kryiea.cn/img/20240131144658.png)
M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。

>老调度器有几个缺点

1. 创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。
2. M 转移 G 会造成延迟和额外的系统负载。
比如当 G 中包含创建新协程的时候，M 创建了 G'，为了继续执行 G，需要把 G'交给 M'执行，也造成了很差的局部性，因为 G'和 G 是相关的，最好放在 M 上执行，而不是其他 M'。
3. 系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。

## 3. 新：GMP模型
### 3.1 GMP符号定义
![20240131144909](http://images.kryiea.cn/img/20240131144909.png)

### 3.2 GMP 模型
在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上
![20240131144952](http://images.kryiea.cn/img/20240131144952.png)