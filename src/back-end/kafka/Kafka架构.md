---
title: Kafka 架构
description: 深入解析Kafka的整体架构、服务层内部架构以及生产者消费者模型
date: 2024-01-01
category:
  - 消息队列
tag:
  - Kafka
  - 架构设计
  - 分布式系统
---

# Kafka 架构

本文详细介绍了Kafka的整体架构设计，包括生产者、服务层和消费者的工作原理。

<!-- more -->

## 一、整体架构

可以把 Kafka 宏观分成3层：生产者、服务层、消费者

- **Producer**：很好理解，就是生产者，在Kafka中，Producer负责创建消息并将其发送到Kafka服务器。Producer是消息的源头，它们将消息发送到特定的主题中，以供Consumer订阅和消费。
- **Server**：即Kafka服务，可以认为是消息的中转站，因为消息不是从生产者直接发送到消费者的，而是先经过一个中转站存放，就像生活中的菜鸟驿站一样Kafka的服务端就担任了菜鸟驿站的角色，但跟菜鸟驿站不同的一点是Server会持久化存储信息，不是说消费了就没有了。
- **Consumer**：即消费者，是Kafka中的另一个重要角色，它们负责订阅主题并消费其中的消息，当生产者向Server传递了消息之后，如果是消费者订阅了对应的主题，那么消费者就会从Server拉取消息做业务处理。

![Kafka整体架构图](images/Kafka%20架构.001.png)

## 二、服务层的内部架构

服务层的内部组成比较丰富：

- **Broker**：可以理解为机器或者节点吧，也可以理解为就是运行Kafka程序的服务器。
- **Topic**：主题是Kafka中的一个核心概念，它是对消息进行分类的一种方式。生产者将消息发送到特定的主题中，而消费者则通过订阅主题来接收相关的消息。但是要注意的是，主题是一个逻辑概念，实际上，一个主题可以被分为多个分区(Partition)，以实现消息的并行处理和负载均衡，数据是存储在Partition这个级别的。
- **Partition**：分区是Kafka中的一个重要概念，它是主题的物理存储单位。每个分区都是一个有序的、不可变的消息序列，可以被独立地读写。分区在物理上对应一个文件夹及文件夹下面的文件，分区的命名规则为主题名称后接"一"连接符，之后再接分区编号，比如TopicA-1就表示主题A得1号分区，每个分区又可以有一至多个副本(Replica)，以提高可用性。

## 三、Producer

::: tip
待补充Producer相关内容
:::

## 四、Server

::: tip
待补充Server相关内容
:::

## 五、Consumer

消费者通过订阅topic，主动拉取消息，消费信息

### 1. 消费形式

1. 不同消费者可以在同一时间对同一主题进行消费
2. 同一消费者可以同一时间从同一主题的不同分片读取信息
3. 如果一个消费者，同时消费多个分片下，无法保证消息之间的先后顺序
4. 如果一个消费者，只消费一个分片，消费顺序即生产顺序，符合队列的先入先出特性

![消费形式示意图](images/Kafka%20架构.002.png)

### 2. 消费是主动拉取

Kafka是需要消费者主动去Broker拉取消息回来消费的。

这样可以让消费者按照自身情况来控制消费速度，根据自身的资源利用情况、业务需要等等因素合理拉取消息。

消费者拉取的频率：max.poll.records，这个参数限制每次拉取返回的消息数量。

### 3. Offset 消息偏移

每条消息在Kafka中会有Partition ID以及OFFSET，通过这两个信息就可以定位到一条消息。

消费者消费消息之后会提交它在某个Partition对应的OFFSET，这样子下一次就可以从这个位置开始消费。

同时，如果一个指定的offset被确认，那么它之前的信息就相当于都确认了，下次消费是从它的下一条消息开始消费。

提交的动作可以是自动周期性进行，也就是每个周期会提交最新的已处理消息。

![Offset消息偏移示意图](images/Kafka%20架构.003.png)

### 4. 消费者组

- Kafka 支持组消费
- 消费者组的意思是将多个消费者组织在一起工作，构成一个小组
- 一个组由一个groupID唯一标识，由消费者这边指定

**组消费的情况：**

1. 同一个消费组中，每个分片只会分配给一个消费者
2. 同一个消费组中，消费者可以被指派多个分片
3. 不同消费组可以同一时间消费同一个主题

![消费者组示意图](images/Kafka%20架构.004.png)

**使用消费者组的优势**

当不使用消费者组时，Kafka不会自动管理分区和消费者之间的关系，需要手动指定消费者要消费的分区，这就意味着如果Partition数量变了，消费者代码就得跟着升级，没法做到自动切换。

### 5. 消费者组的分配策略、再平衡策略

一个消费者组里有多个消费者，分区是按什么规则来分配给这些消费者的呢?

我们可以关注消费端partition.assignment.strategy这个配置，这个参数就是分区的策略，它有如下几种选择:

1. Range Assignor：基于范围的分配策略，将分区按照范围分配给消费者
2. RoundRobin Assignor：基于轮询的分配策略，分区均匀地分配给消费者
3. Sticky Assignor：优先保持当前的分配状态，并尽量减少在再平衡过程中的分区移动
4. CooperativeStickyAssignor：和Sticky Assignor的策略是一样，区别在于未受变动的消费者可以继续消费主题

::: info 触发再平衡的情况
1. **新消费者加入：** 当一个新的消费者加入消费者组时，Kafka需要重新分配分区，以包括新的消费者
2. **消费者离开：** 当一个消费者离开(无论是正常关闭还是崩溃)时，需要重新分配该消费者负责的分区给其他消费者
3. **主题分区变化：** 当主题的分区数量发生变化时(例如，增加新的分区)Kafka需要重新分配这些分区
:::

::: info 再平衡过程
1. **暂停消费：** 在再平衡过程中，消费者会暂停对消息的消费，以防止在重新分配期间发生数据丢失或重复
2. **触发再平衡：** 由消费者组协调器(通常是Kafka集群中的一个Broker)触发再平衡
3. **重新分配分区：** 协调器根据当前消费者组的成员重新分配主题的分区
4. **通知消费者：** 重新分配完成后，协调器会通知所有消费者新的分配情况
5. **恢复消费：** 消费者收到新的分配后，恢复消费，开始处理被分配到的新分区
:::


