---
title: MySQL锁机制详解
description: 深入分析MySQL的锁类型、加锁原理及并发控制机制
date: 2024-01-01
category:
  - 数据库
  - MySQL
tag:
  - MySQL
  - 锁机制
  - 并发控制
  - 性能优化
---

**锁**

**MySQL 有哪些锁？**

根据加锁的范围，可以分为 **全局锁、表级锁和行锁** 三类。

- 全局锁： FTWRL
- 表级锁：表锁、元数据锁、意向锁、AUTO-INC 锁
- 行级锁：Record Lock、Gap Lock、Next-key Lock

**全局锁**

**全局锁用法**

要使用全局锁，则要执行这条命令：

```Plain Text
flush tables with read lock
```
执行后， **整个数据库就处于只读状态了** ，这时其他线程执行以下操作，都会被阻塞：

- 对数据的增删改操作，比如 insert、delete、update等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。

如果要释放全局锁，则要执行这条命令：

```Plain Text
unlock tables
```
当然，当会话断开了，全局锁会被自动释放。

**全局锁应用场景**

全局锁主要应用于做 **全库逻辑备份** ，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

**全局锁的缺点**

加上全局锁，意味着整个数据库都是只读状态。

那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成**业务停滞**。

那有什么其他方式可以避免？

有的，如果数据库的引擎支持的事务支持 **可重复读的隔离级别** ，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。

备份数据库的工具是 **mysqldump**，在使用 **mysqldump** 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务。

这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。

InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。

但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。

**表级锁**

**表级锁类型**

MySQL 里面表级别的锁有这几种：

- 表锁；
- 元数据锁（MDL;
- 意向锁；
- AUTO-INC 锁；

**表锁**

如果我们想对学生表（t\_student）加表锁，可以使用下面的命令：

```SQL
//表级别的共享锁，也就是读锁；
lock tables t\_student read;
//表级别的独占锁，也就是写锁；
lock tables t\_stuent write;
```
**需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作**。

也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。

要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：

```Plain Text
unlock tables
```
另外，当会话退出后，也会释放所有表锁。

不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能， **InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁** 。

**元数据锁**

**元数据：**描述数据库结构、表、列、索引等信息的数据

**元数据锁** （MDL）

我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁** ；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁** ；

MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。

反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。

MDL 不需要显示调用，那它是在什么时候释放的?

MDL 是在事务提交后才会释放，这意味着 **事务执行期间，MDL 是一直持有的** 。

那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：

1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
2. 然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，

那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？

这是因为申请 MDL 锁的操作会形成一个队列，队列中 **写锁获取优先级高于读锁** ，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

**意向锁**

- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」

也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：

```Plain Text
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;
//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```
**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（ *lock tables ... read* ）和独占表锁（ *lock tables ... write* ）发生冲突。**

表锁和行锁是满足读读共享、读写互斥、写写互斥的。

如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。

那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。

**意向锁的目的是为了快速判断表里是否有记录被加锁** 。

**AUTO-INC 锁**

AUTO-INC 锁是特殊的表锁机制：**锁不是在        一个事务提交后才释放，而是再执行完插入语句后就会立即释放** 。

表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO\_INCREMENT 属性实现的。

之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁** 实现的。

**在插入数据时，会加一个表级别的 AUTO-INC 锁** ，然后为被 AUTO\_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO\_INCREMENT 修饰的字段的值是连续递增的。

但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

轻量级锁

在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种 **轻量级的锁** 来实现自增。

一样也是在插入数据的时候，会为被 AUTO\_INCREMENT 修饰的字段加上轻量级锁， **然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁** 。

参数控制 inc 锁 or 轻量级锁

InnoDB 存储引擎提供了个 innodb\_autoinc\_lock\_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

- 当 innodb\_autoinc\_lock\_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 innodb\_autoinc\_lock\_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 innodb\_autoinc\_lock\_mode = 1：
- 普通 insert 语句，自增锁在申请之后就马上释放；
- 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

当 innodb\_autoinc\_lock\_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生 **数据不一致的问题** 。

举个例子，考虑下面场景：

session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后 **两个 session 同时执行向表 t2 中插入数据** 。

如果 innodb\_autoinc\_lock\_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：

- session B 先插入了两个记录，(1,1,1)、(2,2,2)；
- 然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；
- 之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。

可以看到， **session B 的 insert 语句，生成的 id 不连续** 。

当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog\_format=statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。

但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在 **从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致** 。

要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。

所以， **当 innodb\_autoinc\_lock\_mode = 2 时，并且 binlog\_format = row，既能提升并发性，又不会出现数据一致性问题** 。

**行级锁**

**InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁**

前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。

如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为 **锁定读** 。

```Plain Text
//对读取的记录加共享锁
select ... lock in share mode;
//对读取的记录加独占锁
select ... for update;
```
**上面这两条语句必须在一个事务中， 因为当事务提交了，锁就会被释放** ，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。

共享锁（S锁）满足读读共享，读写互斥。

独占锁（X锁）满足写写互斥、读写互斥。

行级锁的类型主要有三类：

- Record Lock，记录锁，也就是仅仅把一条记录锁上；
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
- Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

**Record Lock**

**Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：**

![...](images\锁.001.png)

- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

举个例子

当一个事务执行了下面这条语句：

```Plain Text
mysql > begin;
mysql > select \* from t\_test where id = 1 for update;
```
就是对 t\_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。

当事务执行 commit 后，事务过程中生成的锁都会被释放。

**Gap Lock**

**Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。**

假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别， **间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的** 。

**Next-Key Lock**

**Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。**

**锁上界，不锁下界（？，？]**

假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。

兼容问题

**next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的** 。

比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。

虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。

**插入意向锁 （不是意向锁）**

**一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。**

插入意向锁名字虽然有意向锁，但是它并 **不是意向锁，它是一种特殊的间隙锁，属于行级别锁** 。

如果有的话，插入操作就会发生 **阻塞** ，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个 **插入意向锁** ，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。

当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（ *PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁* ），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。

如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。

插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。

**加锁**

**什么 sql 会加锁**

通的 select 语句是不会对记录加锁的，因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。

如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为 **锁定读** 

```Plain Text
//对读取的记录加共享锁(S型锁)
select ... lock in share mode;
//对读取的记录加独占锁(X型锁)
select ... for update;
```
**怎么加行级锁**

行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。

**加锁对象是 索引**

**加锁的基本单位是 next-key lock，next-key lock 是前开后闭区间**

next-key lock 在一些场景下会退化成记录锁或间隙锁

**在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成退化成记录锁或间隙锁**

**唯一索引 等值查询** 

用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：

- 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会 **退化成「记录锁」** 。
- 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会 **退化成「间隙锁」** 。
1. **记录存在的情况**

假设事务 A 执行了这条等值查询语句，查询的记录是「存在」于表中的。

```Plain Text
mysql> begin;
Query OK, 0 rows affected (0.00 sec)
mysql> select \* from user where id = 1 for update;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  1 | 路飞   |  19 |
+----+--------+-----+
1 row in set (0.02 sec)
```
那么，事务 A 会为 id 为 1 的这条记录就会加上 **X 型的记录锁** 。

![...](images\锁.002.png)

为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock 会退化成记录锁？

原因就是在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读的问题。

- 由于主键具有唯一性，所以 其他事务插入 id = 1 的时候，会因为主键冲突，导致无法插入 id = 1 的新记录 。这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。
- 由于对 id = 1 加了记录锁， 其他事务无法删除该记录 ，这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。
1. **记录不存在的情况**

假设事务 A 执行了这条等值查询语句，查询的记录是「不存在」于表中的。

```Plain Text
mysql> begin;
Query OK, 0 rows affected (0.00 sec)
mysql> select \* from user where id = 2 for update;
Empty set (0.03 sec)
```
通过select \* from performance\_schema.data\_locks\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。

![...](images\锁.003.png)

从上图可以看到，共加了两个锁，分别是：

- 表锁：X 类型的意向锁；
- 行锁：X 类型的间隙锁；

因此， **此时事务 A 在 id = 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)。**

![...](images\锁.004.png)

间隙锁的范围 (1, 5) ，是怎么确定的？

如果 LOCK\_MODE 是 next-key 锁或者间隙锁，那么 LOCK\_DATA 就表示锁的范围「右边界」，此次的事务 A 的 LOCK\_DATA 是 5。

然后锁范围的「左边界」是表中 id 为 5 的上一条记录的 id 值，即 1。

因此，间隙锁的范围 (1, 5) 。

**唯一索引 范围查询**

范围查询和等值查询的加锁规则是不同的。

当唯一索引进行范围查询时， 会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁 ：

- 情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会 退化成记录锁 。
- 情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中： 
- 当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询， 扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁 ，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。
- 当条件值的记录在表中，如果是「小于」条件的范围查询， 扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁 ，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。

**加锁对象不是 索引**

**非唯一索引 等值查询** 

**非唯一索引 范围查询**

**死锁**

**死锁的发生**

建了一张订单表，其中 id 字段为主键索引，order\_no 字段普通索引，也就是非唯一索引：

```SQL
CREATE TABLE 
t\_order
 (
  
id
 int NOT NULL AUTO\_INCREMENT,
  
order\_no
 int DEFAULT NULL,
  
create\_date
 datetime DEFAULT NULL,
  PRIMARY KEY (
id
),
  KEY 
index\_order
 (
order\_no
) USING BTREE
) ENGINE=InnoDB ;
```
然后，先 t\_order 表里现在已经有了 6 条记录：

![...](images\锁.005.png)

假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：

![...](images\锁.006.png)

可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。

这里在查询记录是否存在的时候，使用了 select ... for update 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。

如果没有使用 select ... for update 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：

![...](images\锁.007.png)

**为什么会产生死锁？**

可重复读隔离级别下，是存在幻读的问题。

**Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁** ，它是记录锁和间隙锁的组合。

- Record Lock，记录锁，锁的是记录本身；
- Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。

普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：

```Plain Text
begin;
//对读取的记录加共享锁
select ... lock in share mode;
commit; //锁释放
begin;
//对读取的记录加排他锁
select ... for update;
commit; //锁释放
```
行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。

比如，下面事务 A 查询语句会锁住 (2, +∞] 范围的记录，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。

![...](images\锁.008.png)

next-key 锁的加锁规则其实挺复杂的，在一些场景下会退化成记录锁或间隙锁。

需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。

回到前面死锁的例子。

![...](images\锁.006.png)

事务 A 在执行下面这条语句的时候：

```Plain Text
select id from t\_order where order\_no = 1007 for update;
```
我们可以通过 select \* from performance\_schema.data\_locks\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。

![...](images\锁.009.png)

从上图可以看到，共加了两个锁，分别是：

- 表锁：X 类型的意向锁；
- 行锁：X 类型的间隙锁；

这里我们重点关注行锁，图中 LOCK\_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK\_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：

- 如果 LOCK\_MODE 为 X ，说明是 X 型的 next-key 锁；
- 如果 LOCK\_MODE 为 X, REC\_NOT\_GAP ，说明是 X 型的记录锁；
- 如果 LOCK\_MODE 为 X, GAP ，说明是 X 型的间隙锁；

**因此，此时事务 A 在二级索引（INDEX\_NAME : index\_order）上加的是 X 型的 next-key 锁，锁范围是 (1006, +∞]**。

next-key 锁的范围 (1006, +∞]，是怎么确定的？

如果 LOCK\_MODE 是 next-key 锁或者间隙锁，那么 LOCK\_DATA 就表示锁的范围最右值，

此次的事务 A 的 LOCK\_DATA 是 supremum pseudo-record，表示的是 +∞。（防止插入新的数据，导致）

然后锁范围的最左值是 t\_order 表中最后一个记录的 index\_order 的值，也就是 1006。因此，next-key 锁的范围 (1006, +∞]。

TIP

「当查询的记录不存在时，加 next-key lock，然后会退化为间隙锁」。为什么上面事务 A 的 next-key lock 并没有退化为间隙锁？

如果表中最后一个记录的 order\_no 为 1005，那么等值查询 order\_no = 1006（不存在），就是 next key lock，如上面事务 A 的情况。**锁范围（1006， +∞）**

如果表中最后一个记录的 order\_no 为 1010，那么等值查询 order\_no = 1006（不存在），就是间隙锁，比如下图：**锁范围（1006，1010）**

![...](images\锁.010.png)

当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id = 1008 的记录就会被锁住：

```Plain Text
Insert into t\_order (order\_no, create\_date) values (1008, now());
```
因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁， **而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 select ... for update 语句并不会相互影响** 。

案例中的事务 A 和事务 B 在执行完后 select ... for update 语句后都持有范围为 (1006,+∞] 的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。

为什么间隙锁与间隙锁之间是兼容的？

**间隙锁的意义只在于阻止区间被插入** ，因此是可以共存的。 **一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁** ，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。

这里的共同间隙包括两种场景：

- 其一是两个间隙锁的间隙区间完全一样；
- 其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。

但是有一点要注意， **next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的** 。

比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。

虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系。X 型的记录锁与 X 型的记录锁是冲突的，比如一个事务执行了 select ... where id = 1 for update，后一个事务在执行这条语句的时候，就会被阻塞的。

但是还要注意！对于这种范围为 (1006, +∞] 的 next-key lock，两个事务是可以同时持有的，不会冲突。因为 +∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系。

插入意向锁是什么？

注意！插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁。

这段话表明尽管 **插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作** 。

**如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。**

插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。

另外，我补充一点，插入意向锁的生成时机：

- 每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（ *PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁* ），现象就是 Insert 语句会被阻塞。

**Insert 语句是怎么加行级锁的？**

Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx\_id 隐藏列来作为 **隐式锁** 来保护记录的。

什么是隐式锁？

当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。

隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。

隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景。

- 如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；
- 如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；

**1、记录之间加有间隙锁**

每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（ *PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁* ），现象就是 Insert 语句会被阻塞。

举个例子，现在 t\_order 表中，只有这些数据， **order\_no 是二级索引** 。

![...](images\锁.001.png)

现在，事务 A 执行了下面这条语句。

**事务 A
mysql> begin;
Query OK, 0 rows affected (0.01 sec)
mysql> select \* from t\_order where order\_no = 1006 for update;
Empty set (0.01 sec)**

接着，我们执行 select \* from performance\_schema.data\_locks\G; 语句 ，确定事务 A 加了什么类型的锁，这里只关注在记录上加锁的类型。

![...](images\锁.011.png)

本次的例子加的是 next-key 锁（记录锁+间隙锁），锁范围是 （1005, +∞] 。

然后，有个事务 B 在这个间隙锁中，插入了一个记录，那么此时该事务 B 就会被阻塞：

**事务 B 插入一条记录
mysql> begin;
Query OK, 0 rows affected (0.01 sec)
mysql> insert into t\_order(order\_no, create\_date) values(1010,now());
阻塞状态。。。。**

接着，我们执行 select \* from performance\_schema.data\_locks\G; 语句 ，确定事务 B 加了什么类型的锁，这里只关注在记录上加锁的类型。

![...](images\锁.012.png)

可以看到，事务 B 的状态为等待状态（LOCK\_STATUS: WAITING），因为向事务 A 生成的 next-key 锁（记录锁+间隙锁）范围 （1005, +∞] 中插入了一条记录，所以事务 B 的插入操作生成了一个插入意向锁（ LOCK\_MODE: X,INSERT\_INTENTION ），锁的状态是等待状态，意味着事务 B 并没有成功获取到插入意向锁，因此事务 B 发生阻塞。

**2、遇到唯一键冲突**

如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 **S 型的锁** 。

- 如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录 **添加 S 型记录锁** 。
- 如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录 **添加 S 型 next-key 锁** 。

**主键索引冲突**

下面举个「主键冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。

t\_order 表中的 id 字段为主键索引，并且已经存在 id 值为 5 的记录，此时有个事务，插入了一条 id 为 5 的记录，就会报主键索引冲突的错误。

![...](images\锁.013.png)

但是除了报错之外，还做一个很重要的事情，就是对 id 为 5 的这条记录加上了 **S 型的记录锁** 。

可以执行 select \* from performance\_schema.data\_locks\G; 语句，确定事务加了什么锁。

![...](images\锁.014.png)

可以看到，主键索引为 5 （LOCK\_DATA）的这条记录中加了锁类型为 S 型的记录锁。注意，这里 LOCK\_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是 S 型记录锁的话，LOCK\_MODE 会显示 S, REC\_NOT\_GAP 。

所以，在隔离级别是「可重复读」的情况下，如果在插入数据的时候，发生了主键索引冲突，插入新记录的事务会给已存在的主键值重复的聚簇索引记录 **添加 S 型记录锁** 。

**唯一二级索引冲突**

下面举个「唯一二级索引冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。

t\_order 表中的 order\_no 字段为唯一二级索引，并且已经存在 order\_no 值为 1001 的记录，此时事务 A，插入了 order\_no 为 1001 的记录，就出现了报错。

![...](images\锁.015.png)

但是除了报错之外，还做一个很重要的事情，就是对 order\_no 值为 1001 这条记录加上了 **S 型的 next-key 锁** 。

我们可以执行 select \* from performance\_schema.data\_locks\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。

![...](images\锁.016.png)

可以看到， **index\_order 二级索引加了 S 型的 next-key 锁，范围是(-∞, 1001]** 。注意，这里 LOCK\_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是记录锁的话，LOCK\_MODE 会显示 S, REC\_NOT\_GAP 。

此时，事务 B 执行了 select \* from t\_order where order\_no = 1001 for update; 就会阻塞，因为这条语句**想加 X 型的锁，是与 S 型的锁是冲突**的，所以就会被阻塞。

![...](images\锁.017.png)

我们也可以从 performance\_schema.data\_locks 这个表中看到，事务 B 的状态（LOCK\_STATUS）是等待状态，加锁的类型 X 型的记录锁（LOCK\_MODE: X,REC\_NOT\_GAP ）。

![...](images\锁.018.png)

上面的案例是针对唯一二级索引重复而插入失败的场景。

接下来，分析两个事务执行过程中，执行了相同的 insert 语句的场景。

现在 t\_order 表中，只有这些数据， **order\_no 为唯一二级索引** 。

![...](images\锁.001.png)

在隔离级别可重复读的情况下，开启两个事务，前后执行相同的 Insert 语句，此时 **事务 B 的 Insert 语句会发生阻塞** 。

![...](images\锁.019.png)

两个事务的加锁过程：

- 事务 A 先插入 order\_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，你可以看查 performance\_schema.data\_locks 信息，可以看到这条记录是没有加任何锁的）；
- 接着，事务 B 也插入 order\_no 为 1006 的记录，由于事务 A 已经插入 order\_no 值为 1006 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交， **事务 A 插入的 order\_no 值为 1006 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态** 。

我们可以执行 select \* from performance\_schema.data\_locks\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。

先看事务 A 对 order\_no 为 1006 的记录加了什么锁？

从下图可以看到， **事务 A 对 order\_no 为 1006 记录加上了类型为 X 型的记录锁** （ *注意，这个是在执行事务 B 之后才产生的锁，没执行事务 B 之前，该记录还是隐式锁* ）。

![...](images\锁.020.png)

然后看事务 B 想对 order\_no 为 1006 的记录加什么锁？

从下图可以看到， **事务 B 想对 order\_no 为 1006 的记录加 S 型的 next-key 锁，但是由于事务 A 在该记录上持有了 X 型的记录锁，这两个锁是冲突的，所以导致事务 B 处于等待状态** 。

![...](images\锁.021.png)

从这个实验可以得知，并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。

但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会 **被阻塞** ， **因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的** ，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。

如果 order\_no 不是唯一二级索引，那么两个事务，前后执行相同的 Insert 语句，是不会发生阻塞的，就如前面的这个例子。

![...](images\锁.007.png)

**如何避免死锁？**

死锁的四个必要条件：

**互斥、占有且等待、不可强占用、循环等待** 。

只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

当有死锁发生时，解除死锁策略

在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：

- **设置事务等待锁的超时时间** 。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。
  在 InnoDB 中，参数 innodb\_lock\_wait\_timeout 是用来设置超时时间的，默认值时 50 秒。
  当发生超时后，就出现下面这个提示：

![...](images\锁.022.png)

- **开启主动死锁检测** 。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。
  将参数 innodb\_deadlock\_detect 设置为 on，表示开启这个逻辑，默认就开启。
  当检测到死锁后，就会出现下面这个提示：

![...](images\锁.023.png)


