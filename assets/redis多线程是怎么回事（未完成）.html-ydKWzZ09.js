import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,e as r,o as a}from"./app-CB9WG6K8.js";const n="/assets/redis%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.001-D5p1m2HK.png",o="/assets/redis%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.002-CSAIzvBm.png",E="/assets/redis%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.003-BDwQHACt.png",p="/assets/redis%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.004-qc5PIavW.png",s="/assets/redis%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.005-DHudbTxg.png",l="/assets/redis%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.006-B2vgD1eW.png",c="/assets/redis%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.007-ZFG4ynrr.png",d={};function g(A,e){return a(),t("div",null,e[0]||(e[0]=[r('<p><strong>redis 多线程是怎么回事（未完成）</strong></p><p><strong>redis 多线程模型</strong></p><ul><li>随着业务发展，很多业务请求量都达到了一个曾经难以现象的高度，IO 操作确实成为了瓶颈，之前的 redis 处理流程中读取请求，发送回包都属于 IO 操作</li><li>redis 多线程也不是将整个逻辑都多线程化，而是将网络 io 多线程化</li></ul><p>redis 多线程设计思路</p><figure><img src="'+n+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>再详细一点</p><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+E+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>分开看</strong></p><p>什么时候启动多线程</p><ol><li>服务初始化的时候，会调用 initThreadedIO来初始化多线程</li><li>根据server.io_thread来配置，如果为 1，表示只有一个主线程，那就不会再创建其他线程</li><li>如果大于 1 并且不超过 128，就会进入多线程模式</li></ol><p>进入多线程模式后</p><ol><li>为多线程模式创建资源</li></ol><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol><li>这里为所有线程，在 io_threads_list 中创建对象</li><li>提前锁定了 pthread_mutex_lock 互斥锁资源（单纯的加锁操作，锁住这个 io 线程对应的 mutex，类似不允许这个 io 线程创建多次）</li><li>pthread_create就创建了多线程，子线程运行 IOThreadMain 操作，它是一个无限循环函数，也就是说子线程会一直处于运行状态，直到进程结束</li></ol><p>redis 多线程默认是关闭的，需要主动开启</p><p>用户可以在redis.conf配置文件中开启</p><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>主线程视角</strong></p><p><strong>事件循环</strong></p><p>主线程和 6.0 版本之前一样，还是用 aeMain 来处理事件循环</p><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>aeMain 是 redis 的主线程入口，再 eventloop 一直循环</li><li>当有客户端连接到来，acceptTcpHandeler 被调用，主线程使用 AE 的 API 将 readQueryFromClient命令读取处理器与新连接对应的文件描述符关联起来，并初始化一个 client 绑定到这个客户端连接</li><li>当 client 的读写请求过来，会调用readQueryFromClient这个方法</li><li>老版本实在readQueryFromClient函数中同步完成读取、解析、执行、将回包放入客户端输出缓冲区</li><li>多线程模式下：只会调用postponeClientRead将 client 加入到clients_pending_read任务队列中，后面主线程再分配 IO 线程去读取客户端请求命令</li></ul><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>放进队列之后，主线程会在事件循环 beforeSleep 函数中，调用</li></ul>',25)]))}const _=i(d,[["render",g],["__file","redis多线程是怎么回事（未完成）.html.vue"]]),f=JSON.parse('{"path":"/back-end/redis/Operating-principle/redis%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.html","title":"Redis多线程机制详解","lang":"zh-CN","frontmatter":{"title":"Redis多线程机制详解","description":"深入分析Redis多线程的实现原理、应用场景及性能影响","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","多线程","性能优化","系统架构"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Operating-principle/redis%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%88%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis多线程机制详解"}],["meta",{"property":"og:description","content":"深入分析Redis多线程的实现原理、应用场景及性能影响"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"多线程"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:tag","content":"系统架构"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis多线程机制详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.52,"words":755},"filePathRelative":"back-end/redis/Operating-principle/redis多线程是怎么回事（未完成）.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>redis 多线程是怎么回事（未完成）</strong></p>\\n<p><strong>redis 多线程模型</strong></p>\\n<ul>\\n<li>随着业务发展，很多业务请求量都达到了一个曾经难以现象的高度，IO 操作确实成为了瓶颈，之前的 redis 处理流程中读取请求，发送回包都属于 IO 操作</li>\\n<li>redis 多线程也不是将整个逻辑都多线程化，而是将网络 io 多线程化</li>\\n</ul>\\n<p>redis 多线程设计思路</p>\\n<figure><figcaption>...</figcaption></figure>\\n<p>再详细一点</p>"}');export{_ as comp,f as data};
