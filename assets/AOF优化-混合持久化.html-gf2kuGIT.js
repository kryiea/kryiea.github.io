import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,e as r,o}from"./app-CB9WG6K8.js";const i="/assets/AOF%E4%BC%98%E5%8C%96-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.001-DJOp3rSE.png",n="/assets/AOF%E4%BC%98%E5%8C%96-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.002-DePzZK3g.png",a={};function s(c,t){return o(),p("div",null,t[0]||(t[0]=[r('<p><strong>AOF优化-混合持久化</strong></p><p><strong>混合持久化是什么？</strong></p><p>混合部署听名字似乎是同时开启RDB和AOF，实际上不是</p><p>混合部署实际发生在AOF重写阶段，将当前状态保存为RDB二进制内容，写入新的AOF文件，再将重写缓冲区的内容追加到新的AOF文件，最后替代原有的AOF文件。</p><p>此时的AOF文件，就不再单纯的是日志数据，而是二进制数据+日志数据的混合体，所以叫混合持久化。</p><p><strong>混合持久化解决什么问题？</strong></p><p>混合持久化是发生在原有的AOF流程，如果从这个视角来看，其实本质还是AOF，只是重写时使用了RDB进行了优化。</p><p>如果从更高层面来看，这个确实是属于RDB和AOF优点的融合，属于一种折中方案吧，变成了：可读性降低的AOF 或者说 性能变差的RDB？</p><p>在我看来，如果是考虑到对Redis核心处理性能的影响，那还是需要用RDB，如果是为了相对更可靠的数据记录，也就是尽可能丢失更少的数据，那还是得用AOF，同时，如果对可读性没有太大执念，那进一步开启混合持久化，是一个很好的选择，毕竟其实生产上，关注AOF可读性的情况实际比较少。</p><p><strong>怎么开启</strong></p><p>打开 redis 配置文件 redis.conf</p><p>aof-use-rdb-preamble5.0之后默认是打开的，所以5.0之后只要AOF配置开启，默认就是混合持久化</p><p>混合持久化开启之后，服务启动时如何加载持久化数据？</p><p>如果同时启用了 AOF 和 RDB，Redis 重新启动时，会使用 AOF 文件来重建数据集，因为通常来说， AOF 的数据会更完整</p><p>混合持久化还是属于AOF，所以如果有混合持久化，那肯定是优先使用混合持久化的数据。</p><p>如何区别是否有AOF混合持久化的数据</p><p>可以使用文件开头是否为&quot;REDIS&quot;来判断。</p><p>如下例子就是开启了混合持久化的 AOF 文件</p><figure><img src="'+i+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>完整的具体加载流程</p><figure><img src="'+n+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>总结</strong></p><p>混合持久化是对AOF重写的优化，这种方式可以大大降低AOF重写的性能损耗，以及降低AOF文件的存储空间，付出的代价则是降低AOF文件的读写性</p><p>实际中，很少有真正需要去人肉读AOF数据的情况，这点从5.0之后默认打开AOF混合持久化模式也能看出。</p>',24)]))}const m=e(a,[["render",s],["__file","AOF优化-混合持久化.html.vue"]]),A=JSON.parse('{"path":"/back-end/redis/persistence/AOF%E4%BC%98%E5%8C%96-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.html","title":"Redis AOF混合持久化详解","lang":"zh-CN","frontmatter":{"title":"Redis AOF混合持久化详解","description":"深入分析Redis AOF混合持久化的实现原理及优化策略","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","AOF","持久化","性能优化"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/persistence/AOF%E4%BC%98%E5%8C%96-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis AOF混合持久化详解"}],["meta",{"property":"og:description","content":"深入分析Redis AOF混合持久化的实现原理及优化策略"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"AOF"}],["meta",{"property":"article:tag","content":"持久化"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis AOF混合持久化详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.48,"words":745},"filePathRelative":"back-end/redis/persistence/AOF优化-混合持久化.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>AOF优化-混合持久化</strong></p>\\n<p><strong>混合持久化是什么？</strong></p>\\n<p>混合部署听名字似乎是同时开启RDB和AOF，实际上不是</p>\\n<p>混合部署实际发生在AOF重写阶段，将当前状态保存为RDB二进制内容，写入新的AOF文件，再将重写缓冲区的内容追加到新的AOF文件，最后替代原有的AOF文件。</p>\\n<p>此时的AOF文件，就不再单纯的是日志数据，而是二进制数据+日志数据的混合体，所以叫混合持久化。</p>\\n<p><strong>混合持久化解决什么问题？</strong></p>\\n<p>混合持久化是发生在原有的AOF流程，如果从这个视角来看，其实本质还是AOF，只是重写时使用了RDB进行了优化。</p>"}');export{m as comp,A as data};
