import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,e as p,o as n}from"./app-DRR9Yo7Y.js";const e="/assets/list.001-llJTYG_i.png",o="/assets/list.002-6z1jH32_.png",r="/assets/list.003-Q-MsUO9A.png",a="/assets/list.004-DXXd6nFD.png",g="/assets/list.005-CJ8esDBy.png",l="/assets/list.006-DtYI_Vam.png",c="/assets/list.007-Dy0AxcCE.png",d="/assets/list.008-DVAjW9ZH.png",m="/assets/list.009-B5tkDPqs.png",f="/assets/list.010-DF_tNB9W.png",u="/assets/list.011-DzZTVjzC.png",_="/assets/list.012-Bc_oZdRT.png",y="/assets/list.013-DVxEiYS3.png",z="/assets/list.014-C0Fcs8_1.png",b="/assets/list.015-BXoO9uFL.png",L={};function x(k,t){return n(),s("div",null,t[0]||(t[0]=[p('<p><strong>list</strong></p><p><strong>是什么</strong></p><p>redis list 是一组连接起来的字符串集合</p><p>list 最大元素个数是 2^32-1，新版是 2^64-1</p><p><strong>适合场景</strong></p><p>作为一个列表存储，属于比较底层的数据结构，可以使用的场景非常多。</p><p>存储一批任务数据，一批消息等</p><p><strong>常用操作</strong></p><figure><img src="'+e+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>写</strong></p><p><strong>1. LPUSH</strong></p><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>2. RPUSH</strong></p><figure><img src="'+r+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>3. LPOP</strong></p><figure><img src="'+a+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>4. RPOP</strong></p><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>5. LREM</strong></p><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>6. DEL</strong></p><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>7. UNLINK</strong></p><figure><img src="'+d+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>读</strong></p><p><strong>8. LLEN</strong></p><figure><img src="'+m+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>9. LRANGE</strong></p><figure><img src="'+f+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>底层实现</strong></p><p><strong>编码方式</strong></p><p>3.2 之前，list 对象有两种编码方式</p><figure><img src="'+u+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>3.2 之后</p><figure><img src="'+_+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>编码选择</strong></p><p><strong>ZIPLIST</strong></p><p>条件</p><ol><li>列对象保存的所有字符串对象长度小于 64 字节</li><li>列表对象元素个数少于 512 个，注意，这是 list 的限制，不是 ziplist 的限制</li></ol><p>ziplist 底层</p><ol><li>ziplist 底层用压缩列表实现，是一个偏向数组的结构</li><li><code></code>整个 ziplist 是一起分配内存的，当插入元素时候，需要为整个 ziplist 重新分配内存，会造成内存的复制，是会消耗性能的</li></ol><p>比如列表中有三个元素：hello、niuniu、smart</p><figure><img src="'+y+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>可以看到三个元素都挨在一起，正如 zip 的名字一样，ziplist 内存排列得很紧凑，可以有效节约内存空间</p><p><strong>LINKEDLIST</strong></p><p>条件</p><p>当列表个数或节点数据比较大会使用。</p><p>ziplist 可以自动转换成 linkedlist</p><p>底层</p><p>linkedlist 是双向链表</p><figure><img src="'+z+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>可以看到，内存不够紧凑，但是删除更为灵活，能加快处理性能，空间换时间</p><p><strong>QUICKLIST</strong></p><ul><li>ziplist 是为了在数据少的时候节约内存，linkedlist 是为了数据多的时候提高更新效率</li><li>ziplist 数据稍多（不一定是个数多）时，插入数据会导致很多内存复制</li><li>linkedlist 节点非常多的时候，会占用不少内存</li></ul><p>怎么办？</p><p>/quicklist 来了/</p><p>底层</p><ol><li>quicklist 是 ziplist 和 linkedlist 的结合结构</li><li>原来 linkedlist 是单个节点，只能存一个数据。现在单个节点存一个 ziplist，即多个数据</li></ol><figure><img src="'+b+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>ziplist 的优化</p><p>zipslist 本身存在一个连锁更新的问题，7.0 后使用 LISTPACK 的编码模式取代了 ZIPLIST，他们本质都是一种压缩的列表</p>',61)]))}const D=i(L,[["render",x],["__file","list.html.vue"]]),R=JSON.parse('{"path":"/back-end/redis/Data-object/list.html","title":"Redis List类型详解","lang":"zh-CN","frontmatter":{"title":"Redis List类型详解","description":"详细介绍Redis List类型的实现原理、使用方法及应用场景","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","数据类型","List","数据结构"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Data-object/list.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis List类型详解"}],["meta",{"property":"og:description","content":"详细介绍Redis List类型的实现原理、使用方法及应用场景"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"数据类型"}],["meta",{"property":"article:tag","content":"List"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis List类型详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.13,"words":639},"filePathRelative":"back-end/redis/Data-object/list.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>list</strong></p>\\n<p><strong>是什么</strong></p>\\n<p>redis list 是一组连接起来的字符串集合</p>\\n<p>list 最大元素个数是 2^32-1，新版是 2^64-1</p>\\n<p><strong>适合场景</strong></p>\\n<p>作为一个列表存储，属于比较底层的数据结构，可以使用的场景非常多。</p>\\n<p>存储一批任务数据，一批消息等</p>\\n<p><strong>常用操作</strong></p>\\n<figure><figcaption>...</figcaption></figure>\\n<p><strong>写</strong></p>"}');export{D as comp,R as data};
