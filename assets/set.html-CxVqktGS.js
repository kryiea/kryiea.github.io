import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as s,a as t,o}from"./app-DRR9Yo7Y.js";const a="/assets/set.001-CxrXVQeX.png",r="/assets/set.002-91yH0tBw.png",p="/assets/set.003-DNAP1ike.png",g="/assets/set.004-Dkym5XXU.png",c="/assets/set.005-BVAh1UzI.png",l="/assets/set.006-DT4Zyhd_.png",m="/assets/set.007-BkVuuVT0.png",d="/assets/set.008-Dx6nWQV9.png",f="/assets/set.009-BwkuqvcW.png",u="/assets/set.010-zwzzKSzz.png",_="/assets/set.011-C8FvW9QM.png",y="/assets/set.012-_z4NCKxI.png",S="/assets/set.013-dZlg8aes.png",b="/assets/set.014-ChC7MD3g.png",h={};function z(x,e){return o(),n("div",null,e[0]||(e[0]=[s('<p><strong>set</strong></p><p><strong>是什么</strong></p><p>是一个不重复、无序的字符串集合</p><p>如果是 intset 编码时，其实是有序的，整体看成无序的就行</p><p><strong>适合场景</strong></p><p>适合无序集合场景，如某个用户关注了哪些公众号</p><p>set 还提供了查交集，并集的功能</p><p><strong>常用操作</strong></p><figure><img src="'+a+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>写</strong></p><p><strong>1. SADD</strong></p><figure><img src="'+r+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>2. SREM</strong></p><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>读</strong></p><p><strong>3. SISMEMBER</strong></p><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>4. SCARD</strong></p><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>5. SMEMBERS</strong></p><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>6. SSCAN</strong></p><p><a href="https://www.cnblogs.com/zhaoyongjie-z/p/14311711.html" target="_blank" rel="noopener noreferrer">redis使用scan count 返回数量不准确 - 二娃的园子 - 博客园</a></p><p>每次使用游标，都会使用上次使用后返回的游标作为本次游标参数，来延续之前的迭代过程</p><figure><img src="'+m+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>7. SINTER</strong></p><figure><img src="'+d+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+f+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>8. SUNION</strong></p><figure><img src="'+u+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>9. SDIFF</strong></p><figure><img src="'+_+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>底层实现</strong></p><p><strong>编码方式</strong></p><figure><img src="'+y+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>INTSET</strong></p><ul><li>如果集群元素都是整数，且元素数量不超过 512 个，可以使用 INTSET 编码</li><li>INTSET 排列比较紧凑，内存占用少</li><li>查找时需要 二分查找</li></ul><figure><img src="'+S+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>HASHTABLE</strong></p><ul><li>不满足 INTSET 条件，就使用 HASHTABLE</li><li>查询一个元素的性能很高，O1</li></ul>',40),t("p",{"1：null，2：null，3：null":""},"比如 set（1，2，3）在 hashtable 中以键值对形式存在就是",-1),t("figure",null,[t("img",{src:b,alt:"...",tabindex:"0",loading:"lazy"}),t("figcaption",null,"...")],-1)]))}const N=i(h,[["render",z],["__file","set.html.vue"]]),R=JSON.parse('{"path":"/back-end/redis/Data-object/set.html","title":"Redis Set类型详解","lang":"zh-CN","frontmatter":{"title":"Redis Set类型详解","description":"详细介绍Redis Set类型的实现原理、使用方法及应用场景","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","数据类型","Set","数据结构"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Data-object/set.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis Set类型详解"}],["meta",{"property":"og:description","content":"详细介绍Redis Set类型的实现原理、使用方法及应用场景"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"数据类型"}],["meta",{"property":"article:tag","content":"Set"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis Set类型详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":1.2,"words":360},"filePathRelative":"back-end/redis/Data-object/set.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>set</strong></p>\\n<p><strong>是什么</strong></p>\\n<p>是一个不重复、无序的字符串集合</p>\\n<p>如果是 intset 编码时，其实是有序的，整体看成无序的就行</p>\\n<p><strong>适合场景</strong></p>\\n<p>适合无序集合场景，如某个用户关注了哪些公众号</p>\\n<p>set 还提供了查交集，并集的功能</p>\\n<p><strong>常用操作</strong></p>\\n<figure><figcaption>...</figcaption></figure>\\n<p><strong>写</strong></p>"}');export{N as comp,R as data};
