import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,d as r,e as t,o as n}from"./app-DRR9Yo7Y.js";const s="/assets/Kafka%20%E9%AB%98%E5%8F%AF%E7%94%A8.001-eaRFicnr.png",o="/assets/Kafka%20%E9%AB%98%E5%8F%AF%E7%94%A8.002-D6U09R36.png",d={};function p(h,e){return n(),i("div",null,[e[0]||(e[0]=a("h1",{id:"kafka-高可用",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#kafka-高可用"},[a("span",null,"Kafka 高可用")])],-1)),e[1]||(e[1]=a("p",null,"本文详细介绍了Kafka的副本机制、高可用架构及数据同步原理，帮助读者深入理解Kafka的容灾能力。",-1)),r(" more "),e[2]||(e[2]=t('<h2 id="一、kafka-的副本机制" tabindex="-1"><a class="header-anchor" href="#一、kafka-的副本机制"><span>一、Kafka 的副本机制</span></a></h2><p>Kafka 是天然提供容灾解决方案的，通过多副本机制来实现容灾。</p><h3 id="_1-kafka-副本的概念" tabindex="-1"><a class="header-anchor" href="#_1-kafka-副本的概念"><span>1. Kafka 副本的概念</span></a></h3><ul><li><strong>Replica：</strong> Replica是指Kafka集群中的一个副本，它可以是Leader的副本或者Follower的副本的一种。每个分区都有多个副本，其中一个是Leader的副本，其余的是Follower的副本。每个副本都保存了分区的完整数据，以保证数据的可靠性和高可用性。</li><li><strong>Leader：</strong> Leader是指Kafka集群中的一个分区副本，它负责处理该分区的所有读写请求。Leader副本是唯一可以自主向分区写入数据的副本，它将写入的数据都会同步到所有的Folower副本中，以保证数据的可靠性和一致性。leader副本必须在leader节点中。</li><li><strong>Folower：</strong> Follower是指Kafka集群中的一个分区副本，Follower副本不能直接向分区写入数据，它只能从Leader副本中复制数据，并将数据同步到本地的副本中，以保证数据的可靠性和一致性。在Leader副本挂掉的时候Follower副本有机会被选举为新的leader副本从而保证分区的可用性。</li></ul><h3 id="_2-易混淆的概念" tabindex="-1"><a class="header-anchor" href="#_2-易混淆的概念"><span>2. 易混淆的概念</span></a></h3><h4 id="_2-1-分区和副本" tabindex="-1"><a class="header-anchor" href="#_2-1-分区和副本"><span>2.1 分区和副本</span></a></h4><ul><li><strong>分区（Partition）</strong>：Kafka中的每个主题（Topic）可以被划分为多个分区。每个分区内是一个有序的、不可变的消息序列，这些消息存储在Kafka集群的不同节点（broker）上。</li><li><strong>副本（Replica）</strong>：为了实现高可用性和数据冗余，每个分区的数据会被复制到多个节点上。每个分区的副本包括一个Leader副本和多个Follower副本。</li></ul><h4 id="_2-2-leader-节点和-follower-节点" tabindex="-1"><a class="header-anchor" href="#_2-2-leader-节点和-follower-节点"><span>2.2 Leader 节点和 Follower 节点</span></a></h4><ul><li><strong>Leader 节点</strong>：负责处理读写请求的分区主节点。</li><li><strong>Follower 节点</strong>：从 Leader副本 复制数据的分区从节点。</li></ul><h4 id="_2-3-leader-副本和-follower-副本" tabindex="-1"><a class="header-anchor" href="#_2-3-leader-副本和-follower-副本"><span>2.3 Leader 副本和 Follower 副本</span></a></h4><ul><li><strong>Leader副本</strong>：这是当前分区的主副本，负责处理所有的读写请求。Leader副本存储在被选为该分区Leader的节点上。</li><li><strong>Follower副本</strong>：这是从副本，从Leader副本复制数据，以保持数据的一致性和冗余。Follower副本存储在其他节点上。</li></ul><h4 id="_2-4-leader-副本只能存储在-leader-节点上" tabindex="-1"><a class="header-anchor" href="#_2-4-leader-副本只能存储在-leader-节点上"><span>2.4 Leader 副本只能存储在 Leader 节点上</span></a></h4><ul><li><strong>集中处理</strong>：Leader节点负责处理所有的写请求和读请求，这样可以集中管理数据的更新和读取，简化了数据一致性管理。</li><li><strong>减少延迟</strong>：由于读写请求直接由Leader节点处理，避免了在多个节点之间进行额外的网络通信，从而减少了延迟，提高了性能。</li></ul><h3 id="_3-kafka-的副本机制优势" tabindex="-1"><a class="header-anchor" href="#_3-kafka-的副本机制优势"><span>3. Kafka 的副本机制优势</span></a></h3><p>Kafka 是支持多副本的，发生了一定的异常也可以保证系统正常运作，Kafka 的多副本机制大致有如下优势：</p><ol><li><strong>高可用性：</strong> 如果 Leader 副本所在的 Broker 宕机，Kafka 会自动从其它副本中选取一个新的 Leader，确保服务的持续性，具体选择规则我们后面会介绍。</li><li><strong>容灾：</strong> 即使部分副本数据丢失，只要有一个副本是完整的，数据就不会丢失，简单来说就是多备份情况下数据丢失风险变小。</li><li><strong>读性能提升：</strong> 默认情况下，虽然数据的多个副本可以分布在不同的 broker 上，但是Kafka都是Leader提供读写，如果特定业务需要，也可以让消费者从Follower上读数据，增加读的并发度。</li></ol><h3 id="_4-为用户的消息创建多副本" tabindex="-1"><a class="header-anchor" href="#_4-为用户的消息创建多副本"><span>4. 为用户的消息创建多副本</span></a></h3><div class="hint-container warning"><p class="hint-container-title">注意</p><p>分区的副本数量必须小于等于Broker的数量，比如只有1个Broker，却想为分区创建2个副本，会报错。</p></div><p>使用kafka-topics.sh脚本，并指定Topic名称、副本个数和分区数：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">./kafka-topics.sh</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --create</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -bootstrap-server</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> locahost:9092</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --topic</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> niugetest4</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --partitions</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --replication-factor</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>如下图：</strong></p><ul><li>对于 TopicA 的 partition0 来说</li><li>Broker10 是 Leader 节点，Broker10 的 TopicA-Partition0 是 Leader 副本</li><li>Broker11 是 Follower 节点，Broker11 的 TopicA-Partition0 是 Follower 副本</li><li>数据持久化过程：不光写入Broker10上的Topic-A Partition0，还会最终同步到Broker11上的Topic-A Partition0</li></ul><figure><img src="'+s+'" alt="副本创建示意图" tabindex="0" loading="lazy"><figcaption>副本创建示意图</figcaption></figure><h3 id="_5-为kafka内部的topic配置多副本" tabindex="-1"><a class="header-anchor" href="#_5-为kafka内部的topic配置多副本"><span>5. 为Kafka内部的Topic配置多副本</span></a></h3><div class="hint-container tip"><p class="hint-container-title">提示</p><p>待补充内容</p></div><h2 id="二、多副本的写入机制" tabindex="-1"><a class="header-anchor" href="#二、多副本的写入机制"><span>二、多副本的写入机制</span></a></h2><h3 id="_1-写入机制" tabindex="-1"><a class="header-anchor" href="#_1-写入机制"><span>1. 写入机制</span></a></h3><div class="hint-container info"><p class="hint-container-title">总结</p><p>数据是直接往Leader写入，写入之后Leader和Folower之间会进行同步，是否要等待同步完成取决于选择哪种写入策略（acks）。</p></div><ul><li>Kafka 会在诸多分区中选举一个分区作为主节点（Leader），它的副本作为Leader副本，负责接收生产者的消息并处理读写请求。</li><li>其他的副本是从副本，从Leader副本复制数据，保持只读。当主节点掉线后，有机会被选举成为新的主节点，去负责读写请求。Follower副本存储在其他节点上。</li><li>对于生产者来说，主节点是可见的，副节点是透明的。</li></ul><h3 id="_2-副本管理机制" tabindex="-1"><a class="header-anchor" href="#_2-副本管理机制"><span>2. 副本管理机制</span></a></h3><p>一个分区会有多个副本，为了对这些副本更好的管理，Kafka 会对所有副本进行划分，对应不同的集合。</p><ol><li><strong>AR 集合</strong><ul><li>AR 是指分区的所有副本，包括 Leader 副本和 Follower 副本，也就是整体的集合。</li></ul></li><li><strong>ISR 集合</strong><ul><li>ISR 是指与 Leader 副本保持同步的副本集合，或者说是跟得上节奏的副本集合。</li><li>ISR 中的副本与 Leader 副本保持同步，即它们已经复制了 Leader 副本中的所有数据，并且与 Leader 副本之间的数据差异不超过一定的阈值（Follower 副本能够落后 Leader 副本的最长时间间隔）。</li><li>ISR 副本集合是动态变化的，不是一成不变的。除非开启了 Unclean 选举，否则只有处于 ISR 中的副本才有可能被选举为新的 Leader 副本，以保证分区的正常运行。</li></ul></li><li><strong>OSR 集合</strong><ul><li>OSR 是指与 Leader 副本不同步的副本集合，也就是跟不上节奏的副本</li><li>OSR 中的副本与 Leader 副本之间的数据差异超过了一定的阈值，或者它们还没有复制 Leader 副本中的所有数据。除非开启了 Unclean 选举，否则 OSR 中的副本不能被选举为新的 Leader 副本。</li></ul></li></ol><p><strong>简单来说：</strong></p><figure><img src="'+o+'" alt="副本集合关系图" tabindex="0" loading="lazy"><figcaption>副本集合关系图</figcaption></figure><h3 id="_3-isr-的动态调整" tabindex="-1"><a class="header-anchor" href="#_3-isr-的动态调整"><span>3. ISR 的动态调整</span></a></h3><p>每个Partition都会由Leader 动态维护一个与自己基本保持同步的ISR列表。</p><ul><li>所谓动态维护，就是说如果一个Follower比一个Leader落后超过了给定阈值，默认是10s，则Leader将其从ISR中移除。</li><li>如果OSR列表内的Follower副本与Leader副本保持了同步，那么就将其添加到ISR列表当中。</li></ul><h3 id="_4-isr-为空-新-leader-如何选举" tabindex="-1"><a class="header-anchor" href="#_4-isr-为空-新-leader-如何选举"><span>4. ISR 为空，新 Leader 如何选举</span></a></h3><p>可以通过配置参数 unclean.leader.election来决定是否从OSR中选举出leader：</p><ul><li><strong>true：</strong> 允许 OSR 成为 Leader，但是 OSR 的消息较为滞后，可能会出现消息丢失的问题</li><li><strong>false：</strong> 坚决不能让那些OSR竞选Leader。这样做的后果是这个分区就不可用</li></ul><h2 id="三、副本间的同步机制" tabindex="-1"><a class="header-anchor" href="#三、副本间的同步机制"><span>三、副本间的同步机制</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>待补充内容</p></div><h2 id="四、副本间的同步机制-优化" tabindex="-1"><a class="header-anchor" href="#四、副本间的同步机制-优化"><span>四、副本间的同步机制 - 优化</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>待补充内容</p></div>',44))])}const f=l(d,[["render",p],["__file","Kafka高可用.html.vue"]]),g=JSON.parse('{"path":"/back-end/kafka/Kafka%E9%AB%98%E5%8F%AF%E7%94%A8.html","title":"Kafka 高可用","lang":"zh-CN","frontmatter":{"title":"Kafka 高可用","description":"深入解析Kafka的副本机制、高可用架构及数据同步原理","date":"2024-01-01T00:00:00.000Z","category":["消息队列"],"tag":["Kafka","高可用","分布式系统"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/kafka/Kafka%E9%AB%98%E5%8F%AF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Kafka 高可用"}],["meta",{"property":"og:description","content":"深入解析Kafka的副本机制、高可用架构及数据同步原理"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Kafka"}],["meta",{"property":"article:tag","content":"高可用"}],["meta",{"property":"article:tag","content":"分布式系统"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kafka 高可用\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[{"level":2,"title":"一、Kafka 的副本机制","slug":"一、kafka-的副本机制","link":"#一、kafka-的副本机制","children":[{"level":3,"title":"1. Kafka 副本的概念","slug":"_1-kafka-副本的概念","link":"#_1-kafka-副本的概念","children":[]},{"level":3,"title":"2. 易混淆的概念","slug":"_2-易混淆的概念","link":"#_2-易混淆的概念","children":[{"level":4,"title":"2.1 分区和副本","slug":"_2-1-分区和副本","link":"#_2-1-分区和副本","children":[]},{"level":4,"title":"2.2 Leader 节点和 Follower 节点","slug":"_2-2-leader-节点和-follower-节点","link":"#_2-2-leader-节点和-follower-节点","children":[]},{"level":4,"title":"2.3 Leader 副本和 Follower 副本","slug":"_2-3-leader-副本和-follower-副本","link":"#_2-3-leader-副本和-follower-副本","children":[]},{"level":4,"title":"2.4 Leader 副本只能存储在 Leader 节点上","slug":"_2-4-leader-副本只能存储在-leader-节点上","link":"#_2-4-leader-副本只能存储在-leader-节点上","children":[]}]},{"level":3,"title":"3. Kafka 的副本机制优势","slug":"_3-kafka-的副本机制优势","link":"#_3-kafka-的副本机制优势","children":[]},{"level":3,"title":"4. 为用户的消息创建多副本","slug":"_4-为用户的消息创建多副本","link":"#_4-为用户的消息创建多副本","children":[]},{"level":3,"title":"5. 为Kafka内部的Topic配置多副本","slug":"_5-为kafka内部的topic配置多副本","link":"#_5-为kafka内部的topic配置多副本","children":[]}]},{"level":2,"title":"二、多副本的写入机制","slug":"二、多副本的写入机制","link":"#二、多副本的写入机制","children":[{"level":3,"title":"1. 写入机制","slug":"_1-写入机制","link":"#_1-写入机制","children":[]},{"level":3,"title":"2. 副本管理机制","slug":"_2-副本管理机制","link":"#_2-副本管理机制","children":[]},{"level":3,"title":"3. ISR 的动态调整","slug":"_3-isr-的动态调整","link":"#_3-isr-的动态调整","children":[]},{"level":3,"title":"4. ISR 为空，新 Leader 如何选举","slug":"_4-isr-为空-新-leader-如何选举","link":"#_4-isr-为空-新-leader-如何选举","children":[]}]},{"level":2,"title":"三、副本间的同步机制","slug":"三、副本间的同步机制","link":"#三、副本间的同步机制","children":[]},{"level":2,"title":"四、副本间的同步机制 - 优化","slug":"四、副本间的同步机制-优化","link":"#四、副本间的同步机制-优化","children":[]}],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":6.48,"words":1943},"filePathRelative":"back-end/kafka/Kafka高可用.md","localizedDate":"2024年1月1日","excerpt":"\\n<p>本文详细介绍了Kafka的副本机制、高可用架构及数据同步原理，帮助读者深入理解Kafka的容灾能力。</p>\\n"}');export{f as comp,g as data};
