import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,e as i,o as p}from"./app-DRR9Yo7Y.js";const o="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU.001-B4WFd0C-.png",n="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU.002-DfEdDkOA.png",l={};function s(a,e){return p(),r("div",null,e[0]||(e[0]=[i('<p><strong>内存淘汰算法-LRU</strong></p><p><strong>标准 LRU</strong></p><p>LRU 是一个流行的资源淘汰算法</p><p><strong>是什么</strong></p><p>最近最久未使用，即记录每个 key 的最近访问时间，维护一个访问时间数据</p><p><strong>redis 使用标准的 LRU 会有什么问题</strong></p><p>为所有数据维护一个顺序列表，实际就是做一个双向链表，如果 redis 数据稍微多些，这个链表就成本就很大</p><p><strong>redis 的近似 LRU</strong></p><p><a href="https://juejin.cn/post/6844903454708596750" target="_blank" rel="noopener noreferrer">Redis 近似 LRU 算法优化 - 掘金</a></p><p><strong>概述</strong></p><ul><li>在 LRU 模式中，redisObject 对象中 lru 字段存储的是 key 被访问时，redis 的时钟 server.lrulock</li><li>当 key 被访问时，redis 会更新这个 key 的 lru 字段</li><li>但是，redis 为了保证核心单线程服务性能，缓存了 Unix 操作系统时钟，默认每 100ms 更新一次，缓存的值时 Unix 时间戳取模 2^24</li></ul><p>近似 LRU</p><ul><li>近似 lru 算法在现有的数据结构基础上采用随机取样的方式来淘汰元素，当内存不足，就执行一次近似 lru</li><li>具体步骤：</li><li>随机采用 n 个 key，默认 5 个</li><li>根据时间戳淘汰掉最旧的 key</li><li>淘汰后还是内存不足，继续采样淘汰</li></ul><p><strong>采样范围</strong></p><ol><li>allkeys：从所有 key 中随机采样</li><li>volatile：从有过期时间的 key 随机采样</li></ol><p>对应：allkeys-lru 和 volatile-lru</p><p><strong>淘汰池优化</strong></p><p>近似 lru 的一些问题</p><p>近似 lru 优点在于节约了内存，但缺点就是它不是一完整的 lru，随机采样得到的结果，其实不是全局真正的最久未访问，数据量大的时候更加</p><p>redis3.0 对近似 lru 进行了一些优化</p><ol><li>新算法会维护一个大小为 16 （不是固定的，会动态调整）的候选池，池中的数据根据空闲时间长短进行排序</li><li>第一次随机选取的 key 都会放入池中，然后淘汰最久未访问的。 比如选了 5 个，淘汰 1 个，池子还剩 4 个</li><li>随后每次随机选取的 key，只有活性比池子里活性最小的 key 还小时，才会放入池中</li><li>池子满了之后每次放一个 key 进，满之前符合的都放进</li><li>当池子满了，如果有新的 key 需要放入，就会将池子中活性最低（这里的活性低就是空闲时间长）的 key 淘汰</li><li>新的 key 要放入的意思：随机选取的 n 个采样里面活性最低的与池中活性最低的比较，谁更低谁被淘汰，没被淘汰的放入池子</li></ol><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>空闲时间的计算</p><p>idle = object.lru - server.lrulock</p><p>淘汰池的结构</p><p>Redis的淘汰池是一个字典结构，而不是链表。</p><p>字典中的每个键值对都包含一个指向对象的指针，而不是相邻节点的指针。</p><p>因此，在遍历淘汰池时，Redis需要使用哈希表算法来查找大于当前最大可用内存的键。</p><figure><img src="'+n+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure>',29)]))}const g=t(l,[["render",s],["__file","内存淘汰算法-LRU.html.vue"]]),m=JSON.parse('{"path":"/back-end/redis/Operating-principle/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU.html","title":"Redis LRU内存淘汰算法详解","lang":"zh-CN","frontmatter":{"title":"Redis LRU内存淘汰算法详解","description":"深入分析Redis LRU（Least Recently Used）算法的实现原理及应用","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","LRU","内存淘汰","算法原理"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Operating-principle/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LRU.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis LRU内存淘汰算法详解"}],["meta",{"property":"og:description","content":"深入分析Redis LRU（Least Recently Used）算法的实现原理及应用"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"LRU"}],["meta",{"property":"article:tag","content":"内存淘汰"}],["meta",{"property":"article:tag","content":"算法原理"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis LRU内存淘汰算法详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.77,"words":832},"filePathRelative":"back-end/redis/Operating-principle/内存淘汰算法-LRU.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>内存淘汰算法-LRU</strong></p>\\n<p><strong>标准 LRU</strong></p>\\n<p>LRU 是一个流行的资源淘汰算法</p>\\n<p><strong>是什么</strong></p>\\n<p>最近最久未使用，即记录每个 key 的最近访问时间，维护一个访问时间数据</p>\\n<p><strong>redis 使用标准的 LRU 会有什么问题</strong></p>\\n<p>为所有数据维护一个顺序列表，实际就是做一个双向链表，如果 redis 数据稍微多些，这个链表就成本就很大</p>\\n<p><strong>redis 的近似 LRU</strong></p>"}');export{g as comp,m as data};
