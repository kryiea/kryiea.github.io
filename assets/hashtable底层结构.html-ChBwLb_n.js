import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,e as a,o as l}from"./app-DRR9Yo7Y.js";const s="/assets/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.001-B63x8w0E.png",n="/assets/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.002-ACdUwOCm.png",r="/assets/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.003-BfmcdoCP.png",o="/assets/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.004-Dx8-ZRg5.png",p="/assets/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.005-D7F6c9qq.png",h="/assets/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.006-Cmaq_pyO.png",c={};function g(d,t){return l(),e("div",null,t[0]||(t[0]=[a('<p><strong>hashtable底层结构</strong></p><p><strong>概述</strong></p><ul><li>可以理解成目录，要翻看内容可以直接通过目录找到页数，翻过去看</li><li>hashtable 扮演者类似目录这样一个快速索引角色</li></ul><p><strong>结构</strong></p><p>代码定义</p><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>结构图</p><figure><img src="'+n+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>最外层是一个 dictht，字段如下</li><li>*table：指向实际 hash 存储。存储看成一个数组</li><li>size：哈希大小。实际就是 dictEntry 有多少元素空间</li><li>sizemask：哈希表大小的掩码表示，总是等于 size-1.这个属性和哈希值一起决定一个键一个被放在 table 数组的哪个索引上面，规则是：Index = hash&amp;sizemask</li><li>used：表示已经使用的节点数量</li></ul><p><strong>hash 表渐进式扩容</strong></p><p>reids 把 dictht 再封装了一层：dict</p><figure><img src="'+r+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>结构图</p><ul><li>dict 结构里 ht[2] 包含两个 dictht 结构，也就是 2 个 hashtable</li><li>dictEntry 是链表结构，用拉链法解决 hash 冲突，用的是头插法</li></ul><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>扩容：渐进式！</p><ol><li>实际平常使用的是一个 hashtable，在触发扩容之后，就会两个 hashtable 同时使用</li><li>扩容过程：往字典添加元素，发现需要扩容会进行 rehash</li><li>先为新 hash 表 ht[1] 分配空间，新表大小为第一个大于等于原表 2 倍 used 的 2 次方幂 🌰原表的 used = 500，2 倍就是 1000，那大于 1000 的 2 次方幂则为 1024</li><li>扩容后，同时拥有两个 hash 表 ht[0]、ht[1]。</li><li>将字典的偏移索引 rehashidx 从静默状态 -1，设置为 0，表示 rehash 工作正式开始</li><li>工作流程</li></ol><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol><li>迁移 ht[0] 的数据到 ht[1]</li><li>在 rehash 期间，每次对字典执行增删改查，程序会顺带迁移当前 rehashidx 在 ht[0] 上对应的数据，并更新偏移索引。（只有被删改查的数据才会别迁移，不然一直不动）</li><li>与此同时，部分情况周期函数也会进行迁移</li><li>随着字典操作不断，最终在某个时间点上，ht[0] 的所有数据会被 rehash 到 ht[1] 上</li><li>此时将 ht[1] 和 ht[0] 的指针互换，同时将偏移索引的值设为-1，表示 rehash 已经完成</li></ol><p>dictRehash 函数</p><figure><img src="'+h+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>可以看到，如果 rehashidx 刚好在一个已经删除的空位置，是会继续往下找，但是有上限 n*10</li><li>n 是传进来的参数，调用时实际为 1，则最多往后找 10 个，防止因为碰到连续的空位置导致主线程操作被阻塞</li><li>每次迁移一个函数，rehash 都会检查一下是否完成整个迁移</li></ul><p>总结</p><p>核心是：操作时顺带迁移</p><p><strong>扩容时机</strong></p><p>负载因子表示目前 redis hashtable 的负载情况</p><ul><li>设负载因子为 k</li><li>k = ht[0].used / ht[0].size</li><li>k 是会大于 1 的，因为是拉链法处理扩容，且 used 是表示 dictEntry** 的使用情况</li></ul><p>何时扩容</p><ol><li>负载因子大于等于 1：说明空间非常紧张</li><li>新数据实在链表上叠加的（拉链法），越来越多数据无法在 O1 时间复杂度上找到，需要遍历一次链表</li><li>如果此时服务器没有执行 BGSAVE 或 BGREWRITEAOF 这两个命令 （复制命令）</li><li>就发生扩容</li><li>负载因子大于 5：说明 hashtable 不堪重负</li><li>现在即使有复制命令在执行，也会进行 rehash 扩容</li></ol><p><strong>缩容</strong></p><p>渐进式缩容：看负载因子 k</p><ul><li>k 小于 0.1，即负载率小于 10%，就会进行缩容</li><li>新表大小为第一个大于等于原表 used 的 2 次方幂</li><li>如果有BGSAVE 或 BGREWRITEAOF 这两个复制命令，缩容不会进行</li></ul><p><strong>总结</strong></p><p>hashtable 是面试热点。。</p>',34)]))}const E=i(c,[["render",g],["__file","hashtable底层结构.html.vue"]]),f=JSON.parse('{"path":"/back-end/redis/Data-object/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.html","title":"Redis哈希表底层结构详解","lang":"zh-CN","frontmatter":{"title":"Redis哈希表底层结构详解","description":"深入分析Redis哈希表的底层实现原理及优化策略","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","哈希表","数据结构","底层实现"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Data-object/hashtable%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis哈希表底层结构详解"}],["meta",{"property":"og:description","content":"深入分析Redis哈希表的底层实现原理及优化策略"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"哈希表"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"底层实现"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis哈希表底层结构详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":3.45,"words":1035},"filePathRelative":"back-end/redis/Data-object/hashtable底层结构.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>hashtable底层结构</strong></p>\\n<p><strong>概述</strong></p>\\n<ul>\\n<li>可以理解成目录，要翻看内容可以直接通过目录找到页数，翻过去看</li>\\n<li>hashtable 扮演者类似目录这样一个快速索引角色</li>\\n</ul>\\n<p><strong>结构</strong></p>\\n<p>代码定义</p>\\n<figure><figcaption>...</figcaption></figure>\\n<p>结构图</p>\\n<figure><figcaption>...</figcaption></figure>\\n<ul>\\n<li>最外层是一个 dictht，字段如下</li>\\n<li>*table：指向实际 hash 存储。存储看成一个数组</li>\\n<li>size：哈希大小。实际就是 dictEntry 有多少元素空间</li>\\n<li>sizemask：哈希表大小的掩码表示，总是等于 size-1.这个属性和哈希值一起决定一个键一个被放在 table 数组的哪个索引上面，规则是：Index = hash&amp;sizemask</li>\\n<li>used：表示已经使用的节点数量</li>\\n</ul>"}');export{E as comp,f as data};
