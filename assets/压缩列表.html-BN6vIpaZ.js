import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,e as p,o as r}from"./app-DRR9Yo7Y.js";const o="/assets/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.001-DulR3GkH.png",t="/assets/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.002-6u2MfScR.png",s="/assets/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.003-DotRS5Rj.png",l="/assets/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.004-0o_kZbzc.png",a="/assets/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.005-BdBBX9SV.png",g="/assets/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.006-Clyr1Oxk.png",c={};function d(m,i){return r(),n("div",null,i[0]||(i[0]=[p('<p><strong>压缩列表</strong></p><p><strong>压缩列表是什么</strong></p><ul><li>压缩列表：排列紧凑的列表</li><li>压缩列表在 redis 中有两种编码形式</li><li>ziplist</li><li>listpack：5.0 引入，直到 7.0 完全取代 ziplist，成为 ziplist 的进阶版本</li></ul><p><strong>解决什么问题</strong></p><p>压缩列表是 list 的底层数据结构，压缩列表作为底层数据结构能提供紧凑型的数据存储方式，能节约内存（节省链表指针的开销），小数据量时遍历访问性能好（连续+缓存命中率高）</p><p><strong>ziplist 整体结构</strong></p><p>虽然 listpack，但是实际聊的比较多的还是 ziplist</p><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>zlbytes：表示该 ziplist 一共占了多少字节数，这个数字包含 zlbytes 本身占据的字节</li><li>zltail：尾巴节点，相对于 ziplist 的开头（起始指针）而言偏移的字节数。</li><li>这个字段可以快速定位到尾部节点。</li><li>例如 zl 指向开头，需要获取尾巴节点，即 ziplist 最后一个 entry 节点，可以 zl + zltail</li><li>如果没有尾巴节点，就定位到 zlend，如空 ziplist</li><li>zllen：表示有多少个数据节点，上图中，zllen = 3</li><li>entry：表示压缩列表的数据节点</li><li>zlend：一个特殊的 entry 节点，表示 ziplist 结束。</li></ul><p><strong>entry 节点结构</strong></p><p>定义</p><figure><img src="'+t+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>prevlen：表示上一个节点的数据长度。通过这个字段可以定位到上一个节点的起始地址</li><li>即当前地址 p-prevlen 可以跳到前一个节点的开头位置，实现从后往前的操作，所以压缩列表可以从后往前遍历</li><li>如果前一个节点 entry 的大小小于 254 字节，那么 prevlen 属性只需要用 1 字节长的空间来保存这个长度值。255 是特殊字符，被 zlend 使用</li><li>前一节点的长度大于等于 254 字节，那么 prevlen 属性需要 5 字节来保存这个长度值，注意 5 个字节中，第一个字节的 8bit 为 11111110，也就是 254，标志这是 5 个字节的 prelen 信息，剩下的 4 字节来表示大小</li><li>encoding：编码类型。编码类型里还包含 entry 的长度信息，用于正向遍历</li><li>entry-data：实际的数据</li></ul><p>encoding</p><ul><li>encoding 字段是一个整形数据，其二进制编码由内容数据的类型和内容数据的字节长度两部分组成，根据内容类型有如下几种情况</li></ul><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>如果是 string 类型，encoding 有两部分，一般是前几位表示类型，后几位表示长度。</li><li>如果是 int 类型，整体 1 字节编码，只是表示了类型，但没有大小，因为 int 的具体类型就自带了大小 int16、int32...不用要 encoding 特别标识</li><li>encoding 的编码规则复杂，只要知道怎么去区分不同类型即可，不用去背具体编码。</li><li>解释一下表格最后一个 xxxx 为什么只有 13 个，全 1 不能用（zlend 用了），11111110 是 int64 也不能用</li></ul><p><strong>ziplist 查询数据</strong></p><p><strong>1. 查询 ziplist 数据总量</strong></p><ul><li>由于 ziplist 的 header 定义了记录节点数量的字段 zllen，通常可以在 O1 直接返回。</li><li>为什么是通常呢？</li><li>因为 zllen 是 2 个字节的，当 zllen 大于 65534，就存不下了，zllen 变成 0， 此时真实的 zllen 需要重新遍历得到</li></ul><p>注意</p><ul><li>list 使用 ziplist 编码的条件之一是数据对象的数量小于 512，超过就会使用 linkedlist 编码</li><li>而 ziplist 这个数据结构，本身的限制是可以存 65534 个数据（也不算限制，存超了就需要重新遍历浪费 On，而不是直接 O1 返回）</li><li>简而言之，list 底层使用了 ziplist 这个底层数据结构，并且自己设定了一个限制，数据量小于 512</li></ul><p><strong>2. 查询指定数据的节点</strong></p><p>需要遍历这个压缩列表，平均 On，所以查找复杂度是比较高的</p><p><strong>3. 更新数据</strong></p><p>数据节点 entry 往后移</p><ul><li>ziplist 支持在头尾插入数据，但是平均操作时间确是 On 不是 O1，因为在头部增加一个节点会导致后面的节点都往后移动</li></ul><p>连锁更新</p><p>这里有图文讲解<a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0" target="_blank" rel="noopener noreferrer">Redis 数据结构</a></p><ul><li>entry 后移不叫连锁更新！</li><li>连锁更新的情况：</li><li>增加一个大于 254 字节的节点到头部，可能会导致后续大量entry 的 prevlen 需要更新。</li><li>比如：原本每个 entry 中的 prevlen 都是 1 字节，而且每个 entry 的总字节数都接近 254。挺好的，无事发生。</li><li>突然加了一个大于 254 字节的数据到头部，导致后一个 entry 的 prevlen 原本 1 字节太小了，需要重新分配大小为 5 字节，从 1 变 5，导致这个 entry 的总字节数大于 254，下一个 entry 的 prevlen 又要 1 变 5。</li><li>小林的图文解释的很好。</li><li>这种现象叫连锁更新，时间复杂度是 On^2</li><li>连锁更新会带来性能问题，虽然实际很少遇到，但是 ziplist 最大的问题还是连锁更新导致性能不稳定</li></ul><p><strong>listpack 优化</strong></p><p>目的：解决连锁更新</p><p><strong>ziplist 连锁更新原因分析</strong></p><ol><li>list 是双端访问结构，而 ziplist 需要支持 list 双端访问的特性，在 entry 增加了 prevlen 字段记录上一个节点的长度，使其能够从后往前遍历。</li><li>连锁更新就是 prevlen 需要字节从 1 变 5 导致的</li></ol><p>entry 的结构</p><figure><img src="'+t+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>对症下药</strong></p><p>需要一种不记录 prevlen，并且还可以找到上一节点的起始位置的办法</p><p>listpack。</p><p><strong>listpack 节点定义</strong></p><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>encoding-type：编码类型</li><li>element-data：数据内容</li><li>element-tot-len：存储整个节点除了它自身之外的长度。就是 type+data</li></ul><p>element-tot-len</p><ul><li>tot-len 所占用的每个字节的第一个 bit 用于标识是否结束。</li><li>0 结束，1 结束。剩下的 7 个 bit 用来存储数据大小</li><li>当我们需要查找当前元素的上一个元素，可以从 tot-len 从后往前依次查找每一个字节，找到上一个 entry 的 tot-len 结束标识，就可以算出上一个节点的受位置</li><li>例子：上一个 tot-len 为 00000001 1000010，每个字节第一个 bit 标志是否结束。</li><li>从后往前依次查找，把有效的 7 位拿出来，拼接在一起：0000001 000010 = 132 字节</li><li>说明再往前走 132 字节就到了节点起始位置</li></ul><figure><img src="'+a+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>listpack 结构设计</strong></p><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>listpack entry 的三个字段就是上面的</li></ul><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>总结</strong></p><ul><li>listpack 和 ziplist 都叫压缩列表，前者是后者的进阶版，解决了连锁更新带来的性能瓶颈</li><li>在结构上没太大的区别，用 element-tot-len 取代了导致连锁更新的 prevlen</li></ul>',51)]))}const z=e(c,[["render",d],["__file","压缩列表.html.vue"]]),f=JSON.parse('{"path":"/back-end/redis/Data-object/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.html","title":"Redis压缩列表详解","lang":"zh-CN","frontmatter":{"title":"Redis压缩列表详解","description":"深入介绍Redis压缩列表的实现原理、优化策略及应用","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","压缩列表","数据结构","性能优化"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Data-object/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis压缩列表详解"}],["meta",{"property":"og:description","content":"深入介绍Redis压缩列表的实现原理、优化策略及应用"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"压缩列表"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis压缩列表详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":6.08,"words":1823},"filePathRelative":"back-end/redis/Data-object/压缩列表.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>压缩列表</strong></p>\\n<p><strong>压缩列表是什么</strong></p>\\n<ul>\\n<li>压缩列表：排列紧凑的列表</li>\\n<li>压缩列表在 redis 中有两种编码形式</li>\\n<li>ziplist</li>\\n<li>listpack：5.0 引入，直到 7.0 完全取代 ziplist，成为 ziplist 的进阶版本</li>\\n</ul>\\n<p><strong>解决什么问题</strong></p>\\n<p>压缩列表是 list 的底层数据结构，压缩列表作为底层数据结构能提供紧凑型的数据存储方式，能节约内存（节省链表指针的开销），小数据量时遍历访问性能好（连续+缓存命中率高）</p>"}');export{z as comp,f as data};
