import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as e,d as r,e as n,o as l}from"./app-DRR9Yo7Y.js";const o="/assets/Kafka%20%E6%9E%B6%E6%9E%84.001-mfVu0BHQ.png",s="/assets/Kafka%20%E6%9E%B6%E6%9E%84.002-Cvifq9AD.png",p="/assets/Kafka%20%E6%9E%B6%E6%9E%84.003-BYazzCxS.png",c="/assets/Kafka%20%E6%9E%B6%E6%9E%84.004-C3FYnKtB.png",d={};function f(g,a){return l(),i("div",null,[a[0]||(a[0]=e("h1",{id:"kafka-架构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kafka-架构"},[e("span",null,"Kafka 架构")])],-1)),a[1]||(a[1]=e("p",null,"本文详细介绍了Kafka的整体架构设计，包括生产者、服务层和消费者的工作原理。",-1)),r(" more "),a[2]||(a[2]=n('<h2 id="一、整体架构" tabindex="-1"><a class="header-anchor" href="#一、整体架构"><span>一、整体架构</span></a></h2><p>可以把 Kafka 宏观分成3层：生产者、服务层、消费者</p><ul><li><strong>Producer</strong>：很好理解，就是生产者，在Kafka中，Producer负责创建消息并将其发送到Kafka服务器。Producer是消息的源头，它们将消息发送到特定的主题中，以供Consumer订阅和消费。</li><li><strong>Server</strong>：即Kafka服务，可以认为是消息的中转站，因为消息不是从生产者直接发送到消费者的，而是先经过一个中转站存放，就像生活中的菜鸟驿站一样Kafka的服务端就担任了菜鸟驿站的角色，但跟菜鸟驿站不同的一点是Server会持久化存储信息，不是说消费了就没有了。</li><li><strong>Consumer</strong>：即消费者，是Kafka中的另一个重要角色，它们负责订阅主题并消费其中的消息，当生产者向Server传递了消息之后，如果是消费者订阅了对应的主题，那么消费者就会从Server拉取消息做业务处理。</li></ul><figure><img src="'+o+'" alt="Kafka整体架构图" tabindex="0" loading="lazy"><figcaption>Kafka整体架构图</figcaption></figure><h2 id="二、服务层的内部架构" tabindex="-1"><a class="header-anchor" href="#二、服务层的内部架构"><span>二、服务层的内部架构</span></a></h2><p>服务层的内部组成比较丰富：</p><ul><li><strong>Broker</strong>：可以理解为机器或者节点吧，也可以理解为就是运行Kafka程序的服务器。</li><li><strong>Topic</strong>：主题是Kafka中的一个核心概念，它是对消息进行分类的一种方式。生产者将消息发送到特定的主题中，而消费者则通过订阅主题来接收相关的消息。但是要注意的是，主题是一个逻辑概念，实际上，一个主题可以被分为多个分区(Partition)，以实现消息的并行处理和负载均衡，数据是存储在Partition这个级别的。</li><li><strong>Partition</strong>：分区是Kafka中的一个重要概念，它是主题的物理存储单位。每个分区都是一个有序的、不可变的消息序列，可以被独立地读写。分区在物理上对应一个文件夹及文件夹下面的文件，分区的命名规则为主题名称后接&quot;一&quot;连接符，之后再接分区编号，比如TopicA-1就表示主题A得1号分区，每个分区又可以有一至多个副本(Replica)，以提高可用性。</li></ul><h2 id="三、producer" tabindex="-1"><a class="header-anchor" href="#三、producer"><span>三、Producer</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>待补充Producer相关内容</p></div><h2 id="四、server" tabindex="-1"><a class="header-anchor" href="#四、server"><span>四、Server</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>待补充Server相关内容</p></div><h2 id="五、consumer" tabindex="-1"><a class="header-anchor" href="#五、consumer"><span>五、Consumer</span></a></h2><p>消费者通过订阅topic，主动拉取消息，消费信息</p><h3 id="_1-消费形式" tabindex="-1"><a class="header-anchor" href="#_1-消费形式"><span>1. 消费形式</span></a></h3><ol><li>不同消费者可以在同一时间对同一主题进行消费</li><li>同一消费者可以同一时间从同一主题的不同分片读取信息</li><li>如果一个消费者，同时消费多个分片下，无法保证消息之间的先后顺序</li><li>如果一个消费者，只消费一个分片，消费顺序即生产顺序，符合队列的先入先出特性</li></ol><figure><img src="'+s+'" alt="消费形式示意图" tabindex="0" loading="lazy"><figcaption>消费形式示意图</figcaption></figure><h3 id="_2-消费是主动拉取" tabindex="-1"><a class="header-anchor" href="#_2-消费是主动拉取"><span>2. 消费是主动拉取</span></a></h3><p>Kafka是需要消费者主动去Broker拉取消息回来消费的。</p><p>这样可以让消费者按照自身情况来控制消费速度，根据自身的资源利用情况、业务需要等等因素合理拉取消息。</p><p>消费者拉取的频率：max.poll.records，这个参数限制每次拉取返回的消息数量。</p><h3 id="_3-offset-消息偏移" tabindex="-1"><a class="header-anchor" href="#_3-offset-消息偏移"><span>3. Offset 消息偏移</span></a></h3><p>每条消息在Kafka中会有Partition ID以及OFFSET，通过这两个信息就可以定位到一条消息。</p><p>消费者消费消息之后会提交它在某个Partition对应的OFFSET，这样子下一次就可以从这个位置开始消费。</p><p>同时，如果一个指定的offset被确认，那么它之前的信息就相当于都确认了，下次消费是从它的下一条消息开始消费。</p><p>提交的动作可以是自动周期性进行，也就是每个周期会提交最新的已处理消息。</p><figure><img src="'+p+'" alt="Offset消息偏移示意图" tabindex="0" loading="lazy"><figcaption>Offset消息偏移示意图</figcaption></figure><h3 id="_4-消费者组" tabindex="-1"><a class="header-anchor" href="#_4-消费者组"><span>4. 消费者组</span></a></h3><ul><li>Kafka 支持组消费</li><li>消费者组的意思是将多个消费者组织在一起工作，构成一个小组</li><li>一个组由一个groupID唯一标识，由消费者这边指定</li></ul><p><strong>组消费的情况：</strong></p><ol><li>同一个消费组中，每个分片只会分配给一个消费者</li><li>同一个消费组中，消费者可以被指派多个分片</li><li>不同消费组可以同一时间消费同一个主题</li></ol><figure><img src="'+c+'" alt="消费者组示意图" tabindex="0" loading="lazy"><figcaption>消费者组示意图</figcaption></figure><p><strong>使用消费者组的优势</strong></p><p>当不使用消费者组时，Kafka不会自动管理分区和消费者之间的关系，需要手动指定消费者要消费的分区，这就意味着如果Partition数量变了，消费者代码就得跟着升级，没法做到自动切换。</p><h3 id="_5-消费者组的分配策略、再平衡策略" tabindex="-1"><a class="header-anchor" href="#_5-消费者组的分配策略、再平衡策略"><span>5. 消费者组的分配策略、再平衡策略</span></a></h3><p>一个消费者组里有多个消费者，分区是按什么规则来分配给这些消费者的呢?</p><p>我们可以关注消费端partition.assignment.strategy这个配置，这个参数就是分区的策略，它有如下几种选择:</p><ol><li>Range Assignor：基于范围的分配策略，将分区按照范围分配给消费者</li><li>RoundRobin Assignor：基于轮询的分配策略，分区均匀地分配给消费者</li><li>Sticky Assignor：优先保持当前的分配状态，并尽量减少在再平衡过程中的分区移动</li><li>CooperativeStickyAssignor：和Sticky Assignor的策略是一样，区别在于未受变动的消费者可以继续消费主题</li></ol><div class="hint-container info"><p class="hint-container-title">触发再平衡的情况</p><ol><li><strong>新消费者加入：</strong> 当一个新的消费者加入消费者组时，Kafka需要重新分配分区，以包括新的消费者</li><li><strong>消费者离开：</strong> 当一个消费者离开(无论是正常关闭还是崩溃)时，需要重新分配该消费者负责的分区给其他消费者</li><li><strong>主题分区变化：</strong> 当主题的分区数量发生变化时(例如，增加新的分区)Kafka需要重新分配这些分区</li></ol></div><div class="hint-container info"><p class="hint-container-title">再平衡过程</p><ol><li><strong>暂停消费：</strong> 在再平衡过程中，消费者会暂停对消息的消费，以防止在重新分配期间发生数据丢失或重复</li><li><strong>触发再平衡：</strong> 由消费者组协调器(通常是Kafka集群中的一个Broker)触发再平衡</li><li><strong>重新分配分区：</strong> 协调器根据当前消费者组的成员重新分配主题的分区</li><li><strong>通知消费者：</strong> 重新分配完成后，协调器会通知所有消费者新的分配情况</li><li><strong>恢复消费：</strong> 消费者收到新的分配后，恢复消费，开始处理被分配到的新分区</li></ol></div>',39))])}const m=t(d,[["render",f],["__file","Kafka架构.html.vue"]]),u=JSON.parse('{"path":"/back-end/kafka/Kafka%E6%9E%B6%E6%9E%84.html","title":"Kafka 架构","lang":"zh-CN","frontmatter":{"title":"Kafka 架构","description":"深入解析Kafka的整体架构、服务层内部架构以及生产者消费者模型","date":"2024-01-01T00:00:00.000Z","category":["消息队列"],"tag":["Kafka","架构设计","分布式系统"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/kafka/Kafka%E6%9E%B6%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Kafka 架构"}],["meta",{"property":"og:description","content":"深入解析Kafka的整体架构、服务层内部架构以及生产者消费者模型"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Kafka"}],["meta",{"property":"article:tag","content":"架构设计"}],["meta",{"property":"article:tag","content":"分布式系统"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kafka 架构\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[{"level":2,"title":"一、整体架构","slug":"一、整体架构","link":"#一、整体架构","children":[]},{"level":2,"title":"二、服务层的内部架构","slug":"二、服务层的内部架构","link":"#二、服务层的内部架构","children":[]},{"level":2,"title":"三、Producer","slug":"三、producer","link":"#三、producer","children":[]},{"level":2,"title":"四、Server","slug":"四、server","link":"#四、server","children":[]},{"level":2,"title":"五、Consumer","slug":"五、consumer","link":"#五、consumer","children":[{"level":3,"title":"1. 消费形式","slug":"_1-消费形式","link":"#_1-消费形式","children":[]},{"level":3,"title":"2. 消费是主动拉取","slug":"_2-消费是主动拉取","link":"#_2-消费是主动拉取","children":[]},{"level":3,"title":"3. Offset 消息偏移","slug":"_3-offset-消息偏移","link":"#_3-offset-消息偏移","children":[]},{"level":3,"title":"4. 消费者组","slug":"_4-消费者组","link":"#_4-消费者组","children":[]},{"level":3,"title":"5. 消费者组的分配策略、再平衡策略","slug":"_5-消费者组的分配策略、再平衡策略","link":"#_5-消费者组的分配策略、再平衡策略","children":[]}]}],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":6.08,"words":1824},"filePathRelative":"back-end/kafka/Kafka架构.md","localizedDate":"2024年1月1日","excerpt":"\\n<p>本文详细介绍了Kafka的整体架构设计，包括生产者、服务层和消费者的工作原理。</p>\\n"}');export{m as comp,u as data};
