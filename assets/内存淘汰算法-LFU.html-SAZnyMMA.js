import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,e as r,o as n}from"./app-DRR9Yo7Y.js";const o="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.001-BHeKdv19.png",p="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.002-BvwrJwvl.png",a="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.003-QeK9WzKo.png",s="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.004-D1I7x3Sb.png",l="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.005-Bv3R75Ge.png",g="/assets/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.006-D7eiFFpn.png",c={};function d(m,t){return n(),i("div",null,t[0]||(t[0]=[r('<p><strong>内存淘汰算法-LFU</strong></p><p>最不频繁淘汰算法，优先淘汰活跃最低、使用频率最低的</p><p><strong>为什么 4.0 引入 LFU</strong></p><p>LRU 能解决大部分场景，但是一下场景</p><ul><li>mart 会被淘汰</li></ul><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>LFU</strong></p><p>回顾一下 redisObject 结构</p><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>LFU 和 LRU 不会同时开启，因此LFU 会复用 lru 这个字段来统计访问情况</p><ul><li>lru 原本 24 位，LFU 将其拆成高16 + 低 8</li><li>高 16：存 ldt（Last Decrement Time）</li><li>低 8：存 logc（Logistic Counter）</li></ul><p>key 是否活跃，由这两个字段综合决定</p><figure><img src="'+a+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>高 16 位保存上次访问的时间戳，比原来少了 8 位，因此 LFU 下时间精度是 1 分钟</li><li>👁️2^16 = 65536，如果用秒作为精度，范围太小。用分钟可以表示 1092 小时，范围大点</li><li>后 8 位存储访问计数</li></ul><p>访问计数的 8 bits</p><ul><li>如果上一次访问时间很久，那么访问计数就会衰减</li><li>为什么要衰减，因为只是简单的增加访可计数的方法并不完美，访问的热度一直在变，比如一个key,他原来是255,夸张一点，一年没访问了，不该归零么。</li><li>而本身访问，会增加访问计数。</li><li>当然，最后起作用的就是访问计数。</li></ul><p><strong>源码分析</strong></p><p><strong>LFU 数据更新</strong></p><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>第一步，计算次数衰减</strong></p><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>第二步，一定概率增加访问次数</strong></p><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>第三步，更新</strong></p><p>当前时间更新到高16位，次数更新到低8位</p>',25)]))}const f=e(c,[["render",d],["__file","内存淘汰算法-LFU.html.vue"]]),B=JSON.parse('{"path":"/back-end/redis/Operating-principle/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.html","title":"Redis LFU内存淘汰算法详解","lang":"zh-CN","frontmatter":{"title":"Redis LFU内存淘汰算法详解","description":"深入分析Redis LFU（Least Frequently Used）算法的实现原理及应用","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","LFU","内存淘汰","算法原理"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Operating-principle/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95-LFU.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis LFU内存淘汰算法详解"}],["meta",{"property":"og:description","content":"深入分析Redis LFU（Least Frequently Used）算法的实现原理及应用"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"LFU"}],["meta",{"property":"article:tag","content":"内存淘汰"}],["meta",{"property":"article:tag","content":"算法原理"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis LFU内存淘汰算法详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":1.59,"words":477},"filePathRelative":"back-end/redis/Operating-principle/内存淘汰算法-LFU.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>内存淘汰算法-LFU</strong></p>\\n<p>最不频繁淘汰算法，优先淘汰活跃最低、使用频率最低的</p>\\n<p><strong>为什么 4.0 引入 LFU</strong></p>\\n<p>LRU 能解决大部分场景，但是一下场景</p>\\n<ul>\\n<li>mart 会被淘汰</li>\\n</ul>\\n<figure><figcaption>...</figcaption></figure>\\n<p><strong>LFU</strong></p>\\n<p>回顾一下 redisObject 结构</p>\\n<figure><figcaption>...</figcaption></figure>"}');export{f as comp,B as data};
