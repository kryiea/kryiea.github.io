import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,e as l,o as n}from"./app-DRR9Yo7Y.js";const o="/assets/%E4%BC%A0%E8%BE%93%E5%B1%82.001-BkDIgnR7.png",p="/assets/%E4%BC%A0%E8%BE%93%E5%B1%82.002-CUqHOHb8.png",r={};function s(a,t){return n(),e("div",null,t[0]||(t[0]=[l('<p><strong>传输层</strong></p><p><strong>一、TCP 三次握手（以SOCKET的角度）</strong></p><p><strong>二、TCP 四次挥手</strong></p><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol><li><strong>TIME_WAIT 状态的产生</strong></li></ol><p>该状态出现在主动断开方，在主动断开方完成第四次挥手，也就是发送完最后一个ACK报文后，进入 TIME_WAIT 状态，该状态会持续 2MSL 的时长，以确保对方已收到了最后一个ACK报文。</p><ul><li>**MSL：**最大报文存活时长，单位是时间，Linux默认 30s。</li><li>**TTL：**IP报文在网络中允许经过的最大路由数，单位是经过路由数，Linux默认64。</li></ul><ol start="2"><li><strong>TIME_WAIT 为什么要等待 2MSL</strong></li></ol><p>2 MSL的时长，相当于：允许报文在网络中丢失一次。</p><p>比如：第四挥手ACK报文没有被被动方接收到，1个MSL后该ACK报文在网路中消亡，被动方由于没有收到ACK响应，会启动FIN报文重传，另一方接收到FIN报文，就可以重发ACK报文。这样的一来一回正是 2MSL时长内。</p><ol start="3"><li><strong>TIME_WAIT 过多的危害</strong></li></ol><p>在Linux中，某种东西过多一般会意味着：占用系统资源。文件描述符、内存资源、CPU资源等等。</p><p>TIME_WAIT 过多的时候，由于与网络有关，所以会有以下两个基本的影响：</p><ol><li>占用系统资源，一切皆文件，会占用较多的文件描述符、内存资源。</li><li>占用系统端口，端口资源是有限的，linux一般可以开启的端口为 3w-6w。</li></ol><p>在以上基本影响外，客户端和服务端的 TIME_WAIT 过多的影响也有不同：</p><ol><li><p>客户端：TCP四元组确定一条连接，所以不能对 目的IP+目的port 相同的服务端发起连接请求，端口耗尽。</p></li><li><p>服务端：由于TCP四元组确定一条连接，所以服务端可以处理的TCP连接理论上可以非常多，但是TCP连接在服务端会受限于系统资源，文件描述符和内存资源</p></li><li><p><strong>TIME_WAIT 过多如何解决</strong></p></li></ol><ul><li>**客户端：**可以考虑开启 tcp_tw_reuse 参数，设置为1为开启。当发起新连接的时候，就会复用处于 time_wait的连接。</li><li>启用后，处于 TIME-WAIT 状态的连接可能被重用。这种重用可能导致新的连接混淆，因为内核会重用一个旧连接的五元组（源 IP、源端口、目的 IP、目的端口和协议），这可能导致数据包被误导。</li><li>**服务端：**说明服务端主动关闭了连接，服务端应该尽量避免主动断开连接，由客户端来进行，可以在应用层设计一个逻辑，当服务端要断开的时候，发送一个消息给客户端，让客户端收到信息后发起断开TCP连接。</li></ul><ol start="5"><li><strong>TIME_WAIT 在服务端大量出现的原因？</strong></li></ol><p>相当于： 服务端为什么会主动关闭连接？</p><ol><li><p>**没有开启HTTP长连接：**服务端发完HTTP响应后，会主动关闭连接。</p></li><li><p>**HTTP长连接的请求数量设置过小：**web服务端通常会有个参数来定义 HTTP 长连接能处理的最大请求数量，比如 nginx的 keepalive_requests默认是100。QPS高的时候，就会频繁关闭连接，导致time_wait过多。</p></li><li><p><strong>TIME_WAIT 状态设计的目的</strong></p></li></ol><p>设计 TIME_WAIT 状态，主要有两个原因：</p><ol><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收（序列号是32位，可能会有序列号绕回导致数据完整性破坏）；</li><li>保证「被动关闭连接」的一方，能被正确的关闭（确保有没有收到最后一次挥手）；</li></ol><p>假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。</p><figure><img src="'+p+`" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>32 位的序列号（2^32 = 4 GB）在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。</p><ol start="7"><li><strong>TCP_TW_REUSE 为什么默认关闭</strong></li></ol><ul><li>开启 tcp_tw_reuse 的同时，也需要开启tcp_timestamps。</li><li>开启了 tcp_timestamps参数，TCP 头部就会使用时间戳选项，它有两个好处，一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）。</li></ul><p><strong>默认关闭的原因：</strong></p><p>启用后，处于 TIME-WAIT 状态的连接可能被重用。这种重用可能导致新的连接混淆，因为内核会重用一个旧连接的五元组（源 IP、源端口、目的 IP、目的端口和协议），这可能导致数据包被误导。</p><p><strong>三、TCP长连接、HTTP长连接 的保活机制</strong></p><ul><li>**TCP长连接保活：**通过探测报文来检测连接状态。这是传输层的机制，独立于应用层的具体协议。</li><li>**HTTP长连接保活：**通过Connection: keep-alive和Keep-Alive头部字段来管理连接的持久性和空闲超时。</li></ul><div class="language-http line-numbers-mode" data-highlighter="shiki" data-ext="http" data-title="http" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Connection</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> keep-alive</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">Keep-Alive</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> timeout=5, max=100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>HTTP长连接的保活实际上是由两部分组成的：应用层的HTTP保活机制和传输层的TCP保活机制。</p><ul><li>HTTP保活负责管理HTTP请求/响应的连接复用和空闲超时</li><li>TCP保活负责确保底层连接的持续有效性。如果TCP连接因任何原因断开，HTTP长连接也会失效。</li></ul><p><strong>三、socket 五元组</strong></p><ol><li>源IP地址</li><li>目的IP地址</li><li>源端口号</li><li>目的端口号</li><li>传输协议（通常是TCP或UDP）</li></ol><p>常说的TCP四元组，是指默认 传输协议固定为TCP的情况下讨论的。</p><p>也可以得出，tcp/udp可以使用同一个端口。因为传输协议不同，不会认为是相同的连接。</p><p><strong>四、传输层的报文</strong></p><ol><li><strong>端口</strong></li></ol><p>tcp和udp都有端口字段，用于区分同一主机的不同应用程序的数据包。</p>`,41)]))}const c=i(r,[["render",s],["__file","传输层.html.vue"]]),m=JSON.parse('{"path":"/back-end/network/%E4%BC%A0%E8%BE%93%E5%B1%82.html","title":"计算机网络传输层详解","lang":"zh-CN","frontmatter":{"title":"计算机网络传输层详解","description":"详细介绍传输层协议、TCP/UDP原理及其应用","date":"2024-01-01T00:00:00.000Z","category":["计算机网络","网络协议"],"tag":["TCP","UDP","传输层","网络协议"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/network/%E4%BC%A0%E8%BE%93%E5%B1%82.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"计算机网络传输层详解"}],["meta",{"property":"og:description","content":"详细介绍传输层协议、TCP/UDP原理及其应用"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"TCP"}],["meta",{"property":"article:tag","content":"UDP"}],["meta",{"property":"article:tag","content":"传输层"}],["meta",{"property":"article:tag","content":"网络协议"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"计算机网络传输层详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":5.52,"words":1657},"filePathRelative":"back-end/network/传输层.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>传输层</strong></p>\\n<p><strong>一、TCP 三次握手（以SOCKET的角度）</strong></p>\\n<p><strong>二、TCP 四次挥手</strong></p>\\n<figure><figcaption>...</figcaption></figure>\\n<ol>\\n<li><strong>TIME_WAIT 状态的产生</strong></li>\\n</ol>\\n<p>该状态出现在主动断开方，在主动断开方完成第四次挥手，也就是发送完最后一个ACK报文后，进入 TIME_WAIT 状态，该状态会持续 2MSL 的时长，以确保对方已收到了最后一个ACK报文。</p>"}');export{c as comp,m as data};
