import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,e,o as n}from"./app-CB9WG6K8.js";const r="/assets/%E5%BA%94%E7%94%A8%E5%B1%82.001-BJDPxoTh.png",o="/assets/%E5%BA%94%E7%94%A8%E5%B1%82.002--ifYNlAz.png",p="/assets/%E5%BA%94%E7%94%A8%E5%B1%82.003-D9AKksv6.png",a={};function s(g,t){return n(),l("div",null,t[0]||(t[0]=[e('<p><strong>应用层</strong></p><p><strong>一、HTTP</strong></p><ol><li><strong>状态码</strong></li></ol><ul><li>200类 表示：服务端正常处理客户端的请求</li><li>200：成功，通常body会有数据</li><li>204：也是成功，但是没有body数据</li><li>206：文件断点续传</li><li>300类 表示：客户端请求的资源发生了变动，需要用新的url重新发送请求获取资源。</li><li>301：永久重定向。浏览器会记录新的url，下次会自动跳转。</li><li>302：临时重定向。要到新的url请求资源，但这不是永久的，还会更改。</li><li>304：表示资源请求成功，在本地浏览器缓存就有这个资源。</li><li>400类 表示：客户端请求报文有误，服务端无法处理。</li><li>400：请求报文有错误，是一个笼统的错误。</li><li>403：请求的资源权限不够。</li><li>404：请求的资源不存在。</li><li>500类 表示：客户端请求报文正确，但是服务端内部处理发生错误。</li><li>500：服务器程序错误</li><li>501：服务端不具备完成请求的功能，可能是无法识别这个请求方法</li><li>502：服务器作为网关层（nginx）返回的错误码，表示网关服务器正常，但是访问后端服务器错误。</li><li>503：服务器很忙，无法响应。也就是网络正忙</li><li>504：服务器作为网关，但是没有及时收到上游服务器的请求</li></ul><ol start="2"><li><strong>版本差异</strong></li></ol><table><thead><tr><th style="text-align:center;"><p><strong>http 1.0</strong></p><p>1. 明文传输</p><p>2. 默认短链接</p></th><th style="text-align:center;"><p><strong>http 1.1</strong></p><p>1. 明文传输</p><p>2. 默认长连接</p><p>3. 无法并发传输</p><p></p></th><th style="text-align:center;"><p><strong>http 2.0</strong></p><p>1. 基于https，基于tls1.2（rsa算法，2RTT） 握手。</p><p>2. 引入stream，复用tcp连接能并发传输。</p><p>3. 头部压缩，hpack算法压缩http报文的头部</p><p>4. 明文传输改为二进制格式，提高传输效率</p><p>5. 支持服务器主动推送资源。</p><p></p></th><th style="text-align:center;"><p><strong>http 3.0</strong></p><p>1. 基于udp协议，并在应用层实现可靠机制。用tls1.3（rcdhe算法，1RTT）握手</p><p>2. udp协议解决tcp的对头阻塞问题</p><p>3. 只要3次握手就可以完成3tcp+4tls的过程。</p><p>4. 网络切换不需要重新建立连接，在应用层通过连接id来维护，而不是tcp4元组</p></th></tr></thead><tbody><tr><td style="text-align:center;"><strong>二、HTTPS</strong></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><ol start="3"><li><strong>TLS握手 - RSA算法</strong></li></ol><figure><img src="'+r+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>CA 签发证书的过程，如上图左边部分：</strong></p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p><strong>客户端校验服务端的数字证书的过程，如上图右边部分：</strong></p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p><strong>三、HTTP 状态维护</strong></p><ol><li><strong>JWT</strong></li></ol><p><strong>[该类型的内容暂不支持下载]</strong></p><p><strong>四、ngnix</strong></p><ol><li><strong>正向代理、反向代理</strong></li></ol><ul><li>**正向代理：**代理客户端，相当于客户端是第三方身份，服务器不知道真实的客户端。</li><li>**反向代理：**代理服务端，相当于服务器是第三方身份，客户端不知道真实的服务器。</li></ul><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol start="2"><li><strong>负载均衡算法</strong></li></ol>',21)]))}const m=i(a,[["render",s],["__file","应用层.html.vue"]]),h=JSON.parse('{"path":"/back-end/network/%E5%BA%94%E7%94%A8%E5%B1%82.html","title":"计算机网络应用层详解","lang":"zh-CN","frontmatter":{"title":"计算机网络应用层详解","description":"深入介绍应用层协议、HTTP/HTTPS、DNS等常用协议","date":"2024-01-01T00:00:00.000Z","category":["计算机网络","网络协议"],"tag":["HTTP","HTTPS","DNS","应用层"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/network/%E5%BA%94%E7%94%A8%E5%B1%82.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"计算机网络应用层详解"}],["meta",{"property":"og:description","content":"深入介绍应用层协议、HTTP/HTTPS、DNS等常用协议"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"HTTP"}],["meta",{"property":"article:tag","content":"HTTPS"}],["meta",{"property":"article:tag","content":"DNS"}],["meta",{"property":"article:tag","content":"应用层"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"计算机网络应用层详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":3.37,"words":1012},"filePathRelative":"back-end/network/应用层.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>应用层</strong></p>\\n<p><strong>一、HTTP</strong></p>\\n<ol>\\n<li><strong>状态码</strong></li>\\n</ol>\\n<ul>\\n<li>200类 表示：服务端正常处理客户端的请求</li>\\n<li>200：成功，通常body会有数据</li>\\n<li>204：也是成功，但是没有body数据</li>\\n<li>206：文件断点续传</li>\\n<li>300类 表示：客户端请求的资源发生了变动，需要用新的url重新发送请求获取资源。</li>\\n<li>301：永久重定向。浏览器会记录新的url，下次会自动跳转。</li>\\n<li>302：临时重定向。要到新的url请求资源，但这不是永久的，还会更改。</li>\\n<li>304：表示资源请求成功，在本地浏览器缓存就有这个资源。</li>\\n<li>400类 表示：客户端请求报文有误，服务端无法处理。</li>\\n<li>400：请求报文有错误，是一个笼统的错误。</li>\\n<li>403：请求的资源权限不够。</li>\\n<li>404：请求的资源不存在。</li>\\n<li>500类 表示：客户端请求报文正确，但是服务端内部处理发生错误。</li>\\n<li>500：服务器程序错误</li>\\n<li>501：服务端不具备完成请求的功能，可能是无法识别这个请求方法</li>\\n<li>502：服务器作为网关层（nginx）返回的错误码，表示网关服务器正常，但是访问后端服务器错误。</li>\\n<li>503：服务器很忙，无法响应。也就是网络正忙</li>\\n<li>504：服务器作为网关，但是没有及时收到上游服务器的请求</li>\\n</ul>"}');export{m as comp,h as data};
