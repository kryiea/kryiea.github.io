import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,e as a,o}from"./app-DRR9Yo7Y.js";const p="/assets/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.001-Dxvhgo78.png",n="/assets/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.002-s9Xwc5WO.png",r="/assets/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.003-GU0OO7UR.png",l="/assets/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.004-C5y8mLnL.png",s="/assets/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.005-CZrgGzNM.png",c="/assets/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.006-C-1F9y_v.png",g="/assets/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.007-CSrhM_EM.png",m={};function d(f,t){return o(),e("div",null,t[0]||(t[0]=[a('<p><strong>消息队列</strong></p><p><strong>是什么</strong></p><ul><li>传递消息的队列，有先入先出的特性。</li><li>消息队列一般用于异步流程，消息分发，流量削峰</li><li>消息队列可以实现高性能、高可用、高拓展的架构</li></ul><p>比较出名的消息队列</p><p>ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ</p><p><strong>redis 做消息队列</strong></p><p>上面出名的消息队列，比如 kafka 都是很优秀的消息队列中间件，但是接入和维护一个消息队列中间件，还是比较繁重的事务。</p><p>轻量级的消息队列能用 redis 实现</p><p><strong>List 做消息队列</strong></p><p>回顾 List</p><ol><li>是一个双端列表，可以先入先出</li></ol><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>使用 List 相关命令就可以实现一个消息队列</p><ol><li>RPUSH</li><li>LPOP</li></ol><p>缺点 1</p><p>消费者无法知道 LPOP 时机，只能不停按时间间隔轮询。</p><p>解决 1：阻塞版 POP</p><ol><li>BRPOP</li><li>BLPOP</li></ol><p>如果没有消息，就会阻塞，直到达到超时时间，设置为 10S</p><figure><img src="'+n+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>缺点 2：无 ACK 机制</p><p>消费者去消息后，消息就退出队列了，如果消费失败，消息还得想办法放回去，同时也不支持多人消费</p><p><strong>Pub/Sub 生产订阅模式</strong></p><p>当某个订阅者订阅了某个频道，如果生产者将消息发送到这个频道，订阅者就会收到该消息，支持多个消费者订阅相同的频道，无不干扰</p><figure><img src="'+r+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>用法</p><ol><li>两个客户端订阅 chanmsg 这个 channel，语法：subscribe channel</li></ol><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol><li>在第三个终端，连续发送 3 条信息，语法：publish channel message</li></ol><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol><li>在订阅者终端，两个终端均显示如下</li></ol><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>订阅者支持订阅模式，即一个模式消息，比如 chan*，就订阅所有 chan 开头的频道</p><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>缺点</p><ol><li>不支持 ack</li><li>不支持持久化，redis 重启，信息会全部丢失，所以适合处理不那么重要的信息</li></ol><p><strong>stream 做消息队列</strong></p><p>。不重要</p><p><strong>几种方式对比</strong></p><ul><li>List，不需要ACK，不需要消费组，可用</li><li>PUB/SUB，不需要ACK，不需要持久化，可用</li><li>Stream，需要ACK，需要消费组，需要持久化，可用 Stream功能最全，但是相对完备的消息队列中间件比如Kafka，可靠性还是很大差距，不支持至少一次语意，因为Redis本身的数据持久化都是有时间空隙的，如果对数据的可靠要求比较强，还是需要用完整的消息中间件。</li></ul><p>Redis这三种，是三种不同功能要求下的消息传递手段，Stream相对来说在轻量级里相对完善。</p>',41)]))}const _=i(m,[["render",d],["__file","消息队列.html.vue"]]),y=JSON.parse('{"path":"/back-end/redis/application/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html","title":"Redis消息队列实现详解","lang":"zh-CN","frontmatter":{"title":"Redis消息队列实现详解","description":"详细介绍如何使用Redis实现消息队列及其应用场景","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","消息队列","异步处理","系统设计"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/application/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis消息队列实现详解"}],["meta",{"property":"og:description","content":"详细介绍如何使用Redis实现消息队列及其应用场景"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:tag","content":"异步处理"}],["meta",{"property":"article:tag","content":"系统设计"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis消息队列实现详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.54,"words":762},"filePathRelative":"back-end/redis/application/消息队列.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>消息队列</strong></p>\\n<p><strong>是什么</strong></p>\\n<ul>\\n<li>传递消息的队列，有先入先出的特性。</li>\\n<li>消息队列一般用于异步流程，消息分发，流量削峰</li>\\n<li>消息队列可以实现高性能、高可用、高拓展的架构</li>\\n</ul>\\n<p>比较出名的消息队列</p>\\n<p>ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ</p>\\n<p><strong>redis 做消息队列</strong></p>\\n<p>上面出名的消息队列，比如 kafka 都是很优秀的消息队列中间件，但是接入和维护一个消息队列中间件，还是比较繁重的事务。</p>"}');export{_ as comp,y as data};
