import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,d as n,e as l,o as t}from"./app-0osyVvdq.js";const h="/assets/JNF7banE4oFBn5xvvXccdmgOnid-CwUysfAo.png",r="/assets/HHB4bmGosoUijWx36H6cHYoNn7b-W1kHCtAt.png",d="/assets/Aghyb8g9coWg5rxTlBEczu5enec-BSd9lBat.png",k={};function p(c,i){return t(),e("div",null,[i[0]||(i[0]=a("p",null,"dokcer 的框架与核心概念",-1)),n(" more "),i[1]||(i[1]=l('<h1 id="docker-框架与核心" tabindex="-1"><a class="header-anchor" href="#docker-框架与核心"><span>Docker 框架与核心</span></a></h1><h2 id="一、docker-镜像、容器、仓库" tabindex="-1"><a class="header-anchor" href="#一、docker-镜像、容器、仓库"><span>一、docker 镜像、容器、仓库</span></a></h2><h3 id="_1-1-镜像" tabindex="-1"><a class="header-anchor" href="#_1-1-镜像"><span>1.1 <strong>镜像</strong></span></a></h3><ul><li>它是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。</li><li>所以你想启动一个容器，那首先必须要有一个镜像。</li></ul><h3 id="_1-2-容器" tabindex="-1"><a class="header-anchor" href="#_1-2-容器"><span>1.2 <strong>容器</strong></span></a></h3><ul><li>容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。</li><li>即<strong>容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态。</strong></li><li>虽然容器的本质是主机上运行的一个进程，但是**容器有自己独立的命名空间隔离和资源限制。**也就是说，在容器内部，无法看到主机上的进程、环境变量、网络等信息，这是容器与直接运行在主机上进程的本质区别。</li></ul><h3 id="_1-3-仓库" tabindex="-1"><a class="header-anchor" href="#_1-3-仓库"><span>1.3 <strong>仓库</strong></span></a></h3><ul><li>Docker 的镜像仓库类似于代码仓库，用来存储和分发 Docker 镜像。</li><li>镜像仓库分为公共镜像仓库和私有镜像仓库。目前，<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">Docker Hub</a> 是 Docker 官方的公开镜像仓库</li></ul><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="二、docker-框架架构" tabindex="-1"><a class="header-anchor" href="#二、docker-框架架构"><span>二、docker 框架架构</span></a></h2><ul><li>Docker 整体架构采用 C/S 模式，主要由客户端和服务端两大部分组成。</li><li>客户端负责发送操作指令，服务端负责接收和处理指令。</li></ul><figure><img src="'+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-1-docker-客户端" tabindex="-1"><a class="header-anchor" href="#_2-1-docker-客户端"><span>2.1 docker 客户端</span></a></h3><p>有 3 种</p><ul><li>Docker cli</li><li>Docker rest api</li><li>语言的 SDK</li></ul><h3 id="_2-2-docker-服务端" tabindex="-1"><a class="header-anchor" href="#_2-2-docker-服务端"><span>2.2 docker 服务端</span></a></h3><p>Docker 服务端是 Docker 所有后台服务的统称。</p><ul><li><code>dockerd</code> 是一个非常重要的后台管理进程，它负责响应和处理来自 Docker 客户端的请求，然后将客户端的请求转化为 Docker 的具体操作。</li><li><code>dockerd</code> 通过 <code>grpc</code> 与 <code>containerd</code> 通信</li></ul><h3 id="_2-3-docker-重要组件" tabindex="-1"><a class="header-anchor" href="#_2-3-docker-重要组件"><span>2.3 docker 重要组件</span></a></h3><p>图上有 ⬇️</p><ul><li><code>runc</code>：runC 是一个用来运行容器的轻量级工具，是真正用来运行容器的。</li><li><code>containerd</code>：containerd 通过 containerd-shim 启动并管理 runC，可以说 containerd 真正管理了容器的生命周期。</li></ul><h3 id="_2-4-docker-各组件之间的关系" tabindex="-1"><a class="header-anchor" href="#_2-4-docker-各组件之间的关系"><span>2.4 <strong>Docker 各组件之间的关系</strong></span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> busybox</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sleep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3600</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> #这个容器会在后台运行一个简单的sleep任务，即等待 3600 秒，然后停止。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>启动一个 busybox 容器(是一个非常小巧的 Linux 镜)，查看进程的父子关系：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> pstree</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -l</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -a</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -A</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4147</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dockerd</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-containerd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --config</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/run/docker/containerd/containerd.toml</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --log-level</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> info</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |   |</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-containerd-shim</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -namespace</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> moby</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -workdir</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/d14d20507073e5743e607efd616571c834f1a914f903db6279b8de4b5ba3a45a</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -address</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/run/docker/containerd/containerd.sock</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -containerd-binary</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /usr/bin/containerd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -runtime-root</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/run/docker/runtime-runc</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |   |   |</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-sleep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3600</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>dockerd 启动的时候， containerd 就随之启动了，dockerd 与 containerd 一直存在。</p><p>当执行 <code>docker run</code> 命令（通过 busybox 镜像创建并启动容器）时，containerd 会创建 <code>containerd-shim</code> 充当 “垫片” 进程，然后启动容器的真正进程 sleep 3600 。</p><h2 id="三、docker-数据管理" tabindex="-1"><a class="header-anchor" href="#三、docker-数据管理"><span>三、docker 数据管理</span></a></h2><p>在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><h3 id="_3-1-数据卷" tabindex="-1"><a class="header-anchor" href="#_3-1-数据卷"><span>3.1 数据卷</span></a></h3><p>数据卷是一个<u>可供一个或多个容器使用</u>的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷 可以在容器之间共享和重用。</li><li>对 数据卷 的修改会立马生效。</li><li>对 数据卷 的更新，不会影响镜像 。</li><li>数据卷 默认会一直存在，即使容器被删除。</li></ul><h4 id="创建一个数据卷" tabindex="-1"><a class="header-anchor" href="#创建一个数据卷"><span>创建一个数据卷</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> volume</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> myVolName</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="查看所有数据卷" tabindex="-1"><a class="header-anchor" href="#查看所有数据卷"><span>查看所有数据卷</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> volume</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ls</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="查看指定数据卷的信息" tabindex="-1"><a class="header-anchor" href="#查看指定数据卷的信息"><span>查看指定数据卷的信息</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> volume</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> inspect</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my-vol</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="启动一个挂载数据卷的容器" tabindex="-1"><a class="header-anchor" href="#启动一个挂载数据卷的容器"><span>启动一个挂载数据卷的容器</span></a></h4><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 数据卷 挂载到容器里。</p><p>在一次 <code>docker run</code> 中可以挂载多个 数据卷 。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 数据卷 到容器的 <code>/webapp </code> 目录。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -P</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> web</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    #-v my-vol:/wepapp \\</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    --mount</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> source=my-vol,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> target=/webapp</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    training/webapp</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    python</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> app.py</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除数据卷" tabindex="-1"><a class="header-anchor" href="#删除数据卷"><span>删除数据卷</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> volume</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my-vol</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_3-2-目录挂载" tabindex="-1"><a class="header-anchor" href="#_3-2-目录挂载"><span>3.2 目录挂载</span></a></h3><h4 id="挂载一个主机目录作为数据卷" tabindex="-1"><a class="header-anchor" href="#挂载一个主机目录作为数据卷"><span>挂载一个主机目录作为数据卷</span></a></h4><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -P</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> web</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    #-v my-vol:/wepapp \\</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    --mount</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> type=bind,source=/src/webapp,target=/opt/webapp</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    training/webapp</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    python</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> app.py</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code> 目录。</p><p>这个功能在进行测试 的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。</p><p>本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount </code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的<u>默认权限是读写</u> ，用户也可以通过增加 <code>readonly</code> 指定为 只读 。</p><p>加了 <code>readonly</code> 之后，就挂载为只读了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">touch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> new.txt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">touch:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> new.txt:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Read-only</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> file</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> system</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="查看容器的数据卷具体信息" tabindex="-1"><a class="header-anchor" href="#查看容器的数据卷具体信息"><span>查看容器的数据卷具体信息</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> inspect</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> web</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="挂载一个本地主机文件作为数据卷" tabindex="-1"><a class="header-anchor" href="#挂载一个本地主机文件作为数据卷"><span>挂载一个本地主机文件作为数据卷</span></a></h4><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><h2 id="四、docker-网络模式" tabindex="-1"><a class="header-anchor" href="#四、docker-网络模式"><span>四、docker 网络模式</span></a></h2><h3 id="_4-1-端口映射-外部访问容器" tabindex="-1"><a class="header-anchor" href="#_4-1-端口映射-外部访问容器"><span>4.1 端口映射 外部访问容器</span></a></h3><p>以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。注意大小写。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>例子：</p><ul><li><code>docker run -d -p 5000:5000</code> 此时默认会绑定本地所有接口上的所有地址。</li><li><code>docker run -d -p 127.0.0.1:5000:5000</code> 映射到指定地址的指定端口</li><li><code>docker run -d -p 127.0.0.1::5000</code> 映射到指定地址的任意端口</li><li><code>docker run -d -p 127.0.0.1:5000:5000/udp</code> 还可以使用 udp 标记来指定 udp 端口</li></ul><p><code>-p</code> 标记还可以多次使用来绑定多个端口：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\ </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 5000:5000</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\ </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 3000:80</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-查看端口映射配置" tabindex="-1"><a class="header-anchor" href="#_4-2-查看端口映射配置"><span>4.2 查看端口映射配置</span></a></h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址。</p><h3 id="_4-3-容器互联" tabindex="-1"><a class="header-anchor" href="#_4-3-容器互联"><span>4.3 容器互联</span></a></h3><p>新建容器网络，<code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 、<code>overlay</code>。</p><p>其中 <code>overlay</code> 网络类型用于 <code>Swarm mode</code>。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> network</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> create</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bridge</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my-net</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 运行一个容器并加入到 my-net 网络</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -it</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --rm</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> busybox2</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --network</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> my-net</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> busybox</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sh</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-4-网络模式" tabindex="-1"><a class="header-anchor" href="#_4-4-网络模式"><span>4.4 网络模式</span></a></h3><h4 id="基础理论" tabindex="-1"><a class="header-anchor" href="#基础理论"><span>基础理论</span></a></h4><p>docker 使用 Linux 桥接网卡，在宿主机虚拟一个<u>docker 容器网桥</u><u>docker0</u>。</p><p>docker 启动一个容器时会根据 docker 网桥的网段分配给容器一个 IP 地址，称为 <code>Container-IP</code>，同时 Docker 网桥是每个容器的默认网络网关。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ip</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> address</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">4:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> docker0:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  mtu</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1500</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> qdisc</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> noqueue</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> state</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> DOWN</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> group</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> defa</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ult</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                                                                         </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    link/ether</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 02:42:ef:30:24:5b</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> brd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ff:ff:ff:ff:ff:ff</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                      </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    inet</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 172.17.0.1/16</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> brd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 172.17.255.255</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> scope</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> global</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> docker0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                              </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">       valid_lft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forever</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> preferred_lft</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> forever</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 <code>Container-IP</code> 直接通信。</p><p>docker 网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接 <code>Container-IP</code> 访问到容器。</p><p>如果容器希望外部访问能够访问到，可以通过端口映射，即通过 <code>-p或-P</code> 参数来启用，访问容器的时候就通过 <code>宿主机IP:容器端口</code> 访问容器。</p><h4 id="dokcer-支持的网络模式" tabindex="-1"><a class="header-anchor" href="#dokcer-支持的网络模式"><span>Dokcer 支持的网络模式</span></a></h4><table><thead><tr><th>Docker 网络模式<br></th><th>配置<br></th><th>说明<br></th></tr></thead><tbody><tr><td>host 模式<br></td><td>-net=host<br><br></td><td>容器和宿主机共享 Network namespace。<br>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。<br></td></tr><tr><td>container 模式<br></td><td>-net=container:NAME_or_ID<br></td><td>容器和另外一个容器共享 Network namespace。<br>创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围。<br></td></tr><tr><td>none 模式<br></td><td>-net=none<br></td><td>容器有独立的 Network namespace，并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，配置 IP 等。<br>该模式关闭了容器的网络功能。<br></td></tr><tr><td>bridge 模式<br></td><td>-net=bridge<br></td><td>(默认模式)。此模式会为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0 虚拟网桥，通过 docker0 网桥以及 Iptable nat 表配置与宿主机通信<br></td></tr><tr><td>Macvlan network<br></td><td>无<br></td><td>容器具备 Mac 地址，使其显示为网络上的物理设备<br></td></tr><tr><td>Overlay<br></td><td>无<br></td><td>(覆盖网络)：利用 VXLAN 实现的 bridge 模式<br></td></tr></tbody></table><h4 id="bridge-模式" tabindex="-1"><a class="header-anchor" href="#bridge-模式"><span>Bridge 模式</span></a></h4><p>容器的默认的网络模式。该模式下的容器只有宿主机可以直接访问,外部主机是不可见的。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li>Docker Daemon 利用 veth pair 技术，在宿主机上创建两个虚拟网络接口设备，假设为 veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。</li><li>Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0 网桥上。保证宿主机的网络报 文可以发往 veth0;</li><li>Docker Daemon 将 veth1 添加到 Docker Container 所属的 namespace 下，并被改名为 eth0。 如此一来，保证宿主机的网络报文若发往 veth0 则立即会被 eth0 接收，实现宿主机到 Docker Container 网络的联通性;同时也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性。</li></ul></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。 这对接口一端在容器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT ）。</p><p>通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p></div><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="host-网络" tabindex="-1"><a class="header-anchor" href="#host-网络"><span>Host 网络</span></a></h4><p>host 模式相当于 Vmware 中的 NAT 模式，与宿主机在同一个网络中，但 <code>没有独立IP地址</code>。</p><p>启动容器使用 host 模式，容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。</p><p>使用 host 模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行 NAT，<code>host最大的优势就是网络性能比较好</code>，docker host 上已经使用的端口就不能再用了，网络的隔离性不好。</p><h4 id="container-网络模式" tabindex="-1"><a class="header-anchor" href="#container-网络模式"><span>Container 网络模式</span></a></h4><p>一种特殊 host 网络模式， ontainer 网络模式是 Docker 中一种较为特别的网络的模式。</p><p>在容器创建时使用 <code>– network=container:vm1</code> 指定。(vm1 指定的是运行的容器名)处于这个模式下的 Docker 容器会共享一个网络环境,这样两个容器之间可以使用 localhost 高效快速通信。</p><p>Container 网络模式没有改善容器与宿主机以外世界通信的情况(和桥接模式一样，不能连接宿主机以外的其他设备)。</p><p>这个模式指定新创建的容器和已经存在的一个容器<u>共享一个 Network Namespace</u>，而不是和宿主机共享。</p><p>新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><h4 id="none-模式" tabindex="-1"><a class="header-anchor" href="#none-模式"><span>None 模式</span></a></h4><p>none 模式可以在容器创建时通过 <code>-- network=none</code> 来指定。</p><p>使用 none 模式，Docker 容器有自己的 Network Namespace，但不进行任何网络配置。容器无网卡、IP、路由等信息，需自行添加网卡、配置 IP。此模式下容器只有 lo 回环网络，无其他网卡。</p>',102))])}const b=s(k,[["render",p],["__file","FrameworkAndcore.html.vue"]]),u=JSON.parse('{"path":"/back-end/docker/FrameworkAndcore.html","title":"docker 框架与核心","lang":"zh-CN","frontmatter":{"title":"docker 框架与核心","cover":null,"icon":"file","order":1,"author":null,"date":"2024-11-29T00:00:00.000Z","category":["docker"],"tag":["docker"],"sticky":false,"star":null,"footer":null,"copyright":null,"description":"dokcer 的框架与核心概念","head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/docker/FrameworkAndcore.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"docker 框架与核心"}],["meta",{"property":"og:description","content":"dokcer 的框架与核心概念"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-03T12:59:30.000Z"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:published_time","content":"2024-11-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-03T12:59:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"docker 框架与核心\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-29T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-03T12:59:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[{"level":2,"title":"一、docker 镜像、容器、仓库","slug":"一、docker-镜像、容器、仓库","link":"#一、docker-镜像、容器、仓库","children":[{"level":3,"title":"1.1 镜像","slug":"_1-1-镜像","link":"#_1-1-镜像","children":[]},{"level":3,"title":"1.2 容器","slug":"_1-2-容器","link":"#_1-2-容器","children":[]},{"level":3,"title":"1.3 仓库","slug":"_1-3-仓库","link":"#_1-3-仓库","children":[]}]},{"level":2,"title":"二、docker 框架架构","slug":"二、docker-框架架构","link":"#二、docker-框架架构","children":[{"level":3,"title":"2.1 docker 客户端","slug":"_2-1-docker-客户端","link":"#_2-1-docker-客户端","children":[]},{"level":3,"title":"2.2 docker 服务端","slug":"_2-2-docker-服务端","link":"#_2-2-docker-服务端","children":[]},{"level":3,"title":"2.3 docker 重要组件","slug":"_2-3-docker-重要组件","link":"#_2-3-docker-重要组件","children":[]},{"level":3,"title":"2.4 Docker 各组件之间的关系","slug":"_2-4-docker-各组件之间的关系","link":"#_2-4-docker-各组件之间的关系","children":[]}]},{"level":2,"title":"三、docker 数据管理","slug":"三、docker-数据管理","link":"#三、docker-数据管理","children":[{"level":3,"title":"3.1 数据卷","slug":"_3-1-数据卷","link":"#_3-1-数据卷","children":[{"level":4,"title":"创建一个数据卷","slug":"创建一个数据卷","link":"#创建一个数据卷","children":[]},{"level":4,"title":"查看所有数据卷","slug":"查看所有数据卷","link":"#查看所有数据卷","children":[]},{"level":4,"title":"查看指定数据卷的信息","slug":"查看指定数据卷的信息","link":"#查看指定数据卷的信息","children":[]},{"level":4,"title":"启动一个挂载数据卷的容器","slug":"启动一个挂载数据卷的容器","link":"#启动一个挂载数据卷的容器","children":[]},{"level":4,"title":"删除数据卷","slug":"删除数据卷","link":"#删除数据卷","children":[]}]},{"level":3,"title":"3.2 目录挂载","slug":"_3-2-目录挂载","link":"#_3-2-目录挂载","children":[{"level":4,"title":"挂载一个主机目录作为数据卷","slug":"挂载一个主机目录作为数据卷","link":"#挂载一个主机目录作为数据卷","children":[]},{"level":4,"title":"查看容器的数据卷具体信息","slug":"查看容器的数据卷具体信息","link":"#查看容器的数据卷具体信息","children":[]},{"level":4,"title":"挂载一个本地主机文件作为数据卷","slug":"挂载一个本地主机文件作为数据卷","link":"#挂载一个本地主机文件作为数据卷","children":[]}]}]},{"level":2,"title":"四、docker 网络模式","slug":"四、docker-网络模式","link":"#四、docker-网络模式","children":[{"level":3,"title":"4.1 端口映射 外部访问容器","slug":"_4-1-端口映射-外部访问容器","link":"#_4-1-端口映射-外部访问容器","children":[]},{"level":3,"title":"4.2 查看端口映射配置","slug":"_4-2-查看端口映射配置","link":"#_4-2-查看端口映射配置","children":[]},{"level":3,"title":"4.3 容器互联","slug":"_4-3-容器互联","link":"#_4-3-容器互联","children":[]},{"level":3,"title":"4.4 网络模式","slug":"_4-4-网络模式","link":"#_4-4-网络模式","children":[{"level":4,"title":"基础理论","slug":"基础理论","link":"#基础理论","children":[]},{"level":4,"title":"Dokcer 支持的网络模式","slug":"dokcer-支持的网络模式","link":"#dokcer-支持的网络模式","children":[]},{"level":4,"title":"Bridge 模式","slug":"bridge-模式","link":"#bridge-模式","children":[]},{"level":4,"title":"Host 网络","slug":"host-网络","link":"#host-网络","children":[]},{"level":4,"title":"Container 网络模式","slug":"container-网络模式","link":"#container-网络模式","children":[]},{"level":4,"title":"None 模式","slug":"none-模式","link":"#none-模式","children":[]}]}]}],"git":{"createdTime":1733230770000,"updatedTime":1733230770000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":10.56,"words":3167},"filePathRelative":"back-end/docker/FrameworkAndcore.md","localizedDate":"2024年11月29日","excerpt":"<p>dokcer 的框架与核心概念</p>\\n","autoDesc":true}');export{b as comp,u as data};
