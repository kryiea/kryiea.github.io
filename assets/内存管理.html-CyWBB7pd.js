import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,e as n,o}from"./app-DRR9Yo7Y.js";const s="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.001-qKF4rxpP.png",r="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.002-BTAF2Jcf.png",p="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.003-D5A30hwh.png",e="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.004-D3zZjyws.png",g="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.005-B9xxLppb.png",a="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.006-DoJKIU1g.png",c="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.007-BwLgiSzc.png",m="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.008-KshcJm_R.png",u="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.009-Ad5ltKWW.png",d="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.010-5Iv22MS5.png",f="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.011-a5Ce9cdf.png",E="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.012-CLFgxoW1.png",h="/assets/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.013-0mSGABQQ.png",A={};function b(k,t){return o(),l("div",null,t[0]||(t[0]=[n('<p><strong>内存管理</strong></p><p><strong>一、虚拟内存</strong></p><p><strong>1.1 为什么需要虚拟内存</strong></p><p><strong>前提</strong>：单片机的 CPU 是直接操作内存的 物理地址。</p><p><strong>问题</strong>：想在单片机的内存中同时运行两个程序是做不到的。</p><p><strong>原因</strong>：单片机没有操作系统，每次写完代码都要借助工具把程序烧录进去，直接使用绝对物理地址。</p><p><strong>虚拟内存有什么作用？</strong></p><ul><li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li><li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题。</strong></li><li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的<strong>安全性。</strong></li></ul><p><strong>1.2 虚拟内存的实现方式</strong></p><p><strong>1.2.1 内存分段管理</strong></p><ol><li><strong>分段机制下的虚拟地址：</strong></li></ol><p>段选择因子 ➕ 段内偏移量。</p><ol start="2"><li><strong>虚拟地址和物理地址如何映射：</strong></li></ol><ul><li><strong>段选择因子：<strong>保存在</strong>段寄存器</strong>里面。</li><li>段选择因子里面最重要的是<strong>段号，用作段表的索引</strong>。</li><li>段表里面保存的是这个段的基地址、段的界限和特权等级等。</li><li><strong>段内偏移量：<strong>虚拟地址中的段内偏移量应该位于 <strong>0 和段界限之间</strong>，如果段内偏移量是合法的，就将段基地址</strong>加</strong>上段内偏移量得到物理内存地址。</li></ul><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol start="3"><li><strong>不足之处：</strong></li></ol><ul><li>内存碎片的问题。（外部碎片）</li><li>内存交换的效率低的问题。</li><li>对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。</li><li>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</li></ul><p><strong>1.2.2 内存分页管理</strong></p><p><strong>分段管理的不足：</strong></p><p>分段的好处就是能产生连续的内存空间，但是会出现外部内存碎片和内存交换的空间太大的问题。</p><p><strong>1.2.2.1 单页表的实现方式</strong></p><ol><li><strong>分页机制：</strong></li></ol><ul><li>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（<em>Page</em>）。</li><li>在 Linux 下，每一页的大小为 4KB。</li></ul><ol start="2"><li><strong>分页机制下内存如何映射</strong></li></ol><ul><li>虚拟地址分为两部分，页号 ➕ 页内偏移。</li><li><strong>页号作为页表的索引</strong>，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。</li><li><strong>页表是存储在内存里的</strong>，内存管理单元（<em>MMU</em>）完成映射的工作。</li><li>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</li></ul><figure><img src="'+r+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ol start="3"><li><strong>不足之处：</strong></li></ol><ul><li>出现内部碎片：分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费。</li><li>多进程的系统中页表可能会占用大量内存：</li><li><code></code>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB，需要 4MB 的内存来存页表。</li><li>每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了。</li></ul><p><strong>1.2.2.2 多级页表的实现方式（知道）</strong></p><p>解决单页表的内存占用问题。</p><p><strong>二级分页</strong></p><ul><li>将一级页表分为 1024 个二级页表</li><li>每个表二级页表中包含 1024 个页表项</li></ul><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>1.2.2.3 TLB - Translation Lookaside Buffer</strong></p><p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。</p><p>那把最常访问的几个页表项存储到访问速度更快的硬件，在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache。</p><p>这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p><figure><img src="'+e+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>1.2.3 段页式内存管理</strong></p><p>段页式内存管理实现的方式：</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ul><p>这样，地址结构就由段号、段内页号、页内位移三部分组成。</p><p>段页式地址变换中要得到物理地址须经过三次内存访问：</p><ul><li>第一次访问段表，得到页表起始地址；</li><li>第二次访问页表，得到物理页号；</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>二、Linux 内存管理</strong></p><p><strong>2.1 Linux 的虚拟地址空间是如何分布的</strong></p><p><strong>2.1.1 虚拟地址空间如何划分</strong></p><p><strong>地址空间通常分为两部分：</strong></p><ol><li>**内核空间：**用于操作系统内核和内核模块。内核空间是全局共享的，所有进程都可以访问相同的内核地址空间，但通常只有内核态代码才能访问内核空间。</li><li>**用户空间：**用于运行用户态的应用程序。用户空间中的每个进程都有其独立的虚拟地址空间，不同进程间的用户空间是相互隔离的。</li></ol><figure><img src="'+a+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>2.1.2 用户空间如何划分</strong></p><p>在Linux操作系统中，每个进程都有自己独立的虚拟地址空间。这意味着每个进程都有一份独立的用户空间划分，包括代码段、数据段、堆、栈等。</p><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>以 32 位系统为例，每个进程的用户空间划分的情况（高地址 -- &gt; 低地址）：</strong></p><ul><li>**内核空间：**所有进程共享内核的代码和数据，独享与进程相关的数据结构</li><li>**栈段：**包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；从高地址往低地址增长</li><li>**文件映射段：**包括动态库、共享内存等，从低地址开始向上增长（<a href="http://lishiwen4.github.io/linux/linux-process-memory-location" target="_blank" rel="noopener noreferrer">跟硬件和内核版本有关 (opens new window)</a>）；</li><li>**堆段：**包括动态分配的内存，从低地址开始向上增长；</li><li>**BSS 段：**包括未初始化的静态变量和全局变量；</li><li>**数据段：**包括已初始化的静态常量和全局变量；</li><li>**代码段：**包括二进制可执行代码；</li></ul><p>堆和文件映射段的内存是动态分配的。</p><p>比如说，使用 C 标准库的 malloc() 或者 mmap()，就可以分别在堆和文件映射段动态分配内存。</p><figure><img src="'+m+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>2.2 Linux 如何分配虚拟内存</strong></p><div class="language-&lt;p&gt;高级语言（如go、java line-numbers-mode" data-highlighter="shiki" data-ext="&lt;p&gt;高级语言（如go、java" data-title="&lt;p&gt;高级语言（如go、java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2.2.1 malloc() 如何分配虚拟内存</strong></p><p><strong>2.2.1.1 malloc 涉及的两种系统调用</strong></p><p>malloc申请内存的时候，会有两种方式向操作系统申请堆内存。</p><ul><li>**方式一：**通过 brk() 系统调用从堆分配内存</li><li>free内存后堆内存还存在，放在malloc的内存池里。</li><li>将堆顶指针向高地址移动，获得新的内存空间。</li></ul><figure><img src="'+u+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>**方式二：**通过 mmap() 系统调用在文件映射区域分配内存；不连续的哦！！！！</li><li>free释放内存后就会归还给操作系统</li><li>在文件映射区分配一块内存，也就是从文件映射区&quot;偷&quot;了一块内存。</li></ul><figure><img src="'+d+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>2.2.1.2 两种系统调用的阈值</strong></p><p>malloc() 源码里默认定义了一个阈值：</p><ul><li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li><li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li></ul><p>不同的 glibc 版本定义的阈值也是不同的。</p><p><strong>2.2.1.3 两种系统调用的异同</strong></p><p><strong>不同：</strong></p><ol><li>申请的内存位置不同</li><li>brk()在堆上</li><li>mmap()在文件映射区域</li><li>free()释放内存的处理不同</li><li>brk()申请的内存不会归给操作系统，先放在malloc的缓冲区，下次再有申请的时候可以直接使用。</li><li>mmap()申请的内存会马上归还给操作系统</li></ol><p>共同：</p><ol><li>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节</li></ol><p>多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。</p><p>当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存</p><figure><img src="'+f+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>2.2.1.4 两种系统调用的设计目的</strong></p><p>问题：malloc()函数会在＞某个阈值的时候，通过系统调用mmap()来申请内存而不是brk()，而mmap()又会申请文件映射区域的虚拟内存返回，为什么要这么设计？</p><div class="language-&lt;p&gt;gpt&lt;/p&gt;&lt;p&gt;malloc()函数在分配较大块内存时选择通过系统调用mmap()而不是brk()来申请内存，这种设计有几个重要的原因和优势：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. line-numbers-mode" data-highlighter="shiki" data-ext="&lt;p&gt;gpt&lt;/p&gt;&lt;p&gt;malloc()函数在分配较大块内存时选择通过系统调用mmap()而不是brk()来申请内存，这种设计有几个重要的原因和优势：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1." data-title="&lt;p&gt;gpt&lt;/p&gt;&lt;p&gt;malloc()函数在分配较大块内存时选择通过系统调用mmap()而不是brk()来申请内存，这种设计有几个重要的原因和优势：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1." style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2.3 Linux 的 swap 机制</strong></p><div class="language-物理内存不足时，将不常使用的内存页移到磁盘上的交换空间（swap line-numbers-mode" data-highlighter="shiki" data-ext="物理内存不足时，将不常使用的内存页移到磁盘上的交换空间（swap" data-title="物理内存不足时，将不常使用的内存页移到磁盘上的交换空间（swap" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2.3.1 swap 机制工作原理</strong></p><ol><li><strong>内存页的分类</strong>:</li></ol><ul><li><strong>活跃页（Active Pages）</strong>: 最近被访问过的内存页，系统认为它们可能会被再次访问。</li><li><strong>非活跃页（Inactive Pages）</strong>: 最近未被访问的内存页，系统认为它们不太可能被立刻访问。</li></ul><ol start="2"><li><strong>交换空间（Swap Space）</strong>:</li></ol><ul><li>交换空间通常是一个专用的磁盘分区或文件，用于存储被交换出去的内存页。</li></ul><ol start="3"><li><strong>页交换（Paging）</strong>:</li></ol><ul><li>当系统的物理内存不足时，内核会选择一些非活跃页，将它们从物理内存中移出，写入到交换空间。</li><li>当这些页再次被访问时，内核会将它们从交换空间读回物理内存。如果物理内存仍然不足，内核可能会继续交换出其他非活跃页。</li></ul><p><strong>三、数组的物理空间连续？</strong></p><p>数组的虚拟地址是连续的，对于程序而言，只知道虚拟地址空间，物理地址对程序不可见。</p><p>虚拟地址到物理地址的映射是操作系统负责的。</p><p><strong>四、用户空间的栈和堆区有什么区别</strong></p><ol><li>增长方向不同</li><li>内存回收策略不同，栈自动分配和回收，堆是手动申请和释放（c语言malloc()会有两种堆内存申请策略，对应两个系统调用brk和mmap，所以堆的释放也是有区别的）</li><li>大小不同：栈一般是8MB（linux下），堆则受虚拟内存大小影响</li></ol><p><strong>五、栈上操作比堆要快，为什么</strong></p><p>栈有寄存器直接对栈进行访问（esp、ebp），所以快。</p><p>堆的数据需要通过指针访问（操作系统管理堆内存是有一个链表的，记录指针），将指针放在寄存器，再去取出这个地址的值，涉及到间接寻址。</p><p><strong>六、64 位和 32 位的操作系统，物理内存为4GB，申请 8G 的内存有什么区别</strong></p><ul><li>32 位的操作系统，最大可用虚拟内存只有 4GB， 申请8GB的话会在申请阶段就失败</li><li>64 位的操作系统，最大可用虚拟内存有 128TB， 申请8GB的话要考虑是否开启swap分区：</li><li>未开启swap：由于物理内存不够，进程会被操作系统杀掉（kill），原因是：OOM（内存溢出）。</li><li>开启了swap：可以正常使用8GB内存，进程可以正常运行。</li></ul><p><strong>七、swap 区是动态调整的吗</strong></p><p>Macos 是会动态增长，每次1GB。</p><p>Linux 不会自动增长，需要手动管理。</p><p><strong>八、fork 的写时复制</strong></p><ul><li>Fork 创建子进程的时候，只会复制虚拟内存，不会复制物理内存。因此会先共享这份物理内存。</li><li>当父/子进程进行写操作的时候，才会复制物理内存。</li></ul><figure><img src="'+E+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>未发生写操作</p><figure><img src="'+h+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>发生了写操作</p>',112)]))}const y=i(A,[["render",b],["__file","内存管理.html.vue"]]),v=JSON.parse('{"path":"/back-end/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"Linux内存管理详解","lang":"zh-CN","frontmatter":{"title":"Linux内存管理详解","description":"详细介绍Linux系统内存管理机制、虚拟内存及内存优化技术","date":"2024-01-01T00:00:00.000Z","category":["Linux","操作系统"],"tag":["Linux","内存管理","虚拟内存","系统优化"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/linux/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Linux内存管理详解"}],["meta",{"property":"og:description","content":"详细介绍Linux系统内存管理机制、虚拟内存及内存优化技术"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Linux"}],["meta",{"property":"article:tag","content":"内存管理"}],["meta",{"property":"article:tag","content":"虚拟内存"}],["meta",{"property":"article:tag","content":"系统优化"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux内存管理详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":14.37,"words":4311},"filePathRelative":"back-end/linux/内存管理.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>内存管理</strong></p>\\n<p><strong>一、虚拟内存</strong></p>\\n<p><strong>1.1 为什么需要虚拟内存</strong></p>\\n<p><strong>前提</strong>：单片机的 CPU 是直接操作内存的 物理地址。</p>\\n<p><strong>问题</strong>：想在单片机的内存中同时运行两个程序是做不到的。</p>\\n<p><strong>原因</strong>：单片机没有操作系统，每次写完代码都要借助工具把程序烧录进去，直接使用绝对物理地址。</p>\\n<p><strong>虚拟内存有什么作用？</strong></p>"}');export{y as comp,v as data};
