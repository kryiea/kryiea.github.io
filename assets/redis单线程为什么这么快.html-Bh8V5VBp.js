import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,e as r,o as p}from"./app-CB9WG6K8.js";const o="/assets/redis%20%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB.001-BgUs7HIX.png",l={};function a(n,e){return p(),i("div",null,e[0]||(e[0]=[r('<p><strong>redis 单线程为什么这么快</strong></p><p>快的 4 点原因</p><ol><li>基于内存设计，内存的读写速度对比磁盘和固态都快，有更高的吞吐量和低延迟。</li><li>单线程，因为执行本身不是瓶颈。对比多线程，从投入产生来看，引入多线程要付出更大的时间复杂度：上下文切换，同步机制的开销等等成本很高。事实也证明单纯性的 redis 已经很高效。瓶颈通常在网络 IO。</li><li>IO 多路复用</li><li>高效的底层数据结构</li></ol><p><strong>redis 单线程</strong></p><p>redis 使用单线程，能达到每秒数万级别的处理能力</p><ol><li>redis 大部分操作在内存上完成，内存操作本身快</li><li>redis 选择了很多高效的数据结构，并做了很多优化，比如 ziplist、hash、跳表....</li><li>有时候一种对象底层有几种实现以对应不同的场景</li><li>redis 采用了多路复用机制，使其在网络 IO 操作中，能并发处理大量的客户端请求，实现高吞吐量</li></ol><p><strong>IO 可能存在的问题</strong></p><p>一个单线程在一次完整的处理中， 会有哪些地方拖慢整个流程</p><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>redis 服务端在启动时，以及 bind 了端口，并且 listen 操作监听客户端请求，此时客户端就可以发起连接请求</p><ol><li>客户端 get 请求到来，使用 accept 建立连接</li><li>调用 recv 从套接字中读取请求</li><li>解析客户端发送请求，拿到参数</li><li>处理请求，这里是 get，redis 通过 key 获取对应的数据</li><li>最后将数据通过 send 发送给客户端</li></ol><p>哪些流程会拖沓</p><p>套接字默认是阻塞模式的，可能发生在两个地方</p><ol><li>accept 时：accept 建立时间过长</li><li>recv 时：客户端一直都没有发送数据</li></ol><p>怎么解决：IO 多路复用</p><p>当有 IO 操作触发的时候，就会产生通知，收到通知，再去通知对应的事件，针对 IO 多路复用，reids 做了一层包装，叫 Reactor 模型</p><p>Reactor</p><p>本质就是监听各种事件，当事件发生，将事件分发给不同的处理器</p><p>这样就不会阻塞在一个操作上，IO 多路复用让 redis 单线程也有了较大的并发度（不是并行）</p>',19)]))}const d=t(l,[["render",a],["__file","redis单线程为什么这么快.html.vue"]]),m=JSON.parse('{"path":"/back-end/redis/Operating-principle/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB.html","title":"Redis单线程高性能原理解析","lang":"zh-CN","frontmatter":{"title":"Redis单线程高性能原理解析","description":"深入分析Redis单线程模型下实现高性能的关键因素","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","性能优化","单线程模型","系统架构"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Operating-principle/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis单线程高性能原理解析"}],["meta",{"property":"og:description","content":"深入分析Redis单线程模型下实现高性能的关键因素"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:tag","content":"单线程模型"}],["meta",{"property":"article:tag","content":"系统架构"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis单线程高性能原理解析\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.26,"words":679},"filePathRelative":"back-end/redis/Operating-principle/redis单线程为什么这么快.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>redis 单线程为什么这么快</strong></p>\\n<p>快的 4 点原因</p>\\n<ol>\\n<li>基于内存设计，内存的读写速度对比磁盘和固态都快，有更高的吞吐量和低延迟。</li>\\n<li>单线程，因为执行本身不是瓶颈。对比多线程，从投入产生来看，引入多线程要付出更大的时间复杂度：上下文切换，同步机制的开销等等成本很高。事实也证明单纯性的 redis 已经很高效。瓶颈通常在网络 IO。</li>\\n<li>IO 多路复用</li>\\n<li>高效的底层数据结构</li>\\n</ol>\\n<p><strong>redis 单线程</strong></p>\\n<p>redis 使用单线程，能达到每秒数万级别的处理能力</p>"}');export{d as comp,m as data};
