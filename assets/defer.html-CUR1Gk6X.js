import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as r,d as i,e as n,o}from"./app-DRR9Yo7Y.js";const d="/assets/defer.001-DxJgtEwv.png",s="/assets/defer.002-me4UZYRL.png",f="/assets/defer.003-BJpWwqsY.png",p="/assets/defer.004-CqJJwm4o.png",l="/assets/defer.005-fI4F48nX.png",c="/assets/defer.006-pzWodbG_.png",g="/assets/defer.007-BQctFmXE.png",m="/assets/defer.008-C9ySpsTA.png",_="/assets/defer.009-ChoCDalB.png",h="/assets/defer.010-C514H6Cr.png",u="/assets/defer.011-BePD4KUm.png",y="/assets/defer.012-DwPgEEbq.png",b="/assets/defer.013-De3fAWth.png",x="/assets/defer.014-ioW2PUd5.png",k={};function z(G,e){return o(),a("div",null,[e[0]||(e[0]=r("p",null,"本文详细介绍Go语言defer机制的底层实现原理和执行过程。",-1)),i(" more "),e[1]||(e[1]=n('<h2 id="_1-defer底层数据结构" tabindex="-1"><a class="header-anchor" href="#_1-defer底层数据结构"><span>1. defer底层数据结构</span></a></h2><p>defer在Go语言运行时由特定的数据结构支持：</p><figure><img src="'+d+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_2-defer执行过程" tabindex="-1"><a class="header-anchor" href="#_2-defer执行过程"><span>2. defer执行过程</span></a></h2><p>defer语句执行过程涉及注册和实际调用两个阶段：</p><figure><img src="'+f+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_3-defer内存分配方式" tabindex="-1"><a class="header-anchor" href="#_3-defer内存分配方式"><span>3. defer内存分配方式</span></a></h2><h3 id="_3-1-defer结构体的分配" tabindex="-1"><a class="header-anchor" href="#_3-1-defer结构体的分配"><span>3.1 _defer结构体的分配</span></a></h3><p>_defer结构体在不同场景下有不同的分配策略：</p><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_3-2-堆上分配" tabindex="-1"><a class="header-anchor" href="#_3-2-堆上分配"><span>3.2 堆上分配</span></a></h3><p>当defer无法在栈上分配时，会在堆上分配内存：</p><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_3-3-栈上分配" tabindex="-1"><a class="header-anchor" href="#_3-3-栈上分配"><span>3.3 栈上分配</span></a></h3><p>在特定条件下，defer可以直接在栈上分配，避免堆分配的开销：</p><figure><img src="'+m+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_4-defer的优化-开放编码" tabindex="-1"><a class="header-anchor" href="#_4-defer的优化-开放编码"><span>4. defer的优化 - 开放编码</span></a></h2><p>开放编码是Go语言对defer实现的一种重要优化方式：</p><figure><img src="'+_+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+h+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+u+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+y+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_5-defer函数的执行机制" tabindex="-1"><a class="header-anchor" href="#_5-defer函数的执行机制"><span>5. defer函数的执行机制</span></a></h2><p>defer函数的实际调用发生在包含它的函数返回前：</p><figure><img src="'+b+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+x+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure>',29))])}const C=t(k,[["render",z],["__file","defer.html.vue"]]),D=JSON.parse('{"path":"/back-end/go/DataStructure/defer.html","title":"Go语言defer机制详解","lang":"zh-CN","frontmatter":{"title":"Go语言defer机制详解","description":"详细介绍Go语言defer的工作原理、使用场景及注意事项","date":"2024-01-01T00:00:00.000Z","category":["Go","语言特性"],"tag":["Go","defer","延迟调用","资源管理"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/go/DataStructure/defer.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Go语言defer机制详解"}],["meta",{"property":"og:description","content":"详细介绍Go语言defer的工作原理、使用场景及注意事项"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:tag","content":"defer"}],["meta",{"property":"article:tag","content":"延迟调用"}],["meta",{"property":"article:tag","content":"资源管理"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go语言defer机制详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[{"level":2,"title":"1. defer底层数据结构","slug":"_1-defer底层数据结构","link":"#_1-defer底层数据结构","children":[]},{"level":2,"title":"2. defer执行过程","slug":"_2-defer执行过程","link":"#_2-defer执行过程","children":[]},{"level":2,"title":"3. defer内存分配方式","slug":"_3-defer内存分配方式","link":"#_3-defer内存分配方式","children":[{"level":3,"title":"3.1 _defer结构体的分配","slug":"_3-1-defer结构体的分配","link":"#_3-1-defer结构体的分配","children":[]},{"level":3,"title":"3.2 堆上分配","slug":"_3-2-堆上分配","link":"#_3-2-堆上分配","children":[]},{"level":3,"title":"3.3 栈上分配","slug":"_3-3-栈上分配","link":"#_3-3-栈上分配","children":[]}]},{"level":2,"title":"4. defer的优化 - 开放编码","slug":"_4-defer的优化-开放编码","link":"#_4-defer的优化-开放编码","children":[]},{"level":2,"title":"5. defer函数的执行机制","slug":"_5-defer函数的执行机制","link":"#_5-defer函数的执行机制","children":[]}],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":1.06,"words":317},"filePathRelative":"back-end/go/DataStructure/defer.md","localizedDate":"2024年1月1日","excerpt":"<p>本文详细介绍Go语言defer机制的底层实现原理和执行过程。</p>\\n"}');export{C as comp,D as data};
