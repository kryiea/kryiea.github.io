import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,e as p,a as t,f as i,o as e}from"./app-DRR9Yo7Y.js";const r="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.001-DHBgzEpV.png",a="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.002-CU4x6E6b.png",s="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.003-DA6pfeEJ.png",g="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.004-C6kinnI7.png",c="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.005-CjCkl7cB.png",m="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.006-BCt9AKa3.png",E="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.007-BTmhejRx.png",d="/assets/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.008-Ctg9tKAn.png",u={};function B(f,n){return e(),l("div",null,n[0]||(n[0]=[p('<p><strong>海量数据处理</strong></p><ol><li>海量数据处理</li></ol><figure><img src="'+r+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>1.1 什么是数据处理</strong></p><p>数据的存储 + 计算</p><p><strong>1.2 什么是海量数据处理</strong></p><p>数据量太大，无法在短时间内迅速解决，或者是数据太大，导致无法一次性装入内存的数据处理</p><p><strong>1.3 海量数据处理的常用方法</strong></p><ol><li><p>巧用数据结构（bitmap、hash、布隆过滤器、堆）</p></li><li><p>分治法：把规模大的数据转化为规模小的数据，逐个击破</p></li><li><p>海量数据处理场景</p></li><li><p>40亿个QQ号，如何判断一个QQ号是否存在?</p></li><li><p>给定1000万个整数，内存限制1MB，如何对他们进行排序?</p></li><li><p>给定1GB单词，内存限制1MB，如何找到出现频率最高的100个单词?</p></li><li><p>内存限制4GB，如何对100亿URL查重?</p></li><li><p>1000万字符串，其中有些是重复的，需要去重，保留没有重复的字符串。请怎么设计和实现?</p></li><li><p>给定10亿个手机号，如何快速判断一个手机号是否存在?</p></li><li><p>海量数据处理方法应用</p></li></ol><p><strong>3.1 bitmap 方法</strong></p><p><strong>3.1.1 问题拆解</strong></p><p><strong>问题场景</strong></p><p>40亿个QQ号，如何判断一个QQ号是否存在?</p><p><strong>问题拆解</strong></p><ol><li>40亿QQ号存储位置：文件</li><li>查找QQ号的时间要求：快速，1s内</li></ol><p><strong>3.1.2 问题思路</strong></p><p><strong>问题思路 1：hash结构</strong></p><p>要快，用hash结构存储QQ号码，O(1) 时间内查找到某个QQ 号码</p><figure><img src="'+a+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>QQ号码无符号整数 uint</li><li>hash存储结构，key：号码，value：次数</li><li>所需内存：4byte * 40亿 / 1024 / 1024 / 1024 ≈ 14.9GB</li><li>思路缺点：需要较大的内存成本</li></ul><p><strong>如果条件限制是：内存限制为 1G 呢？</strong></p><p><strong>问题思路 2：Bitmap</strong></p><ol><li>只存储必要信息(QQ号码一定要存吗？)</li><li>字节存储 ---&gt; 位存储</li></ol><p><strong>3.1.3 解决方案</strong></p><p><strong>整体思路</strong></p><ol><li>只存储QQ号码存在与否(0/1)</li><li>建立QQ号码与二进制位之间的映射</li></ol><p><strong>bitmap(二进制数组) 如何表示QQ号码</strong></p><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>key (数组索引下标)： QQ号码</li><li>value： key这个索引对应的数组的 bit 值 (0/1)</li></ul><p>索引可以理解为地址，不用额外存储，不占用内存地址</p><p><strong>所需内存</strong></p><ul><li>最大qq号码：4个字节的最大无符号整数 = 2^32 - 1 ≈ 43 亿</li><li>所需内存 = 43 亿 / 8 / 1024 / 1024 / 1024 ≈ 521 MB</li></ul><p><strong>实现流程</strong></p><ol><li>申请长度为 43 亿的二进制位数组</li><li>遍历文件中的40亿个QQ号码，将二进制位数组中的对应值设置为 1</li><li>根据给定QQ号码，到二进制数组中查找对应索引位置的值，若为 1 则存在，否则不存在</li></ol><p><strong>3.1.4 问题变形</strong></p><p><strong>利用bitmap去重</strong></p><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>利用bitmap进行排序</strong></p><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>3.1.5 bitmap 具体实现</strong></p><p><strong>如何定位号码在数组中的位置</strong></p>',41),t("ul",null,[t("li",null,[t("code"),i("需要多大的数组： "),t("strong",null,"size = (max_value + 8) / 8")]),t("li",null,[t("code"),i("对应第几个数组： "),t("strong",null,"byteIndex = num / 8")]),t("li",null,[t("code"),i("在字节的第几位： "),t("strong",null,"bitIndex = num % 8")]),t("li",{"2,6,5,4,8,1,3":""},[t("code"),i("比如现在有一堆号码")]),t("li",null,[t("code"),i("需要找到号码 8 的具体位置")])],-1),p('<figure><img src="'+m+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>如何将二进制位设置为 1</strong></p><ul><li><strong>byte[byteIndex] | 1 &lt;&lt; bitIndex</strong></li><li>将号码 8 对应的二进制位设置为 1</li></ul><figure><img src="'+E+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>如何判断号码对应的二进制位是否为 1</strong></p><ul><li><strong>byte[byteIndex] &amp; 1 &lt;&lt; bitIndex</strong></li></ul><figure><img src="'+d+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>3.2 外部排序</strong></p><p>。。</p>',9)]))}const Q=o(u,[["render",B],["__file","海量数据处理.html.vue"]]),b=JSON.parse('{"path":"/back-end/Back-endOptimizationScenarios/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html","title":"海量数据处理技术与方案","lang":"zh-CN","frontmatter":{"title":"海量数据处理技术与方案","description":"详细介绍海量数据处理的概念、常用方法及应用场景","date":"2024-01-01T00:00:00.000Z","category":["后端","大数据","算法"],"tag":["海量数据","Bitmap","分治法","数据结构"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/Back-endOptimizationScenarios/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"海量数据处理技术与方案"}],["meta",{"property":"og:description","content":"详细介绍海量数据处理的概念、常用方法及应用场景"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"海量数据"}],["meta",{"property":"article:tag","content":"Bitmap"}],["meta",{"property":"article:tag","content":"分治法"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"海量数据处理技术与方案\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":3.28,"words":984},"filePathRelative":"back-end/Back-endOptimizationScenarios/海量数据处理.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>海量数据处理</strong></p>\\n<ol>\\n<li>海量数据处理</li>\\n</ol>\\n<figure><figcaption>...</figcaption></figure>\\n<p><strong>1.1 什么是数据处理</strong></p>\\n<p>数据的存储 + 计算</p>\\n<p><strong>1.2 什么是海量数据处理</strong></p>\\n<p>数据量太大，无法在短时间内迅速解决，或者是数据太大，导致无法一次性装入内存的数据处理</p>\\n<p><strong>1.3 海量数据处理的常用方法</strong></p>\\n<ol>\\n<li>\\n<p>巧用数据结构（bitmap、hash、布隆过滤器、堆）</p>\\n</li>\\n<li>\\n<p>分治法：把规模大的数据转化为规模小的数据，逐个击破</p>\\n</li>\\n<li>\\n<p>海量数据处理场景</p>\\n</li>\\n<li>\\n<p>40亿个QQ号，如何判断一个QQ号是否存在?</p>\\n</li>\\n<li>\\n<p>给定1000万个整数，内存限制1MB，如何对他们进行排序?</p>\\n</li>\\n<li>\\n<p>给定1GB单词，内存限制1MB，如何找到出现频率最高的100个单词?</p>\\n</li>\\n<li>\\n<p>内存限制4GB，如何对100亿URL查重?</p>\\n</li>\\n<li>\\n<p>1000万字符串，其中有些是重复的，需要去重，保留没有重复的字符串。请怎么设计和实现?</p>\\n</li>\\n<li>\\n<p>给定10亿个手机号，如何快速判断一个手机号是否存在?</p>\\n</li>\\n<li>\\n<p>海量数据处理方法应用</p>\\n</li>\\n</ol>"}');export{Q as comp,b as data};
