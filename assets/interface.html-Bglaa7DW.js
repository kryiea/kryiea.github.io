import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as t,d as n,e as r,o as l}from"./app-DRR9Yo7Y.js";const s="/assets/interface.001-Bcz5uLfL.png",c="/assets/interface.002-DteNuT0_.png",p="/assets/interface.003-NQeqrYdm.png",o="/assets/interface.004-BXwReWL8.png",g="/assets/interface.005-CQqXZIJi.png",f="/assets/interface.006-Bl4l6UgE.png",d="/assets/interface.007-CGf_ga9Z.png",h="/assets/interface.008-BLY0uy22.png",_="/assets/interface.009-ZKgNBF-c.png",u="/assets/interface.010-CACGWM2B.png",m="/assets/interface.011-DQSV80lc.png",b="/assets/interface.012-BLhMPMrd.png",y="/assets/interface.013-CbtYcHMc.png",x="/assets/interface.014-FzgV8zq6.png",k="/assets/interface.015-CINtNljd.png",z="/assets/interface.016-CO7EGbvT.png",v="/assets/interface.017-D1mXayHj.png",G="/assets/interface.018-DQUfdC0r.png",T={};function B(C,e){return l(),i("div",null,[e[0]||(e[0]=t("p",null,"本文详细介绍Go语言接口的底层实现原理和使用方法。",-1)),n(" more "),e[1]||(e[1]=r('<h2 id="_1-接口基础概念" tabindex="-1"><a class="header-anchor" href="#_1-接口基础概念"><span>1. 接口基础概念</span></a></h2><p>Go语言中的接口是一种特殊的类型，定义了一组方法的集合，但没有具体实现。</p><h2 id="_2-空接口-interface" tabindex="-1"><a class="header-anchor" href="#_2-空接口-interface"><span>2. 空接口 interface{}</span></a></h2><h3 id="_2-1-概念与用途" tabindex="-1"><a class="header-anchor" href="#_2-1-概念与用途"><span>2.1 概念与用途</span></a></h3><ul><li>没有任何方法的接口为空接口</li><li>空接口可以接受任意数据类型：可以将任意类型的数据赋值给一个空接口</li></ul><h3 id="_2-2-空接口的结构" tabindex="-1"><a class="header-anchor" href="#_2-2-空接口的结构"><span>2.2 空接口的结构</span></a></h3><p>空接口在运行时由以下结构表示：</p><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_2-3-type字段解析" tabindex="-1"><a class="header-anchor" href="#_2-3-type字段解析"><span>2.3 _type字段解析</span></a></h3><p>_type 是什么：</p><ul><li>_type 是 Go 里面所有类型的一个抽象，包含了：类型大小，哈希，对齐，以及k类型编号等，决定了data字段如何解析和操作</li><li>Go 中几乎所有的数据结构都可以抽象成_type</li></ul><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_2-4-动态类型和动态值" tabindex="-1"><a class="header-anchor" href="#_2-4-动态类型和动态值"><span>2.4 动态类型和动态值</span></a></h3><p>空接口的动态类型和动态值示例：</p><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+o+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_3-非空接口" tabindex="-1"><a class="header-anchor" href="#_3-非空接口"><span>3. 非空接口</span></a></h2><h3 id="_3-1-概念" tabindex="-1"><a class="header-anchor" href="#_3-1-概念"><span>3.1 概念</span></a></h3><ul><li>包含方法列表的接口就是非空接口</li></ul><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_3-2-非空接口结构" tabindex="-1"><a class="header-anchor" href="#_3-2-非空接口结构"><span>3.2 非空接口结构</span></a></h3><p>非空接口在运行时由以下结构表示：</p><figure><img src="'+f+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_3-3-itab结构详解" tabindex="-1"><a class="header-anchor" href="#_3-3-itab结构详解"><span>3.3 itab结构详解</span></a></h3><p>itab结构是非空接口实现的核心：</p><figure><img src="'+d+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+h+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>itab字段含义：</p><ul><li>**inter：**指向 interfacetype 结构的指针，interfacetype 结构记录了这个接口的方法列表。</li><li>**_type：**实际类型的指针，指向 _type 结构，_type 结构保存了接口的动态类型信息，与空接口的_type 一样，即赋值给这个接口的具体类型信息的元数据</li><li>**hash：**该类型的hash值，itab 中的 hash 和 itab.type 中的 hash 相等，其实是从 itab._type 中拷贝出来的，目的是用于快速判断类型是否相等。</li><li>**fun：**fun 是一个指针数组，里面保存了实现了该接口的实际类型的方法地址（只包含该接口方法）。 <ul><li>这些方法地址实际上是从interfacetype结构中的mhdr 拷贝出来的，用的时候快速定位到方法。</li><li>如果该接口对应的动态类型没有实现接口的所有方法，那么itab.fun[0] == 0,表示断言失败，该类型不能赋值给该接口</li></ul></li></ul><h3 id="_3-4-interfacetype结构" tabindex="-1"><a class="header-anchor" href="#_3-4-interfacetype结构"><span>3.4 interfacetype结构</span></a></h3><p>接口类型在运行时由interfacetype结构表示：</p><figure><img src="'+_+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_4-接口赋值过程" tabindex="-1"><a class="header-anchor" href="#_4-接口赋值过程"><span>4. 接口赋值过程</span></a></h2><h3 id="_4-1-接口赋值示例" tabindex="-1"><a class="header-anchor" href="#_4-1-接口赋值示例"><span>4.1 接口赋值示例</span></a></h3><p>下面是一个非空接口赋值的例子：</p><figure><img src="'+u+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_4-2-赋值前后的结构变化" tabindex="-1"><a class="header-anchor" href="#_4-2-赋值前后的结构变化"><span>4.2 赋值前后的结构变化</span></a></h3><p>在程序第28行，赋值之前，ifc的结构如下：</p><figure><img src="'+m+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>在第29行，给ifc赋值一个包含方法的结构体a之后，ifc的结构如下图：</p><figure><img src="'+b+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+y+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_5-itab缓存机制" tabindex="-1"><a class="header-anchor" href="#_5-itab缓存机制"><span>5. itab缓存机制</span></a></h2><h3 id="_5-1-itab复用" tabindex="-1"><a class="header-anchor" href="#_5-1-itab复用"><span>5.1 itab复用</span></a></h3><p>为了提高性能，Go运行时会复用itab结构体：</p><figure><img src="'+x+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h3 id="_5-2-itabtable实现" tabindex="-1"><a class="header-anchor" href="#_5-2-itabtable实现"><span>5.2 itabTable实现</span></a></h3><p>itabTable是Go运行时管理itab的数据结构：</p><figure><img src="'+k+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+z+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+v+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+G+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><h2 id="_6-参考资料" tabindex="-1"><a class="header-anchor" href="#_6-参考资料"><span>6. 参考资料</span></a></h2><ul><li><a href="https://www.bilibili.com/video/BV1iZ4y1T7zF/?p=3&amp;spm_id_from=888.80997.embed_other.whitelist" target="_blank" rel="noopener noreferrer">类型断言究竟咋&quot;断言&quot;？_哔哩哔哩_bilibili</a></li></ul>',54))])}const D=a(T,[["render",B],["__file","interface.html.vue"]]),q=JSON.parse('{"path":"/back-end/go/DataStructure/interface.html","title":"Go语言接口详解","lang":"zh-CN","frontmatter":{"title":"Go语言接口详解","description":"详细介绍Go语言interface的概念、使用方法及实现原理","date":"2024-01-01T00:00:00.000Z","category":["Go","数据结构"],"tag":["Go","interface","接口","多态"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/go/DataStructure/interface.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Go语言接口详解"}],["meta",{"property":"og:description","content":"详细介绍Go语言interface的概念、使用方法及实现原理"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:tag","content":"interface"}],["meta",{"property":"article:tag","content":"接口"}],["meta",{"property":"article:tag","content":"多态"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Go语言接口详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 接口基础概念","slug":"_1-接口基础概念","link":"#_1-接口基础概念","children":[]},{"level":2,"title":"2. 空接口 interface{}","slug":"_2-空接口-interface","link":"#_2-空接口-interface","children":[{"level":3,"title":"2.1 概念与用途","slug":"_2-1-概念与用途","link":"#_2-1-概念与用途","children":[]},{"level":3,"title":"2.2 空接口的结构","slug":"_2-2-空接口的结构","link":"#_2-2-空接口的结构","children":[]},{"level":3,"title":"2.3 _type字段解析","slug":"_2-3-type字段解析","link":"#_2-3-type字段解析","children":[]},{"level":3,"title":"2.4 动态类型和动态值","slug":"_2-4-动态类型和动态值","link":"#_2-4-动态类型和动态值","children":[]}]},{"level":2,"title":"3. 非空接口","slug":"_3-非空接口","link":"#_3-非空接口","children":[{"level":3,"title":"3.1 概念","slug":"_3-1-概念","link":"#_3-1-概念","children":[]},{"level":3,"title":"3.2 非空接口结构","slug":"_3-2-非空接口结构","link":"#_3-2-非空接口结构","children":[]},{"level":3,"title":"3.3 itab结构详解","slug":"_3-3-itab结构详解","link":"#_3-3-itab结构详解","children":[]},{"level":3,"title":"3.4 interfacetype结构","slug":"_3-4-interfacetype结构","link":"#_3-4-interfacetype结构","children":[]}]},{"level":2,"title":"4. 接口赋值过程","slug":"_4-接口赋值过程","link":"#_4-接口赋值过程","children":[{"level":3,"title":"4.1 接口赋值示例","slug":"_4-1-接口赋值示例","link":"#_4-1-接口赋值示例","children":[]},{"level":3,"title":"4.2 赋值前后的结构变化","slug":"_4-2-赋值前后的结构变化","link":"#_4-2-赋值前后的结构变化","children":[]}]},{"level":2,"title":"5. itab缓存机制","slug":"_5-itab缓存机制","link":"#_5-itab缓存机制","children":[{"level":3,"title":"5.1 itab复用","slug":"_5-1-itab复用","link":"#_5-1-itab复用","children":[]},{"level":3,"title":"5.2 itabTable实现","slug":"_5-2-itabtable实现","link":"#_5-2-itabtable实现","children":[]}]},{"level":2,"title":"6. 参考资料","slug":"_6-参考资料","link":"#_6-参考资料","children":[]}],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.72,"words":815},"filePathRelative":"back-end/go/DataStructure/interface.md","localizedDate":"2024年1月1日","excerpt":"<p>本文详细介绍Go语言接口的底层实现原理和使用方法。</p>\\n"}');export{D as comp,q as data};
