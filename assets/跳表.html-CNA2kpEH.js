import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as o,o as r}from"./app-DRR9Yo7Y.js";const i="/assets/%E8%B7%B3%E8%A1%A8.001-zrWWH1dx.png",l="/assets/%E8%B7%B3%E8%A1%A8.002-d--TXmBV.png",n="/assets/%E8%B7%B3%E8%A1%A8.003-DLgwf26j.png",s="/assets/%E8%B7%B3%E8%A1%A8.004-Cq42wpjx.png",p="/assets/%E8%B7%B3%E8%A1%A8.005-9WnNNfT0.png",g="/assets/%E8%B7%B3%E8%A1%A8.006-INb1sZTM.png",c="/assets/%E8%B7%B3%E8%A1%A8.007-B7R8vkas.png",d="/assets/%E8%B7%B3%E8%A1%A8.008-B2vHaYkP.png",m={};function f(u,t){return r(),a("div",null,t[0]||(t[0]=[o('<p><strong>跳表</strong></p><p><strong>是什么</strong></p><ul><li>跳表是有序集合 zset 底层数据结构，也是 zset 的灵魂所在。</li><li>跳表本质还是链表</li></ul><figure><img src="'+i+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>虽然链表结构简单清晰，但是查询某个节点的效率比较低，为了调高查找性能，引入了跳表。</li><li>跳表在链表基础上，给链表增加了多级索引，通过索引可以一次实现多个节点的跳跃，调高性能</li></ul><p><strong>跳表的结构</strong></p><p><a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#%E8%B7%B3%E8%A1%A8" target="_blank" rel="noopener noreferrer">Redis 数据结构</a></p><p>结构示意图</p><figure><img src="'+l+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>图上的某些节点不是只有一层。比如 35，就有三层</li><li>理论上，层次越高平均步长越大，并不是和上图一样绝对均衡的，节点的层高是概率随机的</li></ul><p>或者这样画</p><figure><img src="'+n+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>结构的好处</strong></p><p>场景 1：查找分数为 35 的数据</p><ul><li>如果是只有原始链表，需要走 4 步</li><li>二级索引走一步</li></ul><p>场景 2：插入 score 为 36 的数据</p><ol><li>先定位到第一个比 score 大的位置，这里是 45，定位方式和查询类似</li><li>然后构造一个新节点，假设节点层高随机到 3（随机算法决定的）</li><li>补齐各层链表</li></ol><figure><img src="'+s+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>标准的跳表的限制</strong></p><ol><li>score 不能重复</li><li>只有向前指针，没有回退指针</li></ol><p>⛔在 reids 中，跳表是用来支持有序集合的，所以 redis 对跳表做了一些优化：</p><ol><li>score 可以重复</li><li>增加回退指针</li></ol><p><strong>redis 的跳表实现</strong></p><p>结构图</p><figure><img src="'+p+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><figure><img src="'+g+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>下面的更准确。</p><figure><img src="'+i+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p>节点源码</p><figure><img src="'+c+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><ul><li>ele：sds 结构，用来存储数据</li><li>score：节点的分数，浮点型数据。节点排列是从小到大</li><li>backwaid：指向上一个节点的回退指针。支持从表尾向表头遍历，也就是ZREVRANGE命令</li><li>level：是 zskiplistLevel 结构体数组，有两个字段：</li><li>forward：指向该层下一个能跳到的节点</li><li>span：记录距离下一个节点的步数</li><li>结构体数组：表示每个节点都可能是多层结构</li></ul><p>跳表结构体</p><figure><img src="'+d+'" alt="..." tabindex="0" loading="lazy"><figcaption>...</figcaption></figure><p><strong>redis 跳表单个节点有几层</strong></p><p>层次的决定，需要比较随机才能在各个场景表现出较为平均的性能，这里 redis 使用概率均衡的死了来决定新插入节点的层数：</p><ul><li>redis 跳表决定每一个节点，是否能增加一层的概率为 25%，而最大层数限制在 redis5.0 是 64 层，7.0 是 32 层</li></ul>',36)]))}const B=e(m,[["render",f],["__file","跳表.html.vue"]]),E=JSON.parse('{"path":"/back-end/redis/Data-object/%E8%B7%B3%E8%A1%A8.html","title":"Redis跳表实现详解","lang":"zh-CN","frontmatter":{"title":"Redis跳表实现详解","description":"深入分析Redis跳表的实现原理、性能特性及应用场景","date":"2024-01-01T00:00:00.000Z","category":["数据库","Redis"],"tag":["Redis","跳表","数据结构","性能优化"],"head":[["meta",{"property":"og:url","content":"https://kryiea.cn/back-end/redis/Data-object/%E8%B7%B3%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"🧐kryiea"}],["meta",{"property":"og:title","content":"Redis跳表实现详解"}],["meta",{"property":"og:description","content":"深入分析Redis跳表的实现原理、性能特性及应用场景"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T15:53:39.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"跳表"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:published_time","content":"2024-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T15:53:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis跳表实现详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-31T15:53:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"kryiea\\",\\"url\\":\\"https://github.com/kryiea\\",\\"email\\":\\"kryieaa@outlook.com\\"}]}"]]},"headers":[],"git":{"createdTime":1743436419000,"updatedTime":1743436419000,"contributors":[{"name":"kryiea","email":"1582877056@qq.com","commits":1}]},"readingTime":{"minutes":2.37,"words":710},"filePathRelative":"back-end/redis/Data-object/跳表.md","localizedDate":"2024年1月1日","excerpt":"<p><strong>跳表</strong></p>\\n<p><strong>是什么</strong></p>\\n<ul>\\n<li>跳表是有序集合 zset 底层数据结构，也是 zset 的灵魂所在。</li>\\n<li>跳表本质还是链表</li>\\n</ul>\\n<figure><figcaption>...</figcaption></figure>\\n<ul>\\n<li>虽然链表结构简单清晰，但是查询某个节点的效率比较低，为了调高查找性能，引入了跳表。</li>\\n<li>跳表在链表基础上，给链表增加了多级索引，通过索引可以一次实现多个节点的跳跃，调高性能</li>\\n</ul>\\n<p><strong>跳表的结构</strong></p>"}');export{B as comp,E as data};
