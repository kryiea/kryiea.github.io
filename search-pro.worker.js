const{entries:V}=Object,{fromEntries:et}=Object,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":284,\"nextId\":284,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"3\",\"3\":\"3#一、vscode-设置\",\"4\":\"3#二、ui-类\",\"5\":\"3#_1-1-主题\",\"6\":\"3#_1-2-图标包\",\"7\":\"3#三、编程类\",\"8\":\"3#_2-1-代码视觉优化\",\"9\":\"3#_2-2-项目管理\",\"10\":\"3#_2-3-开发实用\",\"11\":\"3#_2-4-git可视化\",\"12\":\"3#四、ai-类\",\"13\":\"3#五、没啥用but安装了类\",\"14\":\"3@0\",\"15\":\"3@1\",\"16\":\"4\",\"17\":\"5\",\"18\":\"5#一、docker-镜像、容器、仓库\",\"19\":\"5#_1-1-镜像\",\"20\":\"5#_1-2-容器\",\"21\":\"5#_1-3-仓库\",\"22\":\"5#二、docker-框架架构\",\"23\":\"5#_2-1-docker-客户端\",\"24\":\"5#_2-2-docker-服务端\",\"25\":\"5#_2-3-docker-重要组件\",\"26\":\"5#_2-4-docker-各组件之间的关系\",\"27\":\"5#三、docker-数据管理\",\"28\":\"5#_3-1-数据卷\",\"29\":\"5#创建一个数据卷\",\"30\":\"5#查看所有数据卷\",\"31\":\"5#查看指定数据卷的信息\",\"32\":\"5#启动一个挂载数据卷的容器\",\"33\":\"5#删除数据卷\",\"34\":\"5#_3-2-目录挂载\",\"35\":\"5#挂载一个主机目录作为数据卷\",\"36\":\"5#查看容器的数据卷具体信息\",\"37\":\"5#挂载一个本地主机文件作为数据卷\",\"38\":\"5#四、docker-网络模式\",\"39\":\"5#_4-1-端口映射-外部访问容器\",\"40\":\"5#_4-2-查看端口映射配置\",\"41\":\"5#_4-3-容器互联\",\"42\":\"5#_4-4-网络模式\",\"43\":\"5#基础理论\",\"44\":\"5#dokcer-支持的网络模式\",\"45\":\"5#bridge-模式\",\"46\":\"5#host-网络\",\"47\":\"5#container-网络模式\",\"48\":\"5#none-模式\",\"49\":\"5@0\",\"50\":\"5@1\",\"51\":\"6\",\"52\":\"6#docker-的常用命令\",\"53\":\"6#_1-帮助命令\",\"54\":\"6#_2-镜像命令\",\"55\":\"6#_2-1-docker-images\",\"56\":\"6#_2-2-docker-search-搜索镜像\",\"57\":\"6#_2-3-docker-pull-下载镜像\",\"58\":\"6#_2-4-docker-rmi-删除镜像\",\"59\":\"6#_3-容器命令\",\"60\":\"6#_3-1-新建容器并启动\",\"61\":\"6#_3-2-列出所有运行的容器\",\"62\":\"6#_3-3-退出容器\",\"63\":\"6#_3-4-删除容器\",\"64\":\"6#_3-5-启动和停止容器的操作\",\"65\":\"6#_4-常用其他命令\",\"66\":\"6#_4-1-后台启动容器\",\"67\":\"6#_4-2-查看日志\",\"68\":\"6#_4-3-查看容器中进程的信息\",\"69\":\"6#_4-4-查看镜像的元数据\",\"70\":\"6#_4-5-进入当前正在运行的容器\",\"71\":\"6#_4-6-从容器内拷贝文件到主机\",\"72\":\"6@0\",\"73\":\"6@1\",\"74\":\"7\",\"75\":\"7#一、demo-代码\",\"76\":\"7#二、输出结果\",\"77\":\"7#n-10\",\"78\":\"7#n-257\",\"79\":\"7#n-258\",\"80\":\"7#三、问题解答\",\"81\":\"7#为什么先打印它-一次调度流程是怎么样的\",\"82\":\"7#如果-n-设置为-257、258-打印输出的规律是什么\",\"83\":\"7@0\",\"84\":\"7@1\",\"85\":\"8\",\"86\":\"8#一、go-的协程-goroutine\",\"87\":\"8#二、旧-gm模型\",\"88\":\"8#_2-1-gm符号概念\",\"89\":\"8#_2-2-废弃的调度器模型-gm-是如何实现的\",\"90\":\"8#三、新-gmp模型\",\"91\":\"8#_3-1-gmp符号定义\",\"92\":\"8#_3-2-gmp-模型\",\"93\":\"8@0\",\"94\":\"8@1\",\"95\":\"9\",\"96\":\"9#go-编译器\",\"97\":\"9#一般编译器\",\"98\":\"9#go-编译器-1\",\"99\":\"9#第一阶段-词法分析和语法分析\",\"100\":\"9#第二阶段-语义分析\",\"101\":\"9#第三阶段-ssa-生成\",\"102\":\"9#第四阶段-机器码生成\",\"103\":\"9@0\",\"104\":\"9@1\",\"105\":\"10\",\"106\":\"10#_3-1-指针逃逸\",\"107\":\"10#_3-2-栈空间不足逃逸\",\"108\":\"10#_3-3-动态类型逃逸\",\"109\":\"10#_3-3-变量大小不确定\",\"110\":\"10@0\",\"111\":\"11\",\"112\":\"11#几个问题\",\"113\":\"11#一、go的函数调用\",\"114\":\"11#_1-1-go-函数调用基本概念\",\"115\":\"11#_1-2-程序运行时在内存中的布局\",\"116\":\"11#_1-3-go-的函数栈帧布局\",\"117\":\"11#_1-4-go1-15-的函数调用过程\",\"118\":\"11#二、go的多值返回\",\"119\":\"11@0\",\"120\":\"12\",\"121\":\"12#_1-1-标识符大小写\",\"122\":\"12#_1-2-文件结构\",\"123\":\"12#_2-1-基本规范\",\"124\":\"12#_2-2-单变量声明\",\"125\":\"12#_2-3-多变量声明\",\"126\":\"12#_2-4-注意\",\"127\":\"12#_2-5-变量的生命周期\",\"128\":\"12#_2-6-常量\",\"129\":\"12#_2-7-常量用作枚举\",\"130\":\"12#_2-8-iota\",\"131\":\"12#_3-1-逻辑运算符\",\"132\":\"12#_3-2-位运算符\",\"133\":\"12#_3-3-运算符优先级\",\"134\":\"12#_3-3-特殊运算符\",\"135\":\"12#_4-1-键值对初始化\",\"136\":\"12#_4-2-值列表初始化\",\"137\":\"12#_5-1-if\",\"138\":\"12#_5-2-switch-case\",\"139\":\"12#_6-1-理解-for-的结构\",\"140\":\"12#_6-2-for-range\",\"141\":\"12#_6-3-for-range-陷阱\",\"142\":\"12#_7-1-参数传递\",\"143\":\"12#_7-2-基本类型\",\"144\":\"12#_7-3-引用类型和指针\",\"145\":\"12#_7-4-结构体和数组\",\"146\":\"12#_7-5-可变参数\",\"147\":\"12#_8-1-go-普通指针特性\",\"148\":\"12#_8-2-unsafe-包中的-uintptr-和-pointer\",\"149\":\"12#_9-1-自定义方法的位置\",\"150\":\"12#_10-1-组合实现继承\",\"151\":\"12#_10-2-接口\",\"152\":\"12#_10-3-方法重写\",\"153\":\"12#_11-1-接口定义\",\"154\":\"12#_11-2-实现多个接口\",\"155\":\"12#_11-3-空接口\",\"156\":\"12#_11-4-断言陷阱\",\"157\":\"12#_11-5-断言原理\",\"158\":\"12#_11-6-接口作为函数参数\",\"159\":\"12#_11-7-接口嵌套\",\"160\":\"12#_12-1-error-接口类型\",\"161\":\"12#_13-1-需要思考的-3-个问题\",\"162\":\"12#_13-2-使用场景-1-资源的释放\",\"163\":\"12#_13-3-使用场景-2-配合-recover-处理-panic\",\"164\":\"12#_13-4-defer-的快照读\",\"165\":\"12#_14-1-return-的非原子性\",\"166\":\"12#_15-1-painc-捕获方式\",\"167\":\"12#_15-2-panic的传递\",\"168\":\"12@0\",\"169\":\"12@1\",\"170\":\"13\",\"171\":\"13#json-marshal-序列化-与json-unmarshal-反序列化-的基本用法。\",\"172\":\"13#结构体tag介绍\",\"173\":\"13#使用json-tag指定字段名\",\"174\":\"13#忽略某个字段\",\"175\":\"13#忽略空值字段\",\"176\":\"13#如果想要在最终的序列化结果中去掉空值字段-可以像下面这样定义结构体-使用omitempty\",\"177\":\"13#忽略嵌套结构体空值字段\",\"178\":\"13#不修改原结构体忽略空值字段\",\"179\":\"13#优雅处理字符串格式的数字\",\"180\":\"13@0\",\"181\":\"13@1\",\"182\":\"14\",\"183\":\"14#一、map-与-sync-map\",\"184\":\"14#_1-模拟-map-的并发读写-fatal\",\"185\":\"14#_2-盲点-加上打印却可以避免-fatal\",\"186\":\"14#二、sync-map-简介\",\"187\":\"14#三、sync-map-的使用\",\"188\":\"14#_1-基本的-crud\",\"189\":\"14#_2-验证并发安全\",\"190\":\"14#四、sync-map-的结构\",\"191\":\"14#五、两个-map-的数据双向流转机制\",\"192\":\"14#_1-dirty-map-read-map\",\"193\":\"14#_2-read-map-dirty-map\",\"194\":\"14#_3-为什么要双向流转\",\"195\":\"14#六、enrty-的状态解读\",\"196\":\"14#_1-entry-的结构\",\"197\":\"14#_2-entry-的三个状态\",\"198\":\"14#_3-nil-状态\",\"199\":\"14#_4-expunged-状态\",\"200\":\"14#七、回顾-sync-map-的底层原理\",\"201\":\"14#八、sync-map-的不足\",\"202\":\"14#九、sync-map-源码走读\",\"203\":\"14#_1-load-读\",\"204\":\"14#_2-misslocked-missssss\",\"205\":\"14#_3-store-写\",\"206\":\"14#_4-range-读\",\"207\":\"14@0\",\"208\":\"14@1\",\"209\":\"15\",\"210\":\"15#一、-一条-select-语句的执行过程\",\"211\":\"15#二、一条-update-语句的执行过程\",\"212\":\"15#三、三种日志、mvcc、bufferpool-之间的相互配合\",\"213\":\"15#_3-1-三种日志的主要作用\",\"214\":\"15#_3-2-undolog-回滚日志\",\"215\":\"15#_3-2-1-为什么需要-undolog\",\"216\":\"15#_3-2-2-认识-undolog-机制\",\"217\":\"15#_3-2-3-undolog-如何记录和回滚\",\"218\":\"15#_3-2-4-undolog-日志的格式\",\"219\":\"15#_3-2-5-undolog-readview-实现-mvcc\",\"220\":\"15#_3-2-6-readview-机制\",\"221\":\"15#_3-2-7-undolog-如何刷盘的\",\"222\":\"15#_3-3-buffer-pool-缓冲池\",\"223\":\"15#_3-3-1-buffer-pool-的意义\",\"224\":\"15#_3-3-2-buffer-pool-缓存什么\",\"225\":\"15#_3-3-3-buffer-pool-刷盘策略\",\"226\":\"15#_3-4-redolog-重做日志\",\"227\":\"15#_3-4-1-为什么需要-redolog\",\"228\":\"15#_3-4-2-认识-redolog-机制\",\"229\":\"15#_3-4-3-redolog-与-undolog-的配合\",\"230\":\"15#_3-4-4-redolog与数据分开写入磁盘的必要性\",\"231\":\"15#_3-4-5-redolog-的刷盘策略\",\"232\":\"15#_3-4-6-redolog-buffer-的刷盘时机\",\"233\":\"15#_3-4-7-redolog-日志重写\",\"234\":\"15#_3-5-binlog-重做日志\",\"235\":\"15#_3-5-1-binlog-的作用\",\"236\":\"15#_3-5-2-binlog-刷盘策略\",\"237\":\"15#_3-5-3-binlog-主从同步模型\",\"238\":\"15#_3-6-两阶段提交\",\"239\":\"15#_3-6-1-两阶段提交的提出\",\"240\":\"15#_3-6-2-两阶段提交的概念\",\"241\":\"15#_3-6-3-两阶段提交的过程\",\"242\":\"15#_3-6-4-两阶段提交有什么问题\",\"243\":\"15#_3-6-5-对两阶段提交加强-加入组提交\",\"244\":\"15@0\",\"245\":\"15@1\",\"246\":\"16\",\"247\":\"16#最简化版本\",\"248\":\"16#升级-1-支持过期时间\",\"249\":\"16#升级-2-超时-锁归属\",\"250\":\"16#升级-3-引入-lua\",\"251\":\"16#升级-3-满足-对称性-安全性-互斥性\",\"252\":\"16#升级-4-可靠性的保证\",\"253\":\"16#主从容灾\",\"254\":\"16#多机部署\",\"255\":\"16#redlock-可靠性探索\",\"256\":\"16@0\",\"257\":\"16@1\",\"258\":\"17\",\"259\":\"17#_1-1-存储形式为-redisobject\",\"260\":\"17#_1-2-redisobject-结构\",\"261\":\"17#_1-3-实际例子\",\"262\":\"17#_1-3-redisobject-代码\",\"263\":\"17#_2-1-dict-结构\",\"264\":\"17#_2-2-dict-代码\",\"265\":\"17#_3-1-redisdb-结构\",\"266\":\"17#_3-2-redisdb-代码\",\"267\":\"17#_4-1-redis-哈希冲突如何解决\",\"268\":\"17#_4-2-redisdb-的-expires\",\"269\":\"17@0\",\"270\":\"17@1\",\"271\":\"18\",\"272\":\"19\",\"273\":\"20\",\"274\":\"21\",\"275\":\"22\",\"276\":\"23\",\"277\":\"24\",\"278\":\"25\",\"279\":\"26\",\"280\":\"27\",\"281\":\"28\",\"282\":\"29\",\"283\":\"30\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[2],\"2\":[3,2],\"3\":[3,30],\"4\":[3],\"5\":[2,11],\"6\":[3,7],\"7\":[2],\"8\":[3,7],\"9\":[2,7],\"10\":[3,15],\"11\":[3,7],\"12\":[3,12],\"13\":[2,7],\"14\":[null,null,1],\"15\":[null,null,3],\"16\":[1],\"17\":[2,2],\"18\":[5],\"19\":[1,6],\"20\":[2,19],\"21\":[2,9],\"22\":[3,9],\"23\":[4,9],\"24\":[3,14],\"25\":[4,13],\"26\":[2,64],\"27\":[3,7],\"28\":[3,13],\"29\":[1,4],\"30\":[1,3],\"31\":[1,5],\"32\":[1,31],\"33\":[1,5],\"34\":[3],\"35\":[1,55],\"36\":[1,3],\"37\":[1,3],\"38\":[3],\"39\":[4,31],\"40\":[3,6],\"41\":[3,26],\"42\":[2],\"43\":[1,70],\"44\":[2,59],\"45\":[2,61],\"46\":[2,25],\"47\":[2,38],\"48\":[2,21],\"49\":[null,null,1],\"50\":[null,null,1],\"51\":[2,2],\"52\":[2],\"53\":[2,9],\"54\":[2],\"55\":[4,13],\"56\":[5,3],\"57\":[6,11],\"58\":[6,14],\"59\":[2,8],\"60\":[3,26],\"61\":[3,13],\"62\":[2,15],\"63\":[3,14],\"64\":[3,10],\"65\":[2],\"66\":[3,22],\"67\":[3,8],\"68\":[3,27],\"69\":[2,3],\"70\":[3,15],\"71\":[3,5],\"72\":[null,null,1],\"73\":[null,null,2],\"74\":[2],\"75\":[3,46],\"76\":[2,2],\"77\":[3,11],\"78\":[3,257],\"79\":[3,259],\"80\":[2],\"81\":[3,51],\"82\":[6,158],\"83\":[null,null,1],\"84\":[null,null,2],\"85\":[1,6],\"86\":[4,31],\"87\":[3],\"88\":[3,1],\"89\":[4,41],\"90\":[3],\"91\":[3,1],\"92\":[4,9],\"93\":[null,null,1],\"94\":[null,null,2],\"95\":[1,2],\"96\":[2,5],\"97\":[1,28],\"98\":[2,24],\"99\":[2,21],\"100\":[2,27],\"101\":[3,34],\"102\":[2,42],\"103\":[null,null,1],\"104\":[null,null,1],\"105\":[1,53],\"106\":[3,42],\"107\":[3,18],\"108\":[2,4],\"109\":[2,32],\"110\":[null,null,1],\"111\":[2,2],\"112\":[1,4],\"113\":[2],\"114\":[3,14],\"115\":[3,1],\"116\":[4,20],\"117\":[5,250],\"118\":[2],\"119\":[null,null,1],\"120\":[1,9],\"121\":[2,13],\"122\":[3,6],\"123\":[3,6],\"124\":[2,21],\"125\":[3,11],\"126\":[3,12],\"127\":[3,5],\"128\":[3,23],\"129\":[3,40],\"130\":[3,47],\"131\":[3,1],\"132\":[3,7],\"133\":[2,4],\"134\":[2,12],\"135\":[3,20],\"136\":[3,16],\"137\":[3,9],\"138\":[4,8],\"139\":[5,14],\"140\":[4,34],\"141\":[5,57],\"142\":[3,9],\"143\":[3,10],\"144\":[3,19],\"145\":[3,6],\"146\":[3,50],\"147\":[4,22],\"148\":[7,59],\"149\":[3,13],\"150\":[3,47],\"151\":[3,18],\"152\":[3,23],\"153\":[3,11],\"154\":[3,36],\"155\":[3,15],\"156\":[3,25],\"157\":[3,46],\"158\":[3,41],\"159\":[3,30],\"160\":[4,23],\"161\":[5,8],\"162\":[5,8],\"163\":[8,5],\"164\":[4,24],\"165\":[4,31],\"166\":[4,22],\"167\":[3,63],\"168\":[null,null,1],\"169\":[null,null,3],\"170\":[1,1],\"171\":[8,37],\"172\":[1,17],\"173\":[2,19],\"174\":[1,21],\"175\":[1,47],\"176\":[3,32],\"177\":[1,51],\"178\":[1,41],\"179\":[1,42],\"180\":[null,null,1],\"181\":[null,null,1],\"182\":[1,2],\"183\":[5,16],\"184\":[5,28],\"185\":[4,43],\"186\":[4,64],\"187\":[4],\"188\":[3,34],\"189\":[2,63],\"190\":[4,66],\"191\":[4],\"192\":[5,21],\"193\":[5,23],\"194\":[2,39],\"195\":[3,6],\"196\":[3,16],\"197\":[3,21],\"198\":[3,54],\"199\":[3,42],\"200\":[5,21],\"201\":[4,26],\"202\":[4],\"203\":[3,77],\"204\":[3,35],\"205\":[3,106],\"206\":[3,41],\"207\":[null,null,1],\"208\":[null,null,1],\"209\":[1,5],\"210\":[4,73],\"211\":[4,23],\"212\":[5],\"213\":[3,43],\"214\":[4],\"215\":[5,29],\"216\":[5,10],\"217\":[4,25],\"218\":[5,18],\"219\":[8,59],\"220\":[5,55],\"221\":[5,19],\"222\":[4],\"223\":[5,46],\"224\":[5,85],\"225\":[4,6],\"226\":[4],\"227\":[5,65],\"228\":[6,34],\"229\":[6,55],\"230\":[3,19],\"231\":[5,34],\"232\":[7,51],\"233\":[5,39],\"234\":[4],\"235\":[5,33],\"236\":[5,83],\"237\":[4,45],\"238\":[3],\"239\":[4,62],\"240\":[4,46],\"241\":[3,72],\"242\":[4,28],\"243\":[5,37],\"244\":[null,null,1],\"245\":[null,null,2],\"246\":[1,27],\"247\":[1,20],\"248\":[3,29],\"249\":[5,41],\"250\":[4,29],\"251\":[6],\"252\":[3,10],\"253\":[1,13],\"254\":[1,48],\"255\":[2,64],\"256\":[null,null,1],\"257\":[null,null,1],\"258\":[1,11],\"259\":[3,20],\"260\":[4,13],\"261\":[3,17],\"262\":[4,53],\"263\":[4,17],\"264\":[3,39],\"265\":[4,20],\"266\":[4,73],\"267\":[4,23],\"268\":[5,32],\"269\":[null,null,1],\"270\":[null,null,1],\"271\":[1,3],\"272\":[1],\"273\":[2],\"274\":[1],\"275\":[1],\"276\":[1],\"277\":[1],\"278\":[1],\"279\":[1],\"280\":[1],\"281\":[1],\"282\":[1],\"283\":[1]},\"averageFieldLength\":[2.9904873154339047,27.619910874586544,0.43614514298611823],\"storedFields\":{\"0\":{\"h\":\"关于\",\"t\":[\"我是你爹\"]},\"1\":{\"h\":\"配置&插件\"},\"2\":{\"h\":\"Vscode 插件&配置\",\"t\":[\"好用好看好玩的vscode插件。\"]},\"3\":{\"h\":\"一、Vscode 设置\",\"t\":[\"可以在vsc的设置里面搜索，也可以直接改 settings.json\",\"settings.json：平滑效果smooth开启后，光标异常丝滑。\",\"{ // 设置在一段延迟后自动保存文件 \\\"files.autoSave\\\": \\\"afterDelay\\\", // 启用工作台列表的平滑滚动效果 \\\"workbench.list.smoothScrolling\\\": true, // 光标移动时的平滑动画效果 \\\"editor.cursorSmoothCaretAnimation\\\": \\\"on\\\", // 编辑器中的平滑滚动效果 \\\"editor.smoothScrolling\\\": true, // 光标闪烁效果设为平滑 \\\"editor.cursorBlinking\\\": \\\"smooth\\\", // 允许使用鼠标滚轮进行编辑器字体缩放 \\\"editor.mouseWheelZoom\\\": true, // 使代码建议不会被片段补全中断 \\\"editor.suggest.snippetsPreventQuickSuggestions\\\": false, }\"]},\"4\":{\"h\":\"二、UI 类\"},\"5\":{\"h\":\"1.1 主题\",\"t\":[\"Dracula Official：目前使用ing \",\"Material Icon Theme ：也是不错的，蛮多人用，是一个主题包，能切换多种主题 \"]},\"6\":{\"h\":\"1.2 图标包\",\"t\":[\"Emoji File Icons： 好看好看好看好看 \",\"vscode-icons ：官方的图标包\"]},\"7\":{\"h\":\"三、编程类\"},\"8\":{\"h\":\"2.1 代码视觉优化\",\"t\":[\"Indent-Rainbow：缩进着色 \",\"Indent Rainbow Palettes：搭配 Indent-Rainbow 使用 \"]},\"9\":{\"h\":\"2.2 项目管理\",\"t\":[\"Project Manager：Easily switch between projects \"]},\"10\":{\"h\":\"2.3 开发实用\",\"t\":[\"Todo Tree：打标签，方便定位、备忘、备注 \",\"Thunder Client：类似 postman \",\"Path Intellisense：写文件路径时，有类似语法提示的效果 \"]},\"11\":{\"h\":\"2.4 Git可视化\",\"t\":[\"GitLens：Supercharge Git in VS Code \"]},\"12\":{\"h\":\"四、AI 类\",\"t\":[\"百度： Comate\",\"GitHub：Copilot\",\"Comate：响应速度快，现在可以免费用，官方申请。（目前首选，体验蛮好还） Copilot：比Comate处理能力强，学生认证可免费使用。\"]},\"13\":{\"h\":\"五、没啥用But安装了类\",\"t\":[\"vscode-pets：电子宠物 \",\"CodeSnap：代码选择截图，带个框好看点 \"]},\"14\":{\"c\":[\"vscode\"]},\"15\":{\"c\":[\"插件\",\"vscode 配置\"]},\"16\":{\"h\":\"前端\"},\"17\":{\"h\":\"docker 框架与核心\",\"t\":[\"dokcer 的框架与核心概念\"]},\"18\":{\"h\":\"一、docker 镜像、容器、仓库\"},\"19\":{\"h\":\"1.1\",\"t\":[\"它是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。\",\"所以你想启动一个容器，那首先必须要有一个镜像。\"]},\"20\":{\"h\":\"1.2\",\"t\":[\"容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。\",\"即容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态。\",\"虽然容器的本质是主机上运行的一个进程，但是**容器有自己独立的命名空间隔离和资源限制。**也就是说，在容器内部，无法看到主机上的进程、环境变量、网络等信息，这是容器与直接运行在主机上进程的本质区别。\"]},\"21\":{\"h\":\"1.3\",\"t\":[\"Docker 的镜像仓库类似于代码仓库，用来存储和分发 Docker 镜像。\",\"镜像仓库分为公共镜像仓库和私有镜像仓库。目前，Docker Hub 是 Docker 官方的公开镜像仓库\"]},\"22\":{\"h\":\"二、docker 框架架构\",\"t\":[\"Docker 整体架构采用 C/S 模式，主要由客户端和服务端两大部分组成。\",\"客户端负责发送操作指令，服务端负责接收和处理指令。\"]},\"23\":{\"h\":\"2.1 docker 客户端\",\"t\":[\"有 3 种\",\"Docker cli\",\"Docker rest api\",\"语言的 SDK\"]},\"24\":{\"h\":\"2.2 docker 服务端\",\"t\":[\"Docker 服务端是 Docker 所有后台服务的统称。\",\"dockerd 是一个非常重要的后台管理进程，它负责响应和处理来自 Docker 客户端的请求，然后将客户端的请求转化为 Docker 的具体操作。\",\"dockerd 通过 grpc 与 containerd 通信\"]},\"25\":{\"h\":\"2.3 docker 重要组件\",\"t\":[\"图上有 ⬇️\",\"runc：runC 是一个用来运行容器的轻量级工具，是真正用来运行容器的。\",\"containerd：containerd 通过 containerd-shim 启动并管理 runC，可以说 containerd 真正管理了容器的生命周期。\"]},\"26\":{\"h\":\"2.4\",\"t\":[\"docker run -d busybox sleep 3600 #这个容器会在后台运行一个简单的sleep任务，即等待 3600 秒，然后停止。\",\"启动一个 busybox 容器(是一个非常小巧的 Linux 镜)，查看进程的父子关系：\",\"sudo pstree -l -a -A 4147 dockerd |-containerd --config /var/run/docker/containerd/containerd.toml --log-level info | |-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/d14d20507073e5743e607efd616571c834f1a914f903db6279b8de4b5ba3a45a -address /var/run/docker/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc | | |-sleep 3600\",\"dockerd 启动的时候， containerd 就随之启动了，dockerd 与 containerd 一直存在。\",\"当执行 docker run 命令（通过 busybox 镜像创建并启动容器）时，containerd 会创建 containerd-shim 充当 “垫片” 进程，然后启动容器的真正进程 sleep 3600 。\"]},\"27\":{\"h\":\"三、docker 数据管理\",\"t\":[\"在容器中管理数据主要有两种方式：\",\"数据卷（Volumes）\",\"挂载主机目录 (Bind mounts)\"]},\"28\":{\"h\":\"3.1 数据卷\",\"t\":[\"数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：\",\"数据卷 可以在容器之间共享和重用。\",\"对 数据卷 的修改会立马生效。\",\"对 数据卷 的更新，不会影响镜像 。\",\"数据卷 默认会一直存在，即使容器被删除。\"]},\"29\":{\"h\":\"创建一个数据卷\",\"t\":[\"docker volume create myVolName\"]},\"30\":{\"h\":\"查看所有数据卷\",\"t\":[\"docker volume ls\"]},\"31\":{\"h\":\"查看指定数据卷的信息\",\"t\":[\"docker volume inspect my-vol\"]},\"32\":{\"h\":\"启动一个挂载数据卷的容器\",\"t\":[\"在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。\",\"在一次 docker run 中可以挂载多个 数据卷 。\",\"下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。\",\"docker run -d -P \\\\ --name web \\\\ #-v my-vol:/wepapp \\\\ --mount source=my-vol, target=/webapp \\\\ training/webapp \\\\ python app.py\"]},\"33\":{\"h\":\"删除数据卷\",\"t\":[\"docker volume rm my-vol\"]},\"34\":{\"h\":\"3.2 目录挂载\"},\"35\":{\"h\":\"挂载一个主机目录作为数据卷\",\"t\":[\"使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。\",\"docker run -d -P \\\\ --name web \\\\ #-v my-vol:/wepapp \\\\ --mount type=bind,source=/src/webapp,target=/opt/webapp \\\\ training/webapp \\\\ python app.py\",\"上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录。\",\"这个功能在进行测试 的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。\",\"本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。\",\"Docker 挂载主机目录的默认权限是读写 ，用户也可以通过增加 readonly 指定为 只读 。\",\"加了 readonly 之后，就挂载为只读了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误\",\"touch new.txt touch: new.txt: Read-only file system\"]},\"36\":{\"h\":\"查看容器的数据卷具体信息\",\"t\":[\"docker inspect web\"]},\"37\":{\"h\":\"挂载一个本地主机文件作为数据卷\",\"t\":[\"--mount 标记也可以从主机挂载单个文件到容器中\"]},\"38\":{\"h\":\"四、docker 网络模式\"},\"39\":{\"h\":\"4.1 端口映射 外部访问容器\",\"t\":[\"以通过 -P 或 -p 参数来指定端口映射。注意大小写。\",\"当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。\",\"例子：\",\"docker run -d -p 5000:5000 此时默认会绑定本地所有接口上的所有地址。\",\"docker run -d -p 127.0.0.1:5000:5000 映射到指定地址的指定端口\",\"docker run -d -p 127.0.0.1::5000 映射到指定地址的任意端口\",\"docker run -d -p 127.0.0.1:5000:5000/udp 还可以使用 udp 标记来指定 udp 端口\",\"-p 标记还可以多次使用来绑定多个端口：\",\"docker run -d \\\\ -p 5000:5000 \\\\ -p 3000:80 \\\\\"]},\"40\":{\"h\":\"4.2 查看端口映射配置\",\"t\":[\"使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址。\"]},\"41\":{\"h\":\"4.3 容器互联\",\"t\":[\"新建容器网络，-d 参数指定 Docker 网络类型，有 bridge 、overlay。\",\"其中 overlay 网络类型用于 Swarm mode。\",\"docker network create -d bridge my-net # 运行一个容器并加入到 my-net 网络 docker run -it --rm --name busybox2 --network my-net busybox sh\"]},\"42\":{\"h\":\"4.4 网络模式\"},\"43\":{\"h\":\"基础理论\",\"t\":[\"docker 使用 Linux 桥接网卡，在宿主机虚拟一个docker 容器网桥docker0。\",\"docker 启动一个容器时会根据 docker 网桥的网段分配给容器一个 IP 地址，称为 Container-IP，同时 Docker 网桥是每个容器的默认网络网关。\",\"ip address 4: docker0: mtu 1500 qdisc noqueue state DOWN group defa ult link/ether 02:42:ef:30:24:5b brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever\",\"因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信。\",\"docker 网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接 Container-IP 访问到容器。\",\"如果容器希望外部访问能够访问到，可以通过端口映射，即通过 -p或-P 参数来启用，访问容器的时候就通过 宿主机IP:容器端口 访问容器。\"]},\"44\":{\"h\":\"Dokcer 支持的网络模式\",\"t\":[\"Docker 网络模式\",\"配置\",\"说明\",\"host 模式\",\"-net=host\",\"容器和宿主机共享 Network namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。\",\"container 模式\",\"-net=container:NAME_or_ID\",\"容器和另外一个容器共享 Network namespace。创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围。\",\"none 模式\",\"-net=none\",\"容器有独立的 Network namespace，并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，配置 IP 等。该模式关闭了容器的网络功能。\",\"bridge 模式\",\"-net=bridge\",\"(默认模式)。此模式会为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0 虚拟网桥，通过 docker0 网桥以及 Iptable nat 表配置与宿主机通信\",\"Macvlan network\",\"无\",\"容器具备 Mac 地址，使其显示为网络上的物理设备\",\"Overlay\",\"无\",\"(覆盖网络)：利用 VXLAN 实现的 bridge 模式\"]},\"45\":{\"h\":\"Bridge 模式\",\"t\":[\"容器的默认的网络模式。该模式下的容器只有宿主机可以直接访问,外部主机是不可见的。\",\"提示\",\"Docker Daemon 利用 veth pair 技术，在宿主机上创建两个虚拟网络接口设备，假设为 veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。\",\"Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0 网桥上。保证宿主机的网络报 文可以发往 veth0;\",\"Docker Daemon 将 veth1 添加到 Docker Container 所属的 namespace 下，并被改名为 eth0。 如此一来，保证宿主机的网络报文若发往 veth0 则立即会被 eth0 接收，实现宿主机到 Docker Container 网络的联通性;同时也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性。\",\"提示\",\"当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。 这对接口一端在容器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT ）。\",\"通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\"]},\"46\":{\"h\":\"Host 网络\",\"t\":[\"host 模式相当于 Vmware 中的 NAT 模式，与宿主机在同一个网络中，但 没有独立IP地址。\",\"启动容器使用 host 模式，容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。\",\"使用 host 模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行 NAT，host最大的优势就是网络性能比较好，docker host 上已经使用的端口就不能再用了，网络的隔离性不好。\"]},\"47\":{\"h\":\"Container 网络模式\",\"t\":[\"一种特殊 host 网络模式， ontainer 网络模式是 Docker 中一种较为特别的网络的模式。\",\"在容器创建时使用 – network=container:vm1 指定。(vm1 指定的是运行的容器名)处于这个模式下的 Docker 容器会共享一个网络环境,这样两个容器之间可以使用 localhost 高效快速通信。\",\"Container 网络模式没有改善容器与宿主机以外世界通信的情况(和桥接模式一样，不能连接宿主机以外的其他设备)。\",\"这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。\",\"新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。\"]},\"48\":{\"h\":\"None 模式\",\"t\":[\"none 模式可以在容器创建时通过 -- network=none 来指定。\",\"使用 none 模式，Docker 容器有自己的 Network Namespace，但不进行任何网络配置。容器无网卡、IP、路由等信息，需自行添加网卡、配置 IP。此模式下容器只有 lo 回环网络，无其他网卡。\"]},\"49\":{\"c\":[\"docker\"]},\"50\":{\"c\":[\"docker\"]},\"51\":{\"h\":\"docker 常用命令\",\"t\":[\"常用的docker命令。\"]},\"52\":{\"h\":\"Docker 的常用命令\"},\"53\":{\"h\":\"1 帮助命令\",\"t\":[\"docker version # 显示docker的版本信息 docker info # 显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help # 帮助命令\"]},\"54\":{\"h\":\"2 镜像命令\"},\"55\":{\"h\":\"2.1 docker images\",\"t\":[\"images 列表标签说明：\",\"REPOSITORY 镜像的仓库源\",\"TAG 镜像的标签\",\"IMAGE ID 镜像的id\",\"CREATED 镜像的创建时间\",\"SIZE 镜像的大小\"]},\"56\":{\"h\":\"2.2 docker search（搜索镜像）\",\"t\":[\"docker search redis\"]},\"57\":{\"h\":\"2.3 docker pull（下载镜像）\",\"t\":[\"# 下载镜像：docker pull 镜像名[:tag] # 两个命令是等价的 docker pull mysql docker pull docker.io/library/mysql:latest\"]},\"58\":{\"h\":\"2.4 docker rmi（删除镜像）\",\"t\":[\"[root@kryiea //]：docker rmi -f 镜像id # 删除指定的镜像 [root@kryiea //]：docker rmi -f 镜像id 镜像id 镜像id # 删除多个镜像（空格分隔） [root@kryiea //]：docker rmi -f $(docker images -aq) # 删除全部的镜像\"]},\"59\":{\"h\":\"3. 容器命令\",\"t\":[\"说明：我们有了镜像才可以创建容器， linux ，下载一个 centos 镜像来测试学习。\",\"docker pull centos\"]},\"60\":{\"h\":\"3.1 新建容器并启动\",\"t\":[\"docker run [可选参数] image # 参数说明 --name=\\\"name\\\" 容器名字：用来区分容器 -d 后台方式运行：相当于nohup -it 使用交互式运行：进入容器查看内容 -p 指定容器的端口（四种方式）小写字母p -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 容器端口 -P 随机指定端口（大写字母P）\"]},\"61\":{\"h\":\"3.2 列出所有运行的容器\",\"t\":[\"docker ps # 列出当前正在运行的容器 # 命令参数可选项 -a # 列出当前正在运行的容器+历史运行过的容器 -n=? # 显示最近创建的容器（可以指定显示几条，比如-n=1） -q # 只显示容器的编号\"]},\"62\":{\"h\":\"3.3 退出容器\",\"t\":[\"exit # 容器直接停止，并退出 ctrl+P+Q # 容器不停止，退出 [root@kryiea //]# docker run -it centos /bin/bash //交互式进入\"]},\"63\":{\"h\":\"3.4 删除容器\",\"t\":[\"docker rm 容器id # 删除容器（不能删除正在运行的容器）如果要强制删除：docker rm -f 容器id docker rm -f $(docker ps -aq) # 删除全部容器 docker ps -a -q|xargs docker rm # 删除所有容器\"]},\"64\":{\"h\":\"3.5 启动和停止容器的操作\",\"t\":[\"docker start 容器id # 启动容器 docker restart 容器id # 重启容器 docker stop 容器id # 停止当前正在运行的容器 docker kill 容器id # 强制停止当前容器\"]},\"65\":{\"h\":\"4 常用其他命令\"},\"66\":{\"h\":\"4.1 后台启动容器\",\"t\":[\"常见的坑：docker 容器使用后台运行，就必须要有要一个前台进程，docker 发现没有应用，就会自动停止。 比如：nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了\",\"# 命令docker run -d 镜像名 [root@kryiea //] docker run -d centos 5b06d0d14b3312e589a411dd9ae15589dc9321f771e5615b7ae26e85017de080 # 问题：docker ps发现centos停止了\"]},\"67\":{\"h\":\"4.2 查看日志\",\"t\":[\"docker logs -tf --tail 容器id # 显示日志 -tf # 显示日志 --tail number # 要显示的日志条数\"]},\"68\":{\"h\":\"4.3 查看容器中进程的信息\",\"t\":[\"# 命令 docker top 容器id [root@kryiea ~] docker top 25eb9d70b2b4 UID PID PPID C STIME TTY TIME CMD systemd+ 181442 181422 0 09:47 ? 00:00:00 redis-server *:6379\"]},\"69\":{\"h\":\"4.4 查看镜像的元数据\",\"t\":[\"docker inspect 容器id\"]},\"70\":{\"h\":\"4.5 进入当前正在运行的容器\",\"t\":[\"# 方式一 docker exec -it 容器id /bin/bash # 方式二 docker attach 容器id docker exec # 进入容器后开启一个新的终端，可以再里面操作（常用） docker attach # 进入容器正在执行的终端，不会启动新的进程。\"]},\"71\":{\"h\":\"4.6 从容器内拷贝文件到主机\",\"t\":[\"docker cp 容器id:容器内路径 目的主机的路径\"]},\"72\":{\"c\":[\"docker\"]},\"73\":{\"c\":[\"docker\",\"命令\"]},\"74\":{\"h\":\"GMP模型：demo演示\"},\"75\":{\"h\":\"一、Demo 代码\",\"t\":[\"提示\",\"根据 Demo，思考以下问题：\",\"输出结果是什么？\",\"为什么先打印它，一次调度流程是怎么样的？\",\"如果 n 设置为 257、258，输出有什么不同？\",\"package main import ( \\\"fmt\\\" \\\"runtime\\\" \\\"sync\\\" ) func main() { // 设置只有一个 P 工作 runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} n := 10 // 启动 n 个 goroutine 打印 wg.Add(n) for i := 1; i <= n; i++ { go func(i int) { defer wg.Done() fmt.Println(\\\"我是协程：\\\", i) }(i) } wg.Wait() }\"]},\"76\":{\"h\":\"二、输出结果\",\"t\":[\"比较长...........\"]},\"77\":{\"h\":\"N = 10\",\"t\":[\"我是协程： 10 我是协程： 1 我是协程： 2 我是协程： 3 我是协程： 4 我是协程： 5 我是协程： 6 我是协程： 7 我是协程： 8 我是协程： 9\"]},\"78\":{\"h\":\"N = 257\",\"t\":[\"我是协程： 256 我是协程： 1 我是协程： 2 我是协程： 3 我是协程： 4 我是协程： 5 我是协程： 6 我是协程： 7 我是协程： 8 我是协程： 9 我是协程： 10 我是协程： 11 我是协程： 12 我是协程： 13 我是协程： 14 我是协程： 15 我是协程： 16 我是协程： 17 我是协程： 18 我是协程： 19 我是协程： 20 我是协程： 21 我是协程： 22 我是协程： 23 我是协程： 24 我是协程： 25 我是协程： 26 我是协程： 27 我是协程： 28 我是协程： 29 我是协程： 30 我是协程： 31 我是协程： 32 我是协程： 33 我是协程： 34 我是协程： 35 我是协程： 36 我是协程： 37 我是协程： 38 我是协程： 39 我是协程： 40 我是协程： 41 我是协程： 42 我是协程： 43 我是协程： 44 我是协程： 45 我是协程： 46 我是协程： 47 我是协程： 48 我是协程： 49 我是协程： 50 我是协程： 51 我是协程： 52 我是协程： 53 我是协程： 54 我是协程： 55 我是协程： 56 我是协程： 57 我是协程： 58 我是协程： 59 我是协程： 60 我是协程： 61 我是协程： 62 我是协程： 63 我是协程： 64 我是协程： 65 我是协程： 66 我是协程： 67 我是协程： 68 我是协程： 69 我是协程： 70 我是协程： 71 我是协程： 72 我是协程： 73 我是协程： 74 我是协程： 75 我是协程： 76 我是协程： 77 我是协程： 78 我是协程： 79 我是协程： 80 我是协程： 81 我是协程： 82 我是协程： 83 我是协程： 84 我是协程： 85 我是协程： 86 我是协程： 87 我是协程： 88 我是协程： 89 我是协程： 90 我是协程： 91 我是协程： 92 我是协程： 93 我是协程： 94 我是协程： 95 我是协程： 96 我是协程： 97 我是协程： 98 我是协程： 99 我是协程： 100 我是协程： 101 我是协程： 102 我是协程： 103 我是协程： 104 我是协程： 105 我是协程： 106 我是协程： 107 我是协程： 108 我是协程： 109 我是协程： 110 我是协程： 111 我是协程： 112 我是协程： 113 我是协程： 114 我是协程： 115 我是协程： 116 我是协程： 117 我是协程： 118 我是协程： 119 我是协程： 120 我是协程： 121 我是协程： 122 我是协程： 123 我是协程： 124 我是协程： 125 我是协程： 126 我是协程： 127 我是协程： 128 我是协程： 129 我是协程： 130 我是协程： 131 我是协程： 132 我是协程： 133 我是协程： 134 我是协程： 135 我是协程： 136 我是协程： 137 我是协程： 138 我是协程： 139 我是协程： 140 我是协程： 141 我是协程： 142 我是协程： 143 我是协程： 144 我是协程： 145 我是协程： 146 我是协程： 147 我是协程： 148 我是协程： 149 我是协程： 150 我是协程： 151 我是协程： 152 我是协程： 153 我是协程： 154 我是协程： 155 我是协程： 156 我是协程： 157 我是协程： 158 我是协程： 159 我是协程： 160 我是协程： 161 我是协程： 162 我是协程： 163 我是协程： 164 我是协程： 165 我是协程： 166 我是协程： 167 我是协程： 168 我是协程： 169 我是协程： 170 我是协程： 171 我是协程： 172 我是协程： 173 我是协程： 174 我是协程： 175 我是协程： 176 我是协程： 177 我是协程： 178 我是协程： 179 我是协程： 180 我是协程： 181 我是协程： 182 我是协程： 183 我是协程： 184 我是协程： 185 我是协程： 186 我是协程： 187 我是协程： 188 我是协程： 189 我是协程： 190 我是协程： 191 我是协程： 192 我是协程： 193 我是协程： 194 我是协程： 195 我是协程： 196 我是协程： 197 我是协程： 198 我是协程： 199 我是协程： 200 我是协程： 201 我是协程： 202 我是协程： 203 我是协程： 204 我是协程： 205 我是协程： 206 我是协程： 207 我是协程： 208 我是协程： 209 我是协程： 210 我是协程： 211 我是协程： 212 我是协程： 213 我是协程： 214 我是协程： 215 我是协程： 216 我是协程： 217 我是协程： 218 我是协程： 219 我是协程： 220 我是协程： 221 我是协程： 222 我是协程： 223 我是协程： 224 我是协程： 225 我是协程： 226 我是协程： 227 我是协程： 228 我是协程： 229 我是协程： 230 我是协程： 231 我是协程： 232 我是协程： 233 我是协程： 234 我是协程： 235 我是协程： 236 我是协程： 237 我是协程： 238 我是协程： 239 我是协程： 240 我是协程： 241 我是协程： 242 我是协程： 243 我是协程： 244 我是协程： 245 我是协程： 246 我是协程： 247 我是协程： 248 我是协程： 249 我是协程： 250 我是协程： 251 我是协程： 252 我是协程： 253 我是协程： 254 我是协程： 255\"]},\"79\":{\"h\":\"N = 258\",\"t\":[\"我是协程： 258 我是协程： 129 我是协程： 130 我是协程： 131 我是协程： 132 我是协程： 133 我是协程： 134 我是协程： 135 我是协程： 136 我是协程： 137 我是协程： 138 我是协程： 139 我是协程： 140 我是协程： 141 我是协程： 142 我是协程： 143 我是协程： 144 我是协程： 145 我是协程： 146 我是协程： 147 我是协程： 148 我是协程： 149 我是协程： 150 我是协程： 151 我是协程： 152 我是协程： 153 我是协程： 154 我是协程： 155 我是协程： 156 我是协程： 157 我是协程： 158 我是协程： 159 我是协程： 160 我是协程： 161 我是协程： 162 我是协程： 163 我是协程： 164 我是协程： 165 我是协程： 166 我是协程： 167 我是协程： 168 我是协程： 169 我是协程： 170 我是协程： 171 我是协程： 172 我是协程： 173 我是协程： 174 我是协程： 175 我是协程： 176 我是协程： 177 我是协程： 178 我是协程： 179 我是协程： 180 我是协程： 181 我是协程： 182 我是协程： 183 我是协程： 184 我是协程： 185 我是协程： 186 我是协程： 187 我是协程： 188 我是协程： 1 我是协程： 189 我是协程： 190 我是协程： 191 我是协程： 192 我是协程： 193 我是协程： 194 我是协程： 195 我是协程： 196 我是协程： 197 我是协程： 198 我是协程： 199 我是协程： 200 我是协程： 201 我是协程： 202 我是协程： 203 我是协程： 204 我是协程： 205 我是协程： 206 我是协程： 207 我是协程： 208 我是协程： 209 我是协程： 210 我是协程： 211 我是协程： 212 我是协程： 213 我是协程： 214 我是协程： 215 我是协程： 216 我是协程： 217 我是协程： 218 我是协程： 219 我是协程： 220 我是协程： 221 我是协程： 222 我是协程： 223 我是协程： 224 我是协程： 225 我是协程： 226 我是协程： 227 我是协程： 228 我是协程： 229 我是协程： 230 我是协程： 231 我是协程： 232 我是协程： 233 我是协程： 234 我是协程： 235 我是协程： 236 我是协程： 237 我是协程： 238 我是协程： 239 我是协程： 240 我是协程： 241 我是协程： 242 我是协程： 243 我是协程： 244 我是协程： 245 我是协程： 246 我是协程： 247 我是协程： 248 我是协程： 2 我是协程： 249 我是协程： 250 我是协程： 251 我是协程： 252 我是协程： 253 我是协程： 254 我是协程： 255 我是协程： 256 我是协程： 3 我是协程： 4 我是协程： 5 我是协程： 6 我是协程： 7 我是协程： 8 我是协程： 9 我是协程： 10 我是协程： 11 我是协程： 12 我是协程： 13 我是协程： 14 我是协程： 15 我是协程： 16 我是协程： 17 我是协程： 18 我是协程： 19 我是协程： 20 我是协程： 21 我是协程： 22 我是协程： 23 我是协程： 24 我是协程： 25 我是协程： 26 我是协程： 27 我是协程： 28 我是协程： 29 我是协程： 30 我是协程： 31 我是协程： 32 我是协程： 33 我是协程： 34 我是协程： 35 我是协程： 36 我是协程： 37 我是协程： 38 我是协程： 39 我是协程： 40 我是协程： 41 我是协程： 42 我是协程： 43 我是协程： 44 我是协程： 45 我是协程： 46 我是协程： 47 我是协程： 48 我是协程： 49 我是协程： 50 我是协程： 51 我是协程： 52 我是协程： 53 我是协程： 54 我是协程： 55 我是协程： 56 我是协程： 57 我是协程： 58 我是协程： 59 我是协程： 60 我是协程： 61 我是协程： 62 我是协程： 63 我是协程： 64 我是协程： 65 我是协程： 66 我是协程： 67 我是协程： 68 我是协程： 69 我是协程： 70 我是协程： 71 我是协程： 72 我是协程： 73 我是协程： 74 我是协程： 75 我是协程： 76 我是协程： 77 我是协程： 78 我是协程： 79 我是协程： 80 我是协程： 81 我是协程： 82 我是协程： 83 我是协程： 84 我是协程： 85 我是协程： 86 我是协程： 87 我是协程： 88 我是协程： 89 我是协程： 90 我是协程： 91 我是协程： 92 我是协程： 93 我是协程： 94 我是协程： 95 我是协程： 96 我是协程： 97 我是协程： 98 我是协程： 99 我是协程： 100 我是协程： 101 我是协程： 102 我是协程： 103 我是协程： 104 我是协程： 105 我是协程： 106 我是协程： 107 我是协程： 108 我是协程： 109 我是协程： 110 我是协程： 111 我是协程： 112 我是协程： 113 我是协程： 114 我是协程： 115 我是协程： 116 我是协程： 117 我是协程： 118 我是协程： 119 我是协程： 120 我是协程： 121 我是协程： 122 我是协程： 123 我是协程： 124 我是协程： 125 我是协程： 126 我是协程： 127 我是协程： 128 我是协程： 257\"]},\"80\":{\"h\":\"三、问题解答\"},\"81\":{\"h\":\"为什么先打印它，一次调度流程是怎么样的？\",\"t\":[\"提示\",\"该问题以 n = 10 的结果展开讨论。\",\"打印是有序的，先创建的 g 先被调度执行。\",\"最后创建的 10 却是最先被调度。\",\"这段 demo 中设置了 runtime.GOMAXPROCS(1)，也就是只有一个 P 能够工作，不设置就是默认等于 cpu 的核心数。\",\"因为只有一个 P，所以创建的协程 G 会被依次放入到 P 的本地队列中，然后被调度执行。\",\"那么为什么最先调度的是 g10？？\",\"因为 GMP 在运行时，有一个 runnext 指针，会指向最新切换进来的协程 g，把原本指向的 g 放入到 P 的本地队列中。\",\"模拟一下：\",\"g1 创建：Runnext --> g1 、P --> nil\",\"g2 加入调度：runnext ---> g2、P --> g1\",\"g3 加入调度：runnext ---> g3、P --> g1、g2\",\"........\",\"g10 加入调度：runnext ---> g10、P --> g1、... 、g9\"]},\"82\":{\"h\":\"如果 设置为 257、258，打印输出的规律是什么？\",\"t\":[\"提示\",\"先解释一下为什么选 257 和 258 两个数值：\",\"**257：**P 本地队列的长度是 256，runnext 又可以指向一个 g，加起来就是 257。\",\"258：258 个 g > 最大的本地队列长度256 + 1，就会把部分 g 放进全局队列，多了全局队列的参与，调度又会发生很多不同。\",\"根据上面 问题 1 的模拟过程，我们可以知道：\",\"g257 加入调度： runnext ---> g257、P --> g1、... 、g256、Global：--> nil\",\"g258 加入调度，把 g257 切换出来，由于 P 已经满了，会把 P 的一半 1-128 放到全局队列，再把 257 也放到全局队列： runnext ---> g258、P --> g129 、... 、g256、Global：--> g1、...、g128、g257\",\"所以当 n = 257 的时候：\",\"会先调度 g257，然后再在 P 中从 g1 到 g256 依次调度。\",\"输出结果也是如此。\",\"但是 当 n = 258 的时候：\",\"先调度 g258，\",\"后面先调度本地队列 P 的待执行的 g。\",\"(思考) 但是发现到 g188 的时候，突然又调度了一下 g1，在接着调度 g189。到 g248 之后又到了 g2。\",\"接下来把 p 本地队列中的最后一个 g256 调度后，就开始从 g3 开始调度堆积在全局队列的 g。\",\"最后 s 把全局队列的 g 全部调度完了。\",\"回想八股：GMP 模型下，内核线程 M 每调度 61 次本地队列 p 中的协程后，都会去全局队列中获取一个 g 来执行。\",\"But： 188 - 128 = 60，也就是完整调度了 60 次就去全局队列中偷一个协程 g 了，岂不是八股错了？\",\"哦哦哦： GMP 调度过程不仅仅只处理用户定义的协程，还有一些 runtime 本来就有的协程要调度，也会算到这 61 次里面。只是其中的 60 次调度了用户定义的 g。\",\"再回想八股：当 P 为空时，会去全局队列中拿一批 g 回来调度\",\"一批是多少：\",\"// 简化版： n = min( len(global) / GOMAXPROCS + 1, len(global/2) )\",\"因为设置了 GOMAXPROCS = 1，所以 n = min ( 129 / 1 + 1 , 129 / 2) = 全拿\",\"详细如下：\",\"// Try get a batch of G's from the global runnable queue. // sched.lock must be held. func globrunqget(pp *p, max int32) *g { assertLockHeld(&sched.lock) if sched.runqsize == 0 { return nil } n := sched.runqsize/gomaxprocs + 1 if n > sched.runqsize { n = sched.runqsize } if max > 0 && n > max { n = max } if n > int32(len(pp.runq))/2 { n = int32(len(pp.runq)) / 2 } sched.runqsize -= n gp := sched.runq.pop() n-- for ; n > 0; n-- { gp1 := sched.runq.pop() runqput(pp, gp1, false) } return gp }\"]},\"83\":{\"c\":[\"Go\"]},\"84\":{\"c\":[\"Go\",\"GMP\"]},\"85\":{\"h\":\"GMP模型\",\"t\":[\"GMP模型是 Go 语言运行时的核心组成部分，它负责管理 Go 程序的并发执行。\"]},\"86\":{\"h\":\"一、Go 的协程 - goroutine\",\"t\":[\"Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。\",\"虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。\",\"goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。\",\"最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。\"]},\"87\":{\"h\":\"二、旧：GM模型\"},\"88\":{\"h\":\"2.1 GM符号概念\",\"t\":[\"20240131144616\"]},\"89\":{\"h\":\"2.2 废弃的调度器模型 GM 是如何实现的\",\"t\":[\" M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。\",\"老调度器有几个缺点\",\"创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。\",\"M 转移 G 会造成延迟和额外的系统负载。 比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。\",\"系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。\"]},\"90\":{\"h\":\"三、新：GMP模型\"},\"91\":{\"h\":\"3.1 GMP符号定义\",\"t\":[\"20240131144909\"]},\"92\":{\"h\":\"3.2 GMP 模型\",\"t\":[\"在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上 \"]},\"93\":{\"c\":[\"Go\"]},\"94\":{\"c\":[\"GMP\",\"Go\"]},\"95\":{\"h\":\"Go大致编译过程\",\"t\":[\"了解Go语言的编译大致过程。\"]},\"96\":{\"h\":\"Go 编译器\",\"t\":[\".go为后缀的UTF-8格式的Go文本文件，.go最终能被编译成特定机器上的可执行文件，离不开Go语言编译器的复杂工作。\"]},\"97\":{\"h\":\"一般编译器\",\"t\":[\"一般将编译器分为：编译器前端、优化器、编译器后端。这种编译器被称为三阶段编译器（three-phase compiler）\",\"1707147903867\",\"编译器前端：主要专注于理解源程序、扫描解析源程序并进行精准的语义表达。\",\"编译器的中间阶段 （Intermediate Representation，IR）：可能有多个，编译器会使用多个IR阶段、多种数据结构表示代码，并在中间阶段对代码进行多次优化。例如，识别冗余代码、识别内存逃逸等。编译器的中间阶段离不开编译器前端记录的细节。\",\"编译器后端：专注于生成特定目标机器上的程序，这种程序可能是可执行文件，也可能是需要进一步处理的中间形态obj文件、汇编语言等。\"]},\"98\":{\"h\":\"Go 编译器\",\"t\":[\"Go语言编译器一般缩写为小写的gc（go compiler），需要和大写的**GC（垃圾回收）**进行区分。\",\"Go语言的编译器遵循了主流编译器采用的经典策略及相似的处理流程和优化规则（例如经典的递归下降的语法解析、抽象语法树的构建）。\",\"另外，Go语言编译器有一些特殊的设计，如内存的逃逸等\",\"编译器执行流程\",\"1707147895527\",\"编译器相关源代码位置\",\"Go 语言编译器有关的代码主要位于 go/src/cmd/compile/internal 目录下： \"]},\"99\":{\"h\":\"第一阶段：词法分析和语法分析\",\"t\":[\"cmd/compile/internal/syntax（词法分析器，解析器，语法树）\",\"在编译的第一阶段，源代码被 token 化（词法分析），解析（语法分析），并为每个源构造语法树文件。\",\"每个语法树都是相应源文件的精确表示，对应于源的各种元素的节点，如表达式，声明和陈述。\",\"语法树还包括位置信息用于错误报告和调试信息的创建。\"]},\"100\":{\"h\":\"第二阶段：语义分析\",\"t\":[\"cmd/compile/internal/gc（类型检查，AST变换）\",\"对 AST 进行类型检查：第一步是名称解析和类型推断，它们确定哪个对象属于哪个标识符，以及每个表达式具有的类型。类型检查包括某些额外的检查，例如 “声明和未使用” 以及确定函数是否终止。\",\"在 AST 上也进行了某些转换：一些节点基于类型信息被细化，死代码消除，函数调用内联和转义分析。\",\"语义分析的过程中包含几个重要的操作：逃逸分析、变量捕获、函数内联、闭包处理。\"]},\"101\":{\"h\":\"第三阶段：SSA 生成\",\"t\":[\"cmd/compile/internal/gc (转换为SSA)\",\"cmd/compile/internal/ssa(SSA 传递与规则)\",\"在此阶段，抽象语法树（AST）会被转换成静态单赋值（SSA）形式。SSA是一种低级别的中间表示法，具有便于实施优化和生成机器代码的特性。\",\"在转换过程中，编译器能够识别并将代码中的特定函数替换为高效的代码片段。\",\"在AST转换为SSA的过程中，一些节点会简化为更基本的元素，以便编译器的其他部分可以更容易地使用。例如，内置的复制操作会被替换为内存移动操作，而范围循环则被改写成for循环。\",\"接下来，会执行一系列与具体机器无关的优化步骤和规则。这些步骤和规则不特定于任何一种计算机架构，因此它们适用于所有的GOARCH变体。\",\"这些通用优化过程包括移除死代码、消除不必要的零值检查、以及删除未使用的代码分支。通用的重写规则主要关注表达式，比如用常数替换特定表达式，优化乘法和浮点运算。\"]},\"102\":{\"h\":\"第四阶段：机器码生成\",\"t\":[\"cmd/compile/internal/ssa (底层SSA和架构特定的传递)\",\"cmd/internal/obj (生成机器码)\",\"编译器的机器相关阶段从“底层”传递开始，此过程将通用值转换成特定于机器的形式。例如，在amd64架构中，可以合并多个加载和存储操作，因为其内存操作数具有这样的能力。\",\"需要注意的是，这一底层阶段执行了所有针对特定机器的重写规则，同时也实施了大量的优化措施。\",\"当SSA被“降低”至更贴近目标体系结构后，便会启动最终的代码优化过程。这个过程包括进行另一轮的死代码消除、将值移动至更接近其使用点的位置、删除从未被读取的局部变量，以及进行寄存器分配。\",\"此阶段的其他重要任务包括堆栈框架的布局，这一步骤为局部变量分配堆栈偏移量，并进行指针活动分析，计算每个垃圾收集（GC）安全点上的堆栈指针情况。\",\"在SSA生成阶段完成时，Go函数已被转换成一系列的obj.Prog指令。这些指令随后被传递给装载器cmd/internal/obj，装载器将它们转换为机器代码，并生成最终的目标文件。目标文件除了包含机器代码外，还包括反射数据、导出数据和调试信息。\"]},\"103\":{\"c\":[\"Go\"]},\"104\":{\"c\":[\"编译器\"]},\"105\":{\"h\":\"Go内存逃逸\",\"t\":[\"Go语言内存逃逸的场景\",\"编译器用于决定变量分配到堆上还是栈上的一种行为\",\"发生逃逸的时机\",\"**首先：**函数运行在栈上，在栈里声明临时变量分配内存， 函数运行完毕后回收内存。每个函数的栈空间都是独立的，其他函数不能进行访问。\",\"**发生内存逃逸：**在某些情况下，栈上的数据需要在函数结束之后还能被访问，这时会发生内存逃逸：\",\"如果变量从栈上逃逸，会跑到堆上：\",\"栈上面的变量在函数结束的时候会自动回收，回收代价比较小。而且栈内存的分配和释放，只需要两个CPU指令PUSH和RELEASE。\",\"堆分配内存，需要先找到一块大小合适的内存，之后通过GC回收才能释放，如果频繁进行，占用比较大的系统开销\",\"**所以：**尽量在栈上分配内存，可以减少gc压力，提高程序运行速度\",\"如果函数外部没有引用，则优先放到栈中；\",\"如果函数外部存在引用，则必定放到堆中；\",\"最基本的逃逸分析原则\",\"如果一个函数返回了一个变量的引用，那它系一定发生逃逸，逃到堆上。\",\"编译器会分析代码的特征和生命周期，Go的变量如果能在编译器编译过程中证明确认在函数返回后不会再被引用，才会分配到栈上。其他情况都是分配到堆上。\",\"Go中没有一个关键字或者函数可以让变量被编译器分配到堆上，只能是编译器来分析代码确定 \",\"**指针逃逸：**在函数内部返回一个局部变量指针\",\"**分配大对象：**导致栈空间不足，不得不分配到堆上\",\"**调用接口类型的方法：**接口类型的方法调用是动态调度（实际使用的具体实现只能在运行时确定）。\",\"尽管在能符合分配到栈的场景，但是它的大小不能在编译时确定的情况，也会分配到堆上\"]},\"106\":{\"h\":\"3.1 指针逃逸\",\"t\":[\"传递指针可以减少底层值拷贝，提高效率。\",\"但是如果拷贝的数据量小，由于指针传递会逃逸（发生了函数外引用），可能会使用到堆，这样子会增加GC的负担，所以传递指针不一定是高效的\",\"使用命令：go build -gcflags '-m' xxx.go\",\"例子\",\"package main import \\\"fmt\\\" type Student struct { Name string Age int } func StudentRegister(name string, age int) *Student { // s 原本是局部指针变量，被返回了引用，逃逸到了堆 s := new(Student) s.Age = age s.Name = name return s } func main() { ss := StudentRegister(\\\"kryiea\\\", 20) fmt.Println(ss) }\"]},\"107\":{\"h\":\"3.2 栈空间不足逃逸\",\"t\":[\"栈空间足够时，没有逃逸\",\"package main func MakeSlice() { s := make([]int, 100, 100) for index, _ := range s { s[index] = index } } func main() { MakeSlice() }\",\"容量增大后，发生逃逸\",\"package main func MakeSlice() { s := make([]int, 10000, 10000) for index, _ := range s { s[index] = index } } func main() { MakeSlice() }\",\"20240115164413\"]},\"108\":{\"h\":\"3.3 动态类型逃逸\",\"t\":[\"函数参数为interface，在编译期间很难确定参数具体类型，也能产生逃逸\",\"20240115164427\"]},\"109\":{\"h\":\"3.3 变量大小不确定\",\"t\":[\"在创建切片的时候，初始化切片容量的时候，传入一个变量来指定其大小，由于变量的值不能在编译器确定，所以就不能确定其内存大小，会将对象分配在堆上\",\" package main func MakeSlice() { length := 1 a := make([]int, length, length) for i := 0; i < length; i++ { a[i] = i } } func main() { MakeSlice() }\",\"对于性能要求高且访问频次高的函数调用，应该尽量避免使用接口类型。因为go中接口类型的方法调用都是动态，不能再编译阶段确定\",\"避免变量大小不能确定的时候\",\"不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。\",\"但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。\"]},\"110\":{\"c\":[\"Go\"]},\"111\":{\"h\":\"Go函数调用过程&多值返回实现\",\"t\":[\"go语言函数调用过程、多返回值实现原理\"]},\"112\":{\"h\":\"几个问题\",\"t\":[\"Go的函数调用时参数是通过栈传递还是寄存器传递？\",\"Go的函数调用过程？\",\"GO的多值返回如何实现？\",\"下面内容会详细分析\"]},\"113\":{\"h\":\"一、Go的函数调用\"},\"114\":{\"h\":\"1.1 Go 函数调用基本概念\",\"t\":[\"调用者caller：如果一个函数调用另外一个函数，那么该函数被称为调用者函数\",\"被调用者callee：被调用函数就是 callee\",\"函数栈：函数执行时供它存放局部变量、参数等数据的空间，对应到虚拟地址空间的栈，即函数栈。栈的增长方向是从高位地址到地位地址向下进行增长。\",\"函数栈帧：分配给一个个函数的栈空间被称为函数栈帧\"]},\"115\":{\"h\":\"1.2 程序运行时在内存中的布局\",\"t\":[\"ace8fbfdc7ab04f9e7f20bae079cd91\"]},\"116\":{\"h\":\"1.3 Go 的函数栈帧布局\",\"t\":[\"函数栈帧(上图栈部分)从高到低的布局\",\"调用者caller栈基地址\",\"调用者函数caller的局部变量\",\"被调用函数callee的返回值和参数\",\"被调用者callee的栈帧\",\"Go1.17以前的版本，函数栈空间布局如下： \",\"注意，栈和栈帧是不一样的\",\"在一个函数调用链中，比如函数A调用B，B调用C，则在函数栈上，A的栈帧在上面，下面依次是B、C的函数栈帧。\"]},\"117\":{\"h\":\"1.4 Go1.15 的函数调用过程\",\"t\":[\"先理解几条规则\",\"函数参数完全通过栈传递，参数列表从右至左依次压栈。\",\"Go1.17.1之前版本，callee函数返回值通过caller的栈传递。\",\"Go中，函数栈空间从高地址向低地址使用，通过 栈指针SP + 偏移量OFFSET 寻址。\",\"Go 编译器有4个伪寄存器 \",\"FP/BP 栈底寄存器，指向一个函数栈的顶部\",\"PC 程序计数器，指向下一条执行指令\",\"SB 指向静态数据的基指针，全局符号\",\"SP 栈顶寄存器\",\"示例代码 main.go\",\"package main func main() { var r1, r2, r3, r4, r5, r6, r7 int64 = 1, 2, 3, 4, 5, 6, 7 A(r1, r2, r3, r4, r5, r6, r7) } func A(p1, p2, p3, p4, p5, p6, p7 int64) int64 { return p1 + p2 + p3 + p4 + p5 + p6 + p7 }\",\"打印出main.go汇编\",\"GOOS=linux GOARCH=amd64 go tool compile -S -N -l main.go\",\"查看汇编代码\",\"\\\"\\\".main STEXT size=190 args=0x0 locals=0x80 0x0000 00000 (main.go:3) TEXT \\\"\\\".main(SB), ABIInternal, $128-0 #main函数定义, $128-0：128表示将分配的main函数的栈帧大小；0指定了调用方传入的参数，由于main是最上层函数，这里没有入参 0x0000 00000 (main.go:3) MOVQ (TLS), CX # 将本地线程存储信息保存到CX寄存器中 0x0009 00009 (main.go:3) CMPQ SP, 16(CX) # 栈溢出检测：比较当前栈顶地址(SP寄存器存放的)与本地线程存储的栈顶地址 0x000d 00013 (main.go:3) PCDATA $0, $-2 # PCDATA，FUNCDATA用于Go汇编额外信息，不必关注 0x000d 00013 (main.go:3) JLS 180 # 如果当前栈顶地址(SP寄存器存放的)小于本地线程存储的栈顶地址，则跳到180处代码处进行栈分裂扩容操作 0x0013 00019 (main.go:3) PCDATA $0, $-1 0x0013 00019 (main.go:3) ADDQ $-128, SP # 为main函数栈帧分配了128字节的空间，注意此时的SP寄存器指向，会往下移动128个字节 0x0017 00023 (main.go:3) MOVQ BP, 120(SP) # BP寄存器存放的是main函数caller的基址，movq这条指令是将main函数caller的基址入栈。 0x001c 00028 (main.go:3) LEAQ 120(SP), BP # 将main函数的基址存放到到BP寄存器 0x0021 00033 (main.go:3) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0021 00033 (main.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0021 00033 (main.go:4) MOVQ $1, \\\"\\\".r1+112(SP) # main函数局部变量r1入栈 0x002a 00042 (main.go:4) MOVQ $2, \\\"\\\".r2+104(SP) # main函数局部变量r2入栈 0x0033 00051 (main.go:4) MOVQ $3, \\\"\\\".r3+96(SP) # main函数局部变量r3入栈 0x003c 00060 (main.go:4) MOVQ $4, \\\"\\\".r4+88(SP) # main函数局部变量r4入栈 0x0045 00069 (main.go:4) MOVQ $5, \\\"\\\".r5+80(SP) # main函数局部变量r5入栈 0x004e 00078 (main.go:4) MOVQ $6, \\\"\\\".r6+72(SP) # main函数局部变量r6入栈 0x0057 00087 (main.go:4) MOVQ $7, \\\"\\\".r7+64(SP) # main函数局部变量r7入栈 0x0060 00096 (main.go:5) MOVQ \\\"\\\".r1+112(SP), AX # 将局部变量r1传给寄存器AX 0x0065 00101 (main.go:5) MOVQ AX, (SP) # 寄存器AX将局部变量r1加入栈头SP指向的位置 0x0069 00105 (main.go:5) MOVQ \\\"\\\".r2+104(SP), AX # 将局部变量r2传给寄存器AX 0x006e 00110 (main.go:5) MOVQ AX, 8(SP) # 寄存器AX将局部变量r2加入栈头SP+8指向的位置 0x0073 00115 (main.go:5) MOVQ \\\"\\\".r3+96(SP), AX # 将局部变量r3传给寄存器AX 0x0078 00120 (main.go:5) MOVQ AX, 16(SP) # 寄存器AX将局部变量r3加入栈头SP+16指向的位置 0x007d 00125 (main.go:5) MOVQ \\\"\\\".r4+88(SP), AX # 将局部变量r4传给寄存器AX 0x0082 00130 (main.go:5) MOVQ AX, 24(SP) # 寄存器AX将局部变量r4加入栈头SP+24指向的位置 0x0087 00135 (main.go:5) MOVQ \\\"\\\".r5+80(SP), AX # 将局部变量r5传给寄存器AX 0x008c 00140 (main.go:5) MOVQ AX, 32(SP) # 寄存器AX将局部变量r4加入栈头SP+32指向的位置 0x0091 00145 (main.go:5) MOVQ \\\"\\\".r6+72(SP), AX # 将局部变量r6传给寄存器AX 0x0096 00150 (main.go:5) MOVQ AX, 40(SP) # 寄存器AX将局部变量r6加入栈头SP+40指向的位置 0x009b 00155 (main.go:5) MOVQ \\\"\\\".r7+64(SP), AX # 将局部变量r7传给寄存器AX 0x00a0 00160 (main.go:5) MOVQ AX, 48(SP) # 寄存器AX将局部变量r7加入栈头SP+48指向的位置 0x00a5 00165 (main.go:5) PCDATA $1, $0 0x00a5 00165 (main.go:5) CALL \\\"\\\".A(SB) # 调用 A函数 0x00aa 00170 (main.go:6) MOVQ 120(SP), BP # 将栈上存储的main函数的调用方的基地址恢复到BP 0x00af 00175 (main.go:6) SUBQ $-128, SP # 增加SP的值，栈收缩，收回分配给main函数栈帧的128字节空间 0x00b3 00179 (main.go:6) RET\",\"画图表示\",\"SP+64~SP+112 指向的56个栈空间，存储的是r1~r7这7个main函数的局部变量；\",\"SP+56 该地址接收函数A的返回值；\",\"SP~SP+48 指向的56个字节空间，用来存放A函数的 7 个入参。\",\"20240208155716\",\"当程序准备好函数的入参之后，会调用汇编指令CALL \\\"\\\".A(SB)\",\"这个指令首先会将 main 的返回地址 (8 bytes) 存入栈中，然后改变当前的栈指针 SP 并执行 A 函数的汇编指令。(A 函数没有占用栈空间而已)\",\"栈空间变为：\"]},\"118\":{\"h\":\"二、Go的多值返回\"},\"119\":{\"c\":[\"Go\"]},\"120\":{\"h\":\"Go基础语法\",\"t\":[\"Go 语言的基础语法\",\"好文章\",\"【一文Go起来】快速上手篇\",\"语法的特性符合 Go 1.22 以前版本\"]},\"121\":{\"h\":\"1.1 标识符大小写\",\"t\":[\"标识符：常量、变量、类型、函数名、结构字段...\",\"以大写字母开头：这种形式的标识符对象可以被外部包的代码所使用\",\"以小写字母开头：对包外不可见，但在整个本包内是可见而且是可用的（类似protected）\"]},\"122\":{\"h\":\"1.2 文件结构\",\"t\":[\"文件名与包名： 没有直接关系，不一定要将文件名与包名定成一个名称\",\"文件夹名与包名： 没有直接关系，也不一定要一致\",\"同一个文件夹下的文件只能有一个包名\"]},\"123\":{\"h\":\"2.1 基本规范\",\"t\":[\"变量命名：首个字符不能是数字\",\"声明变量格式：var Name type\"]},\"124\":{\"h\":\"2.2 单变量声明\",\"t\":[\"声明变量，没有显示初始化，变量默认为零值，不同类型零值不一样： \",\"bool类型：false\",\"数值类型：0\",\"字符串类型：“” 空字符串\",\"指针、chan、切片 类型：nil\",\"根据值自行判断变量类型 \",\"var v_name = value\",\":=\"]},\"125\":{\"h\":\"2.3 多变量声明\",\"t\":[\"声明格式：var v_name1 v_name2 v_name3 type\",\"var()： 一般用于声明全局变量\",\"var( v_name1 int v_name2 string )\"]},\"126\":{\"h\":\"2.4 注意\",\"t\":[\":= 只能在函数体内使用，不可以用于全局变量的声明和赋值\",\" // g,h := 123, \\\"hello\\\" 不行 func main(){ //这里可行 g,h := 123, \\\"hello\\\" }\"]},\"127\":{\"h\":\"2.5 变量的生命周期\",\"t\":[\"全局变量： 生命周期是程序存活时间\",\"局部变量： 在不发生内存逃逸的情况下，局部变量周期是函数存活时间\"]},\"128\":{\"h\":\"2.6 常量\",\"t\":[\"不可被修改\",\"常量数据类型只能是：布尔型、数字型（整数型、浮点型、复数型）、字符串型\",\"定义方式：const identifier [type] = value\",\"[type] 可以省略，编译器可以根据变量的值来推断类型\",\"const b string = \\\"abc\\\" 👇等价👇 const b = \\\"abc\\\" // := 错误 const a := 111\"]},\"129\":{\"h\":\"2.7 常量用作枚举\",\"t\":[\"go没有专门的枚举类型，枚举一般用常量表示\",\"package main import \\\"unsafe\\\" const( a = \\\"abc\\\" b = len(a) // 必须是内置函数 c = unsafe.Sizeof(a) ) func main(){ println(a,b,c) } // result：abc 3 16\",\"注意：字符串的 unsafe.Sizeof() 的返回值一直都是16！\",\"解释：\",\"字符串类型对应一个16字节大小的结构体，该结构体有两个域：\",\"type StringHeader srtuct{ Data uintptr // 8字节 Len int // 8字节 }\",\"sizeof(stringType) 只是获取string顶层结构体的大小，并不会深入到实际数据\",\"结论：\",\"sizeof(stringType) 的返回值始终是 16\"]},\"130\":{\"h\":\"2.8 iota\",\"t\":[\"iota 是一个特殊的常量，可认为是一个计数器\",\"iota 在 const 关键字出现时将被重置为 0 （const 内部的第一行之前），const中每新增加一行常量声明将使iota计数一次\",\"const( a = iota // 第一次声明 iota为 0 b = iota // 第二次声明 iota为 1 c = iota // 第三次声明 iota为 2 ) const( a = iota // 第一次声明 iota为 0 b // 1 c // 2 )\",\" func main(){ const( a = iota // 0 b // 1 c // 2 d = \\\"ha\\\" // d是字符串\\\"ha\\\"，但是iota = 3 e // e是字符串\\\"ha\\\"，但是iota = 4 f = 100 // iota = 5 g // 6 h = iota // 7 并且恢复默认记数 i // 8 ) }\",\"go语言跟其他语言一样，运算符大体上也分为以下几种：\",\"算术运算符\",\"关系运算符\",\"逻辑运算符\",\"位运算符\",\"赋值运算符\",\"其他运算符\"]},\"131\":{\"h\":\"3.1 逻辑运算符\",\"t\":[\"20240424155614\"]},\"132\":{\"h\":\"3.2 位运算符\",\"t\":[\"位运算符是对内存中的二进制数进行按位运算，包括 & ，| ，^ ，<<，>>\",\"20240424155622\"]},\"133\":{\"h\":\"3.3 运算符优先级\",\"t\":[\"有些运算符拥有较高的优先级，二元运算待的运算方向均是从左至右。 由上至下代表优先级由高到低： \"]},\"134\":{\"h\":\"3.3 特殊运算符\",\"t\":[\"&^：位清除，先 & 再 ^ 就全变成 0 了 a &^ b：清零a中，ab都为1的位\"]},\"135\":{\"h\":\"4.1 键值对初始化\",\"t\":[\"在初始化时以属性：值的方式完成，如果有的属性不写，则为默认值\",\"type student struct{ ID int Name string Age int Score int } func main(){ st := student{ ID :100, Name : \\\"kryiea\\\", } }\"]},\"136\":{\"h\":\"4.2 值列表初始化\",\"t\":[\"直接按照 属性顺序 来初始化 ⚠️值列表的个数必须 = 结构体属性个数，且按顺序，允许后空缺，不允许中间跳开\",\"st := student{ 101, \\\"ddd\\\" 2, 33, }\"]},\"137\":{\"h\":\"5.1 if\",\"t\":[\"处理map的时候可以用多重赋值写法，表达性强\",\"if num, ok := dic[\\\"apple\\\"]; ok{ ... }\"]},\"138\":{\"h\":\"5.2 switch - case\",\"t\":[\"case 默认有break 跳出条件选择。 若希望从某个case开始按顺序往下执行，可以使用fallthrough。\",\"只有 for 一种循环方式\"]},\"139\":{\"h\":\"6.1 理解 for 的结构\",\"t\":[\"init: 一般为赋值表达式，给控制变量赋初值，执行一次；\",\"condition: 关系表达式或逻辑表达式，循环控制条件；\",\"post: 一般为赋值表达式，给控制变量增量或减量。\",\"// 1 for init; condition; post{ } // 2 for condition{ } // 3 for{ }\"]},\"140\":{\"h\":\"6.2 for range\",\"t\":[\"go version 1.22.2 之后 每次迭代都是一个新变量。\",\"go version 1.22.2 之前\",\"for range 格式可以对 slice、map、数组、字符串继续迭代读取\",\"但是属于副本读，每次迭代都共享一个底层变量 temp，覆盖写入 temp 返回给 value！\",\"详细分析看 6.3 部分。\",\"示例代码：\",\"// range 返回值 for key/index, value := range Map{ } // 或者 for key :=range Map{ } //或者 for _,value :=range Map{ }\"]},\"141\":{\"h\":\"6.3 for range 陷阱\",\"t\":[\"以下分析适合 go version 1.22.2 之前，之后的版本已经更改。\",\"坑 1： for range 取不到所有元素的地址\",\"func main(){ arr := [2]int{1,2} res := []*int{} for _, v := range arr{ res = append(res, &v) } fmt.println(*res[0], *res[1]) } // except: 1, 2 // result: 2, 2\",\"分析：\",\"res 中最终所有的元素都是一个地址，这一个地址最终指向的是 v 最后遍历得到的值，也就是 2。\",\"说明遍历 arr 元素的时候，只是将元素赋值一个临时变量 temp，整个循环都是用这一个 temp变量。\",\"希望得到 1 和 2 怎么实现：\",\"方式 1：用局部变量 v1 拷贝 v\",\"for _, v := range arr{ v1 := v res = append(res, &v1) }\",\"方式 2：直接使用索引获取原来的元素\",\"for k, _ := range arr{ res = append(res, &arr[k])\",\"坑 2：循环终止问题\",\"在 for-range 中向切片追加元素时，循环会在完成遍历原本切片长度后停止。因为 for-range 循环在开始前就已经确定了切片的长度。\",\"循环迭代的是切片在迭代开始时的状态，后续追加的元素不会影响当前的迭代过程。\",\"v := []int{1, 2, 3} for i := range v { fmt.Println(i) // 这里打印的是切片v的索引 v = append(v, i) } // result: 1, 2, 3\"]},\"142\":{\"h\":\"7.1 参数传递\",\"t\":[\"go中参数传递都是值传递，不存在引用传递（区别于c++）\",\"值传递时，可以改变形参的值，但不会改变实参值\",\"传递地址也是值传递，会拷贝原地址，指向同一块区域\"]},\"143\":{\"h\":\"7.2 基本类型\",\"t\":[\"int、float、bool、string ...\",\"对于基础数据类型，值传递意味着每次函数调用时都会 创建变量的一个新副本。 这些副本是独立的，对副本的任何修改都不会影响原始变量。\"]},\"144\":{\"h\":\"7.3 引用类型和指针\",\"t\":[\"引用类型如：切片、映射、通道\",\"对于引用类型和指针，虽然参数传递仍然是按值传递，但传递的是一个 引用的副本或指针的副本\",\"例子： 内存位置 0xfff0 叫 v1，传到到函教参数 v2，v2 的内存位置可能是 0xffe8，里面再保存 0xfff0。\"]},\"145\":{\"h\":\"7.4 结构体和数组\",\"t\":[\"结构体和数组也是按值传递的。 当你传递一个结构体或数组给函数时，会 创建这个结构体或数组的一个完整副本。 函数内部对副本的修改不会影响原始的结构体或数组。\"]},\"146\":{\"h\":\"7.5 可变参数\",\"t\":[\"在 Go 语言中，可变参数（variadic parameter）允许函数接受数量可变的参数。\",\"可变参数使用省略号（...）表示。\",\"简单的示例\",\"package main import \\\"fmt\\\" func sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } func main() { fmt.Println(sum(1, 2)) // 输出: 3 fmt.Println(sum(1, 2, 3, 4, 5)) // 输出: 15 }\",\"在上面的示例中，sum 函数使用了可变参数语法，其中 nums ...int 表示 sum 函数接受任意数量的 int 类型参数。 在 main 函数中，我们可以调用 sum 函数并传入任意数量的 int 参数，而不需要提前指定参数的个数。\",\"可变参数原理\",\"在函数内部，可变参数会被当作一个切片（slice）来处理\",\"nums ...int 会被当做 nums []int\"]},\"147\":{\"h\":\"8.1 Go 普通指针特性\",\"t\":[\"类型安全：Go 语言的指针是类型安全的。这意味着，如果你有一个指向 int 的指针，你只能将它指向 int 类型的变量。类型安全可以防止许多常见的编程错误。\",\"限制：Go 不允许指针算术。这是一个故意的设计选择，用来简化内存管理并减少与指针相关的错误。\",\"用途：普通指针常用于引用变量，以便在函数之间共享和修改数据，或者在结构体中嵌入指向其他结构体的指针。\",\"零值：未初始化的指针的零值是 nil。\"]},\"148\":{\"h\":\"8.2 unsafe 包中的 uintptr 和 Pointer\",\"t\":[\"类型不安全：unsafe 包允许你绕过 Go 的类型系统，进行任意类型的转换。这带来了更高的灵活性，但也带来了更高的风险，因为错误的类型转换可能会导致程序崩溃。\",\"uintptr指针算术：使用 unsafe 包中的 uintptr 类型，你可以对指针进行算术运算。uintptr是一个可变长的整数类型，它用于表示一个无类型的指针或将一个 unsafe.Pointer 转换成一个可以比较的整数。在32位系统上是32位的。在64位系统上是64位的。\",\"unsafe.Pointer：这是 unsafe 包中定义的一个特殊类型，可以被用来转换任何类型的指针。它提供了一种方式来暂时存储指针值，然后可能将其转换回原来的类型或不同的类型。\",\"方法是绑定在某种类型的变量上的函数\",\"某种类型不限于结构体，基本数据类型也可以\",\"变量类型不仅仅局限于结构体类型，可以是任意类型。\",\"比如：不可以直接对 int 自定义方法，但可以通过起别名来实现绑定\",\"package main import \\\"fmt\\\" // MyInt 是 int 的一个类型别名 type MyInt int // Double 是 MyInt 类型的一个方法，它返回值的两倍 func (m MyInt) Double() MyInt { return m * 2 } func main() { var a MyInt = 10 fmt.Println(a.Double()) // 输出: 20 }\"]},\"149\":{\"h\":\"9.1 自定义方法的位置\",\"t\":[\"⚠️ 必须在同一个包下：类型的定义和绑定在它上面的方法的定义可以不放置在同一个文件中，可以存在不同的源文件\",\"在 Go 中，并没有传统面向对象语言中的继承概念，但可以通过组合和接口来达到类似的效果。\",\"因为 Go 没有类这个概念，没有c++和java一样的显式继承关系，自然就不存在父类子类一说\"]},\"150\":{\"h\":\"10.1 组合实现继承\",\"t\":[\"嵌入 \\\\ 组合 差不多意思\",\"通过在一个结构体中嵌入另一个匿名结构体，可以实现类似继承的效果。\",\"内部结构体的字段和方法会被提升到外部结构体中，使得外部结构体可以直接访问这些字段和方法\",\"// Person type Person struct { Name string } func (p Person) SayHello() { fmt.Println(\\\"Hello, my name is\\\", p.Name) } // Employee type Employee struct { Title string Person // 嵌入 Person 结构体,相当于： /* type Person struct { Name string } */ } func main() { emp := Employee{ Person: Person{Name: \\\"John\\\"}, Title: \\\"Developer\\\", } emp.SayHello() // 可以直接调用内部结构体 Person 的方法 }\",\"这个“提升 ”Go 怎么实现\",\"编译器在生成代码时会进行以下操作：\",\"对于内部结构体的字段，编译器会在外部结构体中创建相同名字的字段，并且这些字段会被初始化为内部结构体的实例。\",\"对于内部结构体的方法，编译器会在外部结构体中创建同名的方法，并且将内部结构体实例作为方法的接收者。\",\"这样，外部结构体就可以直接访问内部结构体的字段和方法，而不需要通过内部结构体的实例来访问。\"]},\"151\":{\"h\":\"10.2 接口\",\"t\":[\"通过定义接口和实现接口的方式，可以实现多态的效果。 一个结构体只要实现了某个接口定义的所有方法，就被视为实现了该接口。\",\"type Shape interface { Area() float64 } type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius }\"]},\"152\":{\"h\":\"10.3 方法重写\",\"t\":[\"在 Go 中，匿名字段的方法可以被外部结构体重写，从而实现类似于继承中方法的覆盖。\",\"type Animal struct { Name string } func (a Animal) Speak() { fmt.Println(\\\"Animal speaks\\\") } type Dog struct { Animal } // 重写Animal的Speal() func (d Dog) Speak() { fmt.Println(\\\"Dog speaks\\\") }\",\"接口用来抽象一系列行为，不推荐把字段定义在接口中\",\"当某一种类型实现了所有这些声明的方法，那么就称这种类型为该接口的一种实现\"]},\"153\":{\"h\":\"11.1 接口定义\",\"t\":[\"type interfaceName interface{ methodName1([parameter_list])[return_type_list] methodName2([parameter_list])[return_type_list] methodName3([parameter_list])[return_type_list] ..... }\",\"例子： \"]},\"154\":{\"h\":\"11.2 实现多个接口\",\"t\":[\"在 Go 中，一个类型可以实现多个接口。\",\"这种灵活性允许一个类型定义多种行为，并且可以根据需要实现不同的接口。\",\"一个简单的例子\",\"package main import \\\"fmt\\\" // 定义接口A type A interface { MethodA() } // 定义接口B type B interface { MethodB() } // 定义一个结构体，实现接口A和接口B type MyStruct struct { } // 实现接口A的方法 func (m MyStruct) MethodA() { fmt.Println(\\\"MethodA called\\\") } // 实现接口B的方法 func (m MyStruct) MethodB() { fmt.Println(\\\"MethodB called\\\") } func main() { var s MyStruct var a A var b B a = s b = s a.MethodA() // 输出: MethodA called b.MethodB() // 输出: MethodB called }\"]},\"155\":{\"h\":\"11.3 空接口\",\"t\":[\"没有任何方法声明的接口称之为空接口\",\"所有类型都实现了空接口，所以空接口可以存储任意类型的数值\",\"Goland很多库的源代码都会以空接口作为参数，表示接受任何类型的参数，fmt包下的Print系列\",\"func Println(a ...interface{})(n int, err error)\"]},\"156\":{\"h\":\"11.4 断言陷阱\",\"t\":[\"例子：不能把interface{}类型的变量i赋值给整形变量b\",\"func main(){ var a int = 1 var i interface{} = a var b int = i } // result: // cannot use i (variable of type interface{}) as int value // in variable declaration: need type assertion\"]},\"157\":{\"h\":\"11.5 断言原理\",\"t\":[\"要实现 11.4 的操作，就要用断言。（更深的理解：接口的数据结构有关。 先不展开。）\",\"类型断言接口操作：用来检查接口变量的值是否实现了某个接口，或者是否是某个具体的类型。 格式：value, ok := x.(T)， x 为接口类型，ok 为 bool 类型\",\"package main import \\\"fmt\\\" func main(){ var x interface{} x = 8 val, ok := x.(int) fmt.Printf(\\\"val is %d, ok is %t \\\\n\\\", val, ok) } //result: val is 8, ok is true\",\"⚠️注意\",\"无论 T是什么类型，如果x是nil接口值，类型断言都会失败\",\"如果ok这个返回值不接受，没问题就没问题，有问题就报panic\"]},\"158\":{\"h\":\"11.6 接口作为函数参数\",\"t\":[\"package main import \\\"fmt\\\" // 定义一个接口 type Shape interface { Area() float64 } // 定义一个函数，接受实现了 Shape 接口的类型作为参数 func PrintArea(s Shape) { fmt.Println(\\\"Area:\\\", s.Area()) } // 定义一个结构体，实现了 Shape 接口 type Circle struct { Radius float64 } // 实现 Shape 接口的方法 func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } // 定义一个结构体，实现了 Shape 接口 type Rectangle struct { Width float64 Height float64 } // 实现 Shape 接口的方法 func (r Rectangle) Area() float64 { return r.Width * r.Height } func main() { c := Circle{Radius: 3} r := Rectangle{Width: 4, Height: 5} PrintArea(c) // 输出: Area: 28.26 PrintArea(r) // 输出: Area: 20 }\"]},\"159\":{\"h\":\"11.7 接口嵌套\",\"t\":[\"一个接口中包含了其他接口，要实现外部接口，就需要实现内部嵌套的接口对应的所有方法。\",\"package main import \\\"fmt\\\" // 定义两个简单的接口 type Reader interface { Read() } type Writer interface { Write() } // 嵌套接口 type ReadWriter interface { Reader Writer } // 实现接口 type MyStruct struct { } func (m MyStruct) Read() { fmt.Println(\\\"Reading data...\\\") } func (m MyStruct) Write() { fmt.Println(\\\"Writing data...\\\") } func main() { var rw ReadWriter rw = MyStruct{} rw.Read() // 输出: Reading data... rw.Write() // 输出: Writing data... }\"]},\"160\":{\"h\":\"12.1 error 接口类型\",\"t\":[\"error是 go 的一个普通的接口，并且不携带任何堆栈信息。\",\"type error interfce{ Error() string }\",\"生成一个 error 对象\",\"常用errors.New()或者 fmt.Errorf() 来返回一个error对象\",\"这两种方式返回的 error 是不可以直接进行比较的，以为errors.New()返回的其实是一个地址，不用用来做等值判断.\"]},\"161\":{\"h\":\"13.1 需要思考的 3 个问题\",\"t\":[\"defer 调用栈\",\"执行到 defer 关键字时会发生什么\",\"defer 的栈什么时机会执行，与 return 的关系\"]},\"162\":{\"h\":\"13.2 使用场景 1: 资源的释放\",\"t\":[\"延迟调用，优雅解决资源回收问题，避免遗漏资源回收。 如：网络连接、数据库连接、文件句柄的资源释放。\"]},\"163\":{\"h\":\"13.3 使用场景 2：配合 recover 处理 panic\",\"t\":[\"用panic抛出异常，用 defer + recover捕获异常\"]},\"164\":{\"h\":\"13.4 defer 的快照读\",\"t\":[\"func derferRun() { var num = 1 derfer fmt.Printf(\\\"num is %d\\\",num) num = 2 return } func main(){ derfer() } // result： num is 1\",\"为什么是 1 不是 2 ：\",\" 就算 defer 中参数是地址，也会相当于快照一样保存那个地址，但是如果地址所指向的内容被修改了，也会跟着一起变化。\"]},\"165\":{\"h\":\"14.1 return 的非原子性\",\"t\":[\"return并非一个原子操作，可被分解成以下3步：\",\"设置返回值\",\"执行defer 栈\",\"将返回值结果返回\",\"思考下面 3 个例子\",\"例子1\",\"package main import \\\"fmt\\\" func main(){ res := deferRun() fmt.Println(res) } func deferRun()(res int){ num := 1 defer func(){ res++ }() return num } // result: 2\",\"例子2\",\"package main import \\\"fmt\\\" func main(){ res := deferRun() fmt.Println(res) } func deferRun() int { num := 1 defer func(){ num++ }() return num } // result: 1\",\"例子3\",\"package main import \\\"fmt\\\" func main(){ res := deferRun() fmt.Println(res) } func deferRun() int { var num int defer func(){ num++ }() return 1 } // result: 1\"]},\"166\":{\"h\":\"15.1 painc 捕获方式\",\"t\":[\"异常：程序运行过程发生的 panic，注意 fatal 这种致命错误是会导致程序直接崩溃，无法捕获。\",\"捕获：不让程序core，在程序中加入recover机制，捕获异常，打印\",\"例子\",\"20240424173111\",\"注意\",\"有了recover之后，程序不会在panic出中断，在执行完panic之后，接下来会执行defer函数，但是当前函数panic后面的代码不会被执行，但是调用该函数的代码可以接着执行(理解panic的传递)。\"]},\"167\":{\"h\":\"15.2 panic的传递\",\"t\":[\"当一个函数发生panic后当前函数体的剩余代码不再执行\",\"若在当前的函数体没有recover，该panic会一直向外层传递，往外传递 panic 过程中也不会执行上层的剩余代码，直到某层被recover后，该层剩下的代码才会恢复执行。\",\"如果一直到主函数，迟迟没有recover，main就会终止。\",\"如果在过程中遇到了最近的recover，就会被捕获，捕获后当前函数体的剩余代码不再执行，但是再上一层的还可以可以继续执行\",\"例子\",\"解析\",\"func 调用链：main --> testpanic1 --> testpanic2 --> testpanic3panic 传递链：testpanic3 --> testpanic2 --> revocer() --> painc 传递结束。\",\"在 testpanic3 中发现了一个 panic，由于 testpanic3 没有 recover，panic 向上传递。\",\"在 testpanic2 中找到了 recover，panic 被捕获了，程序接着运行。\",\"由于 testpanic3 发生了 panic，所以不再继续运行，函数跳出返回到 testpanic2。\",\"testpanic2 也不会再继续执行，跳出函数 testpanic2。\",\"到了 testpanic1 接着运行。\",\"所以 recover 和 panic 可以总结为以下 2 点：\",\"recover 只能恢复当前函数级或以当前函数为首的调用链中的函数中的 panic，恢复后调用当数结束，但是调用此函数的函数继续执行。\",\"函数发生了 panic 之后会 一直向上传递，如果直至 main 函数都没有 recover，程序将终止，如果是碰见了 recover，将被 recover 捕获。\"]},\"168\":{\"c\":[\"vscode\"]},\"169\":{\"c\":[\"插件\",\"vscode 配置\"]},\"170\":{\"h\":\"Json包的使用\",\"t\":[\"json包的用法\"]},\"171\":{\"h\":\"json.Marshal（序列化）与json.Unmarshal（反序列化）的基本用法。\",\"t\":[\"type Person struct { Name string Age int64 Weight float64 } func main() { p1 := Person{ Name: \\\"小明\\\", Age: 18, Weight: 71.5, } // struct -> json string b, err := json.Marshal(p1) if err != nil { fmt.Printf(\\\"json.Marshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) // json string -> struct var p2 Person err = json.Unmarshal(b, &p2) if err != nil { fmt.Printf(\\\"json.Unmarshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"p2:%#v\\\\n\\\", p2) }\",\"输出：\",\"str:{\\\"Name\\\":\\\"小明\\\",\\\"Age\\\":18,\\\"Weight\\\":71.5} p2:main.Person{Name:\\\"小明\\\", Age:18, Weight:71.5}\"]},\"172\":{\"h\":\"结构体tag介绍\",\"t\":[\"Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：\",\"`key1:\\\"value1\\\" key2:\\\"value2\\\"`\",\"总结：\",\"结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。\",\"同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。\"]},\"173\":{\"h\":\"使用json tag指定字段名\",\"t\":[\"序列化与反序列化默认情况下使用结构体的字段名，我们可以通过给结构体字段添加tag来指定json序列化生成的字段名。\",\"// 使用json tag指定序列化与反序列化时的行为 type Person struct { Name string `json:\\\"name\\\"` // 指定json序列化/反序列化时使用小写name Age int64 Weight float64 }\"]},\"174\":{\"h\":\"忽略某个字段\",\"t\":[\"如果你想在json序列化/反序列化的时候忽略掉结构体中的某个字段，可以按如下方式在tag中添加-。\",\"// 使用json tag指定json序列化与反序列化时的行为 type Person struct { Name string `json:\\\"name\\\"` // 指定json序列化/反序列化时使用小写name Age int64 Weight float64 `json:\\\"-\\\"` // 指定json序列化/反序列化时忽略此字段 }\"]},\"175\":{\"h\":\"忽略空值字段\",\"t\":[\"当 struct 中的字段没有值时， json.Marshal() 序列化的时候不会忽略这些字段，而是默认输出字段的类型零值（例如int和float类型零值是 0，string类型零值是\\\"\\\"，对象类型零值是 nil）。 如果想要在序列化时忽略这些没有值的字段时，可以在对应字段添加omitempty tag。 举个例子：\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email\\\"` Hobby []string `json:\\\"hobby\\\"` } func omitemptyDemo() { u1 := User{ Name: \\\"小明\\\", } // struct -> json string b, err := json.Marshal(u1) if err != nil { fmt.Printf(\\\"json.Marshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) }\",\"输出结果：\",\"str:{\\\"name\\\":\\\"小明\\\",\\\"email\\\":\\\"\\\",\\\"hobby\\\":null}\"]},\"176\":{\"h\":\"如果想要在最终的序列化结果中去掉空值字段，可以像下面这样定义结构体：使用omitempty\",\"t\":[\"// 在tag中添加omitempty忽略空值 // 注意这里 hobby,omitempty 合起来是json tag值，中间用英文逗号分隔 type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` }\",\"此时，再执行上述的omitemptyDemo，输出结果如下：\",\"str:{\\\"name\\\":\\\"小明\\\"} // 序列化结果中没有email和hobby字段\",\"说句题外话，我们使用gorm操作数据库的话，经常会遇到想忽略指定字段修改的问题，比如结构体中的关联实体，只想json展示，form提交时忽略实体，这个问题请关注我的Go语言学习专栏吧。\"]},\"177\":{\"h\":\"忽略嵌套结构体空值字段\",\"t\":[\"首先来看几种结构体嵌套的示例：\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` Profile } type Profile struct { Website string `json:\\\"site\\\"` Slogan string `json:\\\"slogan\\\"` } func nestedStructDemo() { u1 := User{ Name: \\\"小明\\\", Hobby: []string{\\\"足球\\\", \\\"篮球\\\"}, } b, err := json.Marshal(u1) if err != nil { fmt.Printf(\\\"json.Marshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) }\",\"匿名嵌套Profile时序列化后的json串为单层的：\",\"str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"蓝球\\\"],\\\"site\\\":\\\"\\\",\\\"slogan\\\":\\\"\\\"}\",\"想要变成嵌套的json串，需要改为具名嵌套或定义字段tag：\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` Profile `json:\\\"profile\\\"` } // str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"篮球\\\"],\\\"profile\\\":{\\\"site\\\":\\\"\\\",\\\"slogan\\\":\\\"\\\"}}\",\"想要在嵌套的结构体为空值时，忽略该字段，仅添加omitempty是不够的\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` Profile `json:\\\"profile,omitempty\\\"` } // str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"篮球\\\"],\\\"profile\\\":{\\\"site\\\":\\\"\\\",\\\"slogan\\\":\\\"\\\"}}\",\"还需要使用嵌套的结构体指针\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` *Profile `json:\\\"profile,omitempty\\\"` //这里是重点 } // str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"篮球\\\"]}\"]},\"178\":{\"h\":\"不修改原结构体忽略空值字段\",\"t\":[\"我们需要json序列化User，但是不想把密码也序列化，又不想修改User结构体，这个时候我们就可以使用创建另外一个结构体PublicUser匿名嵌套原User，同时指定Password字段为匿名结构体指针类型，并添加omitemptytag，示例代码如下：\",\"type User struct { Name string `json:\\\"name\\\"` Password string `json:\\\"password\\\"` } type PublicUser struct { *User // 匿名嵌套 Password *struct{} `json:\\\"password,omitempty\\\"` } func omitPasswordDemo() { u1 := User{ Name: \\\"小明\\\", Password: \\\"123456\\\", } b, err := json.Marshal(PublicUser{User: &u1}) if err != nil { fmt.Printf(\\\"json.Marshal u1 failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) // str:{\\\"name\\\":\\\"小明\\\"} }\"]},\"179\":{\"h\":\"优雅处理字符串格式的数字\",\"t\":[\"有时候，前端在传递来的json数据中可能会使用字符串类型的数字，这个时候可以在结构体tag中添加string来告诉json包从字符串中解析相应字段的数据：\",\"type Card struct { ID int64 `json:\\\"id,string\\\"` // 添加string tag Score float64 `json:\\\"score,string\\\"` // 添加string tag } func intAndStringDemo() { jsonStr1 := `{\\\"id\\\": \\\"1234567\\\",\\\"score\\\": \\\"88.50\\\"}` var c1 Card if err := json.Unmarshal([]byte(jsonStr1), &c1); err != nil { fmt.Printf(\\\"json.Unmarsha jsonStr1 failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"c1:%#v\\\\n\\\", c1) // c1:main.Card{ID:1234567, Score:88.5} }\"]},\"180\":{\"c\":[\"Go\"]},\"181\":{\"c\":[\"Go库\"]},\"182\":{\"h\":\"SyncMap包的源码学习\",\"t\":[\"syncmap 源码学习\"]},\"183\":{\"h\":\"一、map 与 sync.Map\",\"t\":[\"map 不支持并发的读写操作，否则会出现 fatal error 导致程序直接被终止。无法用 defer + recover 捕获。\",\"Go 官方提供了一个并发安全的 sync.Map。\"]},\"184\":{\"h\":\"1. 模拟 map 的并发读写 fatal\",\"t\":[\"报错：fatal\",\"package main func main() { // 初始化一个 map m := make(map[int]int) // 并发写操作 go func() { for i := 0; i < 1000000; i++ { m[i] = i } }() // 并发读操作 go func() { for i := 0; i < 1000000; i++ { _ = m[i] } }() // 阻塞主线程 select {} } result：fatal error: concurrent map read and map write\"]},\"185\":{\"h\":\"2. 盲点：加上打印却可以避免 fatal\",\"t\":[\"给每个协程加上一行打印语句，fatal 就不会发生：\",\"package main import \\\"fmt\\\" func main() { // 初始化一个 map m := make(map[int]int) // 并发写操作 go func() { for i := 0; i < 1000000; i++ { m[i] = i fmt.Println(\\\"写:\\\", m[i]) } }() // 并发读操作 go func() { for i := 0; i < 1000000; i++ { _ = m[i] fmt.Println(\\\"读:\\\", m[i]) } }() // 阻塞主线程 select {} }\",\"原因：fmt.Println 内部使用了锁\",\"每次调用 fmt.Println 时，它会获取一个锁，以确保多个 goroutine 并发调用 fmt.Println 时，输出不会混乱。\",\"这种锁机制会导致其他 goroutine 在等待锁释放时被阻塞，从而改变 goroutine 的执行顺序。从而在某些情况下掩盖数据竞争的问题。\"]},\"186\":{\"h\":\"二、sync.Map 简介\",\"t\":[\"sync.Map 是 Go 官方提供的一个并发安全的一个 Map\",\"它本质是采用空间换时间的思想，使用两个 map(read map 和 dirty map)，这两个 map 互相配合来提供一个拥有并发读写能力，并且会权衡整体操作性能的并发安全 map。\",\"readmap 通过无锁的 cas 操作揽下大部分操作，减少 dirtymap 锁的使用。\",\"请求流程：\",\"当请求访问 sync.map，会让请求在 readmap 上解决，如果无法解决再交给 dirtymap 来兜底完成。\",\"dirtymap 会拥有全量的数据，因为它有兜底完成 readmap 无法处理的请求的责任。\",\"写指的是新增数据，更新指的是更新已有数据。\",\"对于 读、删、更新 会尽量在 readmap 中处理，实在处理不了再去拿锁，找 dirtymap 处理。\",\"对于 写 会通过锁找到 dirtymap 处理。\",\"readmap 是通过无锁的 cas 去完成对变量的操作，而 dirtymap 是通过加锁来做了限流保护的。\",\"关于 entry：\",\"最下面的 entry 被 read 和 dirty 同时指向，代表的是：两个 map 中相同的 key 对应同一块 value 内存，而 value 就是 sync.map 的 entry。这里会涉及到数据的双向流转机制，后面会解读。\"]},\"187\":{\"h\":\"三、sync.map 的使用\"},\"188\":{\"h\":\"1. 基本的 crud\",\"t\":[\"// 添加元素 m.Store(\\\"key1\\\", \\\"value1\\\") m.Store(\\\"key2\\\", \\\"value2\\\") // 更新元素 m.Store(\\\"key1\\\", \\\"newValue1\\\") // 查询元素 if value, ok := m.Load(\\\"key1\\\"); ok { fmt.Println(\\\"key1:\\\", value) } else { fmt.Println(\\\"key1 not found\\\") } // 删除元素 m.Delete(\\\"key2\\\") // 遍历所有元素 m.Range(func(key, value interface{}) bool { fmt.Printf(\\\"%s: %s\\\\n\\\", key, value) return true })\"]},\"189\":{\"h\":\"2. 验证并发安全\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) func main() { var m sync.Map var wg sync.WaitGroup // 启动多个并发写操作 for i := 0; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() for j := 0; j < 1000; j++ { key := fmt.Sprintf(\\\"key-%d-%d\\\", i, j) m.Store(key, j) } }(i) } // 启动多个并发读操作 for i := 0; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() for j := 0; j < 1000; j++ { key := fmt.Sprintf(\\\"key-%d-%d\\\", i, j) if value, ok := m.Load(key); ok { fmt.Printf(\\\"Read key: %s, value: %d\\\\n\\\", key, value) } } }(i) } // 启动多个并发删除操作 for i := 0; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() for j := 0; j < 1000; j++ { key := fmt.Sprintf(\\\"key-%d-%d\\\", i, j) m.Delete(key) } }(i) } // 启动一个 goroutine 遍历所有元素 wg.Add(1) go func() { defer wg.Done() time.Sleep(1 * time.Second) // 等待部分写操作完成 m.Range(func(key, value interface{}) bool { fmt.Printf(\\\"Range key: %s, value: %d\\\\n\\\", key, value) return true }) }() // 等待所有 goroutine 完成 wg.Wait() fmt.Println(\\\"All operations completed.\\\") }\"]},\"190\":{\"h\":\"四、sync.map 的结构\",\"t\":[\"关注这三个结构体：\",\"Map： sync.map 的顶层封装\",\"readOnly： readmap 的封装，里面有一个 amended 字段，true 就是标记 有数据在 read 没有，而 dirty 有。\",\"Entry： 就是 value 的封装\",\"//******************************************************************************** type Map struct { // 互斥锁，保护对映射数据的并发访问 mu Mutex // read map： 用cas操作，无锁 read atomic.Pointer[readOnly] // dirty map：需要配合互斥锁使用 dirty map[any]*entry // misses 记录有多少次请求打到了 dirty 去处理 // 当 misses 的次数足够多时，dirty map将被提升为 read map misses int } //******************************************************************************** type readOnly struct { // read map 存放 k-v的实体，底层还是使用的 map m map[any]*entry // 标记 是否数据缺失 // 即 dirtymap 有，readmap没有的 key，此时 amended 为 true amended bool } //******************************************************************************** type entry struct { // p 字段是一个原子指针，使用 atomic.Pointer[any] 类型，用于存储条目的值。 // 这个指针可以安全地在不同的 goroutine 之间共享和访问，并且支持原子性的读写操作。 p atomic.Pointer[any] }\"]},\"191\":{\"h\":\"五、两个 map 的数据双向流转机制\"},\"192\":{\"h\":\"1. Dirty map --> Read map\",\"t\":[\"read 可以为 dirty 尽量的挡住 读、删、更新的操作流量，但是如果 read 很多次没有挡住请求，让这些请求到了 dirty 中，就意味着：\",\"这个流转的可以理解为：将 readmap 指针指向 dirtymap，然后 dirtymap 置为 nil。\"]},\"193\":{\"h\":\"2. Read map --> Dirty map\",\"t\":[\"从上面可以知道 Dirty map --> Read map 后，dirty 是 nil。\",\"如果这时候来了一个写（新增）请求，写请求是要通过加锁到 dirty 中操作的，dirty 需要保证自己的数据是全量的，就会从 readmap 中复制一份逻辑上存在（能通过 key 查询到的）的数据过来。\"]},\"194\":{\"h\":\"3. 为什么要双向流转\",\"t\":[\"为什么要把数据集当成皮球一样踢来踢去呢？\",\"dirty 把数据全给 read ，为什么自己要置为 nil?\",\"数据隔离： 如果 dirty 不重置为 nil，就会出现 dirty 和 read 使用同一个底层 map。这样就无法做到数据隔离的。go 语言希望 read map 和 dirty map 依赖的是不同的 map，但 entry 是可以共享的。\",\"dirty 能不能 copy 一份全量数据给 read，不把自己置 nil?\",\"并发冲突：在复制的过程中，整个 sync.Map 将会处于一种不稳定的状态。如果在这个过程中有并发访问，可能会导致数据不一致或崩溃。\",\"性能问题：复制大数据量的 dirty 到 read 是一个耗时的操作，会降低性能。直接切换引用可以避免这些性能问题。\"]},\"195\":{\"h\":\"六、Enrty 的状态解读\",\"t\":[\"首先 Entry 是 value 的实体。\"]},\"196\":{\"h\":\"1. entry 的结构\",\"t\":[\"type entry struct { // p 字段是一个原子指针，使用 atomic.Pointer[any] 类型，用于存储条目的值。 // 这个指针可以安全地在不同的 goroutine 之间共享和访问，并且支持原子性的读写操作。 p atomic.Pointer[any] }\"]},\"197\":{\"h\":\"2. entry 的三个状态\",\"t\":[\"**正常值：**正常的 k-v 实体，数据存在。\",\"nil 状态：表示软删除状态，代表 k-v 数据在逻辑上不存在（不能通过 k 获取到 v），但是在内存仍然存在这个 key。\",\"**expunged 状态：**表示硬删除状态，代表逻辑和内存里都不存在这个 k 和 v\",\"画个图理解一下：\"]},\"198\":{\"h\":\"3. Nil 状态\",\"t\":[\"先说结论：\",\"nil 状态是为了优化 “对用一个 key 先删后写的场景优化”，让这个 key 能直接在 readmap 中无锁完成写，不需要加锁到 dirty 中操作。\",\"可以说是让原本的 去 dirty 中加锁写 --> cas 无锁更新\",\"同时 read 是可以挡住删除的流量的，通过 cas 操作在 readmap 中将 key 的值变成 nil，表示当前 key 在逻辑上已经删除了。\",\"现在来模拟一下读、写两个操作：\",\"读：读到 key 的值为 nil，直接返回 nil，读不到，用户可以认为改 key 被删除了。\",\"写：当 key 存在，但是值为 nil，代表 key 在 read 和 dirty 都存着，可以再次通过 cas 操作，将 nil 改为对于的 value 值，完成了更新操作，避免了加锁访问 dirty。\"]},\"199\":{\"h\":\"4. Expunged 状态\",\"t\":[\"在 Read map --> Dirty map 过程中，read 只会将逻辑上存在的数据 copy 给 dirty。\",\"那么问题是：\",\"read 中 nil 的数据，不会 copy 给 dirty，也就是会导致两个 map 的数据不一致。在下一次更新/写操作到来，在 read 层就读到了该 key 为 nil 值，但是 dirty 中是没有这个 key 的。\",\"这个时候就需要在 copy 完之后，将原本为 nil 的 key 设置为 expunged。表示硬删除\",\"简而言之： expunged 状态是由 nil 状态 流转来的，在发生 Read map --> Dirty map 过程后，需要把 readmap 的 nil 状态 修改为 expunged\"]},\"200\":{\"h\":\"七、回顾 sync.Map 的底层原理\",\"t\":[\"空间换时间： read map 尽量用 cas 操作无锁完成 读、删、更新 的操作，dirty map 加锁完成写操作。\",\"数据的双向流转： read <-----> dirty\",\"Entry 的nil 和 expunged状态设计： 优化的先删后写场景和无锁完成删操作。\"]},\"201\":{\"h\":\"八、sync.Map 的不足\",\"t\":[\"不适合多写的场景，当写多的时候 sync.Map 就相当于 map + Mutex 性能没那么好。\",\"sync.Map 存在 read ----> dirty 的数据流转过程，这是一个线性时间复杂度 O(n)的过程，当 k-v 数量较多的时候，容易导致程序性能抖动。比如需要访问 sync.Map 拿锁去操作的协程需要一直等待这个线性时间复杂度的过程完成。\"]},\"202\":{\"h\":\"九、sync.Map 源码走读\"},\"203\":{\"h\":\"1. Load() - 读\",\"t\":[\"// Load 方法根据 key 加载相应的 value，如果 key 存在且value有效，返回存储的值和一个布尔值，表示查找成功。 func (m *Map) Load(key any) (value any, ok bool) { // 首先读取 readOnly 结构体，加载 read map read := m.loadReadOnly() // 尝试从 read 中获取 k-v e, ok := read.m[key] // 若 read 中没有，并且 read 的数据不全，加锁访问 dirty 获取 if !ok && read.amended { // 加锁以操作 dirty m.mu.Lock() // double_check：检查自上次加载 read 以来，dirty 字段是否已经被提升为 read。 // 目的是避免有其他 goroutine 更新了 read。 dirtymap -----> readmap read = m.loadReadOnly() // 再次尝试从 read中获取 k-v e, ok = read.m[key] // 若 read 中没有，并且 read 的数据不全，到 dirty 获取 if !ok && read.amended { // 若在 dirty 字段中找到条目 e, ok = m.dirty[key] // 记录一次 miss，这将加速提升 dirty 到 read 的过程，相当于dirty的压力++ m.missLocked() } // 操作结束，解锁 m.mu.Unlock() } // 若连 dirty 中都没有 if !ok { // 返回 nil 和 false return nil, false } // 若找到 k-v，调用其 load 方法得到 v return e.load() }\"]},\"204\":{\"h\":\"2. missLocked() - missssss\",\"t\":[\"包含：自增 miss，判断是否将 dirty 晋升\",\"// missLocked 处理 read 未命中的情况 func (m *Map) missLocked() { // 每次未命中时增加 misses 计数 m.misses++ // 如果 misses 计数小于脏数据的数量，则不需要采取进一步的操作 if m.misses < len(m.dirty) { return } // 发生数据流转： dirty -----> read // 创建一个新的只读缓存，并将 misses 计数重置为 0 m.read.Store(&readOnly{m: m.dirty}) m.dirty = nil m.misses = 0 }\"]},\"205\":{\"h\":\"3. Store() - 写\",\"t\":[\"// Store 整合了写和更新操作，底层调用 Swap() func (m *Map) Store(key, value any) { _, _ = m.Swap(key, value) } func (m *Map) Swap(key, value any) (previous any, loaded bool) { // 加载 read read := m.loadReadOnly() // 如果 key 已经存在于 read 中，尝试在 read 中更新 key if e, ok := read.m[key]; ok { // 尝试用 cas在 read 更新 key，避免加锁访问 dirty if v, ok := e.trySwap(&value); ok { if v == nil { // 返回 nil 和 false，表示没有加载任何值 return nil, false } // 返回旧值和 true，表示已经加载 return *v, true } } // 加锁操作 dirty m.mu.Lock() // double_check read = m.loadReadOnly() // 如果key存在于read中 if e, ok := read.m[key]; ok { // 将 key 修改为非 expunged 状态 ----> nil if e.unexpungeLocked() { //entry是共享的，expunged状态下的entry，只有read有它的指针，这一步就是让dirty也能有这个key和entry。 //同时unexpungeLocked() 就是通过cas将expunged态的entry变成nil态，这就代表read和dirty都有个nil的entry。 //上面的两个过程一起完成这个enrty“复活”，以便后面完成真正的更新操作 m.dirty[key] = e } // cas交换值 if v := e.swapLocked(&value); v!= nil { // 设置加载标志为 true，表示加载了新值 loaded = true previous = *v } // 如果 k 不存在于 read 中，但存在于 dirty 中 } else if e, ok := m.dirty[key]; ok { // cas交换值 if v := e.swapLocked(&value); v!= nil { // 设置加载标志为 true，表示加载了新值 loaded = true previous = *v // 如果 k 既不存在于 raed 中，也不存在于 dirty 中 } else { // 如果 dirty 未被修改 if!read.amended { // 为 dirty 分配空间并标记 read 为不完整 m.dirtyLocked() m.read.Store(&readOnly{m: read.m, amended: true}) } // 将新的 kv 对添加到 dirty 中 m.dirty[key] = newEntry(value) } // 释放互斥锁 m.mu.Unlock() // 返回 return previous, loaded } func (e *entry) trySwap(i *any) (*any, bool) { // 无限循环，直到交换成功或者entry被移除。 for { // 加载当前 entry 指针。 p := e.p.Load() // 如果entry被移除（指针为 expunged，代表硬删除），则返回 nil 和 false。 if p == expunged { return nil, false } // 尝试使用原子操作 CompareAndSwap 将新值交换到 entry。 if e.p.CompareAndSwap(p, i) { // 如果操作成功，返回 p 和 true。 return p, true } } }\"]},\"206\":{\"h\":\"4. Range() - 读\",\"t\":[\"注意：\",\"Range 方法不保证遍历期间 map 内容的一致性。Range 方法不会阻塞其他方法的执行。\",\"遍历期间，键不会被重复访问，但键的值可能会因为并发操作而发生变化。\",\"func (m *Map) Range(f func(key, value any) bool) { read := m.loadReadOnly() if read.amended { m.mu.Lock() read = m.loadReadOnly() if read.amended { read = readOnly{m: m.dirty} m.read.Store(&read) m.dirty = nil m.misses = 0 } m.mu.Unlock() } for k, e := range read.m { v, ok := e.load() if !ok { continue } if !f(k, v) { break } } }\"]},\"207\":{\"c\":[\"Go\"]},\"208\":{\"c\":[\"syncMap\"]},\"209\":{\"h\":\"MySQL日志系统\",\"t\":[\"从理解 SQL 执行过程到理解MySQL 日志系统的工作过程。\"]},\"210\":{\"h\":\"一、 一条 select 语句的执行过程\",\"t\":[\"一条查询语句执行的过程，属于读一条记录的过程，大致可以分为以下几个步骤：\",\"建立客户端/服务器通信：\",\"客户端发起的连接请求，通过MySQL连接器处理后，客户端将SQL查询语句发送到服务器。\",\"查询解析：\",\"SQL解析器：SQL解析器首先会对查询语句进行语法和词法分析，生成一个解析树（Parse Tree）。\",\"预处理器：预处理器进一步检查解析树的合法性，包括表和列是否存在、名称是否正确等。\",\"查询优化：\",\"查询重写：优化器可能会对解析树进行重写，例如将子查询转换为连接（JOIN），或者进行某些常见的SQL重写优化。\",\"选择执行计划：优化器会生成多个执行计划，并选择其中的最优计划。这里会考虑索引的使用、表扫描的方式（全表扫描或索引扫描）等。\",\"成本估算：MySQL使用一种基于成本的优化算法，通过估算不同执行计划的代价，选择成本最低的计划。\",\"查询执行：\",\"存储引擎接口：MySQL的执行器根据优化器选择的执行计划，通过存储引擎接口调用具体的存储引擎（如InnoDB、MyISAM等）。\",\"存储引擎操作：存储引擎根据执行器的请求进行数据的读取、写入等操作。\",\"结果返回：\",\"结果集处理：执行器将存储引擎返回的数据进行处理，生成最终的结果集。\",\"结果发送：最终的结果集通过网络传输返回给客户端。\",\"缓存处理（可选）：\",\"查询缓存：如果查询缓存开启且命中缓存，MySQL会直接从缓存中返回结果，而不经过上述大部分步骤。需要注意的是，MySQL 8.0 版本已移除查询缓存这一特性。\",\"总结来说，MySQL一条查询语句的执行过程可以概括为：客户端发送SQL语句 -> 解析语句 -> 优化查询 -> 执行查询 -> 返回结果。每个步骤中都有许多细节和优化点，使得MySQL能够高效地处理各种查询请求。\",\"引用小林图解的一张图： \"]},\"211\":{\"h\":\"二、一条 update 语句的执行过程\",\"t\":[\"比如这条待执行的 update 语句：UPDATE t_user SET name = 'kryiea' WHERE id = 10086;\",\"待执行的语句执行过程：\",\"select 语句的那一套流程，update 语句也是同样会走一遍\",\"查询到目标记录后，执行更新操作的同时会涉及对三种日志的改动，undolog、redolog、binlog。\"]},\"212\":{\"h\":\"三、三种日志、MVCC、BufferPool 之间的相互配合\"},\"213\":{\"h\":\"3.1 三种日志的主要作用\",\"t\":[\"UndoLog 回滚日志： 是Innodb存储引擎层生成的日志，保证了事务中的原子性，主要用于事务回滚和MVCC。（撤销已经执行的修改，保证事务的原子性和一致性）\",\"RedoLog 重做日志： 是Innodb存储引擎层生成的日志，保证了事务中的持久性，主要用于掉电等故障恢复。（重做已经提交的修改，保证事务的持久性）\",\"BinLog 归档日志： 是 Server层 生成的日志，主要用于数据备份和主从复制。（记录和重放SQL语句，用于数据的复制和恢复）\",\"⬇️辅助理解： InnoDB 存储引擎的日志：\",\"UndoLog 记录了此次事务 开始前 的数据状态，记录的是 更新 之前 的值；\",\"RedoLog 记录了此次事务 完成后 的数据状态，记录的是 更新 之后 的值；\",\"Server 层的日志：\",\"BinLog 记录了完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog文件。\"]},\"214\":{\"h\":\"3.2 UndoLog 回滚日志\"},\"215\":{\"h\":\"3.2.1 为什么需要 UndoLog\",\"t\":[\"先了解隐式事务： Innodb 引擎在执行一条增删改语句的时候，即使没有显式输入begin开启事务和commit提交事务，也会自动隐式开启事务。 而且执行一条 update 语句是否自动提交事务，是由 autocommit 参数决定，默认开启。\",\"试想以下场景： 在一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？\",\"如何解决： 如果每次在事务执行过程中，都记录下回滚时需要的信息到一个日志（undolog）里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。\"]},\"216\":{\"h\":\"3.2.2 认识 Undolog 机制\",\"t\":[\"在事务没提交之前，MySQL 会先记录更新前的数据到 undolog日志文件，当事务需要回滚时，可以利用 undolog 来进行回滚。\",\"过程如下图: \"]},\"217\":{\"h\":\"3.2.3 Undolog 如何记录和回滚\",\"t\":[\"每当 InnoDB 引擎对一条记录进行操作时，要把回滚时需要的信息都记录到 undolog 里，比如：\",\"在 插入 一条记录时，要把这条记录的主键值记下来，这样回滚时只需要把这个主键值对应的记录 delete 就好了；\",\"在 删除 一条记录时，要把这条记录中的内容都记下来，这样回滚时再把由这些内容组成的记录 insert 到表中就好了；\",\"在 更新 一条记录时，要把被更新的列的旧值记下来，这样回滚时再把这些列 update 为旧值就好了。\"]},\"218\":{\"h\":\"3.2.4 Undolog 日志的格式\",\"t\":[\"需要了解一条记录在innodb引擎中的存储格式。\",\"一条记录的每一次更新操作产生的 undolog 中，都有一个 roll_pointer 指针和一个 trx_id 事务id：\",\"通过 trx_id 可以知道该记录是被哪个事务修改的。\",\"通过 roll_pointer 指针可以将这些 undolog 串成一个链表，这个链表就被称为版本链。\",\"版本链如下图：\"]},\"219\":{\"h\":\"3.2.5 Undolog + ReadView 实现 MVCC\",\"t\":[\"MVCC - Multi-version concurrency control 多版本并发控制（MVCC）是一种数据库管理技术，通过维护数据的多个版本来实现并发访问，从而提高读写操作的性能和一致性。\",\"并发访问的多个版本通过快照控制： 对于读提交和可重复读隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 ReadView + undolog 来实现的。 读提交 和 可重复读 的 快照读 区别在于创建 ReadView 的时机不同：\",\"读提交隔离级别：每次执行 select 都会生成一个新的 ReadView，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\",\"可重复读隔离级别：在启动事务时生成一个 ReadView，然后整个事务期间都在用这个 ReadView，这样就保证了在事务期间读到的数据都是事务启动前的记录。\",\"如何知道版本的可见性，参考 3.2.6 ： 通过 事务的 ReadView 里的字段 和 记录中的两个隐藏列 trx_id 和 roll_pointer 的比对，如果不满足可见行，就会顺着 undolog 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）\"]},\"220\":{\"h\":\"3.2.6 ReadView 机制\",\"t\":[\"ReadView 的四个字段： ReadView 可以理解为记录当前事务id创建时，整个数据库还有哪些其他活着的事务，记录下来，以便于判断数据的可见性。\",\"creator_trx_id：代表创建当前这个 ReadView 的事务ID。\",\"m_ids：表示在生成当前 ReadView 时，系统内活跃且未提交的事务ID列表。\",\"min_trx_id：活跃的事务列表中最小的事务ID。\",\"max_trx_id：表示在生成当前 ReadView 时，系统中要给下一个事务分配的ID值\",\"如何判断可见性： 判定方法：事务 readview 里的字段 与 记录中的两个隐藏列 进行对比：\",\"如果事务ReadView 中的 min_trx_id 值>=记录的 trx_id 值，表示这个版本的记录是在创建 ReadView 前 已经提交的事务生成的，所以该版本的记录对当前事务 可见 。\",\"如果事务ReadView 中的 max_trx_id 值<=记录的 trx_id 值，表示这个版本的记录是在创建 ReadView 后 才启动的事务生成的，所以该版本的记录对当前事务 不可见 。\",\"如果 事务ReadView 中的 min_trx_id<记录的 trx_id 值<事务ReadView 中的 max_trx_id，需要判断 trx_id 是否在 m_ids 列表中： \",\"如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务 不可见 。\",\"如果记录的 trx_id 不在 m_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务 可见 。\"]},\"221\":{\"h\":\"3.2.7 UndoLog 如何刷盘的\",\"t\":[\"Undolog 和 数据页 的刷盘策略是一样的，都需要通过 Redolog 保证持久化。\",\"Buffer pool 中有 Undo 页，对 Undo 页的修改也都会记录到 Redolog。\",\"Redolog 会每秒刷盘，提交事务时也会刷盘，数据页和 Undo 页都是靠这个机制保证持久化的。\"]},\"222\":{\"h\":\"3.3 Buffer Pool 缓冲池\"},\"223\":{\"h\":\"3.3.1 Buffer Pool 的意义\",\"t\":[\"场景： MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。\",\"那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢： 这也是 Buffer Pool 的意义。 当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。\",\"有了Buffer Pool后：\",\"当读取数据时，如果数据存在于 BufferPool 中，客户端就会直接读取 BufferPool 中的数据，否则再去磁盘中读取。\",\"当修改数据时，如果数据存在于 Buffe Pool 中，那直接修改 BufferPool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。\",\"Buffer Pool 属于哪一层： 属于：Innodb引擎层。 区别：不是本文开头讨论 select 语句执行过程中提到的缓存，那个是在 server 层的。\"]},\"224\":{\"h\":\"3.3.2 Buffer Pool 缓存什么\",\"t\":[\"InnoDB中磁盘与内存的交互基本单位： InnoDB 会把存储的数据划分为若干个页，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，BufferPool 同样需要按页来划分，使用与存储引擎一样的基本单位。\",\"在 MySQL 启动的时候： InnoDB 会为 BufferPool 申请一片连续的内存空间，然后按照默认的 16KB 的大小划分出一个个的页， BufferPool 中的页就叫做缓存页。 此时这些缓存页都是空闲的，之后随着程序的运行，会有磁盘上的页被加载缓存到 BufferPool 中的缓存页。\",\"在 MySQL 启动完成的时候： 由于是先申请了一片连续的内存空间但没写入具体数据，所以可以观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小。 这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。\",\"BufferPool 可以缓存的数据类型：\",\"Undo 页是记录什么的 开启事务后，InnoDB 会在更新记录之前，先记录相应操作的 undolog 来保证事务的原子性。\",\"比如：如果是 update 操作，需要把被更新的列的旧值记下来，旧值作为一条 undolog，然后把这条 undolog 写入 BufferPool 中的 Undo页\",\"查询一条记录，只需要缓存一条记录吗？ 刚刚提到了 InnoDB 存储引擎以16KB大小的页作为磁盘与内存交互的基本单位，所以查询一条记录的时候，会将整个页加载进 BufferPool 中，再通过页的页目录去定位到某条具体的记录.\",\"上面提到的 页目录 是什么？ 简单来说：页目录类似于字典的目录，用于快速定位某条记录的大致位置。\",\"这个问题需要了解一个 页 内部是如何组织数据的。小林图解也有提到，这里附上一张更具体的图来辅助理解。\",\"一个页空间会被划分成许多部分，有：文件头、页头、最大最小记录、用户记录、空闲空间、文件尾等。\",\"主要关注用户记录：存储的一行行记录会被存放在这里，记录还会进一步被分成一个个组，每一个组内部都有一些数据记录。\",\"再看到左边的页目录：有一个个的槽位，其指向每一个分组内的最后一条记录。\",\"mysql-4.drawio\"]},\"225\":{\"h\":\"3.3.3 Buffer Pool 刷盘策略\",\"t\":[\"深入学习文章推荐：(十二)MySQL之内存篇：深入探寻数据库内存与Buffer Pool的奥妙！ - 竹子爱熊猫\"]},\"226\":{\"h\":\"3.4 RedoLog 重做日志\"},\"227\":{\"h\":\"3.4.1 为什么需要 Redolog\",\"t\":[\"试想以下场景： Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。\",\"解决方案： 采用 WAL (Write-Ahead Logging) 技术。\",\"MySQL 的写操作并不是立刻写到磁盘上，而是先写日志文件，然后在合适的时间再将新的记录写到磁盘上。\",\"在事务提交时，数据库系统只需确保 redolog 已经写入磁盘，而数据页可以稍后再写入。\",\"解决方案的场景： 当有一条记录需要更新的时候，InnoDB 引擎会先更新 Buffer Pool 中的数据页，同时将该页标记为脏页。然后，将本次对这个页修改后的数据状态以 redo log 的形式记录下来并写入 redo log 文件，这时更新操作就算完成了。\",\"到这里，只是完成了 redo log 文件的刷盘，但还未完成将最新的数据记录（脏的数据页）刷盘到存储表数据的文件 xxx.ibd 中。简而言之：日志文件是最新的，但数据库文件还不是最新的，还需要完成最后的 Buffer Pool --> 磁盘 操作，才能完成持久化存储。\",\"后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL 的核心思想。\",\"图示，第4步的细节参考 3.4.5：\"]},\"228\":{\"h\":\"3.4.2 认识 Redolog 机制\",\"t\":[\"redolog 是物理日志，记录了某个数据页做了什么修改\",\"如何记录这个 “修改”： 格式：AAA表空间 中的 BBB数据页 的 CCC偏移量 的地方做了 DDD的更新，每当执行一个事务就会产生这样的一条或者多条物理日志。\",\"WAL： 在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。\",\"如何保证事务的持久性： 当系统崩溃时，虽然脏页数据没有持久化，但是 redolog 已经持久化，MySQL 能在重启后根据 redolog 的日志内容，将所有数据恢复到最新的状态。\"]},\"229\":{\"h\":\"3.4.3 Redolog 与 Undolog 的配合\",\"t\":[\"配合场景： 开启事务后，InnoDB 在进行更新操作之前，首先会记录相应的 undolog。\",\"如果是更新操作，InnoDB 需要将被更新的列的旧值记下来，也就是生成一条 undolog。这个 undolog 会被写入 Buffer Pool 中的 Undo 页面。 然后在 BufferPool 中完成数据页的更新，标记该页为脏页，并且记录对于的 redolog。\",\"具体的配合过程：\",\"记录 undolog：\",\"当事务对数据库中的记录进行更新时，InnoDB 会先生成一条 undolog，记录被修改前的数据。这个操作是为了保证在事务回滚时能够恢复到原始状态。\",\"生成的 undolog 会被写入 BufferPool 中的 Undo 页面，并在内存中进行修改。\",\"记录 redolog：\",\"在内存中修改 Undo 页面后，InnoDB 还需要记录对应的 redo log。redo log 记录的是对数据页的物理修改操作，是用来在系统崩溃后进行数据恢复的。\",\"具体来说，redo log 会记录对数据页的修改操作细节，包括何时修改、修改了哪些数据等。这些信息会先写入 redolog buffer 中，并在适当的时机（例如事务提交时）刷写到磁盘上的 redo log 文件中。\",\"Redolog Buffer 与 Buffer Pool 不一样! Redolog Buffer 是 redolog 自己的缓存 具体细节往下看。\"]},\"230\":{\"h\":\"3.4.4 Redolog与数据分开写入磁盘的必要性\",\"t\":[\"能提高数据库的写性能：\",\"顺序写入：\",\"redo log 的写入是顺序写入，采用在文件尾部追加写入文件的方式，这样可以减少磁盘的寻道时间和旋转延迟，从而提高写入速度。\",\"顺序写入的性能通常比随机写入高\",\"随机写入：\",\"数据页的写入通常是随机写入。随机写入是指数据写入磁盘的不同位置，写入速度较慢。\",\"通过将数据页首先写入缓冲池（Buffer Pool），然后在适当时机批量写入磁盘，可以减少随机写入的频率和次数。\"]},\"231\":{\"h\":\"3.4.5 Redolog 的刷盘策略\",\"t\":[\"执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。 所以，redo log 也有自己的缓存 redo log buffer ，每当产生一条 redo log 时，会先写入到 redo log buffer，后续再持久化到磁盘.\",\"redo log buffer 默认大小 16 MB，可以通过 innodb_log_Buffer_size 参数动态的调整大小，增大它的大小可以让 MySQL 处理大事务时不必写入磁盘（提高了写入磁盘的阈值），进而提升写 IO 性能。\",\"redo log buffer 的持久化如下图： \"]},\"232\":{\"h\":\"3.4.6 redolog buffer 的刷盘时机：\",\"t\":[\"主要的几个刷盘时机：\",\"MySQL 正常关闭时。\",\"当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘。\",\"InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\",\"每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制）。\",\"了解一个主要参数 innodb_flush_log_at_trx_commit:\",\"innodb_flush_log_at_trx_commit = 0 每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。\",\"innodb_flush_log_at_trx_commit = 1 这是默认值。 每次事务提交时，都 将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘 ，这样可以保证 MySQL 异常重启之后数据不会丢失。\",\"innodb_flush_log_at_trx_commit = 2 每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意并不意味着写入到了磁盘 ，因为操作系统的文件系统中有个 Page Cache（Page Cache 是专门用来缓存文件数据的，所以写入 redo log文件意味着写入到了操作系统的文件缓存。\"]},\"233\":{\"h\":\"3.4.7 Redolog 日志重写\",\"t\":[\"问题背景： redolog 文件写满了/文件过大怎么办？\",\"解决方案 - 日志重写： 默认情况下，InnoDB 存储引擎有 1 个重做日志文件组 redo log Group，由 2 个 redolog 文件 组成，分别是：ib_logfile0 和 ib_logfile1。\",\"日志重写方式：循环写重做日志文件组是以 循环写 的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。 先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。\",\"图示： \"]},\"234\":{\"h\":\"3.5 BinLog 重做日志\"},\"235\":{\"h\":\"3.5.1 Binlog 的作用\",\"t\":[\"binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用，用于备份恢复、主从复制等；\",\"binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。\",\"binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。\",\"产生 binlog 的场景： MySQL 在完成一条更新操作后，Server 层会生成一条 binlog，将其写到 binlog cache（Server 层的 cache），等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写入 binlog 文件。\"]},\"236\":{\"h\":\"3.5.2 Binlog 刷盘策略\",\"t\":[\"MySQL 给每一个处理线程分配了一片内存用于缓冲 binlog，该内存叫 binlog cache。\",\"事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。\",\"关键点1： 一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。\",\"MySQL 设定一个处理线程只能同时有一个事务在执行，所以每当执行一个 begin/start transaction 的时候，就会默认提交上一个事务。\",\"关键点2： 场景：什么时候 binlog cache 会写到 binlog 文件？\",\"回答：在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空binlog cache。\",\"关键点3： 每一个线程都有自己的binlog cache，最终写入同一个Binlog文件\",\"关键点4： 场景：如关键点3所提到的 最终写入同一个Binlog文件，那这里的并发问题如何解决？\",\"回答：MySQL采用了多种机制来确保并发安全和一致性\",\"锁机制\",\"顺序写入\",\"组提交 Group Commit\",\"关键点5： 场景：写入binlog文件的过程还可以继续拆分。\",\"系统调用 write()后，会先写入内核的缓冲区 page cache，这里不涉及磁盘I/O\",\"内核再通过 fsync() 持久化到磁盘，这里涉及磁盘I/O。频繁的 fsync() 会导致磁盘的I/O 升高。\",\"20240603001559\",\"关键点6：fsync() 的频率由参数 sync_binlog 控制\",\"sync_binlog = 0 是默认值 表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘。\",\"sync_binlog = 1 表示每次提交事务都会 write，然后马上执行 fsync，最多丢失一个事务的 binlog。\",\"sync_binlog > 1 表示每次提交事务都 write，但累积 N 个事务后才 fsync。\"]},\"237\":{\"h\":\"3.5.3 Binlog - 主从同步模型\",\"t\":[\"主从同步过程：\",\"写入 binlog： 主库修改数据后，写入 binlog 日志，提交事务，更新本地存储的数据。\",\"同步 binlog： 从库连接到主库后，主库会创建一个 dump 线程，把 binlog 同步到所有从库，每个从库把 binlog 写到暂存日志中。\",\"回放 binlog： 从库启动一个 sql 线程去回放 binlog，去读 relay log 中继日志然后回放 binlog 更新数据。 \",\"三种主从同步模式： MySQL 默认的同步模式：异步模式\",\"同步模式： 主库提交事务的线程要等待所有从库的同步成功，才返回客户端结果。性能最差了。\",\"异步模式： 主库提交事务的线程不会等待 binlog 同步完成就返回客户端结果，性能最好，但是主库宕机，数据就会丢失。\",\"半同步模式： 比如一主二从的集群，只要成功同步到一个从库，就立即返回数据给客户端。即使主库宕机，仍有一个从库有最新数据。\"]},\"238\":{\"h\":\"3.6 两阶段提交\"},\"239\":{\"h\":\"3.6.1 两阶段提交的提出\",\"t\":[\"思考以下问题： 事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。\",\"问题的场景复现：\",\"原数据：表名 t_user，某行记录 id = 1；name = jay 执行SQL：UPDATE t_user SET name = 'kryiea' WHERE id = 1 事务提交后：进行持久化 redolog和 binlog。\",\"这两个日志的刷盘先后顺序可能会导致下面两种情况：\",\"如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入。 \",\"MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 kryiea。\",\"但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致。\",\"如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入 。 \",\"由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name 字段还是旧值 jay。\",\"而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 kryiea，与主库的值不一致。\",\"问题的解决方案： 两阶段提交\"]},\"240\":{\"h\":\"3.6.2 两阶段提交的概念\",\"t\":[\"两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。\",\"两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是准备（Prepare）阶段和提交（Commit）阶段 ，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。\",\"协调者与参与者之间的协作： 例子来自小林图解。\",\"举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？\",\"准备阶段 ： 裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。\",\"提交阶段 ： 如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。\"]},\"241\":{\"h\":\"3.6.3 两阶段提交的过程\",\"t\":[\"在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog与 redolog，为了保证这两个日志的一致性，MySQL 事务提交时使用 内部 XA 事务 来保证一致性。\",\"内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。\",\"（是的，也有外部 XA 事务）\",\"当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务， 分两阶段来完成 XA 事务的提交 。\",\"场景举例： 事务的提交过程有两个阶段：将 redolog 的写入拆成了两个步骤 prepare 和 commit，中间再穿插写入 binlog。\",\"具体如下：\",\"prepare 阶段 ：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）\",\"commit 阶段 ：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了。因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；\",\"20240603005031\"]},\"242\":{\"h\":\"3.6.4 两阶段提交有什么问题\",\"t\":[\"两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差。\",\"主要有两个方面的影响：\",\"磁盘 I/O 次数高 ： 对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。\",\"锁竞争激烈 ： 两阶段提交虽然能够保证单事务两个日志的内容一致，但在多事务的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。\"]},\"243\":{\"h\":\"3.6.5 对两阶段提交加强：加入组提交\",\"t\":[\"MySQL 引入了组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成1个，从而减少磁盘 I/O 的次数。\",\"引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为3个过程： ● flush 阶段 ： 多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）； ● sync 阶段 ： 对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）； ● commit 阶段 ： 各个事务按顺序做 InnoDB commit 操作；\",\"20240603010701\"]},\"244\":{\"c\":[\"mysql\"]},\"245\":{\"c\":[\"MVCC\",\"日志\"]},\"246\":{\"h\":\"redis实现分布式锁\",\"t\":[\"redis实现分布式锁的方式\",\"分布式锁就是分布式场景下的锁，比如多台不同机器上的进程，去竞争同一项资源，这个时候就需要加锁\",\"互斥性：锁的目的是获取资源的使用权，所以只让一个竞争者持有锁，这一点要尽可能保证\",\"安全性：避免锁因为异常永远不被释放。当一个竞争者在持有锁期间内，由于意外崩溃而导致未能主动解锁，其持有的锁也能够被兜底释放，并保证后续其它竞争者也能加锁\",\"对称性：同一个锁，加锁和解锁必须是同一个竞争者。不能把其他竞争者持有的锁给释放了\",\"可靠性：需要有一定程度的异常处理能力、容灾能力。\",\"分布式锁，一般会依托第三方组件实现\",\"利用 redis 实现是用的最多的一种\"]},\"247\":{\"h\":\"最简化版本\",\"t\":[\"实现方式\",\"直接用Redis的setnx命令，这个命令的语法是：setnx key value 如果key不存在，则会将key设置为value，并返回1 如果key存在，不会有任务影响，返回0 基于这个特性，我们就可以用setnx实现加锁的目的：通过setnx加锁，加锁之后其他服务无法加锁，用完之后，再通过delete解锁，\",\"流程图\",\"20240127155257\"]},\"248\":{\"h\":\"升级 1：支持过期时间\",\"t\":[\"最简化版本有一个问题\",\"如果获取锁的服务挂掉了，那么锁就一直得不到释放，就像石沉大海，杳无音信 所以，我们需要一个超时来兜底。\",\"设置过期时间\",\"Redis中有expire命令，用来设置一个key的超时时间。 但是setnx和expire不具备原子性，如果setnx获取锁之后，服务挂掉，依旧是泥牛入海。\",\"原子性问题\",\"Redis考虑到了这种场景，推出了如下执行语句：set key value nx ex seconds nx表示具备setnx 特性，ex表示增加了过期时间，最后一个参数就是过期时间的值\",\"流程图\",\"20240127155314\"]},\"249\":{\"h\":\"升级 2：超时 + 锁归属\",\"t\":[\"升级 1 存在的问题：可能服务 A 会释放掉服务 B\",\"想一下如下场景：服务A获取了锁，由于业务流程比较长，或者网络延迟、GC卡顿等原因，导致锁过期，而业务还会继续进行。 这时候，业务B已经拿到了锁，准备去执行 这个时候服务A恢复过来并做完了业务，就会释放锁，而B却还在继续执行。 在真实的分布式场景中，可能存在几十个竞争者，那么上述情况发生概率就很高，导致同一份资源频繁被不同竞争者同时访问，分布式锁也就失去了意义。 🌰想一下如下场景：基于这个场景，可以发现，问题关键在于，竞争者可以释放其他人的锁。 那么在异常情况下，就会出现问题，所以我们可以进一步给出解决方案： 🌰分布式锁需要满足谁申请谁释放原则，不能释放别人的锁，也就是说，分布式锁，是要有归属的。\",\"给锁加上 owner\",\"20240127155324\"]},\"250\":{\"h\":\"升级 3：引入 Lua\",\"t\":[\"升级 2 存在的问题\",\"升级 2 的流程：竞争者获取锁执行任务，执行完毕后，检查锁是不是自己的，最后再进行释放 这一通下操作都不是原子化的，可能锁获取的时候还是自己的，但是删除的时候已经是别人的了\",\"如何理解：锁获取的时候还是自己的，但是删除的时候已经是别人的了\",\"旧客户端删除前检查锁，显示旧客户端是 owner\",\"旧客户端准备释放锁，恰好这时候锁过期了，相当于锁被自行释放了\",\"此时，新客户端来获取到了这个锁，owner 是新客户端\",\"旧客户端执行释放操作，把新客户端的锁释放了\",\"Redis+Lua\",\"Redis还有个特性，专门整合原子操作 —— Lua \"]},\"251\":{\"h\":\"升级 3 满足：对称性，安全性，互斥性\"},\"252\":{\"h\":\"升级 4：可靠性的保证\",\"t\":[\"前面的内容，基本是基于单机考虑的，如果Redis挂掉了，那锁就不能获取了。 这个问题该如何解决呢？ 一般来说，有两种方法：\",\"主从容灾\",\"多级部署。\"]},\"253\":{\"h\":\"主从容灾\",\"t\":[\"最简单的一种方式，就是为Redis配置从节点，当主节点挂了，用从节点顶包。 但是主从切换，需要人工参与，会提高人力成本。 不过Redis已经有成熟的解决方案，也就是哨兵模式，可以灵活自动切换，不再需要人工介入。\",\"哨兵模式\",\"20240127155359\"]},\"254\":{\"h\":\"多机部署\",\"t\":[\"如果对一致性的要求高一些，可以尝试多机部署，比如Redis的RedLock，\",\"RedLcok\",\"大概的思路就是多个机器，通常是奇数个，达到一半以上同意加锁才算加锁成功，这样，可靠性会向ETCD靠近。 还不了解 etcd？一文带你快速入门（万字长文）-腾讯云开发者社区-腾讯云\",\"现在假设有5个Redis主节点，基本保证它们不会同时宕掉，获取锁和释放锁的过程中，客户端会执行以下操作：\",\"向5个Redis申请加锁\",\"只要超过一半，也就是3个Redis返回成功，那么就是获取到了锁。 如果超过一半失败，需要向每个Redis发送解锁命令\",\"由于向5个Redis发送请求，会有一定时耗，所以锁剩余持有时间，需要减去请求时间 这个可以作为判断依据，如果剩余时间已经为0，那么也是获取锁失败\",\"使用完成之后，向5个Redis发送解锁请求。\",\"20240127155408\",\"这种模式的好处在于，如果挂了2台Redis，整个集群还是可用的，给了运维更多时间来修复。 另外，单点Redis的所有手段，这种多机模式都可以使用 比如为每个节点配置哨兵模式，由于加锁是一半以上同意就成功，那么如果单个节点进行了主从切换，单个节点数据的丢失，就不会让锁失效了。\"]},\"255\":{\"h\":\"RedLock 可靠性探索\",\"t\":[\"分布式系统的三困境：NPC\",\"N：Network Delay（网络延迟）\",\"P：Process Pause（进程暂停）\",\"C：Clock Drift（时钟漂移）\",\"Network Delay\",\"当分布式锁获得返回包的时间过长，此时可能虽然加锁成功，但是已经时过境迁，锁可能很快过期。 RedLock算做了些考量，也就是前面所说的锁剩余持有时间，需要减去请求时间，如此一来，就可以一定程度解决网络延迟的问题\",\"Process Pause\",\"比如发生GC：获取锁之后GC了，处于GC执行中，然后锁超时。 其它锁想获取，这种情况几乎无解。 这时候GC回来了，那么两个进程就获取到了同一个分布式锁。（GC 回来，以为自己还持有锁，继续做任务） 也许会说，在GC回来之后，可以再去查一次啊？这里有两个问题\",\"你怎么知道GC回来了？ 这个可以在做业务之前，通过时间，进行一个粗略判断\",\"如果你判断的时候是ok的，但是判断完才开始 GC 呢？ 这点RedLock是无法解决的。\",\"Clock Drift\",\"如果竞争者A，获得了RedLock，在5台分布式机器上都加上锁。 为了方便分析，直接假设5台机器都发生了时钟漂移，锁瞬间过期了。 这时候竞争者B拿到了锁，此时A和B拿到了相同的执行权限。\",\"根据上述的分析可以看出，RedLock也不能扛住NPC的挑战，因此，单单从分布式锁本身出发，完全可靠是不可能的。 要实现一个相对可靠的分布式锁机制，还是需要和业务的配合，业务本身要幂等可重入，这样的设计可以省却很多麻烦\"]},\"256\":{\"c\":[\"redis\"]},\"257\":{\"c\":[\"redis\"]},\"258\":{\"h\":\"redis数据在内存中的组织过程\",\"t\":[\"redis 的数据在内存中的组织过程\",\"本文不对 redis 的数据对象以及底层编码方式作深入展开。 仅是以 局部到全景 的思路简单理解 redis 的数据在内存中的组织过程。\",\"小林coding 图解redis\",\"Redis 源码日志\"]},\"259\":{\"h\":\"1.1 存储形式为 redisObject\",\"t\":[\"redis 是 键值对 存储，key 和 value 在 redis 中被抽象为redisObject，即对象。\",\"key： 只能是 string 对象。\",\"value： 支持丰富的对象种类，包括：string、list、set、hash、zset等。\"]},\"260\":{\"h\":\"1.2 redisObject 结构\",\"t\":[\"重点关注 type 和 encoding 字段。\",\"type：表明是哪种 redis 数据对象。\",\"encoding：表明数据对象的底层编码方式（底层数据结构）。可以看到不同的数据对象，可能采用相同的编码方式。\",\"2\"]},\"261\":{\"h\":\"1.3 实际例子\",\"t\":[\"存一条数据，redis 命令：set 我是一个key 1000\",\"redisObject 表现为👇\",\"key = “我是一个key” ， Object 的图示（假设用embstr编码）：\",\"3\",\"value = 1000 ，Object 的图示（假设用编码int）：\",\"4\"]},\"262\":{\"h\":\"1.3 redisObject 代码\",\"t\":[\"除了 type 和 encoding 字段外，\",\"lru：记录对象访问信息，用于内存淘汰（lru、lfu 都复用这个字段）\",\"refcount：引用计数，用来描述有几个指针指向该对象\",\"ptr：内容指针，指向实际数据\",\"// redis 6.0.10 struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr; };\",\"从上面了解到 k-v 在内存里的存储形式为 redisObject，那这些 Object 又是被如何组织管理的呢？\",\"自然是dict\"]},\"263\":{\"h\":\"2.1 dict 结构\",\"t\":[\"简单视角理解 dict 管理 redisObject\",\"简单来说，dict 是一张哈希表，Redis 所有的 key-value 都存储在里面。\",\"dict\",\"深入一点理解 dict 管理 redisObject\",\"dict 在 redis 中会有更多层的抽象，以便实现更多功能。\",\"dict+\"]},\"264\":{\"h\":\"2.2 dict 代码\",\"t\":[\"// 哈希表（字典）数据结构，Redis 的所有键值对都会存储在这里。其中包含两个哈希表。 struct dict { // 哈希表的类型，包括哈希函数，比较函数，键值的内存释放函数 dictType *type; // 存储一些额外的数据 void *privdata; // 两个哈希表，先使用ht[0],扩容时启用ht[1] dictht ht[2]; // 哈希表重置下标，指向的是哈希数组的数组下标，扩容时使用。 int rehashidx; // 绑定到哈希表的迭代器个数 int iterators; };\",\"dict 管理存储的 redisObject，那谁来组织 dict 呢？ 自然是再上一层的抽象：redisDB\"]},\"265\":{\"h\":\"3.1 redisDB 结构\",\"t\":[\"redisDB 的重点字段\",\"id：redis 启动时默认开启 16 个 DB，对应0-15 编号。可配置。\",\"dict：指向一个 dict。\",\"expires：指向一个 dict，该 dict 存储含过期时间的 k-v。\",\"redisdb\"]},\"266\":{\"h\":\"3.2 redisDb 代码\",\"t\":[\"struct redisDb { int id; // 数据库ID dict *dict; // 该数据库的键空间 dict *expires; // 设置了超时的键的超时时间 dict *blocking_keys; // 有客户端等待数据的键（BLPOP） dict *ready_keys; // 接收到PUSH操作的阻塞键 dict *watched_keys; // 用于MULTI/EXEC CAS的监视键 long long avg_ttl; // 平均生存时间（TTL），仅用于统计 unsigned long expires_cursor; // 活跃过期周期的游标。 list *defrag_later; // 稍后尝试逐个、逐渐进行碎片整理的键名列表。 }\",\"经过上面对 redisObject、dict、redisDB 的层层理解，对 redis 有了结构化、层次化的理解。\",\"接下来以全景的视角来看 redis 的组织形式\",\"redis.drawio\",\"重点结构：\",\"redisDB：默认是有 0-15 编号，共 16 个 DB ，默认是选择 0 号。\",\"dict：对 hashtable 的一层封装，添加 k-v 的地方\",\"hashtable：对 dictEntry 的一层封装，存有 table 的地址\",\"dictEntry(bucket)：存储 key-value 对象。\",\"redisObject：每个 key 和 value 都表现为一个 redisObject 对象\"]},\"267\":{\"h\":\"4.1 redis 哈希冲突如何解决\",\"t\":[\"redis 依靠 dict 哈希表来组织所有的 k-v 对象。\",\"每次添加 k-v 的时候，需要进行 hash运算 以及 掩码运算 来找到对应的插入位置，这时可能会发生哈希冲突。\",\"redis 用变种拉链法来解决哈希冲突，全景图的 dictEntry 结构有一个 next 字段，指向冲突的下一对 k-v\",\"hash\"]},\"268\":{\"h\":\"4.2 redisDB 的 expires\",\"t\":[\"在全景图的 redisDB 结构中，可以发现 *dict 、*expires 都是指向一个dict 结构。\",\"但 expires 所指向的 dict 在组织形式上会有所差异：\",\"dict 和 expires 中的 key 对象，实际都是存储了 string 对象的指针，所以是不会重复占用内存。\",\"如果设置了过期时间，key 的指针 在 dict 和 expires 都会存储一份。只是 expires 中 value 指向 timestamp（过期时间），而 dict 的 value 指向实际数据。\",\"expires\"]},\"269\":{\"c\":[\"redis\"]},\"270\":{\"c\":[\"redis\"]},\"271\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"272\":{\"h\":\"Docker\"},\"273\":{\"h\":\"Back End\"},\"274\":{\"h\":\"GMP\"},\"275\":{\"h\":\"Go\"},\"276\":{\"h\":\"Feature\"},\"277\":{\"h\":\"Grammar\"},\"278\":{\"h\":\"Library\"},\"279\":{\"h\":\"Basis\"},\"280\":{\"h\":\"Mysql\"},\"281\":{\"h\":\"Application\"},\"282\":{\"h\":\"Redis\"},\"283\":{\"h\":\"Basis\"}},\"dirtCount\":0,\"index\":[[\"过期时间\",{\"1\":{\"268\":1}}],[\"过程如下图\",{\"1\":{\"216\":1}}],[\"过程后\",{\"1\":{\"199\":1}}],[\"过程中\",{\"1\":{\"199\":1}}],[\"过程中也不会执行上层的剩余代码\",{\"1\":{\"167\":1}}],[\"掩码运算\",{\"1\":{\"267\":1}}],[\"哈希冲突如何解决\",{\"0\":{\"267\":1}}],[\"哈希表来组织所有的\",{\"1\":{\"267\":1}}],[\"哈希表重置下标\",{\"1\":{\"264\":1}}],[\"哈希表的类型\",{\"1\":{\"264\":1}}],[\"哈希表\",{\"1\":{\"264\":1}}],[\"号\",{\"1\":{\"266\":1}}],[\"共\",{\"1\":{\"266\":1}}],[\"共同完成\",{\"1\":{\"240\":1}}],[\"经过上面对\",{\"1\":{\"266\":1}}],[\"经常会遇到想忽略指定字段修改的问题\",{\"1\":{\"176\":1}}],[\"逐渐进行碎片整理的键名列表\",{\"1\":{\"266\":1}}],[\"稍后尝试逐个\",{\"1\":{\"266\":1}}],[\"活跃过期周期的游标\",{\"1\":{\"266\":1}}],[\"活跃的事务列表中最小的事务id\",{\"1\":{\"220\":1}}],[\"平均生存时间\",{\"1\":{\"266\":1}}],[\"平滑效果smooth开启后\",{\"1\":{\"3\":1}}],[\"绑定到哈希表的迭代器个数\",{\"1\":{\"264\":1}}],[\"扩容时使用\",{\"1\":{\"264\":1}}],[\"扩容时启用ht\",{\"1\":{\"264\":1}}],[\"管理存储的\",{\"1\":{\"264\":1}}],[\"管理\",{\"1\":{\"263\":2}}],[\"除了\",{\"1\":{\"262\":1}}],[\"假设用编码int\",{\"1\":{\"261\":1}}],[\"假设用embstr编码\",{\"1\":{\"261\":1}}],[\"假设为\",{\"1\":{\"45\":1}}],[\"zset等\",{\"1\":{\"259\":1}}],[\"局部到全景\",{\"1\":{\"258\":1}}],[\"局部变量周期是函数存活时间\",{\"1\":{\"127\":1}}],[\"局部变量\",{\"1\":{\"127\":1}}],[\"仅用于统计\",{\"1\":{\"266\":1}}],[\"仅是以\",{\"1\":{\"258\":1}}],[\"仅添加omitempty是不够的\",{\"1\":{\"177\":1}}],[\"业务本身要幂等可重入\",{\"1\":{\"255\":1}}],[\"业务b已经拿到了锁\",{\"1\":{\"249\":1}}],[\"获得了redlock\",{\"1\":{\"255\":1}}],[\"获取\",{\"1\":{\"203\":2}}],[\"获取到\",{\"1\":{\"197\":1}}],[\"获取锁之后gc了\",{\"1\":{\"255\":1}}],[\"获取锁和释放锁的过程中\",{\"1\":{\"254\":1}}],[\"获取锁\",{\"1\":{\"89\":1}}],[\"呢\",{\"1\":{\"255\":1,\"264\":1}}],[\"继续做任务\",{\"1\":{\"255\":1}}],[\"向5个redis发送解锁请求\",{\"1\":{\"254\":1}}],[\"向5个redis申请加锁\",{\"1\":{\"254\":1}}],[\"向上传递\",{\"1\":{\"167\":1}}],[\"腾讯云\",{\"1\":{\"254\":1}}],[\"腾讯云开发者社区\",{\"1\":{\"254\":1}}],[\"万字长文\",{\"1\":{\"254\":1}}],[\"万一断电重启\",{\"1\":{\"227\":1}}],[\"达到一半以上同意加锁才算加锁成功\",{\"1\":{\"254\":1}}],[\"哨兵模式\",{\"1\":{\"253\":1}}],[\"满足\",{\"0\":{\"251\":1}}],[\"专门整合原子操作\",{\"1\":{\"250\":1}}],[\"专注于生成特定目标机器上的程序\",{\"1\":{\"97\":1}}],[\"恰好这时候锁过期了\",{\"1\":{\"250\":1}}],[\"检查锁是不是自己的\",{\"1\":{\"250\":1}}],[\"检查自上次加载\",{\"1\":{\"203\":1}}],[\"竞争者获取锁执行任务\",{\"1\":{\"250\":1}}],[\"竞争者可以释放其他人的锁\",{\"1\":{\"249\":1}}],[\"🌰分布式锁需要满足谁申请谁释放原则\",{\"1\":{\"249\":1}}],[\"🌰想一下如下场景\",{\"1\":{\"249\":1}}],[\"准备去执行\",{\"1\":{\"249\":1}}],[\"准备阶段\",{\"1\":{\"240\":1}}],[\"想一下如下场景\",{\"1\":{\"249\":1}}],[\"想要在嵌套的结构体为空值时\",{\"1\":{\"177\":1}}],[\"想要变成嵌套的json串\",{\"1\":{\"177\":1}}],[\"想要执行\",{\"1\":{\"89\":1}}],[\"超时\",{\"0\":{\"249\":1}}],[\"特性\",{\"1\":{\"248\":1}}],[\"特殊运算符\",{\"0\":{\"134\":1}}],[\"推出了如下执行语句\",{\"1\":{\"248\":1}}],[\"杳无音信\",{\"1\":{\"248\":1}}],[\"升级\",{\"0\":{\"248\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":1},\"1\":{\"249\":1,\"250\":2}}],[\"升高\",{\"1\":{\"236\":1}}],[\"流程图\",{\"1\":{\"247\":1,\"248\":1}}],[\"流转来的\",{\"1\":{\"199\":1}}],[\"安全性\",{\"0\":{\"251\":1},\"1\":{\"246\":1}}],[\"安全点上的堆栈指针情况\",{\"1\":{\"102\":1}}],[\"各个事务按顺序做\",{\"1\":{\"243\":1}}],[\"合并一次刷盘\",{\"1\":{\"243\":1}}],[\"合起来是json\",{\"1\":{\"176\":1}}],[\"●\",{\"1\":{\"243\":3}}],[\"却不能保证两者的提交顺序一致\",{\"1\":{\"242\":1}}],[\"却是最先被调度\",{\"1\":{\"81\":1}}],[\"双1\",{\"1\":{\"242\":1}}],[\"作为协调者\",{\"1\":{\"241\":1}}],[\"宣布比赛正式开始\",{\"1\":{\"240\":1}}],[\"裁判\",{\"1\":{\"240\":4}}],[\"举个拳击比赛的例子\",{\"1\":{\"240\":1}}],[\"举个例子\",{\"1\":{\"175\":1}}],[\"协调者\",{\"1\":{\"240\":4}}],[\"协调者与参与者之间的协作\",{\"1\":{\"240\":1}}],[\"协程被称为\",{\"1\":{\"86\":1}}],[\"阶段拆分为3个过程\",{\"1\":{\"243\":1}}],[\"阶段不变\",{\"1\":{\"243\":1}}],[\"阶段\",{\"1\":{\"240\":1,\"241\":2,\"243\":4}}],[\"阶段和提交\",{\"1\":{\"240\":1}}],[\"崩溃恢复以后这个事务无效\",{\"1\":{\"239\":1}}],[\"崩溃后\",{\"1\":{\"215\":1}}],[\"丢失了这条更新语句\",{\"1\":{\"239\":1}}],[\"突然宕机了\",{\"1\":{\"239\":2}}],[\"突然又调度了一下\",{\"1\":{\"82\":1}}],[\"某行记录\",{\"1\":{\"239\":1}}],[\"某种类型不限于结构体\",{\"1\":{\"148\":1}}],[\"两位拳击手就可以直接开打\",{\"1\":{\"240\":1}}],[\"两位拳击手\",{\"1\":{\"240\":1}}],[\"两阶段提交虽然能够保证单事务两个日志的内容一致\",{\"1\":{\"242\":1}}],[\"两阶段提交虽然保证了两个日志文件的数据一致性\",{\"1\":{\"242\":1}}],[\"两阶段提交有什么问题\",{\"0\":{\"242\":1}}],[\"两阶段提交把单个事务的提交拆分成了\",{\"1\":{\"240\":1}}],[\"两阶段提交其实是分布式事务一致性协议\",{\"1\":{\"240\":1}}],[\"两阶段提交的过程\",{\"0\":{\"241\":1}}],[\"两阶段提交的概念\",{\"0\":{\"240\":1}}],[\"两阶段提交的提出\",{\"0\":{\"239\":1}}],[\"两阶段提交\",{\"0\":{\"238\":1},\"1\":{\"239\":1}}],[\"两个哈希表\",{\"1\":{\"264\":1}}],[\"两个日志的提交顺序一致\",{\"1\":{\"242\":1}}],[\"两个\",{\"0\":{\"191\":1},\"1\":{\"186\":1}}],[\"两个数值\",{\"1\":{\"82\":1}}],[\"两个命令是等价的\",{\"1\":{\"57\":1}}],[\"两个容器的进程可以通过\",{\"1\":{\"47\":1}}],[\"两个容器除了网络方面\",{\"1\":{\"47\":1}}],[\"仍有一个从库有最新数据\",{\"1\":{\"237\":1}}],[\"半同步模式\",{\"1\":{\"237\":1}}],[\"异步模式\",{\"1\":{\"237\":2}}],[\"异常重启之后数据不会丢失\",{\"1\":{\"232\":1}}],[\"异常\",{\"1\":{\"166\":1}}],[\"线程去回放\",{\"1\":{\"237\":1}}],[\"线程\",{\"1\":{\"237\":1}}],[\"线程是运行\",{\"1\":{\"92\":1}}],[\"控制\",{\"1\":{\"236\":1}}],[\"频繁的\",{\"1\":{\"236\":1}}],[\"锁瞬间过期了\",{\"1\":{\"255\":1}}],[\"锁可能很快过期\",{\"1\":{\"255\":1}}],[\"锁获取的时候还是自己的\",{\"1\":{\"250\":1}}],[\"锁归属\",{\"0\":{\"249\":1}}],[\"锁的目的是获取资源的使用权\",{\"1\":{\"246\":1}}],[\"锁的使用\",{\"1\":{\"186\":1}}],[\"锁竞争激烈\",{\"1\":{\"242\":1}}],[\"锁机制\",{\"1\":{\"236\":1}}],[\"什么时候\",{\"1\":{\"236\":1}}],[\"设定一个处理线程只能同时有一个事务在执行\",{\"1\":{\"236\":1}}],[\"设置了超时的键的超时时间\",{\"1\":{\"266\":1}}],[\"设置过期时间\",{\"1\":{\"248\":1}}],[\"设置加载标志为\",{\"1\":{\"205\":2}}],[\"设置返回值\",{\"1\":{\"165\":1}}],[\"设置只有一个\",{\"1\":{\"75\":1}}],[\"设置为\",{\"0\":{\"82\":1},\"1\":{\"75\":1,\"199\":1}}],[\"设置在一段延迟后自动保存文件\",{\"1\":{\"3\":1}}],[\"设置\",{\"0\":{\"3\":1},\"1\":{\"44\":1}}],[\"产生\",{\"1\":{\"235\":1}}],[\"产生的\",{\"1\":{\"231\":1}}],[\"组提交\",{\"1\":{\"236\":1}}],[\"组成\",{\"1\":{\"233\":1}}],[\"组合\",{\"1\":{\"150\":1}}],[\"组合实现继承\",{\"0\":{\"150\":1}}],[\"留在\",{\"1\":{\"232\":1}}],[\"持久化到磁盘\",{\"1\":{\"232\":1,\"236\":1,\"241\":2}}],[\"持久化到磁盘即可\",{\"1\":{\"228\":1}}],[\"增大它的大小可以让\",{\"1\":{\"231\":1}}],[\"增加sp的值\",{\"1\":{\"117\":1}}],[\"随机写入是指数据写入磁盘的不同位置\",{\"1\":{\"230\":1}}],[\"随机写入\",{\"1\":{\"230\":1}}],[\"随机指定端口\",{\"1\":{\"60\":1}}],[\"顺序写入的性能通常比随机写入高\",{\"1\":{\"230\":1}}],[\"顺序写入\",{\"1\":{\"230\":1,\"236\":1}}],[\"刷入到磁盘之后\",{\"1\":{\"239\":2}}],[\"刷写到磁盘上的\",{\"1\":{\"229\":1}}],[\"刷盘操作合并成1个\",{\"1\":{\"243\":1}}],[\"刷盘\",{\"1\":{\"242\":3}}],[\"刷盘到存储表数据的文件\",{\"1\":{\"227\":1}}],[\"刷盘策略\",{\"0\":{\"225\":1,\"236\":1}}],[\"修改了哪些数据等\",{\"1\":{\"229\":1}}],[\"修改\",{\"1\":{\"228\":1}}],[\"修改为非\",{\"1\":{\"205\":1}}],[\"修改为\",{\"1\":{\"199\":1}}],[\"磁盘\",{\"1\":{\"227\":1,\"242\":1}}],[\"脏的数据页\",{\"1\":{\"227\":1}}],[\"采用在文件尾部追加写入文件的方式\",{\"1\":{\"230\":1}}],[\"采用\",{\"1\":{\"227\":1}}],[\"竹子爱熊猫\",{\"1\":{\"225\":1}}],[\"深入一点理解\",{\"1\":{\"263\":1}}],[\"深入探寻数据库内存与buffer\",{\"1\":{\"225\":1}}],[\"深入学习文章推荐\",{\"1\":{\"225\":1}}],[\"十二\",{\"1\":{\"225\":1}}],[\"刚刚提到了\",{\"1\":{\"224\":1}}],[\"申请物理内存\",{\"1\":{\"224\":1}}],[\"申请一片连续的内存空间\",{\"1\":{\"224\":1}}],[\"否则再去磁盘中读取\",{\"1\":{\"223\":1}}],[\"否则会出现\",{\"1\":{\"183\":1}}],[\"得先要从磁盘读取该记录\",{\"1\":{\"223\":1}}],[\"场景举例\",{\"1\":{\"241\":1}}],[\"场景\",{\"1\":{\"223\":1,\"236\":3}}],[\"缓存什么\",{\"0\":{\"224\":1}}],[\"缓存处理\",{\"1\":{\"210\":1}}],[\"缓冲池\",{\"0\":{\"222\":1}}],[\"页面后\",{\"1\":{\"229\":1}}],[\"页面\",{\"1\":{\"229\":2}}],[\"页头\",{\"1\":{\"224\":1}}],[\"页目录类似于字典的目录\",{\"1\":{\"224\":1}}],[\"页目录\",{\"1\":{\"224\":1}}],[\"页是记录什么的\",{\"1\":{\"224\":1}}],[\"页都是靠这个机制保证持久化的\",{\"1\":{\"221\":1}}],[\"页的修改也都会记录到\",{\"1\":{\"221\":1}}],[\"页\",{\"1\":{\"221\":1,\"224\":1}}],[\"才返回客户端结果\",{\"1\":{\"237\":1}}],[\"才能完成持久化存储\",{\"1\":{\"227\":1}}],[\"才启动的事务生成的\",{\"1\":{\"220\":1}}],[\"才会分配到栈上\",{\"1\":{\"105\":1}}],[\"判定方法\",{\"1\":{\"220\":1}}],[\"判断是否将\",{\"1\":{\"204\":1}}],[\"系统中要给下一个事务分配的id值\",{\"1\":{\"220\":1}}],[\"系统内活跃且未提交的事务id列表\",{\"1\":{\"220\":1}}],[\"系统调用\",{\"1\":{\"89\":1,\"236\":1}}],[\"参与者\",{\"1\":{\"240\":4}}],[\"参考\",{\"1\":{\"219\":1}}],[\"参数控制\",{\"1\":{\"232\":1}}],[\"参数动态的调整大小\",{\"1\":{\"231\":1}}],[\"参数决定\",{\"1\":{\"215\":1}}],[\"参数\",{\"1\":{\"146\":1}}],[\"参数传递\",{\"0\":{\"142\":1}}],[\"参数列表从右至左依次压栈\",{\"1\":{\"117\":1}}],[\"参数等数据的空间\",{\"1\":{\"114\":1}}],[\"参数说明\",{\"1\":{\"60\":1}}],[\"参数来启用\",{\"1\":{\"43\":1}}],[\"参数来指定端口映射\",{\"1\":{\"39\":1}}],[\"参数指定\",{\"1\":{\"41\":1}}],[\"参数时如果本地目录不存在\",{\"1\":{\"35\":2}}],[\"前面的内容\",{\"1\":{\"252\":1}}],[\"前\",{\"1\":{\"220\":1}}],[\"前后两次读的数据可能会出现不一致\",{\"1\":{\"219\":1}}],[\"前端在传递来的json数据中可能会使用字符串类型的数字\",{\"1\":{\"179\":1}}],[\"前端\",{\"0\":{\"16\":1}}],[\"事务由\",{\"1\":{\"241\":1}}],[\"事务提交时使用\",{\"1\":{\"241\":1}}],[\"事务提交后\",{\"1\":{\"239\":2}}],[\"事务提交的时候\",{\"1\":{\"236\":1}}],[\"事务执行过程中\",{\"1\":{\"236\":1}}],[\"事务readview\",{\"1\":{\"220\":1}}],[\"事务\",{\"1\":{\"220\":1,\"241\":3}}],[\"事务的提交过程有两个阶段\",{\"1\":{\"241\":1}}],[\"事务的提交\",{\"1\":{\"241\":1}}],[\"事务的\",{\"1\":{\"219\":1,\"241\":1}}],[\"事务期间的多次读取同一条数据\",{\"1\":{\"219\":1}}],[\"事务id\",{\"1\":{\"218\":1}}],[\"区别\",{\"1\":{\"223\":1}}],[\"区别在于创建\",{\"1\":{\"219\":1}}],[\"区别于c++\",{\"1\":{\"142\":1}}],[\"快照读\",{\"1\":{\"219\":1}}],[\"快速上手篇\",{\"1\":{\"120\":1}}],[\"普通\",{\"1\":{\"219\":1}}],[\"普通指针常用于引用变量\",{\"1\":{\"147\":1}}],[\"普通指针特性\",{\"0\":{\"147\":1}}],[\"版本链里找到满足其可见性的记录\",{\"1\":{\"219\":1}}],[\"版本链如下图\",{\"1\":{\"218\":1}}],[\"版本已移除查询缓存这一特性\",{\"1\":{\"210\":1}}],[\"串成一个链表\",{\"1\":{\"218\":1}}],[\"日志\",{\"1\":{\"237\":1},\"2\":{\"245\":1}}],[\"日志重写方式\",{\"1\":{\"233\":1}}],[\"日志重写\",{\"0\":{\"233\":1},\"1\":{\"233\":1}}],[\"日志文件是最新的\",{\"1\":{\"227\":1}}],[\"日志的格式\",{\"0\":{\"218\":1}}],[\"日志系统的工作过程\",{\"1\":{\"209\":1}}],[\"插入\",{\"1\":{\"217\":1}}],[\"插件\",{\"0\":{\"1\":1,\"2\":1},\"2\":{\"15\":1,\"169\":1}}],[\"机制\",{\"0\":{\"216\":1,\"220\":1,\"228\":1},\"1\":{\"243\":1}}],[\"机器码生成\",{\"0\":{\"102\":1}}],[\"认识\",{\"0\":{\"216\":1,\"228\":1}}],[\"里的完整事务写入到\",{\"1\":{\"236\":1}}],[\"里的\",{\"1\":{\"232\":3}}],[\"里的脏页数据持久化到磁盘\",{\"1\":{\"228\":1}}],[\"里的字段\",{\"1\":{\"219\":1,\"220\":1}}],[\"里\",{\"1\":{\"215\":1,\"217\":1}}],[\"里面记录了这条更新语句\",{\"1\":{\"239\":1}}],[\"里面没有记录这条更新语句\",{\"1\":{\"239\":1}}],[\"里面有一个\",{\"1\":{\"190\":1}}],[\"里面再保存\",{\"1\":{\"144\":1}}],[\"试想以下场景\",{\"1\":{\"215\":1,\"227\":1}}],[\"引入\",{\"0\":{\"250\":1}}],[\"引入了组提交机制后\",{\"1\":{\"243\":1}}],[\"引入了组提交\",{\"1\":{\"243\":1}}],[\"引擎会在适当的时候\",{\"1\":{\"227\":1}}],[\"引擎会先更新\",{\"1\":{\"227\":1}}],[\"引擎对一条记录进行操作时\",{\"1\":{\"217\":1}}],[\"引擎在执行一条增删改语句的时候\",{\"1\":{\"215\":1}}],[\"引用计数\",{\"1\":{\"262\":1}}],[\"引用小林图解的一张图\",{\"1\":{\"210\":1}}],[\"引用的副本或指针的副本\",{\"1\":{\"144\":1}}],[\"引用类型如\",{\"1\":{\"144\":1}}],[\"引用类型和指针\",{\"0\":{\"144\":1}}],[\"统一写入\",{\"1\":{\"213\":1,\"235\":1}}],[\"层次化的理解\",{\"1\":{\"266\":1}}],[\"层会生成一条\",{\"1\":{\"235\":1}}],[\"层实现的日志\",{\"1\":{\"235\":1}}],[\"层的\",{\"1\":{\"223\":1,\"235\":1}}],[\"层的日志\",{\"1\":{\"213\":1}}],[\"层还会生成一条\",{\"1\":{\"213\":1}}],[\"层就读到了该\",{\"1\":{\"199\":1}}],[\"归档日志\",{\"1\":{\"213\":1}}],[\"撤销已经执行的修改\",{\"1\":{\"213\":1}}],[\"待执行的语句执行过程\",{\"1\":{\"211\":1}}],[\"选择成本最低的计划\",{\"1\":{\"210\":1}}],[\"选择执行计划\",{\"1\":{\"210\":1}}],[\"成本估算\",{\"1\":{\"210\":1}}],[\"名称是否正确等\",{\"1\":{\"210\":1}}],[\"名称以\",{\"1\":{\"45\":1}}],[\"预处理器进一步检查解析树的合法性\",{\"1\":{\"210\":1}}],[\"预处理器\",{\"1\":{\"210\":1}}],[\"服务a获取了锁\",{\"1\":{\"249\":1}}],[\"服务挂掉\",{\"1\":{\"248\":1}}],[\"服务器通信\",{\"1\":{\"210\":1}}],[\"服务端是\",{\"1\":{\"24\":1}}],[\"服务端\",{\"0\":{\"24\":1}}],[\"服务端负责接收和处理指令\",{\"1\":{\"22\":1}}],[\"建立客户端\",{\"1\":{\"210\":1}}],[\"大概的思路就是多个机器\",{\"1\":{\"254\":1}}],[\"大致可以分为以下几个步骤\",{\"1\":{\"210\":1}}],[\"大写字母p\",{\"1\":{\"60\":1}}],[\"属于\",{\"1\":{\"223\":1}}],[\"属于哪一层\",{\"1\":{\"223\":1}}],[\"属于读一条记录的过程\",{\"1\":{\"210\":1}}],[\"属性顺序\",{\"1\":{\"136\":1}}],[\"遍历期间\",{\"1\":{\"206\":1}}],[\"遍历所有元素\",{\"1\":{\"188\":1,\"189\":1}}],[\"释放互斥锁\",{\"1\":{\"205\":1}}],[\"既不存在于\",{\"1\":{\"205\":1}}],[\"尝试使用原子操作\",{\"1\":{\"205\":1}}],[\"尝试用\",{\"1\":{\"205\":1}}],[\"尝试在\",{\"1\":{\"205\":1}}],[\"尝试从\",{\"1\":{\"203\":1}}],[\"已经持久化\",{\"1\":{\"228\":1}}],[\"已经写入磁盘\",{\"1\":{\"227\":1}}],[\"已经提交的事务生成的\",{\"1\":{\"220\":1}}],[\"已经存在于\",{\"1\":{\"205\":1}}],[\"已经满了\",{\"1\":{\"82\":1}}],[\"计数重置为\",{\"1\":{\"204\":1}}],[\"计数小于脏数据的数量\",{\"1\":{\"204\":1}}],[\"计数\",{\"1\":{\"204\":1}}],[\"计算每个垃圾收集\",{\"1\":{\"102\":1}}],[\"未被修改\",{\"1\":{\"205\":1}}],[\"未命中的情况\",{\"1\":{\"204\":1}}],[\"未初始化的指针的零值是\",{\"1\":{\"147\":1}}],[\"晋升\",{\"1\":{\"204\":1}}],[\"记录对象访问信息\",{\"1\":{\"262\":1}}],[\"记录被修改前的数据\",{\"1\":{\"229\":1}}],[\"记录\",{\"1\":{\"229\":2}}],[\"记录还会进一步被分成一个个组\",{\"1\":{\"224\":1}}],[\"记录下来\",{\"1\":{\"220\":1}}],[\"记录中的两个隐藏列\",{\"1\":{\"219\":1,\"220\":1}}],[\"记录了某个数据页做了什么修改\",{\"1\":{\"228\":1}}],[\"记录了完成一条更新操作后\",{\"1\":{\"213\":1}}],[\"记录了此次事务\",{\"1\":{\"213\":2}}],[\"记录的是对数据页的物理修改操作\",{\"1\":{\"229\":1}}],[\"记录的是\",{\"1\":{\"213\":2}}],[\"记录和重放sql语句\",{\"1\":{\"213\":1}}],[\"记录一次\",{\"1\":{\"203\":1}}],[\"记录有多少次请求打到了\",{\"1\":{\"190\":1}}],[\"九\",{\"0\":{\"202\":1}}],[\"拿锁去操作的协程需要一直等待这个线性时间复杂度的过程完成\",{\"1\":{\"201\":1}}],[\"性能最好\",{\"1\":{\"237\":1}}],[\"性能最差了\",{\"1\":{\"237\":1}}],[\"性能\",{\"1\":{\"231\":1}}],[\"性能没那么好\",{\"1\":{\"201\":1}}],[\"性能问题\",{\"1\":{\"194\":1}}],[\"八\",{\"0\":{\"201\":1}}],[\"七\",{\"0\":{\"200\":1}}],[\"完全可靠是不可能的\",{\"1\":{\"255\":1}}],[\"完之后\",{\"1\":{\"199\":1}}],[\"完成后\",{\"1\":{\"213\":1}}],[\"完成了更新操作\",{\"1\":{\"198\":1}}],[\"完成\",{\"1\":{\"189\":1}}],[\"改为对于的\",{\"1\":{\"198\":1}}],[\"操作系统才会触发缺页中断\",{\"1\":{\"224\":1}}],[\"操作结束\",{\"1\":{\"203\":1}}],[\"操作无锁完成\",{\"1\":{\"200\":1}}],[\"操作\",{\"1\":{\"198\":1,\"224\":1,\"227\":1,\"231\":1,\"235\":1,\"243\":2}}],[\"操作在\",{\"1\":{\"198\":1}}],[\"操作揽下大部分操作\",{\"1\":{\"186\":1}}],[\"画个图理解一下\",{\"1\":{\"197\":1}}],[\"画图表示\",{\"1\":{\"117\":1}}],[\"状态设置为\",{\"1\":{\"241\":1}}],[\"状态是由\",{\"1\":{\"199\":1}}],[\"状态是为了优化\",{\"1\":{\"198\":1}}],[\"状态\",{\"0\":{\"198\":1,\"199\":1},\"1\":{\"197\":2,\"199\":2,\"205\":1}}],[\"正常关闭时\",{\"1\":{\"232\":1}}],[\"正常的\",{\"1\":{\"197\":1}}],[\"正常值\",{\"1\":{\"197\":1}}],[\"六\",{\"0\":{\"195\":1}}],[\"依靠\",{\"1\":{\"267\":1}}],[\"依旧是泥牛入海\",{\"1\":{\"248\":1}}],[\"依赖的是不同的\",{\"1\":{\"194\":1}}],[\"依次调度\",{\"1\":{\"82\":1}}],[\"请求\",{\"1\":{\"193\":1}}],[\"请求流程\",{\"1\":{\"186\":1}}],[\"置为\",{\"1\":{\"192\":1}}],[\"让这个\",{\"1\":{\"198\":1}}],[\"让这些请求到了\",{\"1\":{\"192\":1}}],[\"让一组可复用的函数运行在一组线程之上\",{\"1\":{\"86\":1}}],[\"很多次没有挡住请求\",{\"1\":{\"192\":1}}],[\"去竞争同一项资源\",{\"1\":{\"246\":1}}],[\"去读\",{\"1\":{\"237\":1}}],[\"去\",{\"1\":{\"198\":1}}],[\"去处理\",{\"1\":{\"190\":1}}],[\"去完成对变量的操作\",{\"1\":{\"186\":1}}],[\"保存的是全量的日志\",{\"1\":{\"235\":1}}],[\"保证持久化\",{\"1\":{\"221\":1}}],[\"保证事务的持久性\",{\"1\":{\"213\":1}}],[\"保证事务的原子性和一致性\",{\"1\":{\"213\":1}}],[\"保证了事务中的持久性\",{\"1\":{\"213\":1}}],[\"保证了事务中的原子性\",{\"1\":{\"213\":1}}],[\"保证宿主机的网络报文若发往\",{\"1\":{\"45\":1}}],[\"保证宿主机的网络报\",{\"1\":{\"45\":1}}],[\"保护对映射数据的并发访问\",{\"1\":{\"190\":1}}],[\"互斥性\",{\"0\":{\"251\":1},\"1\":{\"246\":1}}],[\"互斥锁\",{\"1\":{\"190\":1}}],[\"互相配合来提供一个拥有并发读写能力\",{\"1\":{\"186\":1}}],[\"字典\",{\"1\":{\"264\":1}}],[\"字段外\",{\"1\":{\"262\":1}}],[\"字段还是旧值\",{\"1\":{\"239\":1}}],[\"字段恢复到新值\",{\"1\":{\"239\":1}}],[\"字段中找到条目\",{\"1\":{\"203\":1}}],[\"字段是新值\",{\"1\":{\"239\":1}}],[\"字段是旧值\",{\"1\":{\"239\":1}}],[\"字段是否已经被提升为\",{\"1\":{\"203\":1}}],[\"字段是一个原子指针\",{\"1\":{\"190\":1,\"196\":1}}],[\"字段\",{\"1\":{\"190\":1,\"260\":1,\"267\":1}}],[\"字符串继续迭代读取\",{\"1\":{\"140\":1}}],[\"字符串的\",{\"1\":{\"129\":1}}],[\"字符串型\",{\"1\":{\"128\":1}}],[\"字符串类型对应一个16字节大小的结构体\",{\"1\":{\"129\":1}}],[\"字符串类型\",{\"1\":{\"124\":1}}],[\"验证并发安全\",{\"0\":{\"189\":1}}],[\"查询一条记录\",{\"1\":{\"224\":1}}],[\"查询到目标记录后\",{\"1\":{\"211\":1}}],[\"查询到的\",{\"1\":{\"193\":1}}],[\"查询缓存\",{\"1\":{\"210\":1}}],[\"查询执行\",{\"1\":{\"210\":1}}],[\"查询重写\",{\"1\":{\"210\":1}}],[\"查询优化\",{\"1\":{\"210\":1}}],[\"查询解析\",{\"1\":{\"210\":1}}],[\"查询元素\",{\"1\":{\"188\":1}}],[\"查看汇编代码\",{\"1\":{\"117\":1}}],[\"查看镜像的元数据\",{\"0\":{\"69\":1}}],[\"查看容器中进程的信息\",{\"0\":{\"68\":1}}],[\"查看容器的数据卷具体信息\",{\"0\":{\"36\":1}}],[\"查看日志\",{\"0\":{\"67\":1}}],[\"查看端口映射配置\",{\"0\":{\"40\":1}}],[\"查看指定数据卷的信息\",{\"0\":{\"31\":1}}],[\"查看所有数据卷\",{\"0\":{\"30\":1}}],[\"查看进程的父子关系\",{\"1\":{\"26\":1}}],[\"代表创建当前这个\",{\"1\":{\"220\":1}}],[\"代表硬删除\",{\"1\":{\"205\":1}}],[\"代表逻辑和内存里都不存在这个\",{\"1\":{\"197\":1}}],[\"代表\",{\"1\":{\"197\":1,\"198\":1}}],[\"代表的是\",{\"1\":{\"186\":1}}],[\"代码\",{\"0\":{\"75\":1,\"262\":1,\"264\":1,\"266\":1}}],[\"代码选择截图\",{\"1\":{\"13\":1}}],[\"代码视觉优化\",{\"0\":{\"8\":1}}],[\"找\",{\"1\":{\"186\":1}}],[\"删\",{\"1\":{\"186\":1,\"192\":1,\"200\":1}}],[\"删除\",{\"1\":{\"217\":1}}],[\"删除元素\",{\"1\":{\"188\":1}}],[\"删除从未被读取的局部变量\",{\"1\":{\"102\":1}}],[\"删除所有容器\",{\"1\":{\"63\":1}}],[\"删除全部容器\",{\"1\":{\"63\":1}}],[\"删除全部的镜像\",{\"1\":{\"58\":1}}],[\"删除容器\",{\"0\":{\"63\":1},\"1\":{\"63\":1}}],[\"删除多个镜像\",{\"1\":{\"58\":1}}],[\"删除指定的镜像\",{\"1\":{\"58\":1}}],[\"删除镜像\",{\"0\":{\"58\":1}}],[\"删除数据卷\",{\"0\":{\"33\":1}}],[\"更新数据\",{\"1\":{\"237\":1}}],[\"更新本地存储的数据\",{\"1\":{\"237\":1}}],[\"更新了\",{\"1\":{\"203\":1}}],[\"更新的操作流量\",{\"1\":{\"192\":1}}],[\"更新元素\",{\"1\":{\"188\":1}}],[\"更新\",{\"1\":{\"186\":1,\"200\":1,\"205\":1,\"213\":2,\"217\":1}}],[\"更新指的是更新已有数据\",{\"1\":{\"186\":1}}],[\"更深的理解\",{\"1\":{\"157\":1}}],[\"减少\",{\"1\":{\"186\":1}}],[\"原子性问题\",{\"1\":{\"248\":1}}],[\"原数据\",{\"1\":{\"239\":1}}],[\"原因\",{\"1\":{\"185\":1}}],[\"原本是局部指针变量\",{\"1\":{\"106\":1}}],[\"读提交隔离级别\",{\"1\":{\"219\":1}}],[\"读提交\",{\"1\":{\"219\":1}}],[\"读不到\",{\"1\":{\"198\":1}}],[\"读到\",{\"1\":{\"198\":1}}],[\"读\",{\"0\":{\"203\":1,\"206\":1},\"1\":{\"185\":1,\"186\":1,\"192\":1,\"198\":1,\"200\":1}}],[\"写磁盘成功\",{\"1\":{\"241\":1}}],[\"写满一个文件\",{\"1\":{\"235\":1}}],[\"写到暂存日志中\",{\"1\":{\"237\":1}}],[\"写到末尾就又回到开头\",{\"1\":{\"233\":1}}],[\"写到\",{\"1\":{\"232\":1,\"236\":1}}],[\"写入文件\",{\"1\":{\"243\":1}}],[\"写入到\",{\"1\":{\"241\":2}}],[\"写入binlog文件的过程还可以继续拆分\",{\"1\":{\"236\":1}}],[\"写入速度较慢\",{\"1\":{\"230\":1}}],[\"写入\",{\"1\":{\"224\":1,\"237\":2}}],[\"写入等操作\",{\"1\":{\"210\":1}}],[\"写操作到来\",{\"1\":{\"199\":1}}],[\"写两个操作\",{\"1\":{\"198\":1}}],[\"写请求是要通过加锁到\",{\"1\":{\"193\":1}}],[\"写指的是新增数据\",{\"1\":{\"186\":1}}],[\"写\",{\"0\":{\"205\":1},\"1\":{\"185\":1,\"186\":1,\"198\":1}}],[\"写文件路径时\",{\"1\":{\"10\":1}}],[\"给了运维更多时间来修复\",{\"1\":{\"254\":1}}],[\"给锁加上\",{\"1\":{\"249\":1}}],[\"给每一个处理线程分配了一片内存用于缓冲\",{\"1\":{\"236\":1}}],[\"给每个协程加上一行打印语句\",{\"1\":{\"185\":1}}],[\"给\",{\"1\":{\"199\":2}}],[\"给控制变量增量或减量\",{\"1\":{\"139\":1}}],[\"给控制变量赋初值\",{\"1\":{\"139\":1}}],[\"盲点\",{\"0\":{\"185\":1}}],[\"阻塞主线程\",{\"1\":{\"184\":1,\"185\":1}}],[\"初始化一个\",{\"1\":{\"184\":1,\"185\":1}}],[\"初始化切片容量的时候\",{\"1\":{\"109\":1}}],[\"报错\",{\"1\":{\"184\":1}}],[\"源码日志\",{\"1\":{\"258\":1}}],[\"源码走读\",{\"0\":{\"202\":1}}],[\"源码学习\",{\"1\":{\"182\":1}}],[\"源代码被\",{\"1\":{\"99\":1}}],[\"添加\",{\"1\":{\"266\":1}}],[\"添加元素\",{\"1\":{\"188\":1}}],[\"添加string\",{\"1\":{\"179\":2}}],[\"添加到\",{\"1\":{\"45\":1}}],[\"又是被如何组织管理的呢\",{\"1\":{\"262\":1}}],[\"又不想修改user结构体\",{\"1\":{\"178\":1}}],[\"又可以指向一个\",{\"1\":{\"82\":1}}],[\"蓝球\",{\"1\":{\"177\":1}}],[\"匿名嵌套\",{\"1\":{\"178\":1}}],[\"匿名嵌套profile时序列化后的json串为单层的\",{\"1\":{\"177\":1}}],[\"匿名字段的方法可以被外部结构体重写\",{\"1\":{\"152\":1}}],[\"篮球\",{\"1\":{\"177\":4}}],[\"足球\",{\"1\":{\"177\":5}}],[\"说句题外话\",{\"1\":{\"176\":1}}],[\"说明遍历\",{\"1\":{\"141\":1}}],[\"说明\",{\"1\":{\"44\":1,\"59\":1}}],[\"忽略该字段\",{\"1\":{\"177\":1}}],[\"忽略嵌套结构体空值字段\",{\"0\":{\"177\":1}}],[\"忽略空值字段\",{\"0\":{\"175\":1}}],[\"忽略某个字段\",{\"0\":{\"174\":1}}],[\"键值的内存释放函数\",{\"1\":{\"264\":1}}],[\"键值对\",{\"1\":{\"259\":1}}],[\"键值对初始化\",{\"0\":{\"135\":1}}],[\"键不会被重复访问\",{\"1\":{\"206\":1}}],[\"键与值使用冒号分隔\",{\"1\":{\"172\":1}}],[\"总结来说\",{\"1\":{\"210\":1}}],[\"总结\",{\"1\":{\"172\":1}}],[\"`json\",{\"1\":{\"173\":1,\"174\":2,\"175\":3,\"176\":3,\"177\":17,\"178\":3,\"179\":2}}],[\"`\",{\"1\":{\"172\":1,\"173\":1,\"174\":2,\"175\":3,\"176\":3,\"177\":17,\"178\":3,\"179\":4}}],[\"`key1\",{\"1\":{\"172\":1}}],[\"具体如下\",{\"1\":{\"241\":1}}],[\"具体细节往下看\",{\"1\":{\"229\":1}}],[\"具体来说\",{\"1\":{\"229\":1}}],[\"具体的配合过程\",{\"1\":{\"229\":1}}],[\"具体的格式如下\",{\"1\":{\"172\":1}}],[\"具有便于实施优化和生成机器代码的特性\",{\"1\":{\"101\":1}}],[\"反序列化时忽略此字段\",{\"1\":{\"174\":1}}],[\"反序列化时使用小写name\",{\"1\":{\"173\":1,\"174\":1}}],[\"反序列化的时候忽略掉结构体中的某个字段\",{\"1\":{\"174\":1}}],[\"反序列化\",{\"0\":{\"171\":1}}],[\"序列化结果中没有email和hobby字段\",{\"1\":{\"176\":1}}],[\"序列化的时候不会忽略这些字段\",{\"1\":{\"175\":1}}],[\"序列化与反序列化默认情况下使用结构体的字段名\",{\"1\":{\"173\":1}}],[\"序列化\",{\"0\":{\"171\":1}}],[\"恢复后调用当数结束\",{\"1\":{\"167\":1}}],[\"点\",{\"1\":{\"167\":1}}],[\"跳出函数\",{\"1\":{\"167\":1}}],[\"跳出条件选择\",{\"1\":{\"138\":1}}],[\"迟迟没有recover\",{\"1\":{\"167\":1}}],[\"直到交换成功或者entry被移除\",{\"1\":{\"205\":1}}],[\"直到某层被recover后\",{\"1\":{\"167\":1}}],[\"直接假设5台机器都发生了时钟漂移\",{\"1\":{\"255\":1}}],[\"直接用redis的setnx命令\",{\"1\":{\"247\":1}}],[\"直接持久化到磁盘\",{\"1\":{\"232\":2}}],[\"直接读取缓存中的记录\",{\"1\":{\"223\":1}}],[\"直接返回\",{\"1\":{\"198\":1}}],[\"直接切换引用可以避免这些性能问题\",{\"1\":{\"194\":1}}],[\"直接使用索引获取原来的元素\",{\"1\":{\"141\":1}}],[\"直接按照\",{\"1\":{\"136\":1}}],[\"直接通信\",{\"1\":{\"43\":1}}],[\"往外传递\",{\"1\":{\"167\":1}}],[\"若找到\",{\"1\":{\"203\":1}}],[\"若连\",{\"1\":{\"203\":1}}],[\"若在\",{\"1\":{\"203\":1}}],[\"若在当前的函数体没有recover\",{\"1\":{\"167\":1}}],[\"若\",{\"1\":{\"203\":2}}],[\"若希望从某个case开始按顺序往下执行\",{\"1\":{\"138\":1}}],[\"捕获后当前函数体的剩余代码不再执行\",{\"1\":{\"167\":1}}],[\"捕获异常\",{\"1\":{\"166\":1}}],[\"捕获\",{\"1\":{\"166\":1,\"167\":1,\"183\":1}}],[\"捕获方式\",{\"0\":{\"166\":1}}],[\"配合场景\",{\"1\":{\"229\":1}}],[\"配合\",{\"0\":{\"163\":1}}],[\"配置自己的\",{\"1\":{\"44\":2,\"47\":1}}],[\"配置\",{\"0\":{\"1\":1,\"2\":1},\"1\":{\"44\":2,\"48\":1,\"242\":1},\"2\":{\"15\":1,\"169\":1}}],[\"避免锁因为异常永远不被释放\",{\"1\":{\"246\":1}}],[\"避免加锁访问\",{\"1\":{\"205\":1}}],[\"避免了加锁访问\",{\"1\":{\"198\":1}}],[\"避免遗漏资源回收\",{\"1\":{\"162\":1}}],[\"避免变量大小不能确定的时候\",{\"1\":{\"109\":1}}],[\"优雅处理字符串格式的数字\",{\"0\":{\"179\":1}}],[\"优雅解决资源回收问题\",{\"1\":{\"162\":1}}],[\"优化查询\",{\"1\":{\"210\":1}}],[\"优化的先删后写场景和无锁完成删操作\",{\"1\":{\"200\":1}}],[\"优化乘法和浮点运算\",{\"1\":{\"101\":1}}],[\"优化器会生成多个执行计划\",{\"1\":{\"210\":1}}],[\"优化器可能会对解析树进行重写\",{\"1\":{\"210\":1}}],[\"优化器\",{\"1\":{\"97\":1}}],[\"延迟调用\",{\"1\":{\"162\":1}}],[\"资源的释放\",{\"0\":{\"162\":1}}],[\"嵌套接口\",{\"1\":{\"159\":1}}],[\"嵌入\",{\"1\":{\"150\":2}}],[\"xid\",{\"1\":{\"241\":2}}],[\"xa\",{\"1\":{\"241\":6}}],[\"x\",{\"1\":{\"157\":5}}],[\"xxx\",{\"1\":{\"106\":1,\"227\":1}}],[\"格式\",{\"1\":{\"157\":1,\"228\":1}}],[\"格式可以对\",{\"1\":{\"140\":1}}],[\"要不全部失败\",{\"1\":{\"240\":1}}],[\"要把被更新的列的旧值记下来\",{\"1\":{\"217\":1}}],[\"要把这条记录中的内容都记下来\",{\"1\":{\"217\":1}}],[\"要把这条记录的主键值记下来\",{\"1\":{\"217\":1}}],[\"要把回滚时需要的信息都记录到\",{\"1\":{\"217\":1}}],[\"要怎么回滚到事务之前的数据呢\",{\"1\":{\"215\":1}}],[\"要实现一个相对可靠的分布式锁机制\",{\"1\":{\"255\":1}}],[\"要实现外部接口\",{\"1\":{\"159\":1}}],[\"要实现\",{\"1\":{\"157\":1}}],[\"要显示的日志条数\",{\"1\":{\"67\":1}}],[\"断言原理\",{\"0\":{\"157\":1}}],[\"断言陷阱\",{\"0\":{\"156\":1}}],[\"定义两个简单的接口\",{\"1\":{\"159\":1}}],[\"定义一个函数\",{\"1\":{\"158\":1}}],[\"定义一个接口\",{\"1\":{\"158\":1}}],[\"定义一个结构体\",{\"1\":{\"154\":1,\"158\":2}}],[\"定义接口b\",{\"1\":{\"154\":1}}],[\"定义接口a\",{\"1\":{\"154\":1}}],[\"定义方式\",{\"1\":{\"128\":1}}],[\"相当于锁被自行释放了\",{\"1\":{\"250\":1}}],[\"相当于一个环形\",{\"1\":{\"233\":1}}],[\"相当于dirty的压力++\",{\"1\":{\"203\":1}}],[\"相当于\",{\"1\":{\"150\":1}}],[\"相当于nohup\",{\"1\":{\"60\":1}}],[\"差不多意思\",{\"1\":{\"150\":1}}],[\"自然是再上一层的抽象\",{\"1\":{\"264\":1}}],[\"自然是dict\",{\"1\":{\"262\":1}}],[\"自然就不存在父类子类一说\",{\"1\":{\"149\":1}}],[\"自己的缓存\",{\"1\":{\"229\":1}}],[\"自增\",{\"1\":{\"204\":1}}],[\"自定义方法的位置\",{\"0\":{\"149\":1}}],[\"自定义方法\",{\"1\":{\"148\":1}}],[\"必须在同一个包下\",{\"1\":{\"149\":1}}],[\"必须是内置函数\",{\"1\":{\"129\":1}}],[\"⚠️注意\",{\"1\":{\"157\":1}}],[\"⚠️\",{\"1\":{\"149\":1}}],[\"⚠️值列表的个数必须\",{\"1\":{\"136\":1}}],[\"你怎么知道gc回来了\",{\"1\":{\"255\":1}}],[\"你可以对指针进行算术运算\",{\"1\":{\"148\":1}}],[\"你只能将它指向\",{\"1\":{\"147\":1}}],[\"包含\",{\"1\":{\"204\":1}}],[\"包中定义的一个特殊类型\",{\"1\":{\"148\":1}}],[\"包中的\",{\"0\":{\"148\":1},\"1\":{\"148\":1}}],[\"包允许你绕过\",{\"1\":{\"148\":1}}],[\"包括哈希函数\",{\"1\":{\"264\":1}}],[\"包括何时修改\",{\"1\":{\"229\":1}}],[\"包括表和列是否存在\",{\"1\":{\"210\":1}}],[\"包括\",{\"1\":{\"132\":1,\"259\":1}}],[\"包括镜像和容器的数量\",{\"1\":{\"53\":1}}],[\"零值\",{\"1\":{\"147\":1}}],[\"限制\",{\"1\":{\"147\":1}}],[\"简单视角理解\",{\"1\":{\"263\":1}}],[\"简单来说\",{\"1\":{\"224\":1,\"263\":1}}],[\"简单的示例\",{\"1\":{\"146\":1}}],[\"简而言之\",{\"1\":{\"199\":1,\"227\":1}}],[\"简介\",{\"0\":{\"186\":1}}],[\"简化版\",{\"1\":{\"82\":1}}],[\"叫\",{\"1\":{\"144\":1}}],[\"映射\",{\"1\":{\"144\":1}}],[\"映射到指定地址的任意端口\",{\"1\":{\"39\":1}}],[\"映射到指定地址的指定端口\",{\"1\":{\"39\":1}}],[\"循环写\",{\"1\":{\"233\":1}}],[\"循环写重做日志文件组是以\",{\"1\":{\"233\":1}}],[\"循环迭代的是切片在迭代开始时的状态\",{\"1\":{\"141\":1}}],[\"循环在开始前就已经确定了切片的长度\",{\"1\":{\"141\":1}}],[\"循环会在完成遍历原本切片长度后停止\",{\"1\":{\"141\":1}}],[\"循环终止问题\",{\"1\":{\"141\":1}}],[\"循环控制条件\",{\"1\":{\"139\":1}}],[\"拷贝\",{\"1\":{\"141\":1}}],[\"怎么实现\",{\"1\":{\"141\":1,\"150\":1}}],[\"希望得到\",{\"1\":{\"141\":1}}],[\"元素的时候\",{\"1\":{\"141\":1}}],[\"分布式系统的三困境\",{\"1\":{\"255\":1}}],[\"分布式锁也就失去了意义\",{\"1\":{\"249\":1}}],[\"分布式锁\",{\"1\":{\"246\":1,\"249\":1}}],[\"分布式锁就是分布式场景下的锁\",{\"1\":{\"246\":1}}],[\"分两阶段来完成\",{\"1\":{\"241\":1}}],[\"分别是准备\",{\"1\":{\"240\":1}}],[\"分别是\",{\"1\":{\"233\":1}}],[\"分析\",{\"1\":{\"141\":1}}],[\"分配空间并标记\",{\"1\":{\"205\":1}}],[\"分配给一个个函数的栈空间被称为函数栈帧\",{\"1\":{\"114\":1}}],[\"分配大对象\",{\"1\":{\"105\":1}}],[\"分配到工作线程上\",{\"1\":{\"92\":1}}],[\"分配\",{\"1\":{\"86\":1}}],[\"取不到所有元素的地址\",{\"1\":{\"141\":1}}],[\"坑\",{\"1\":{\"141\":2}}],[\"陷阱\",{\"0\":{\"141\":1}}],[\"返回0\",{\"1\":{\"247\":1}}],[\"返回结果\",{\"1\":{\"210\":1}}],[\"返回旧值和\",{\"1\":{\"205\":1}}],[\"返回\",{\"1\":{\"203\":1,\"205\":3}}],[\"返回存储的值和一个布尔值\",{\"1\":{\"203\":1}}],[\"返回的其实是一个地址\",{\"1\":{\"160\":1}}],[\"返回值\",{\"1\":{\"140\":1}}],[\"返回给\",{\"1\":{\"140\":1}}],[\"部分\",{\"1\":{\"140\":1}}],[\"详细分析看\",{\"1\":{\"140\":1}}],[\"详细如下\",{\"1\":{\"82\":1}}],[\"覆盖写入\",{\"1\":{\"140\":1}}],[\"覆盖网络\",{\"1\":{\"44\":1}}],[\"理解panic的传递\",{\"1\":{\"166\":1}}],[\"理解\",{\"0\":{\"139\":1}}],[\"表现为👇\",{\"1\":{\"261\":1}}],[\"表明数据对象的底层编码方式\",{\"1\":{\"260\":1}}],[\"表明是哪种\",{\"1\":{\"260\":1}}],[\"表名\",{\"1\":{\"239\":1}}],[\"表扫描的方式\",{\"1\":{\"210\":1}}],[\"表示每次提交事务都\",{\"1\":{\"236\":1}}],[\"表示每次提交事务都会\",{\"1\":{\"236\":1}}],[\"表示每次提交事务都只\",{\"1\":{\"236\":1}}],[\"表示生成该版本记录的活跃事务已经被提交\",{\"1\":{\"220\":1}}],[\"表示生成该版本记录的活跃事务依然活跃着\",{\"1\":{\"220\":1}}],[\"表示这个版本的记录是在创建\",{\"1\":{\"220\":2}}],[\"表示在生成当前\",{\"1\":{\"220\":2}}],[\"表示加载了新值\",{\"1\":{\"205\":2}}],[\"表示已经加载\",{\"1\":{\"205\":1}}],[\"表示没有加载任何值\",{\"1\":{\"205\":1}}],[\"表示查找成功\",{\"1\":{\"203\":1}}],[\"表示硬删除\",{\"1\":{\"199\":1}}],[\"表示硬删除状态\",{\"1\":{\"197\":1}}],[\"表示当前\",{\"1\":{\"198\":1}}],[\"表示软删除状态\",{\"1\":{\"197\":1}}],[\"表示接受任何类型的参数\",{\"1\":{\"155\":1}}],[\"表示\",{\"1\":{\"146\":2}}],[\"表达性强\",{\"1\":{\"137\":1}}],[\"表配置与宿主机通信\",{\"1\":{\"44\":1}}],[\"处于gc执行中\",{\"1\":{\"255\":1}}],[\"处于这个模式下的\",{\"1\":{\"47\":1}}],[\"处理大事务时不必写入磁盘\",{\"1\":{\"231\":1}}],[\"处理\",{\"0\":{\"163\":1},\"1\":{\"186\":2,\"204\":1}}],[\"处理map的时候可以用多重赋值写法\",{\"1\":{\"137\":1}}],[\"允许函数接受数量可变的参数\",{\"1\":{\"146\":1}}],[\"允许后空缺\",{\"1\":{\"136\":1}}],[\"允许使用鼠标滚轮进行编辑器字体缩放\",{\"1\":{\"3\":1}}],[\"且按顺序\",{\"1\":{\"136\":1}}],[\"值<事务readview\",{\"1\":{\"220\":1}}],[\"值<=记录的\",{\"1\":{\"220\":1}}],[\"值>=记录的\",{\"1\":{\"220\":1}}],[\"值\",{\"1\":{\"198\":1,\"199\":1,\"220\":2}}],[\"值用双引号括起来\",{\"1\":{\"172\":1}}],[\"值传递意味着每次函数调用时都会\",{\"1\":{\"143\":1}}],[\"值传递时\",{\"1\":{\"142\":1}}],[\"值列表初始化\",{\"0\":{\"136\":1}}],[\"值的方式完成\",{\"1\":{\"135\":1}}],[\"清零a中\",{\"1\":{\"134\":1}}],[\"位清除\",{\"1\":{\"134\":1}}],[\"位运算符是对内存中的二进制数进行按位运算\",{\"1\":{\"132\":1}}],[\"位运算符\",{\"0\":{\"132\":1},\"1\":{\"130\":1}}],[\"由\",{\"1\":{\"233\":1}}],[\"由后台线程将缓存在\",{\"1\":{\"227\":1}}],[\"由一对反引号包裹起来\",{\"1\":{\"172\":1}}],[\"由上至下代表优先级由高到低\",{\"1\":{\"133\":1}}],[\"由于加锁是一半以上同意就成功\",{\"1\":{\"254\":1}}],[\"由于向5个redis发送请求\",{\"1\":{\"254\":1}}],[\"由于业务流程比较长\",{\"1\":{\"249\":1}}],[\"由于意外崩溃而导致未能主动解锁\",{\"1\":{\"246\":1}}],[\"由于是先申请了一片连续的内存空间但没写入具体数据\",{\"1\":{\"224\":1}}],[\"由于main是最上层函数\",{\"1\":{\"117\":1}}],[\"由于变量的值不能在编译器确定\",{\"1\":{\"109\":1}}],[\"由于指针传递会逃逸\",{\"1\":{\"106\":1}}],[\"由于\",{\"1\":{\"82\":1,\"167\":2,\"239\":2}}],[\"^\",{\"1\":{\"132\":1,\"134\":3}}],[\"赋值运算符\",{\"1\":{\"130\":1}}],[\"逻辑运算符\",{\"0\":{\"131\":1},\"1\":{\"130\":1}}],[\"算术运算符\",{\"1\":{\"130\":1}}],[\"运算符优先级\",{\"0\":{\"133\":1}}],[\"运算符大体上也分为以下几种\",{\"1\":{\"130\":1}}],[\"运行完\",{\"1\":{\"86\":1}}],[\"运行一个容器并加入到\",{\"1\":{\"41\":1}}],[\"运行\",{\"1\":{\"20\":1}}],[\"关键点6\",{\"1\":{\"236\":1}}],[\"关键点5\",{\"1\":{\"236\":1}}],[\"关键点4\",{\"1\":{\"236\":1}}],[\"关键点3\",{\"1\":{\"236\":1}}],[\"关键点2\",{\"1\":{\"236\":1}}],[\"关键点1\",{\"1\":{\"236\":1}}],[\"关键字时会发生什么\",{\"1\":{\"161\":1}}],[\"关键字出现时将被重置为\",{\"1\":{\"130\":1}}],[\"关注这三个结构体\",{\"1\":{\"190\":1}}],[\"关系表达式或逻辑表达式\",{\"1\":{\"139\":1}}],[\"关系运算符\",{\"1\":{\"130\":1}}],[\"关于\",{\"0\":{\"0\":1},\"1\":{\"186\":1}}],[\"结果发送\",{\"1\":{\"210\":1}}],[\"结果集处理\",{\"1\":{\"210\":1}}],[\"结果返回\",{\"1\":{\"210\":1}}],[\"结构中\",{\"1\":{\"268\":1}}],[\"结构有一个\",{\"1\":{\"267\":1}}],[\"结构\",{\"0\":{\"260\":1,\"263\":1,\"265\":1},\"1\":{\"268\":1}}],[\"结构体tag由一个或多个键值对组成\",{\"1\":{\"172\":1}}],[\"结构体tag介绍\",{\"0\":{\"172\":1}}],[\"结构体\",{\"1\":{\"150\":1,\"203\":1}}],[\"结构体和数组也是按值传递的\",{\"1\":{\"145\":1}}],[\"结构体和数组\",{\"0\":{\"145\":1}}],[\"结构体属性个数\",{\"1\":{\"136\":1}}],[\"结构字段\",{\"1\":{\"121\":1}}],[\"结论\",{\"1\":{\"129\":1}}],[\"解决方案的场景\",{\"1\":{\"227\":1}}],[\"解决方案\",{\"1\":{\"227\":1,\"233\":1}}],[\"解锁\",{\"1\":{\"203\":1}}],[\"解释\",{\"1\":{\"129\":1}}],[\"解析语句\",{\"1\":{\"210\":1}}],[\"解析\",{\"1\":{\"99\":1,\"167\":1}}],[\"解析器\",{\"1\":{\"99\":1}}],[\"枚举一般用常量表示\",{\"1\":{\"129\":1}}],[\"错误\",{\"1\":{\"128\":1}}],[\"👇等价👇\",{\"1\":{\"128\":1}}],[\"复活\",{\"1\":{\"205\":1}}],[\"复制大数据量的\",{\"1\":{\"194\":1}}],[\"复制是在栈上完成的操作\",{\"1\":{\"109\":1}}],[\"复数型\",{\"1\":{\"128\":1}}],[\"浮点型\",{\"1\":{\"128\":1}}],[\"整合了写和更新操作\",{\"1\":{\"205\":1}}],[\"整个集群还是可用的\",{\"1\":{\"254\":1}}],[\"整个数据库还有哪些其他活着的事务\",{\"1\":{\"220\":1}}],[\"整个\",{\"1\":{\"194\":1}}],[\"整个循环都是用这一个\",{\"1\":{\"141\":1}}],[\"整数型\",{\"1\":{\"128\":1}}],[\"整体架构采用\",{\"1\":{\"22\":1}}],[\"布尔型\",{\"1\":{\"128\":1}}],[\"生命周期是程序存活时间\",{\"1\":{\"127\":1}}],[\"生成的\",{\"1\":{\"229\":1}}],[\"生成的日志\",{\"1\":{\"213\":1}}],[\"生成最终的结果集\",{\"1\":{\"210\":1}}],[\"生成一个解析树\",{\"1\":{\"210\":1}}],[\"生成一个\",{\"1\":{\"160\":1}}],[\"生成机器码\",{\"1\":{\"102\":1}}],[\"生成\",{\"0\":{\"101\":1}}],[\"切片\",{\"1\":{\"124\":1,\"144\":1}}],[\"切换出来\",{\"1\":{\"82\":1}}],[\"空闲空间\",{\"1\":{\"224\":1}}],[\"空间换时间\",{\"1\":{\"200\":1}}],[\"空接口\",{\"0\":{\"155\":1}}],[\"空字符串\",{\"1\":{\"124\":1}}],[\"空格分隔\",{\"1\":{\"58\":1}}],[\"数量较多的时候\",{\"1\":{\"201\":1}}],[\"数组\",{\"1\":{\"140\":1}}],[\"数字型\",{\"1\":{\"128\":1}}],[\"数值类型\",{\"1\":{\"124\":1}}],[\"数据结构\",{\"1\":{\"264\":1}}],[\"数据对象\",{\"1\":{\"260\":1}}],[\"数据就会丢失\",{\"1\":{\"237\":1}}],[\"数据库id\",{\"1\":{\"266\":1}}],[\"数据库系统只需确保\",{\"1\":{\"227\":1}}],[\"数据库连接\",{\"1\":{\"162\":1}}],[\"数据页的写入通常是随机写入\",{\"1\":{\"230\":1}}],[\"数据页和\",{\"1\":{\"221\":1}}],[\"数据页\",{\"1\":{\"221\":1}}],[\"数据的双向流转\",{\"1\":{\"200\":1}}],[\"数据在逻辑上不存在\",{\"1\":{\"197\":1}}],[\"数据存在\",{\"1\":{\"197\":1}}],[\"数据隔离\",{\"1\":{\"194\":1}}],[\"数据卷是一个可供一个或多个容器使用的特殊目录\",{\"1\":{\"28\":1}}],[\"数据卷\",{\"0\":{\"28\":1},\"1\":{\"27\":1,\"28\":4,\"32\":3}}],[\"数据管理\",{\"0\":{\"27\":1}}],[\"单单从分布式锁本身出发\",{\"1\":{\"255\":1}}],[\"单个节点数据的丢失\",{\"1\":{\"254\":1}}],[\"单点redis的所有手段\",{\"1\":{\"254\":1}}],[\"单变量声明\",{\"0\":{\"124\":1}}],[\"单独使用\",{\"1\":{\"45\":1}}],[\"声明格式\",{\"1\":{\"125\":1}}],[\"声明变量\",{\"1\":{\"124\":1}}],[\"声明变量格式\",{\"1\":{\"123\":1}}],[\"声明和未使用\",{\"1\":{\"100\":1}}],[\"声明和陈述\",{\"1\":{\"99\":1}}],[\"首个字符不能是数字\",{\"1\":{\"123\":1}}],[\"首先会记录相应的\",{\"1\":{\"229\":1}}],[\"首先读取\",{\"1\":{\"203\":1}}],[\"首先来看几种结构体嵌套的示例\",{\"1\":{\"177\":1}}],[\"首先\",{\"1\":{\"105\":1,\"195\":1}}],[\"基于这个场景\",{\"1\":{\"249\":1}}],[\"基于这个特性\",{\"1\":{\"247\":1}}],[\"基本保证它们不会同时宕掉\",{\"1\":{\"254\":1}}],[\"基本是基于单机考虑的\",{\"1\":{\"252\":1}}],[\"基本的\",{\"0\":{\"188\":1}}],[\"基本数据类型也可以\",{\"1\":{\"148\":1}}],[\"基本类型\",{\"0\":{\"143\":1}}],[\"基本规范\",{\"0\":{\"123\":1}}],[\"基础理论\",{\"0\":{\"43\":1}}],[\"文件做\",{\"1\":{\"243\":1}}],[\"文件是记录了所有数据库表结构变更和表数据修改的日志\",{\"1\":{\"235\":1}}],[\"文件也被写满时\",{\"1\":{\"233\":1}}],[\"文件被写满的时候\",{\"1\":{\"233\":1}}],[\"文件过大怎么办\",{\"1\":{\"233\":1}}],[\"文件写满了\",{\"1\":{\"233\":1}}],[\"文件中\",{\"1\":{\"229\":1,\"236\":2}}],[\"文件的刷盘\",{\"1\":{\"227\":1}}],[\"文件\",{\"1\":{\"227\":1,\"232\":1,\"233\":4,\"235\":1,\"236\":1}}],[\"文件尾等\",{\"1\":{\"224\":1}}],[\"文件头\",{\"1\":{\"224\":1}}],[\"文件句柄的资源释放\",{\"1\":{\"162\":1}}],[\"文件夹名与包名\",{\"1\":{\"122\":1}}],[\"文件名与包名\",{\"1\":{\"122\":1}}],[\"文件结构\",{\"0\":{\"122\":1}}],[\"文可以发往\",{\"1\":{\"45\":1}}],[\"标识符\",{\"1\":{\"121\":1}}],[\"标识符大小写\",{\"0\":{\"121\":1}}],[\"标记该页为脏页\",{\"1\":{\"229\":1}}],[\"标记\",{\"1\":{\"190\":1}}],[\"标记还可以多次使用来绑定多个端口\",{\"1\":{\"39\":1}}],[\"标记来指定\",{\"1\":{\"39\":1}}],[\"标记来将\",{\"1\":{\"32\":1}}],[\"标记时\",{\"1\":{\"39\":1}}],[\"标记也可以从主机挂载单个文件到容器中\",{\"1\":{\"37\":1}}],[\"标记可以指定挂载一个本地主机的目录到容器中去\",{\"1\":{\"35\":1}}],[\"存有\",{\"1\":{\"266\":1}}],[\"存一条数据\",{\"1\":{\"261\":1}}],[\"存储含过期时间的\",{\"1\":{\"265\":1}}],[\"存储一些额外的数据\",{\"1\":{\"264\":1}}],[\"存储\",{\"1\":{\"259\":1,\"266\":1}}],[\"存储形式为\",{\"0\":{\"259\":1}}],[\"存储的一行行记录会被存放在这里\",{\"1\":{\"224\":1}}],[\"存储的是r1~r7这7个main函数的局部变量\",{\"1\":{\"117\":1}}],[\"存储引擎是参与者\",{\"1\":{\"241\":1}}],[\"存储引擎中\",{\"1\":{\"241\":1}}],[\"存储引擎有\",{\"1\":{\"233\":1}}],[\"存储引擎以16kb大小的页作为磁盘与内存交互的基本单位\",{\"1\":{\"224\":1}}],[\"存储引擎的日志\",{\"1\":{\"213\":1}}],[\"存储引擎根据执行器的请求进行数据的读取\",{\"1\":{\"210\":1}}],[\"存储引擎操作\",{\"1\":{\"210\":1}}],[\"存储引擎接口\",{\"1\":{\"210\":1}}],[\"存在的问题\",{\"1\":{\"249\":1,\"250\":1}}],[\"存在且value有效\",{\"1\":{\"203\":1}}],[\"存在\",{\"1\":{\"198\":1,\"201\":1}}],[\"存放\",{\"1\":{\"190\":1}}],[\"存入栈中\",{\"1\":{\"117\":1}}],[\"收回分配给main函数栈帧的128字节空间\",{\"1\":{\"117\":1}}],[\"寄存器ax将局部变量r7加入栈头sp+48指向的位置\",{\"1\":{\"117\":1}}],[\"寄存器ax将局部变量r6加入栈头sp+40指向的位置\",{\"1\":{\"117\":1}}],[\"寄存器ax将局部变量r4加入栈头sp+32指向的位置\",{\"1\":{\"117\":1}}],[\"寄存器ax将局部变量r4加入栈头sp+24指向的位置\",{\"1\":{\"117\":1}}],[\"寄存器ax将局部变量r3加入栈头sp+16指向的位置\",{\"1\":{\"117\":1}}],[\"寄存器ax将局部变量r2加入栈头sp+8指向的位置\",{\"1\":{\"117\":1}}],[\"寄存器ax将局部变量r1加入栈头sp指向的位置\",{\"1\":{\"117\":1}}],[\"小林coding\",{\"1\":{\"258\":1}}],[\"小林图解也有提到\",{\"1\":{\"224\":1}}],[\"小明\",{\"1\":{\"171\":3,\"175\":2,\"176\":1,\"177\":5,\"178\":2}}],[\"小于本地线程存储的栈顶地址\",{\"1\":{\"117\":1}}],[\"小写字母p\",{\"1\":{\"60\":1}}],[\"jay\",{\"1\":{\"239\":3}}],[\"join\",{\"1\":{\"210\":1}}],[\"john\",{\"1\":{\"150\":1}}],[\"j++\",{\"1\":{\"189\":3}}],[\"j\",{\"1\":{\"189\":10}}],[\"jls\",{\"1\":{\"117\":1}}],[\"jsonstr1\",{\"1\":{\"179\":3}}],[\"json包的用法\",{\"1\":{\"170\":1}}],[\"json包的使用\",{\"0\":{\"170\":1}}],[\"json\",{\"0\":{\"171\":1},\"1\":{\"3\":2,\"171\":6,\"175\":4,\"177\":2,\"178\":2,\"179\":2}}],[\"示例代码如下\",{\"1\":{\"178\":1}}],[\"示例代码\",{\"1\":{\"117\":1,\"140\":1}}],[\"寻址\",{\"1\":{\"117\":1}}],[\"偏移量offset\",{\"1\":{\"117\":1}}],[\"注意并不意味着写入到了磁盘\",{\"1\":{\"232\":1}}],[\"注意这里\",{\"1\":{\"176\":1}}],[\"注意此时的sp寄存器指向\",{\"1\":{\"117\":1}}],[\"注意\",{\"0\":{\"126\":1},\"1\":{\"116\":1,\"129\":1,\"166\":2,\"206\":1}}],[\"注意大小写\",{\"1\":{\"39\":1}}],[\"从上面了解到\",{\"1\":{\"262\":1}}],[\"从上面可以知道\",{\"1\":{\"193\":1}}],[\"从\",{\"1\":{\"243\":1}}],[\"从库执行了这条更新语句\",{\"1\":{\"239\":1}}],[\"从库的这一行\",{\"1\":{\"239\":1}}],[\"从库启动一个\",{\"1\":{\"237\":1}}],[\"从库连接到主库后\",{\"1\":{\"237\":1}}],[\"从头开始写\",{\"1\":{\"233\":1}}],[\"从理解\",{\"1\":{\"209\":1}}],[\"从而减少磁盘\",{\"1\":{\"243\":1}}],[\"从而保证多事务的情况下\",{\"1\":{\"242\":1}}],[\"从而提高写入速度\",{\"1\":{\"230\":1}}],[\"从而提高读写操作的性能和一致性\",{\"1\":{\"219\":1}}],[\"从而控制并发事务访问同一个记录时的行为\",{\"1\":{\"219\":1}}],[\"从而在某些情况下掩盖数据竞争的问题\",{\"1\":{\"185\":1}}],[\"从而改变\",{\"1\":{\"185\":1}}],[\"从而实现类似于继承中方法的覆盖\",{\"1\":{\"152\":1}}],[\"从高到低的布局\",{\"1\":{\"116\":1}}],[\"从容器内拷贝文件到主机\",{\"0\":{\"71\":1}}],[\"被删除了\",{\"1\":{\"198\":1}}],[\"被\",{\"1\":{\"186\":1}}],[\"被捕获了\",{\"1\":{\"167\":1}}],[\"被调用函数callee的返回值和参数\",{\"1\":{\"116\":1}}],[\"被调用函数就是\",{\"1\":{\"114\":1}}],[\"被调用者callee的栈帧\",{\"1\":{\"116\":1}}],[\"被调用者callee\",{\"1\":{\"114\":1}}],[\"被返回了引用\",{\"1\":{\"106\":1}}],[\"几个问题\",{\"0\":{\"112\":1}}],[\"应该尽量避免使用接口类型\",{\"1\":{\"109\":1}}],[\"<<\",{\"1\":{\"132\":1}}],[\"<\",{\"1\":{\"109\":1,\"184\":2,\"185\":2,\"189\":6,\"200\":1,\"204\":1}}],[\"<=\",{\"1\":{\"75\":1}}],[\"传到到函教参数\",{\"1\":{\"144\":1}}],[\"传入一个变量来指定其大小\",{\"1\":{\"109\":1}}],[\"传递结束\",{\"1\":{\"167\":1}}],[\"传递链\",{\"1\":{\"167\":1}}],[\"传递地址也是值传递\",{\"1\":{\"142\":1}}],[\"传递指针可以减少底层值拷贝\",{\"1\":{\"106\":1}}],[\"传递开始\",{\"1\":{\"102\":1}}],[\"传递与规则\",{\"1\":{\"101\":1}}],[\"变量类型不仅仅局限于结构体类型\",{\"1\":{\"148\":1}}],[\"变量的生命周期\",{\"0\":{\"127\":1}}],[\"变量默认为零值\",{\"1\":{\"124\":1}}],[\"变量命名\",{\"1\":{\"123\":1}}],[\"变量\",{\"1\":{\"121\":1}}],[\"变量大小不确定\",{\"0\":{\"109\":1}}],[\"变量捕获\",{\"1\":{\"100\":1}}],[\"动态类型逃逸\",{\"0\":{\"108\":1}}],[\"容灾能力\",{\"1\":{\"246\":1}}],[\"容易导致程序性能抖动\",{\"1\":{\"201\":1}}],[\"容量增大后\",{\"1\":{\"107\":1}}],[\"容器内路径\",{\"1\":{\"71\":1}}],[\"容器内部的服务端口也可以使用宿主机的端口\",{\"1\":{\"46\":1}}],[\"容器启动后\",{\"1\":{\"66\":1}}],[\"容器使用后台运行\",{\"1\":{\"66\":1}}],[\"容器id\",{\"1\":{\"63\":2,\"64\":4,\"67\":1,\"68\":1,\"69\":1,\"70\":2,\"71\":1}}],[\"容器不停止\",{\"1\":{\"62\":1}}],[\"容器直接停止\",{\"1\":{\"62\":1}}],[\"容器名字\",{\"1\":{\"60\":1}}],[\"容器命令\",{\"0\":{\"59\":1}}],[\"容器无网卡\",{\"1\":{\"48\":1}}],[\"容器会共享一个网络环境\",{\"1\":{\"47\":1}}],[\"容器将不会获得一个独立的\",{\"1\":{\"46\":1}}],[\"容器将不会虚拟出自己的网卡\",{\"1\":{\"44\":1}}],[\"容器之间也可以相互通信\",{\"1\":{\"45\":1}}],[\"容器的时候\",{\"1\":{\"45\":1}}],[\"容器的默认的网络模式\",{\"1\":{\"45\":1}}],[\"容器具备\",{\"1\":{\"44\":1}}],[\"容器和另外一个容器共享\",{\"1\":{\"44\":1}}],[\"容器和宿主机共享\",{\"1\":{\"44\":1}}],[\"容器端口\",{\"1\":{\"43\":1,\"60\":4}}],[\"容器网桥docker0\",{\"1\":{\"43\":1}}],[\"容器互联\",{\"0\":{\"41\":1}}],[\"容器有自己的\",{\"1\":{\"48\":1}}],[\"容器有自己独立的命名空间隔离和资源限制\",{\"1\":{\"20\":1}}],[\"容器有独立的\",{\"1\":{\"44\":1}}],[\"容器有初建\",{\"1\":{\"20\":1}}],[\"容器是镜像的运行实体\",{\"1\":{\"20\":1}}],[\"容器\",{\"0\":{\"18\":1},\"1\":{\"26\":1}}],[\"栈\",{\"1\":{\"165\":1}}],[\"栈收缩\",{\"1\":{\"117\":1}}],[\"栈溢出检测\",{\"1\":{\"117\":1}}],[\"栈顶寄存器\",{\"1\":{\"117\":1}}],[\"栈底寄存器\",{\"1\":{\"117\":1}}],[\"栈指针sp\",{\"1\":{\"117\":1}}],[\"栈和栈帧是不一样的\",{\"1\":{\"116\":1}}],[\"栈的增长方向是从高位地址到地位地址向下进行增长\",{\"1\":{\"114\":1}}],[\"栈空间变为\",{\"1\":{\"117\":1}}],[\"栈空间足够时\",{\"1\":{\"107\":1}}],[\"栈空间不足逃逸\",{\"0\":{\"107\":1}}],[\"栈上面的变量在函数结束的时候会自动回收\",{\"1\":{\"105\":1}}],[\"栈上的数据需要在函数结束之后还能被访问\",{\"1\":{\"105\":1}}],[\"尽量用\",{\"1\":{\"200\":1}}],[\"尽量的挡住\",{\"1\":{\"192\":1}}],[\"尽量在栈上分配内存\",{\"1\":{\"105\":1}}],[\"尽管在能符合分配到栈的场景\",{\"1\":{\"105\":1}}],[\"实际都是存储了\",{\"1\":{\"268\":1}}],[\"实际例子\",{\"0\":{\"261\":1}}],[\"实际使用的具体实现只能在运行时确定\",{\"1\":{\"105\":1}}],[\"实体\",{\"1\":{\"197\":1}}],[\"实在处理不了再去拿锁\",{\"1\":{\"186\":1}}],[\"实现方式\",{\"1\":{\"247\":1}}],[\"实现是用的最多的一种\",{\"1\":{\"246\":1}}],[\"实现\",{\"0\":{\"219\":1},\"1\":{\"158\":2}}],[\"实现了\",{\"1\":{\"158\":2}}],[\"实现接口\",{\"1\":{\"159\":1}}],[\"实现接口b的方法\",{\"1\":{\"154\":1}}],[\"实现接口a的方法\",{\"1\":{\"154\":1}}],[\"实现接口a和接口b\",{\"1\":{\"154\":1}}],[\"实现多个接口\",{\"0\":{\"154\":1}}],[\"实现容器网络环境的隔离性\",{\"1\":{\"45\":1}}],[\"实现宿主机到\",{\"1\":{\"45\":1}}],[\"实现的\",{\"1\":{\"44\":1}}],[\"调用其\",{\"1\":{\"203\":1}}],[\"调用链\",{\"1\":{\"167\":1}}],[\"调用栈\",{\"1\":{\"161\":1}}],[\"调用\",{\"1\":{\"117\":1}}],[\"调用者函数caller的局部变量\",{\"1\":{\"116\":1}}],[\"调用者caller栈基地址\",{\"1\":{\"116\":1}}],[\"调用者caller\",{\"1\":{\"114\":1}}],[\"调用接口类型的方法\",{\"1\":{\"105\":1}}],[\"调度器的功能是把可运行的\",{\"1\":{\"92\":1}}],[\"调度\",{\"1\":{\"86\":1,\"89\":1}}],[\"调度过程不仅仅只处理用户定义的协程\",{\"1\":{\"82\":1}}],[\"调度后\",{\"1\":{\"82\":1}}],[\"调度又会发生很多不同\",{\"1\":{\"82\":1}}],[\"逃逸到了堆\",{\"1\":{\"106\":1}}],[\"逃逸分析\",{\"1\":{\"100\":1}}],[\"逃到堆上\",{\"1\":{\"105\":1}}],[\"则会将key设置为value\",{\"1\":{\"247\":1}}],[\"则返回\",{\"1\":{\"205\":1}}],[\"则不需要采取进一步的操作\",{\"1\":{\"204\":1}}],[\"则为默认值\",{\"1\":{\"135\":1}}],[\"则跳到180处代码处进行栈分裂扩容操作\",{\"1\":{\"117\":1}}],[\"则在函数栈上\",{\"1\":{\"116\":1}}],[\"则必定放到堆中\",{\"1\":{\"105\":1}}],[\"则优先放到栈中\",{\"1\":{\"105\":1}}],[\"则立即会被\",{\"1\":{\"45\":1}}],[\"占用比较大的系统开销\",{\"1\":{\"105\":1}}],[\"堆分配内存\",{\"1\":{\"105\":1}}],[\"发生数据流转\",{\"1\":{\"204\":1}}],[\"发生了崩溃\",{\"1\":{\"215\":1}}],[\"发生了\",{\"1\":{\"167\":1}}],[\"发生了函数外引用\",{\"1\":{\"106\":1}}],[\"发生逃逸\",{\"1\":{\"107\":1}}],[\"发生逃逸的时机\",{\"1\":{\"105\":1}}],[\"发生内存逃逸\",{\"1\":{\"105\":1}}],[\"发现自己没有提供服务\",{\"1\":{\"66\":1}}],[\"发现没有应用\",{\"1\":{\"66\":1}}],[\"导致同一份资源频繁被不同竞争者同时访问\",{\"1\":{\"249\":1}}],[\"导致锁过期\",{\"1\":{\"249\":1}}],[\"导致程序直接被终止\",{\"1\":{\"183\":1}}],[\"导致栈空间不足\",{\"1\":{\"105\":1}}],[\"导致频繁的线程阻塞和取消阻塞操作增加了系统开销\",{\"1\":{\"89\":1}}],[\"导出数据和调试信息\",{\"1\":{\"102\":1}}],[\"装载器将它们转换为机器代码\",{\"1\":{\"102\":1}}],[\"便会启动最终的代码优化过程\",{\"1\":{\"102\":1}}],[\"至更贴近目标体系结构后\",{\"1\":{\"102\":1}}],[\"降低\",{\"1\":{\"102\":1}}],[\"底层数据结构\",{\"1\":{\"260\":1}}],[\"底层调用\",{\"1\":{\"205\":1}}],[\"底层还是使用的\",{\"1\":{\"190\":1}}],[\"底层\",{\"1\":{\"102\":1}}],[\"底层ssa和架构特定的传递\",{\"1\":{\"102\":1}}],[\"消除不必要的零值检查\",{\"1\":{\"101\":1}}],[\"因此无论这个事务有多大\",{\"1\":{\"236\":1}}],[\"因此\",{\"1\":{\"224\":1,\"242\":1,\"255\":1}}],[\"因此它们适用于所有的goarch变体\",{\"1\":{\"101\":1}}],[\"因为只要\",{\"1\":{\"241\":1}}],[\"因为只有一个\",{\"1\":{\"81\":1}}],[\"因为操作系统的文件系统中有个\",{\"1\":{\"232\":1}}],[\"因为这样会产生大量的\",{\"1\":{\"231\":1}}],[\"因为可能这期间另外一个事务修改了该记录\",{\"1\":{\"219\":1}}],[\"因为它有兜底完成\",{\"1\":{\"186\":1}}],[\"因为错误的类型转换可能会导致程序崩溃\",{\"1\":{\"148\":1}}],[\"因为go中接口类型的方法调用都是动态\",{\"1\":{\"109\":1}}],[\"因为其内存操作数具有这样的能力\",{\"1\":{\"102\":1}}],[\"因为设置了\",{\"1\":{\"82\":1}}],[\"因为\",{\"1\":{\"81\":1,\"89\":1,\"141\":1,\"149\":1}}],[\"因为在同一宿主机内的容器都接入同一个网桥\",{\"1\":{\"43\":1}}],[\"内容指针\",{\"1\":{\"262\":1}}],[\"内容的一致性\",{\"1\":{\"206\":1}}],[\"内核再通过\",{\"1\":{\"236\":1}}],[\"内核线程\",{\"1\":{\"82\":1}}],[\"内存空间的一半时\",{\"1\":{\"232\":1}}],[\"内存\",{\"1\":{\"186\":1}}],[\"内存位置\",{\"1\":{\"144\":1}}],[\"内部开启一个\",{\"1\":{\"241\":1}}],[\"内部\",{\"1\":{\"241\":3}}],[\"内部是如何组织数据的\",{\"1\":{\"224\":1}}],[\"内部使用了锁\",{\"1\":{\"185\":1}}],[\"内部结构体的字段和方法会被提升到外部结构体中\",{\"1\":{\"150\":1}}],[\"内部的第一行之前\",{\"1\":{\"130\":1}}],[\"内置的复制操作会被替换为内存移动操作\",{\"1\":{\"101\":1}}],[\"形式\",{\"1\":{\"101\":1}}],[\"抽象语法树\",{\"1\":{\"101\":1}}],[\"抽象语法树的构建\",{\"1\":{\"98\":1}}],[\"转换成一个可以比较的整数\",{\"1\":{\"148\":1}}],[\"转换为ssa\",{\"1\":{\"101\":1}}],[\"转移\",{\"1\":{\"89\":1}}],[\"转移到其他可运行的线程上\",{\"1\":{\"86\":1}}],[\"闭包处理\",{\"1\":{\"100\":1}}],[\"函数都没有\",{\"1\":{\"167\":1}}],[\"函数发生了\",{\"1\":{\"167\":1}}],[\"函数跳出返回到\",{\"1\":{\"167\":1}}],[\"函数并传入任意数量的\",{\"1\":{\"146\":1}}],[\"函数中\",{\"1\":{\"146\":1}}],[\"函数接受任意数量的\",{\"1\":{\"146\":1}}],[\"函数使用了可变参数语法\",{\"1\":{\"146\":1}}],[\"函数内部对副本的修改不会影响原始的结构体或数组\",{\"1\":{\"145\":1}}],[\"函数内联\",{\"1\":{\"100\":1}}],[\"函数名\",{\"1\":{\"121\":1}}],[\"函数没有占用栈空间而已\",{\"1\":{\"117\":1}}],[\"函数的汇编指令\",{\"1\":{\"117\":1}}],[\"函数参数完全通过栈传递\",{\"1\":{\"117\":1}}],[\"函数参数为interface\",{\"1\":{\"108\":1}}],[\"函数执行时供它存放局部变量\",{\"1\":{\"114\":1}}],[\"函数栈空间从高地址向低地址使用\",{\"1\":{\"117\":1}}],[\"函数栈空间布局如下\",{\"1\":{\"116\":1}}],[\"函数栈帧\",{\"1\":{\"114\":1,\"116\":1}}],[\"函数栈\",{\"1\":{\"114\":1}}],[\"函数调用基本概念\",{\"0\":{\"114\":1}}],[\"函数调用内联和转义分析\",{\"1\":{\"100\":1}}],[\"函数运行完毕后回收内存\",{\"1\":{\"105\":1}}],[\"函数运行在栈上\",{\"1\":{\"105\":1}}],[\"死代码消除\",{\"1\":{\"100\":1}}],[\"第4步的细节参考\",{\"1\":{\"227\":1}}],[\"第三次声明\",{\"1\":{\"130\":1}}],[\"第三阶段\",{\"0\":{\"101\":1}}],[\"第二次声明\",{\"1\":{\"130\":1}}],[\"第二阶段\",{\"0\":{\"100\":1}}],[\"第四阶段\",{\"0\":{\"102\":1}}],[\"第一次声明\",{\"1\":{\"130\":2}}],[\"第一步是名称解析和类型推断\",{\"1\":{\"100\":1}}],[\"第一阶段\",{\"0\":{\"99\":1}}],[\"每一个线程都有自己的binlog\",{\"1\":{\"236\":1}}],[\"每一个组内部都有一些数据记录\",{\"1\":{\"224\":1}}],[\"每当产生一条\",{\"1\":{\"231\":1}}],[\"每当执行一个事务就会产生这样的一条或者多条物理日志\",{\"1\":{\"228\":1}}],[\"每当\",{\"1\":{\"217\":1}}],[\"每次添加\",{\"1\":{\"267\":1}}],[\"每次事务提交时\",{\"1\":{\"232\":3}}],[\"每次事务提交时都将缓存在\",{\"1\":{\"232\":1}}],[\"每次执行\",{\"1\":{\"219\":1}}],[\"每次未命中时增加\",{\"1\":{\"204\":1}}],[\"每次调用\",{\"1\":{\"185\":1}}],[\"每次迭代都共享一个底层变量\",{\"1\":{\"140\":1}}],[\"每次迭代都是一个新变量\",{\"1\":{\"140\":1}}],[\"每个\",{\"1\":{\"266\":1}}],[\"每个事务提交都会进行两次\",{\"1\":{\"242\":1}}],[\"每个阶段都由协调者\",{\"1\":{\"240\":1}}],[\"每个从库把\",{\"1\":{\"237\":1}}],[\"每个步骤中都有许多细节和优化点\",{\"1\":{\"210\":1}}],[\"每个函数的栈空间都是独立的\",{\"1\":{\"105\":1}}],[\"每个语法树都是相应源文件的精确表示\",{\"1\":{\"99\":1}}],[\"每调度\",{\"1\":{\"82\":1}}],[\"化\",{\"1\":{\"99\":1}}],[\"语句或者在自动提交的情况下\",{\"1\":{\"241\":1}}],[\"语句执行过程中提到的缓存\",{\"1\":{\"223\":1}}],[\"语句是否自动提交事务\",{\"1\":{\"215\":1}}],[\"语句也是同样会走一遍\",{\"1\":{\"211\":1}}],[\"语句的那一套流程\",{\"1\":{\"211\":1}}],[\"语句的执行过程\",{\"0\":{\"210\":1,\"211\":1}}],[\"语句\",{\"1\":{\"211\":1,\"219\":1}}],[\"语义分析的过程中包含几个重要的操作\",{\"1\":{\"100\":1}}],[\"语义分析\",{\"0\":{\"100\":1}}],[\"语法的特性符合\",{\"1\":{\"120\":1}}],[\"语法分析\",{\"1\":{\"99\":1}}],[\"语法树还包括位置信息用于错误报告和调试信息的创建\",{\"1\":{\"99\":1}}],[\"语法树\",{\"1\":{\"99\":1}}],[\"语言希望\",{\"1\":{\"194\":1}}],[\"语言中\",{\"1\":{\"146\":1}}],[\"语言编译器有关的代码主要位于\",{\"1\":{\"98\":1}}],[\"语言运行时的核心组成部分\",{\"1\":{\"85\":1}}],[\"语言的指针是类型安全的\",{\"1\":{\"147\":1}}],[\"语言的基础语法\",{\"1\":{\"120\":1}}],[\"语言的\",{\"1\":{\"23\":1}}],[\"词法分析\",{\"1\":{\"99\":1}}],[\"词法分析器\",{\"1\":{\"99\":1}}],[\"词法分析和语法分析\",{\"0\":{\"99\":1}}],[\"垃圾回收\",{\"1\":{\"98\":1}}],[\"汇编语言等\",{\"1\":{\"97\":1}}],[\"识别内存逃逸等\",{\"1\":{\"97\":1}}],[\"识别冗余代码\",{\"1\":{\"97\":1}}],[\"多机部署\",{\"0\":{\"254\":1}}],[\"多级部署\",{\"1\":{\"252\":1}}],[\"多个事务的\",{\"1\":{\"243\":1}}],[\"多个事务按进入的顺序将\",{\"1\":{\"243\":1}}],[\"多版本并发控制\",{\"1\":{\"219\":2}}],[\"多变量声明\",{\"0\":{\"125\":1}}],[\"多返回值实现原理\",{\"1\":{\"111\":1}}],[\"多值返回实现\",{\"0\":{\"111\":1}}],[\"多种数据结构表示代码\",{\"1\":{\"97\":1}}],[\"多了全局队列的参与\",{\"1\":{\"82\":1}}],[\"扫描解析源程序并进行精准的语义表达\",{\"1\":{\"97\":1}}],[\"离不开go语言编译器的复杂工作\",{\"1\":{\"96\":1}}],[\"之间的相互配合\",{\"0\":{\"212\":1}}],[\"之间的切换\",{\"1\":{\"89\":1}}],[\"之间共享和访问\",{\"1\":{\"190\":1,\"196\":1}}],[\"之前\",{\"1\":{\"140\":1,\"141\":1,\"213\":1}}],[\"之后随着程序的运行\",{\"1\":{\"224\":1}}],[\"之后会\",{\"1\":{\"167\":1}}],[\"之后的版本已经更改\",{\"1\":{\"141\":1}}],[\"之后通过gc回收才能释放\",{\"1\":{\"105\":1}}],[\"之后又到了\",{\"1\":{\"82\":1}}],[\"之后\",{\"1\":{\"35\":1,\"140\":1,\"213\":1}}],[\"执行完毕后\",{\"1\":{\"250\":1}}],[\"执行sql\",{\"1\":{\"239\":1}}],[\"执行器把\",{\"1\":{\"236\":1}}],[\"执行器将存储引擎返回的数据进行处理\",{\"1\":{\"210\":1}}],[\"执行一个事务的过程中\",{\"1\":{\"231\":1}}],[\"执行一次\",{\"1\":{\"139\":1}}],[\"执行更新操作的同时会涉及对三种日志的改动\",{\"1\":{\"211\":1}}],[\"执行查询\",{\"1\":{\"210\":1}}],[\"执行过程到理解mysql\",{\"1\":{\"209\":1}}],[\"执行defer\",{\"1\":{\"165\":1}}],[\"执行到\",{\"1\":{\"161\":1}}],[\"执行\",{\"1\":{\"89\":1}}],[\"交给\",{\"1\":{\"89\":1}}],[\"交互式进入\",{\"1\":{\"62\":1}}],[\"需要进行\",{\"1\":{\"267\":1}}],[\"需要减去请求时间\",{\"1\":{\"254\":1,\"255\":1}}],[\"需要向每个redis发送解锁命令\",{\"1\":{\"254\":1}}],[\"需要人工参与\",{\"1\":{\"253\":1}}],[\"需要有一定程度的异常处理能力\",{\"1\":{\"246\":1}}],[\"需要将被更新的列的旧值记下来\",{\"1\":{\"229\":1}}],[\"需要判断\",{\"1\":{\"220\":1}}],[\"需要了解一条记录在innodb引擎中的存储格式\",{\"1\":{\"218\":1}}],[\"需要保证自己的数据是全量的\",{\"1\":{\"193\":1}}],[\"需要配合互斥锁使用\",{\"1\":{\"190\":1}}],[\"需要改为具名嵌套或定义字段tag\",{\"1\":{\"177\":1}}],[\"需要思考的\",{\"0\":{\"161\":1}}],[\"需要先找到一块大小合适的内存\",{\"1\":{\"105\":1}}],[\"需要注意的是\",{\"1\":{\"102\":1,\"210\":1}}],[\"需要和大写的\",{\"1\":{\"98\":1}}],[\"需要把被更新的列的旧值记下来\",{\"1\":{\"224\":1}}],[\"需要把\",{\"1\":{\"89\":1,\"199\":1}}],[\"需自行添加网卡\",{\"1\":{\"48\":1}}],[\"销毁\",{\"1\":{\"89\":1}}],[\"老调度器有几个缺点\",{\"1\":{\"89\":1}}],[\"队列是有互斥锁进行保护的\",{\"1\":{\"89\":1}}],[\"队列\",{\"1\":{\"89\":1}}],[\"都是指向一个dict\",{\"1\":{\"268\":1}}],[\"都表现为一个\",{\"1\":{\"266\":1}}],[\"都存储在里面\",{\"1\":{\"263\":1}}],[\"都存着\",{\"1\":{\"198\":1}}],[\"都复用这个字段\",{\"1\":{\"262\":1}}],[\"都回答准备好了\",{\"1\":{\"240\":1}}],[\"都要持久化到磁盘\",{\"1\":{\"239\":1}}],[\"都只是缓存在\",{\"1\":{\"232\":1}}],[\"都\",{\"1\":{\"232\":1}}],[\"都需要通过\",{\"1\":{\"221\":1}}],[\"都需要每个\",{\"1\":{\"89\":1}}],[\"都有一个\",{\"1\":{\"218\":1}}],[\"都记录下回滚时需要的信息到一个日志\",{\"1\":{\"215\":1}}],[\"都必须访问全局\",{\"1\":{\"89\":1}}],[\"都会存储一份\",{\"1\":{\"268\":1}}],[\"都会生成一个新的\",{\"1\":{\"219\":1}}],[\"都会去全局队列中获取一个\",{\"1\":{\"82\":1}}],[\"都会将报文传输给另一方\",{\"1\":{\"45\":1}}],[\"废弃的调度器模型\",{\"0\":{\"89\":1}}],[\"旧客户端执行释放操作\",{\"1\":{\"250\":1}}],[\"旧客户端准备释放锁\",{\"1\":{\"250\":1}}],[\"旧客户端删除前检查锁\",{\"1\":{\"250\":1}}],[\"旧值作为一条\",{\"1\":{\"224\":1}}],[\"旧\",{\"0\":{\"87\":1}}],[\"提交阶段\",{\"1\":{\"240\":1}}],[\"提交事务\",{\"1\":{\"237\":1}}],[\"提交事务时也会刷盘\",{\"1\":{\"221\":1}}],[\"提升\",{\"1\":{\"150\":1}}],[\"提高了写入磁盘的阈值\",{\"1\":{\"231\":1}}],[\"提高效率\",{\"1\":{\"106\":1}}],[\"提高程序运行速度\",{\"1\":{\"105\":1}}],[\"提供了更容易的并发\",{\"1\":{\"86\":1}}],[\"提示\",{\"1\":{\"45\":2,\"75\":1,\"81\":1,\"82\":1}}],[\"程序将终止\",{\"1\":{\"167\":1}}],[\"程序接着运行\",{\"1\":{\"167\":1}}],[\"程序不会在panic出中断\",{\"1\":{\"166\":1}}],[\"程序运行过程发生的\",{\"1\":{\"166\":1}}],[\"程序运行时在内存中的布局\",{\"0\":{\"115\":1}}],[\"程序计数器\",{\"1\":{\"117\":1}}],[\"程序员看不到这些底层的细节\",{\"1\":{\"86\":1}}],[\"程序的并发执行\",{\"1\":{\"85\":1}}],[\"虽然脏页数据没有持久化\",{\"1\":{\"228\":1}}],[\"虽然参数传递仍然是按值传递\",{\"1\":{\"144\":1}}],[\"虽然它会减少复制操作\",{\"1\":{\"109\":1}}],[\"虽然一个\",{\"1\":{\"86\":1}}],[\"虽然容器的本质是主机上运行的一个进程\",{\"1\":{\"20\":1}}],[\"支持丰富的对象种类\",{\"1\":{\"259\":1}}],[\"支持过期时间\",{\"0\":{\"248\":1}}],[\"支持了更多的并发\",{\"1\":{\"86\":1}}],[\"支持的网络模式\",{\"0\":{\"44\":1}}],[\"全景图的\",{\"1\":{\"267\":1}}],[\"全表扫描或索引扫描\",{\"1\":{\"210\":1}}],[\"全局变量\",{\"1\":{\"127\":1}}],[\"全局符号\",{\"1\":{\"117\":1}}],[\"全拿\",{\"1\":{\"82\":1}}],[\"全部调度完了\",{\"1\":{\"82\":1}}],[\"为了方便分析\",{\"1\":{\"255\":1}}],[\"为了保证这两个日志的一致性\",{\"1\":{\"241\":1}}],[\"为了减少磁盘i\",{\"1\":{\"223\":1}}],[\"为了继续执行\",{\"1\":{\"89\":1}}],[\"为旧值就好了\",{\"1\":{\"217\":1}}],[\"为不完整\",{\"1\":{\"205\":1}}],[\"为什么需要\",{\"0\":{\"215\":1,\"227\":1}}],[\"为什么自己要置为\",{\"1\":{\"194\":1}}],[\"为什么要把数据集当成皮球一样踢来踢去呢\",{\"1\":{\"194\":1}}],[\"为什么要双向流转\",{\"0\":{\"194\":1}}],[\"为什么是\",{\"1\":{\"164\":1}}],[\"为什么先打印它\",{\"0\":{\"81\":1},\"1\":{\"75\":1}}],[\"为\",{\"1\":{\"157\":1,\"190\":1,\"199\":1,\"205\":1}}],[\"为接口类型\",{\"1\":{\"157\":1}}],[\"为main函数栈帧分配了128字节的空间\",{\"1\":{\"117\":1}}],[\"为空时\",{\"1\":{\"82\":1}}],[\"再通过delete解锁\",{\"1\":{\"247\":1}}],[\"再通过页的页目录去定位到某条具体的记录\",{\"1\":{\"224\":1}}],[\"再看到左边的页目录\",{\"1\":{\"224\":1}}],[\"再次尝试从\",{\"1\":{\"203\":1}}],[\"再执行上述的omitemptydemo\",{\"1\":{\"176\":1}}],[\"再\",{\"1\":{\"134\":1}}],[\"再回想八股\",{\"1\":{\"82\":1}}],[\"再把\",{\"1\":{\"82\":1,\"236\":1}}],[\"本文不对\",{\"1\":{\"258\":1}}],[\"本来就有的协程要调度\",{\"1\":{\"82\":1}}],[\"本地队列中的最后一个\",{\"1\":{\"82\":1}}],[\"本地队列的长度是\",{\"1\":{\"82\":1}}],[\"本地目录的路径必须是绝对路径\",{\"1\":{\"35\":1}}],[\"还不了解\",{\"1\":{\"254\":1}}],[\"还是需要和业务的配合\",{\"1\":{\"255\":1}}],[\"还是将\",{\"1\":{\"232\":1}}],[\"还是选择缓存起来呢\",{\"1\":{\"223\":1}}],[\"还需要加一个锁来保证提交的原子性\",{\"1\":{\"242\":1}}],[\"还需要记录对应的\",{\"1\":{\"229\":1}}],[\"还需要完成最后的\",{\"1\":{\"227\":1}}],[\"还需要使用嵌套的结构体指针\",{\"1\":{\"177\":1}}],[\"还没写\",{\"1\":{\"239\":1}}],[\"还没有来得及写入\",{\"1\":{\"239\":2}}],[\"还没来得及落盘的脏页数据就会丢失\",{\"1\":{\"227\":1}}],[\"还没提交事务\",{\"1\":{\"220\":1}}],[\"还包括反射数据\",{\"1\":{\"102\":1}}],[\"还有一些\",{\"1\":{\"82\":1}}],[\"还可以使用\",{\"1\":{\"39\":1}}],[\"哦哦哦\",{\"1\":{\"82\":1}}],[\"岂不是八股错了\",{\"1\":{\"82\":1}}],[\"了解一个主要参数\",{\"1\":{\"232\":1}}],[\"了解go语言的编译大致过程\",{\"1\":{\"95\":1}}],[\"了\",{\"1\":{\"82\":1,\"134\":1}}],[\"次数高\",{\"1\":{\"242\":1}}],[\"次调度了用户定义的\",{\"1\":{\"82\":1}}],[\"次里面\",{\"1\":{\"82\":1}}],[\"次就去全局队列中偷一个协程\",{\"1\":{\"82\":1}}],[\"次本地队列\",{\"1\":{\"82\":1}}],[\"回来\",{\"1\":{\"255\":1}}],[\"回来调度\",{\"1\":{\"82\":1}}],[\"回放\",{\"1\":{\"237\":1}}],[\"回答没有准备好\",{\"1\":{\"240\":1}}],[\"回答\",{\"1\":{\"236\":2}}],[\"回滚日志\",{\"0\":{\"214\":1},\"1\":{\"213\":1}}],[\"回顾\",{\"0\":{\"200\":1}}],[\"回收代价比较小\",{\"1\":{\"105\":1}}],[\"回想八股\",{\"1\":{\"82\":1}}],[\"回环网络\",{\"1\":{\"48\":1}}],[\"思考下面\",{\"1\":{\"165\":1}}],[\"思考\",{\"1\":{\"82\":1}}],[\"思考以下问题\",{\"1\":{\"75\":1,\"239\":1}}],[\"后续交由操作系统决定何时将数据持久化到磁盘\",{\"1\":{\"236\":1}}],[\"后续再持久化到磁盘\",{\"1\":{\"231\":1}}],[\"后续\",{\"1\":{\"227\":1}}],[\"后续由后台线程选择一个合适的时机将脏页写入到磁盘\",{\"1\":{\"223\":1}}],[\"后续追加的元素不会影响当前的迭代过程\",{\"1\":{\"141\":1}}],[\"后\",{\"1\":{\"193\":1,\"220\":1,\"236\":1}}],[\"后面会解读\",{\"1\":{\"186\":1}}],[\"后面先调度本地队列\",{\"1\":{\"82\":1}}],[\"后台启动容器\",{\"0\":{\"66\":1}}],[\"后台方式运行\",{\"1\":{\"60\":1}}],[\"到文件系统的\",{\"1\":{\"241\":1}}],[\"到这里\",{\"1\":{\"227\":1}}],[\"到表中就好了\",{\"1\":{\"217\":1}}],[\"到了\",{\"1\":{\"167\":1}}],[\"到\",{\"1\":{\"82\":2,\"194\":1,\"203\":2}}],[\"到容器的\",{\"1\":{\"32\":1}}],[\"把新客户端的锁释放了\",{\"1\":{\"250\":1}}],[\"把数据全给\",{\"1\":{\"194\":1}}],[\"把全局队列的\",{\"1\":{\"82\":1}}],[\"把\",{\"1\":{\"82\":1,\"237\":1,\"241\":1}}],[\"把原本指向的\",{\"1\":{\"81\":1}}],[\"放回\",{\"1\":{\"89\":1}}],[\"放到全局队列\",{\"1\":{\"82\":1}}],[\"放进全局队列\",{\"1\":{\"82\":1}}],[\"放入到\",{\"1\":{\"81\":1}}],[\"+=\",{\"1\":{\"146\":1}}],[\"+\",{\"0\":{\"219\":1,\"249\":1},\"1\":{\"82\":4,\"117\":7,\"163\":1,\"183\":1,\"201\":1,\"219\":1}}],[\"最简单的一种方式\",{\"1\":{\"253\":1}}],[\"最简化版本有一个问题\",{\"1\":{\"248\":1}}],[\"最简化版本\",{\"0\":{\"247\":1}}],[\"最多丢失一个事务的\",{\"1\":{\"236\":1}}],[\"最终写入同一个binlog文件\",{\"1\":{\"236\":2}}],[\"最终的结果集通过网络传输返回给客户端\",{\"1\":{\"210\":1}}],[\"最大最小记录\",{\"1\":{\"224\":1}}],[\"最大的本地队列长度256\",{\"1\":{\"82\":1}}],[\"最下面的\",{\"1\":{\"186\":1}}],[\"最基本的逃逸分析原则\",{\"1\":{\"105\":1}}],[\"最好放在\",{\"1\":{\"89\":1}}],[\"最关键的是\",{\"1\":{\"86\":1}}],[\"最后再进行释放\",{\"1\":{\"250\":1}}],[\"最后一个参数就是过期时间的值\",{\"1\":{\"248\":1}}],[\"最后遍历得到的值\",{\"1\":{\"141\":1}}],[\"最后\",{\"1\":{\"82\":1}}],[\"最后创建的\",{\"1\":{\"81\":1}}],[\"加入组提交\",{\"0\":{\"243\":1}}],[\"加入调度\",{\"1\":{\"81\":3,\"82\":2}}],[\"加锁之后其他服务无法加锁\",{\"1\":{\"247\":1}}],[\"加锁和解锁必须是同一个竞争者\",{\"1\":{\"246\":1}}],[\"加锁操作\",{\"1\":{\"205\":1}}],[\"加锁以操作\",{\"1\":{\"203\":1}}],[\"加锁访问\",{\"1\":{\"203\":1}}],[\"加锁完成写操作\",{\"1\":{\"200\":1}}],[\"加载当前\",{\"1\":{\"205\":1}}],[\"加载\",{\"1\":{\"203\":1,\"205\":1}}],[\"加载相应的\",{\"1\":{\"203\":1}}],[\"加上打印却可以避免\",{\"0\":{\"185\":1}}],[\"加起来就是\",{\"1\":{\"82\":1}}],[\"加了\",{\"1\":{\"35\":1}}],[\">>\",{\"1\":{\"132\":1}}],[\">\",{\"0\":{\"192\":1,\"193\":1},\"1\":{\"81\":8,\"82\":12,\"167\":6,\"171\":2,\"175\":1,\"193\":1,\"198\":1,\"199\":2,\"200\":1,\"201\":1,\"203\":1,\"204\":1,\"205\":1,\"210\":4,\"227\":1,\"236\":1}}],[\"模拟\",{\"0\":{\"184\":1}}],[\"模拟一下\",{\"1\":{\"81\":1}}],[\"模型\",{\"0\":{\"92\":1}}],[\"模型下\",{\"1\":{\"82\":1}}],[\"模式可以在容器创建时通过\",{\"1\":{\"48\":1}}],[\"模式的容器可以直接使用宿主机的\",{\"1\":{\"46\":1}}],[\"模式相当于\",{\"1\":{\"46\":1}}],[\"模式\",{\"0\":{\"45\":1,\"48\":1},\"1\":{\"22\":1,\"44\":5,\"46\":2,\"48\":1}}],[\"指向\",{\"1\":{\"268\":1}}],[\"指向冲突的下一对\",{\"1\":{\"267\":1}}],[\"指向一个\",{\"1\":{\"265\":2}}],[\"指向一个函数栈的顶部\",{\"1\":{\"117\":1}}],[\"指向的是哈希数组的数组下标\",{\"1\":{\"264\":1}}],[\"指向的56个字节空间\",{\"1\":{\"117\":1}}],[\"指向的56个栈空间\",{\"1\":{\"117\":1}}],[\"指向实际数据\",{\"1\":{\"262\":1,\"268\":1}}],[\"指向同一块区域\",{\"1\":{\"142\":1}}],[\"指向静态数据的基指针\",{\"1\":{\"117\":1}}],[\"指向下一条执行指令\",{\"1\":{\"117\":1}}],[\"指针可以将这些\",{\"1\":{\"218\":1}}],[\"指针和一个\",{\"1\":{\"218\":1}}],[\"指针为\",{\"1\":{\"205\":1}}],[\"指针指向\",{\"1\":{\"192\":1}}],[\"指针逃逸\",{\"0\":{\"106\":1},\"1\":{\"105\":1}}],[\"指针\",{\"1\":{\"81\":1,\"124\":1,\"205\":1}}],[\"指定json序列化\",{\"1\":{\"173\":1,\"174\":2}}],[\"指定容器的端口\",{\"1\":{\"60\":1}}],[\"指定的是运行的容器名\",{\"1\":{\"47\":1}}],[\"指定\",{\"1\":{\"47\":1}}],[\"指定为\",{\"1\":{\"35\":1}}],[\"那谁来组织\",{\"1\":{\"264\":1}}],[\"那这些\",{\"1\":{\"262\":1}}],[\"那这里的并发问题如何解决\",{\"1\":{\"236\":1}}],[\"那锁就不能获取了\",{\"1\":{\"252\":1}}],[\"那个是在\",{\"1\":{\"223\":1}}],[\"那直接修改\",{\"1\":{\"223\":1}}],[\"那修改完这条记录是选择直接写回到磁盘\",{\"1\":{\"223\":1}}],[\"那么两个进程就获取到了同一个分布式锁\",{\"1\":{\"255\":1}}],[\"那么如果单个节点进行了主从切换\",{\"1\":{\"254\":1}}],[\"那么也是获取锁失败\",{\"1\":{\"254\":1}}],[\"那么就是获取到了锁\",{\"1\":{\"254\":1}}],[\"那么就称这种类型为该接口的一种实现\",{\"1\":{\"152\":1}}],[\"那么在异常情况下\",{\"1\":{\"249\":1}}],[\"那么在事务执行中途发生了\",{\"1\":{\"215\":1}}],[\"那么上述情况发生概率就很高\",{\"1\":{\"249\":1}}],[\"那么锁就一直得不到释放\",{\"1\":{\"248\":1}}],[\"那么这一行\",{\"1\":{\"239\":1}}],[\"那么我们要更新一条记录的时候\",{\"1\":{\"223\":1}}],[\"那么问题是\",{\"1\":{\"199\":1}}],[\"那么该函数被称为调用者函数\",{\"1\":{\"114\":1}}],[\"那么为什么最先调度的是\",{\"1\":{\"81\":1}}],[\"那它系一定发生逃逸\",{\"1\":{\"105\":1}}],[\"那首先必须要有一个镜像\",{\"1\":{\"19\":1}}],[\"能将\",{\"1\":{\"239\":1}}],[\"能提高数据库的写性能\",{\"1\":{\"230\":1}}],[\"能在重启后根据\",{\"1\":{\"228\":1}}],[\"能直接在\",{\"1\":{\"198\":1}}],[\"能不能\",{\"1\":{\"194\":1}}],[\"能通过\",{\"1\":{\"193\":1}}],[\"能够工作\",{\"1\":{\"81\":1}}],[\"能切换多种主题\",{\"1\":{\"5\":1}}],[\"先使用ht\",{\"1\":{\"264\":1}}],[\"先把日志写到\",{\"1\":{\"236\":1}}],[\"先写\",{\"1\":{\"233\":1}}],[\"先记录相应操作的\",{\"1\":{\"224\":1}}],[\"先了解隐式事务\",{\"1\":{\"215\":1}}],[\"先删后写的场景优化\",{\"1\":{\"198\":1}}],[\"先说结论\",{\"1\":{\"198\":1}}],[\"先不展开\",{\"1\":{\"157\":1}}],[\"先\",{\"1\":{\"134\":1}}],[\"先理解几条规则\",{\"1\":{\"117\":1}}],[\"先调度\",{\"1\":{\"82\":1}}],[\"先解释一下为什么选\",{\"1\":{\"82\":1}}],[\"先被调度执行\",{\"1\":{\"81\":1}}],[\"先创建的\",{\"1\":{\"81\":1}}],[\"该数据库的键空间\",{\"1\":{\"266\":1}}],[\"该\",{\"1\":{\"265\":1}}],[\"该内存叫\",{\"1\":{\"236\":1}}],[\"该页的内存数据和磁盘上的数据已经不一致\",{\"1\":{\"223\":1}}],[\"该层剩下的代码才会恢复执行\",{\"1\":{\"167\":1}}],[\"该panic会一直向外层传递\",{\"1\":{\"167\":1}}],[\"该结构体有两个域\",{\"1\":{\"129\":1}}],[\"该地址接收函数a的返回值\",{\"1\":{\"117\":1}}],[\"该线程的其他协程也可以被\",{\"1\":{\"86\":1}}],[\"该问题以\",{\"1\":{\"81\":1}}],[\"该模式下在事务提交时不会主动触发写入磁盘的操作\",{\"1\":{\"232\":1}}],[\"该模式下的容器只有宿主机可以直接访问\",{\"1\":{\"45\":1}}],[\"该模式关闭了容器的网络功能\",{\"1\":{\"44\":1}}],[\"99\",{\"1\":{\"78\":1,\"79\":1}}],[\"98\",{\"1\":{\"78\":1,\"79\":1}}],[\"97\",{\"1\":{\"78\":1,\"79\":1}}],[\"96\",{\"1\":{\"78\":1,\"79\":1}}],[\"95\",{\"1\":{\"78\":1,\"79\":1}}],[\"94\",{\"1\":{\"78\":1,\"79\":1}}],[\"93\",{\"1\":{\"78\":1,\"79\":1}}],[\"92\",{\"1\":{\"78\":1,\"79\":1}}],[\"91\",{\"1\":{\"78\":1,\"79\":1}}],[\"90\",{\"1\":{\"78\":1,\"79\":1}}],[\"9\",{\"0\":{\"149\":1},\"1\":{\"77\":1,\"78\":1,\"79\":1}}],[\"8字节\",{\"1\":{\"129\":2}}],[\"8格式的go文本文件\",{\"1\":{\"96\":1}}],[\"89\",{\"1\":{\"78\":1,\"79\":1}}],[\"88\",{\"1\":{\"78\":1,\"79\":1,\"179\":2}}],[\"87\",{\"1\":{\"78\":1,\"79\":1}}],[\"86\",{\"1\":{\"78\":1,\"79\":1}}],[\"85\",{\"1\":{\"78\":1,\"79\":1}}],[\"84\",{\"1\":{\"78\":1,\"79\":1}}],[\"83\",{\"1\":{\"78\":1,\"79\":1}}],[\"82\",{\"1\":{\"78\":1,\"79\":1}}],[\"81\",{\"1\":{\"78\":1,\"79\":1}}],[\"8\",{\"0\":{\"130\":1,\"147\":1,\"148\":1},\"1\":{\"77\":1,\"78\":1,\"79\":1,\"117\":2,\"130\":1,\"157\":2,\"210\":1,\"262\":1}}],[\"80\",{\"1\":{\"39\":1,\"78\":1,\"79\":1}}],[\"79\",{\"1\":{\"78\":1,\"79\":1}}],[\"78\",{\"1\":{\"78\":1,\"79\":1}}],[\"77\",{\"1\":{\"78\":1,\"79\":1}}],[\"76\",{\"1\":{\"78\":1,\"79\":1}}],[\"75\",{\"1\":{\"78\":1,\"79\":1}}],[\"74\",{\"1\":{\"78\":1,\"79\":1}}],[\"73\",{\"1\":{\"78\":1,\"79\":1}}],[\"72\",{\"1\":{\"78\":1,\"79\":1}}],[\"71\",{\"1\":{\"78\":1,\"79\":1,\"171\":3}}],[\"70\",{\"1\":{\"78\":1,\"79\":1}}],[\"7\",{\"0\":{\"129\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"146\":1,\"159\":1,\"221\":1,\"233\":1},\"1\":{\"77\":1,\"78\":1,\"79\":1,\"117\":2,\"130\":1}}],[\"打印出main\",{\"1\":{\"117\":1}}],[\"打印输出的规律是什么\",{\"0\":{\"82\":1}}],[\"打印是有序的\",{\"1\":{\"81\":1}}],[\"打印\",{\"1\":{\"75\":1,\"166\":1}}],[\"打标签\",{\"1\":{\"10\":1}}],[\"个阶段\",{\"1\":{\"240\":1}}],[\"个事务后才\",{\"1\":{\"236\":1}}],[\"个重做日志文件组\",{\"1\":{\"233\":1}}],[\"个例子\",{\"1\":{\"165\":1}}],[\"个问题\",{\"0\":{\"161\":1}}],[\"个入参\",{\"1\":{\"117\":1}}],[\"个\",{\"1\":{\"75\":1,\"82\":1,\"233\":1,\"265\":1,\"266\":1}}],[\"=range\",{\"1\":{\"140\":2}}],[\"==\",{\"1\":{\"82\":1,\"205\":2}}],[\"=\",{\"0\":{\"77\":1,\"78\":1,\"79\":1},\"1\":{\"75\":3,\"81\":1,\"82\":14,\"106\":4,\"107\":6,\"109\":4,\"117\":1,\"124\":2,\"126\":3,\"128\":5,\"129\":3,\"130\":11,\"135\":1,\"136\":2,\"137\":1,\"140\":1,\"141\":12,\"146\":2,\"148\":1,\"150\":1,\"154\":2,\"156\":3,\"157\":3,\"158\":2,\"159\":1,\"164\":2,\"165\":5,\"171\":5,\"175\":3,\"177\":3,\"178\":3,\"179\":3,\"184\":5,\"185\":5,\"188\":1,\"189\":10,\"203\":5,\"204\":2,\"205\":18,\"206\":7,\"211\":2,\"232\":3,\"236\":2,\"239\":6,\"241\":2,\"261\":2}}],[\"工作\",{\"1\":{\"75\":1}}],[\"输出不会混乱\",{\"1\":{\"185\":1}}],[\"输出\",{\"1\":{\"146\":2,\"148\":1,\"154\":2,\"158\":2,\"159\":2,\"171\":1}}],[\"输出结果如下\",{\"1\":{\"176\":1}}],[\"输出结果也是如此\",{\"1\":{\"82\":1}}],[\"输出结果\",{\"0\":{\"76\":1},\"1\":{\"175\":1}}],[\"输出结果是什么\",{\"1\":{\"75\":1}}],[\"输出有什么不同\",{\"1\":{\"75\":1}}],[\"根据上述的分析可以看出\",{\"1\":{\"255\":1}}],[\"根据上面\",{\"1\":{\"82\":1}}],[\"根据值自行判断变量类型\",{\"1\":{\"124\":1}}],[\"根据\",{\"1\":{\"75\":1}}],[\"69\",{\"1\":{\"78\":1,\"79\":1}}],[\"68\",{\"1\":{\"78\":1,\"79\":1}}],[\"67\",{\"1\":{\"78\":1,\"79\":1}}],[\"66\",{\"1\":{\"78\":1,\"79\":1}}],[\"65\",{\"1\":{\"78\":1,\"79\":1}}],[\"64\",{\"1\":{\"78\":1,\"79\":1}}],[\"63\",{\"1\":{\"78\":1,\"79\":1}}],[\"6379\",{\"1\":{\"68\":1}}],[\"62\",{\"1\":{\"78\":1,\"79\":1}}],[\"61\",{\"1\":{\"78\":1,\"79\":1,\"82\":2}}],[\"60\",{\"1\":{\"78\":1,\"79\":1,\"82\":3}}],[\"6\",{\"0\":{\"71\":1,\"128\":1,\"139\":1,\"140\":1,\"141\":1,\"158\":1,\"220\":1,\"232\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"242\":1,\"243\":1},\"1\":{\"77\":1,\"78\":1,\"79\":1,\"117\":4,\"130\":1,\"140\":1,\"219\":1,\"262\":1}}],[\"方法不会阻塞其他方法的执行\",{\"1\":{\"206\":1}}],[\"方法不保证遍历期间\",{\"1\":{\"206\":1}}],[\"方法得到\",{\"1\":{\"203\":1}}],[\"方法根据\",{\"1\":{\"203\":1}}],[\"方法重写\",{\"0\":{\"152\":1}}],[\"方法是绑定在某种类型的变量上的函数\",{\"1\":{\"148\":1}}],[\"方式\",{\"1\":{\"141\":2}}],[\"方式二\",{\"1\":{\"70\":1}}],[\"方式一\",{\"1\":{\"70\":1}}],[\"方便定位\",{\"1\":{\"10\":1}}],[\"~\",{\"1\":{\"68\":1}}],[\"问题关键在于\",{\"1\":{\"249\":1}}],[\"问题的解决方案\",{\"1\":{\"239\":1}}],[\"问题的场景复现\",{\"1\":{\"239\":1}}],[\"问题背景\",{\"1\":{\"233\":1}}],[\"问题解答\",{\"0\":{\"80\":1}}],[\"问题\",{\"1\":{\"66\":1,\"82\":1}}],[\"常量用作枚举\",{\"0\":{\"129\":1}}],[\"常量数据类型只能是\",{\"1\":{\"128\":1}}],[\"常量\",{\"0\":{\"128\":1},\"1\":{\"121\":1}}],[\"常见的坑\",{\"1\":{\"66\":1}}],[\"常用errors\",{\"1\":{\"160\":1}}],[\"常用\",{\"1\":{\"70\":1}}],[\"常用其他命令\",{\"0\":{\"65\":1}}],[\"常用的docker命令\",{\"1\":{\"51\":1}}],[\"常用命令\",{\"0\":{\"51\":1}}],[\"强制停止当前容器\",{\"1\":{\"64\":1}}],[\"kv\",{\"1\":{\"205\":1}}],[\"k\",{\"1\":{\"141\":2,\"190\":1,\"197\":4,\"201\":1,\"203\":3,\"205\":2,\"206\":2,\"262\":1,\"265\":1,\"266\":1,\"267\":3}}],[\"keys\",{\"1\":{\"266\":3}}],[\"key1\",{\"1\":{\"188\":5}}],[\"key2\",{\"1\":{\"172\":1,\"188\":2}}],[\"key\",{\"1\":{\"140\":2,\"186\":1,\"188\":2,\"189\":14,\"190\":1,\"193\":1,\"197\":1,\"198\":8,\"199\":3,\"203\":6,\"205\":12,\"206\":1,\"247\":1,\"248\":1,\"259\":2,\"261\":1,\"263\":1,\"266\":2,\"268\":2}}],[\"kb\",{\"1\":{\"86\":3}}],[\"kill\",{\"1\":{\"64\":1}}],[\"kryiea\",{\"1\":{\"58\":3,\"62\":1,\"66\":1,\"68\":1,\"106\":1,\"135\":1,\"211\":1,\"239\":3}}],[\"重点结构\",{\"1\":{\"266\":1}}],[\"重点关注\",{\"1\":{\"260\":1}}],[\"重启后\",{\"1\":{\"239\":1}}],[\"重启容器\",{\"1\":{\"64\":1}}],[\"重做已经提交的修改\",{\"1\":{\"213\":1}}],[\"重做日志\",{\"0\":{\"226\":1,\"234\":1},\"1\":{\"213\":1}}],[\"重写animal的speal\",{\"1\":{\"152\":1}}],[\"重要组件\",{\"0\":{\"25\":1}}],[\"退出\",{\"1\":{\"62\":1}}],[\"退出容器\",{\"0\":{\"62\":1}}],[\"只针对\",{\"1\":{\"243\":1}}],[\"只要超过一半\",{\"1\":{\"254\":1}}],[\"只要成功同步到一个从库\",{\"1\":{\"237\":1}}],[\"只要先将\",{\"1\":{\"228\":1}}],[\"只需要\",{\"1\":{\"241\":1}}],[\"只需要缓存一条记录吗\",{\"1\":{\"224\":1}}],[\"只需要两个cpu指令push和release\",{\"1\":{\"105\":1}}],[\"只会将逻辑上存在的数据\",{\"1\":{\"199\":1}}],[\"只想json展示\",{\"1\":{\"176\":1}}],[\"只有read有它的指针\",{\"1\":{\"205\":1}}],[\"只有\",{\"1\":{\"138\":1}}],[\"只是\",{\"1\":{\"268\":1}}],[\"只是完成了\",{\"1\":{\"227\":1}}],[\"只是将元素赋值一个临时变量\",{\"1\":{\"141\":1}}],[\"只是获取string顶层结构体的大小\",{\"1\":{\"129\":1}}],[\"只是其中的\",{\"1\":{\"82\":1}}],[\"只能是\",{\"1\":{\"259\":1}}],[\"只能是编译器来分析代码确定\",{\"1\":{\"105\":1}}],[\"只能恢复当前函数级或以当前函数为首的调用链中的函数中的\",{\"1\":{\"167\":1}}],[\"只能在函数体内使用\",{\"1\":{\"126\":1}}],[\"只占几\",{\"1\":{\"86\":1}}],[\"只显示容器的编号\",{\"1\":{\"61\":1}}],[\"只读\",{\"1\":{\"35\":1}}],[\"queue\",{\"1\":{\"82\":1}}],[\"q|xargs\",{\"1\":{\"63\":1}}],[\"q\",{\"1\":{\"61\":1}}],[\"qdisc\",{\"1\":{\"43\":1}}],[\"显示旧客户端是\",{\"1\":{\"250\":1}}],[\"显示日志\",{\"1\":{\"67\":2}}],[\"显示最近创建的容器\",{\"1\":{\"61\":1}}],[\"显示docker的系统信息\",{\"1\":{\"53\":1}}],[\"显示docker的版本信息\",{\"1\":{\"53\":1}}],[\"列表中\",{\"1\":{\"220\":3}}],[\"列表标签说明\",{\"1\":{\"55\":1}}],[\"列出当前正在运行的容器+历史运行过的容器\",{\"1\":{\"61\":1}}],[\"列出当前正在运行的容器\",{\"1\":{\"61\":1}}],[\"列出所有运行的容器\",{\"0\":{\"61\":1}}],[\"进而提升写\",{\"1\":{\"231\":1}}],[\"进行一个粗略判断\",{\"1\":{\"255\":1}}],[\"进行持久化\",{\"1\":{\"239\":1}}],[\"进行对比\",{\"1\":{\"220\":1}}],[\"进行任意类型的转换\",{\"1\":{\"148\":1}}],[\"进行类型检查\",{\"1\":{\"100\":1}}],[\"进行区分\",{\"1\":{\"98\":1}}],[\"进入容器正在执行的终端\",{\"1\":{\"70\":1}}],[\"进入容器后开启一个新的终端\",{\"1\":{\"70\":1}}],[\"进入容器查看内容\",{\"1\":{\"60\":1}}],[\"进入当前正在运行的容器\",{\"0\":{\"70\":1}}],[\"进程暂停\",{\"1\":{\"255\":1}}],[\"进程列表等还是隔离的\",{\"1\":{\"47\":1}}],[\"进程\",{\"1\":{\"26\":1}}],[\"可配置\",{\"1\":{\"265\":1}}],[\"可靠性探索\",{\"0\":{\"255\":1}}],[\"可靠性会向etcd靠近\",{\"1\":{\"254\":1}}],[\"可靠性的保证\",{\"0\":{\"252\":1}}],[\"可靠性\",{\"1\":{\"246\":1}}],[\"可见\",{\"1\":{\"220\":2}}],[\"可重复读隔离级别\",{\"1\":{\"219\":1}}],[\"可重复读\",{\"1\":{\"219\":1}}],[\"可选\",{\"1\":{\"210\":1}}],[\"可选参数\",{\"1\":{\"60\":1}}],[\"可被分解成以下3步\",{\"1\":{\"165\":1}}],[\"可变参数会被当作一个切片\",{\"1\":{\"146\":1}}],[\"可变参数原理\",{\"1\":{\"146\":1}}],[\"可变参数使用省略号\",{\"1\":{\"146\":1}}],[\"可变参数\",{\"0\":{\"146\":1},\"1\":{\"146\":1}}],[\"可认为是一个计数器\",{\"1\":{\"130\":1}}],[\"可能采用相同的编码方式\",{\"1\":{\"260\":1}}],[\"可能锁获取的时候还是自己的\",{\"1\":{\"250\":1}}],[\"可能存在几十个竞争者\",{\"1\":{\"249\":1}}],[\"可能服务\",{\"1\":{\"249\":1}}],[\"可能出现半成功的状态\",{\"1\":{\"239\":1}}],[\"可能会导致数据不一致或崩溃\",{\"1\":{\"194\":1}}],[\"可能会使用到堆\",{\"1\":{\"106\":1}}],[\"可能有多个\",{\"1\":{\"97\":1}}],[\"可以看到不同的数据对象\",{\"1\":{\"260\":1}}],[\"可以尝试多机部署\",{\"1\":{\"254\":1}}],[\"可以灵活自动切换\",{\"1\":{\"253\":1}}],[\"可以发现\",{\"1\":{\"249\":1,\"268\":1}}],[\"可以通过\",{\"1\":{\"231\":1}}],[\"可以通过端口映射\",{\"1\":{\"43\":1}}],[\"可以减少随机写入的频率和次数\",{\"1\":{\"230\":1}}],[\"可以减少gc压力\",{\"1\":{\"105\":1}}],[\"可以不需要等到将缓存在\",{\"1\":{\"228\":1}}],[\"可以缓存的数据类型\",{\"1\":{\"224\":1}}],[\"可以理解为记录当前事务id创建时\",{\"1\":{\"220\":1}}],[\"可以知道该记录是被哪个事务修改的\",{\"1\":{\"218\":1}}],[\"可以利用\",{\"1\":{\"216\":1}}],[\"可以再去查一次啊\",{\"1\":{\"255\":1}}],[\"可以再次通过\",{\"1\":{\"198\":1}}],[\"可以再里面操作\",{\"1\":{\"70\":1}}],[\"可以为\",{\"1\":{\"192\":1}}],[\"可以像下面这样定义结构体\",{\"0\":{\"176\":1}}],[\"可以按如下方式在tag中添加\",{\"1\":{\"174\":1}}],[\"可以总结为以下\",{\"1\":{\"167\":1}}],[\"可以实现多态的效果\",{\"1\":{\"151\":1}}],[\"可以实现类似继承的效果\",{\"1\":{\"150\":1}}],[\"可以直接调用内部结构体\",{\"1\":{\"150\":1}}],[\"可以存在不同的源文件\",{\"1\":{\"149\":1}}],[\"可以是任意类型\",{\"1\":{\"148\":1}}],[\"可以被用来转换任何类型的指针\",{\"1\":{\"148\":1}}],[\"可以改变形参的值\",{\"1\":{\"142\":1}}],[\"可以使用fallthrough\",{\"1\":{\"138\":1}}],[\"可以省略\",{\"1\":{\"128\":1}}],[\"可以合并多个加载和存储操作\",{\"1\":{\"102\":1}}],[\"可以指定显示几条\",{\"1\":{\"61\":1}}],[\"可以在对应字段添加omitempty\",{\"1\":{\"175\":1}}],[\"可以在运行的时候通过反射的机制读取出来\",{\"1\":{\"172\":1}}],[\"可以在容器之间共享和重用\",{\"1\":{\"28\":1}}],[\"可以在vsc的设置里面搜索\",{\"1\":{\"3\":1}}],[\"可以提供很多有用的特性\",{\"1\":{\"28\":1}}],[\"可以说是让原本的\",{\"1\":{\"198\":1}}],[\"可以说\",{\"1\":{\"25\":1}}],[\"我们需要一个超时来兜底\",{\"1\":{\"248\":1}}],[\"我们需要json序列化user\",{\"1\":{\"178\":1}}],[\"我们就可以用setnx实现加锁的目的\",{\"1\":{\"247\":1}}],[\"我们使用gorm操作数据库的话\",{\"1\":{\"176\":1}}],[\"我们可以通过这个日志回滚到事务之前的数据\",{\"1\":{\"215\":1}}],[\"我们可以通过给结构体字段添加tag来指定json序列化生成的字段名\",{\"1\":{\"173\":1}}],[\"我们可以调用\",{\"1\":{\"146\":1}}],[\"我们可以知道\",{\"1\":{\"82\":1}}],[\"我们有了镜像才可以创建容器\",{\"1\":{\"59\":1}}],[\"我是一个key\",{\"1\":{\"261\":2}}],[\"我是协程\",{\"1\":{\"75\":1,\"77\":10,\"78\":256,\"79\":258}}],[\"我是你爹\",{\"1\":{\"0\":1}}],[\"$7\",{\"1\":{\"117\":1}}],[\"$6\",{\"1\":{\"117\":1}}],[\"$5\",{\"1\":{\"117\":1}}],[\"$4\",{\"1\":{\"117\":1}}],[\"$3\",{\"1\":{\"117\":1}}],[\"$2\",{\"1\":{\"117\":1}}],[\"$1\",{\"1\":{\"117\":3}}],[\"$128\",{\"1\":{\"117\":2}}],[\"$0\",{\"1\":{\"117\":4}}],[\"$\",{\"1\":{\"58\":1,\"63\":1,\"117\":4}}],[\"搜索镜像\",{\"0\":{\"56\":1}}],[\"帮助命令\",{\"0\":{\"53\":1},\"1\":{\"53\":1}}],[\"路由等信息\",{\"1\":{\"48\":1}}],[\"来找到对应的插入位置\",{\"1\":{\"267\":1}}],[\"来保证一致性\",{\"1\":{\"241\":1}}],[\"来保证事务的原子性\",{\"1\":{\"224\":1}}],[\"来实现的\",{\"1\":{\"219\":1}}],[\"来进行回滚\",{\"1\":{\"216\":1}}],[\"来兜底完成\",{\"1\":{\"186\":1}}],[\"来返回一个error对象\",{\"1\":{\"160\":1}}],[\"来处理\",{\"1\":{\"146\":1}}],[\"来初始化\",{\"1\":{\"136\":1}}],[\"来自协程的概念\",{\"1\":{\"86\":1}}],[\"来执行\",{\"1\":{\"82\":1}}],[\"来指定\",{\"1\":{\"48\":1}}],[\"来查看当前映射的端口配置\",{\"1\":{\"40\":1}}],[\"来查看容器是否正常工作\",{\"1\":{\"35\":1}}],[\"其它锁想获取\",{\"1\":{\"255\":1}}],[\"其持有的锁也能够被兜底释放\",{\"1\":{\"246\":1}}],[\"其指向每一个分组内的最后一条记录\",{\"1\":{\"224\":1}}],[\"其他运算符\",{\"1\":{\"130\":1}}],[\"其他情况都是分配到堆上\",{\"1\":{\"105\":1}}],[\"其他函数不能进行访问\",{\"1\":{\"105\":1}}],[\"其他的如文件系统\",{\"1\":{\"47\":1}}],[\"其中包含两个哈希表\",{\"1\":{\"264\":1}}],[\"其中\",{\"1\":{\"41\":1,\"146\":1}}],[\"同一个锁\",{\"1\":{\"246\":1}}],[\"同一个结构体字段可以设置多个键值对tag\",{\"1\":{\"172\":1}}],[\"同一个文件夹下的文件只能有一个包名\",{\"1\":{\"122\":1}}],[\"同步完成就返回客户端结果\",{\"1\":{\"237\":1}}],[\"同步模式\",{\"1\":{\"237\":1}}],[\"同步到所有从库\",{\"1\":{\"237\":1}}],[\"同步\",{\"1\":{\"89\":1,\"237\":1}}],[\"同样需要按页来划分\",{\"1\":{\"224\":1}}],[\"同样\",{\"1\":{\"47\":1}}],[\"同时将\",{\"1\":{\"241\":1}}],[\"同时将该页标记为脏页\",{\"1\":{\"227\":1}}],[\"同时unexpungelocked\",{\"1\":{\"205\":1}}],[\"同时指向\",{\"1\":{\"186\":1}}],[\"同时指定password字段为匿名结构体指针类型\",{\"1\":{\"178\":1}}],[\"同时也实施了大量的优化措施\",{\"1\":{\"102\":1}}],[\"同时也保证\",{\"1\":{\"45\":1}}],[\"同时会创建了一对\",{\"1\":{\"45\":1}}],[\"同时\",{\"1\":{\"43\":1,\"198\":1}}],[\"新客户端来获取到了这个锁\",{\"1\":{\"250\":1}}],[\"新增\",{\"1\":{\"193\":1}}],[\"新\",{\"0\":{\"90\":1}}],[\"新建容器并启动\",{\"0\":{\"60\":1}}],[\"新建容器网络\",{\"1\":{\"41\":1}}],[\"新创建的容器不会创建自己的网卡\",{\"1\":{\"47\":1}}],[\"高效快速通信\",{\"1\":{\"47\":1}}],[\"上面提到的\",{\"1\":{\"224\":1}}],[\"上面的两个过程一起完成这个enrty\",{\"1\":{\"205\":1}}],[\"上面的命令加载主机的\",{\"1\":{\"35\":1}}],[\"上解决\",{\"1\":{\"186\":1}}],[\"上图栈部分\",{\"1\":{\"116\":1}}],[\"上也进行了某些转换\",{\"1\":{\"100\":1}}],[\"上执行\",{\"1\":{\"89\":1}}],[\"上已经使用的端口就不能再用了\",{\"1\":{\"46\":1}}],[\"不再需要人工介入\",{\"1\":{\"253\":1}}],[\"不过redis已经有成熟的解决方案\",{\"1\":{\"253\":1}}],[\"不刷盘\",{\"1\":{\"243\":1}}],[\"不\",{\"1\":{\"236\":1}}],[\"不一样\",{\"1\":{\"229\":1}}],[\"不一定要将文件名与包名定成一个名称\",{\"1\":{\"122\":1}}],[\"不在\",{\"1\":{\"220\":1}}],[\"不存在于\",{\"1\":{\"205\":1}}],[\"不存在引用传递\",{\"1\":{\"142\":1}}],[\"不适合多写的场景\",{\"1\":{\"201\":1}}],[\"不需要加锁到\",{\"1\":{\"198\":1}}],[\"不需要进行\",{\"1\":{\"46\":1}}],[\"不把自己置\",{\"1\":{\"194\":1}}],[\"不重置为\",{\"1\":{\"194\":1}}],[\"不支持并发的读写操作\",{\"1\":{\"183\":1}}],[\"不修改原结构体忽略空值字段\",{\"0\":{\"178\":1}}],[\"不同的键值对之间使用空格分隔\",{\"1\":{\"172\":1}}],[\"不同类型零值不一样\",{\"1\":{\"124\":1}}],[\"不让程序core\",{\"1\":{\"166\":1}}],[\"不是本文开头讨论\",{\"1\":{\"223\":1}}],[\"不是\",{\"1\":{\"164\":1}}],[\"不用用来做等值判断\",{\"1\":{\"160\":1}}],[\"不推荐把字段定义在接口中\",{\"1\":{\"152\":1}}],[\"不允许指针算术\",{\"1\":{\"147\":1}}],[\"不允许中间跳开\",{\"1\":{\"136\":1}}],[\"不可见\",{\"1\":{\"220\":2}}],[\"不可以直接对\",{\"1\":{\"148\":1}}],[\"不可以用于全局变量的声明和赋值\",{\"1\":{\"126\":1}}],[\"不可被修改\",{\"1\":{\"128\":1}}],[\"不行\",{\"1\":{\"126\":1}}],[\"不必关注\",{\"1\":{\"117\":1}}],[\"不要盲目使用变量的指针作为函数参数\",{\"1\":{\"109\":1}}],[\"不得不分配到堆上\",{\"1\":{\"105\":1}}],[\"不设置就是默认等于\",{\"1\":{\"81\":1}}],[\"不会有任务影响\",{\"1\":{\"247\":1}}],[\"不会出现半成功的状态\",{\"1\":{\"240\":1}}],[\"不会覆盖以前的日志\",{\"1\":{\"235\":1}}],[\"不会记录查询类的操作\",{\"1\":{\"235\":1}}],[\"不会立即将脏页写入磁盘\",{\"1\":{\"223\":1}}],[\"不会\",{\"1\":{\"199\":1}}],[\"不会启动新的进程\",{\"1\":{\"70\":1}}],[\"不会影响镜像\",{\"1\":{\"28\":1}}],[\"不能释放别人的锁\",{\"1\":{\"249\":1}}],[\"不能把其他竞争者持有的锁给释放了\",{\"1\":{\"246\":1}}],[\"不能把interface\",{\"1\":{\"156\":1}}],[\"不能通过\",{\"1\":{\"197\":1}}],[\"不能再编译阶段确定\",{\"1\":{\"109\":1}}],[\"不能删除正在运行的容器\",{\"1\":{\"63\":1}}],[\"不能连接宿主机以外的其他设备\",{\"1\":{\"47\":1}}],[\"没问题就没问题\",{\"1\":{\"157\":1}}],[\"没有\",{\"1\":{\"167\":1,\"190\":1}}],[\"没有任何方法声明的接口称之为空接口\",{\"1\":{\"155\":1}}],[\"没有c++和java一样的显式继承关系\",{\"1\":{\"149\":1}}],[\"没有类这个概念\",{\"1\":{\"149\":1}}],[\"没有显示初始化\",{\"1\":{\"124\":1}}],[\"没有直接关系\",{\"1\":{\"122\":2}}],[\"没有逃逸\",{\"1\":{\"107\":1}}],[\"没有独立ip地址\",{\"1\":{\"46\":1}}],[\"没啥用but安装了类\",{\"0\":{\"13\":1}}],[\"但在多事务的情况下\",{\"1\":{\"242\":1}}],[\"但在整个本包内是可见而且是可用的\",{\"1\":{\"121\":1}}],[\"但累积\",{\"1\":{\"236\":1}}],[\"但数据库文件还不是最新的\",{\"1\":{\"227\":1}}],[\"但还未完成将最新的数据记录\",{\"1\":{\"227\":1}}],[\"但键的值可能会因为并发操作而发生变化\",{\"1\":{\"206\":1}}],[\"但存在于\",{\"1\":{\"205\":1}}],[\"但可以通过组合和接口来达到类似的效果\",{\"1\":{\"149\":1}}],[\"但可以通过起别名来实现绑定\",{\"1\":{\"148\":1}}],[\"但也带来了更高的风险\",{\"1\":{\"148\":1}}],[\"但传递的是一个\",{\"1\":{\"144\":1}}],[\"但不会改变实参值\",{\"1\":{\"142\":1}}],[\"但不进行任何网络配置\",{\"1\":{\"48\":1}}],[\"但其实当参数为变量自身的时候\",{\"1\":{\"109\":1}}],[\"但实际是可伸缩的\",{\"1\":{\"86\":1}}],[\"但\",{\"1\":{\"46\":1,\"194\":1,\"268\":1}}],[\"但是判断完才开始\",{\"1\":{\"255\":1}}],[\"但是已经时过境迁\",{\"1\":{\"255\":1}}],[\"但是主从切换\",{\"1\":{\"253\":1}}],[\"但是主库宕机\",{\"1\":{\"237\":1}}],[\"但是删除的时候已经是别人的了\",{\"1\":{\"250\":2}}],[\"但是setnx和expire不具备原子性\",{\"1\":{\"248\":1}}],[\"但是性能很差\",{\"1\":{\"242\":1}}],[\"但是这两个是独立的逻辑\",{\"1\":{\"239\":1}}],[\"但是值为\",{\"1\":{\"198\":1}}],[\"但是在内存仍然存在这个\",{\"1\":{\"197\":1}}],[\"但是不想把密码也序列化\",{\"1\":{\"178\":1}}],[\"但是调用此函数的函数继续执行\",{\"1\":{\"167\":1}}],[\"但是调用该函数的代码可以接着执行\",{\"1\":{\"166\":1}}],[\"但是再上一层的还可以可以继续执行\",{\"1\":{\"167\":1}}],[\"但是当前函数panic后面的代码不会被执行\",{\"1\":{\"166\":1}}],[\"但是如果\",{\"1\":{\"192\":1}}],[\"但是如果地址所指向的内容被修改了\",{\"1\":{\"164\":1}}],[\"但是如果拷贝的数据量小\",{\"1\":{\"106\":1}}],[\"但是属于副本读\",{\"1\":{\"140\":1}}],[\"但是iota\",{\"1\":{\"130\":2}}],[\"但是它的大小不能在编译时确定的情况\",{\"1\":{\"105\":1}}],[\"但是发现到\",{\"1\":{\"82\":1}}],[\"但是\",{\"1\":{\"20\":1,\"82\":1,\"199\":1,\"228\":1,\"239\":1}}],[\"中会有更多层的抽象\",{\"1\":{\"263\":1}}],[\"中被抽象为redisobject\",{\"1\":{\"259\":1}}],[\"中就够了\",{\"1\":{\"241\":1}}],[\"中间再穿插写入\",{\"1\":{\"241\":1}}],[\"中间用英文逗号分隔\",{\"1\":{\"176\":1}}],[\"中继日志然后回放\",{\"1\":{\"237\":1}}],[\"中记录的写入量大于\",{\"1\":{\"232\":1}}],[\"中完成数据页的更新\",{\"1\":{\"229\":1}}],[\"中数据所在的页\",{\"1\":{\"223\":1}}],[\"中有\",{\"1\":{\"221\":1}}],[\"中更新\",{\"1\":{\"205\":1}}],[\"中都没有\",{\"1\":{\"203\":1}}],[\"中没有\",{\"1\":{\"203\":2}}],[\"中获取\",{\"1\":{\"203\":1}}],[\"中是没有这个\",{\"1\":{\"199\":1}}],[\"中将\",{\"1\":{\"198\":1}}],[\"中加锁写\",{\"1\":{\"198\":1}}],[\"中操作\",{\"1\":{\"198\":1}}],[\"中操作的\",{\"1\":{\"193\":1}}],[\"中无锁完成写\",{\"1\":{\"198\":1}}],[\"中复制一份逻辑上存在\",{\"1\":{\"193\":1}}],[\"中相同的\",{\"1\":{\"186\":1}}],[\"中处理\",{\"1\":{\"186\":1}}],[\"中找到了\",{\"1\":{\"167\":1}}],[\"中发现了一个\",{\"1\":{\"167\":1}}],[\"中参数是地址\",{\"1\":{\"164\":1}}],[\"中向切片追加元素时\",{\"1\":{\"141\":1}}],[\"中最终所有的元素都是一个地址\",{\"1\":{\"141\":1}}],[\"中包含创建新协程的时候\",{\"1\":{\"89\":1}}],[\"中\",{\"1\":{\"86\":1,\"92\":1,\"149\":1,\"152\":1,\"154\":1,\"192\":1,\"199\":1,\"205\":6,\"218\":1,\"223\":2,\"224\":1,\"227\":1,\"229\":1,\"232\":1,\"239\":1,\"268\":1}}],[\"中从\",{\"1\":{\"82\":1}}],[\"中设置了\",{\"1\":{\"81\":1}}],[\"中一种较为特别的网络的模式\",{\"1\":{\"47\":1}}],[\"中的缓存页\",{\"1\":{\"224\":1}}],[\"中的页就叫做缓存页\",{\"1\":{\"224\":1}}],[\"中的数据页\",{\"1\":{\"227\":1}}],[\"中的数据\",{\"1\":{\"223\":1}}],[\"中的字段没有值时\",{\"1\":{\"175\":1}}],[\"中的协程后\",{\"1\":{\"82\":1}}],[\"中的\",{\"1\":{\"46\":1,\"220\":4,\"224\":1,\"228\":1,\"229\":2,\"268\":1}}],[\"中可以挂载多个\",{\"1\":{\"32\":1}}],[\"例如事务提交时\",{\"1\":{\"229\":1}}],[\"例如将子查询转换为连接\",{\"1\":{\"210\":1}}],[\"例如int和float类型零值是\",{\"1\":{\"175\":1}}],[\"例如经典的递归下降的语法解析\",{\"1\":{\"98\":1}}],[\"例如\",{\"1\":{\"45\":1,\"97\":1,\"100\":1,\"101\":1,\"102\":1}}],[\"例子来自小林图解\",{\"1\":{\"240\":1}}],[\"例子3\",{\"1\":{\"165\":1}}],[\"例子2\",{\"1\":{\"165\":1}}],[\"例子1\",{\"1\":{\"165\":1}}],[\"例子\",{\"1\":{\"39\":1,\"106\":1,\"144\":1,\"153\":1,\"156\":1,\"166\":1,\"167\":1}}],[\"开启\",{\"1\":{\"241\":1}}],[\"开启事务后\",{\"1\":{\"224\":1,\"229\":1}}],[\"开始比赛之前\",{\"1\":{\"240\":1}}],[\"开始前\",{\"1\":{\"213\":1}}],[\"开始调度堆积在全局队列的\",{\"1\":{\"82\":1}}],[\"开销远比变量逃逸后动态地在堆上分配内存少的多\",{\"1\":{\"109\":1}}],[\"开头\",{\"1\":{\"45\":1}}],[\"开发实用\",{\"0\":{\"10\":1}}],[\"另一次是\",{\"1\":{\"242\":1}}],[\"另一端在本地并被挂载到\",{\"1\":{\"45\":1}}],[\"另外\",{\"1\":{\"98\":1,\"254\":1}}],[\"另外一个接口也可以收到相同的数据包\",{\"1\":{\"45\":1}}],[\"接着调用引擎的提交事务接口\",{\"1\":{\"241\":1}}],[\"接着将虚拟地址和物理地址建立映射关系\",{\"1\":{\"224\":1}}],[\"接着运行\",{\"1\":{\"167\":1}}],[\"接受实现了\",{\"1\":{\"158\":1}}],[\"接下来以全景的视角来看\",{\"1\":{\"266\":1}}],[\"接下来会执行defer函数\",{\"1\":{\"166\":1}}],[\"接下来\",{\"1\":{\"101\":1}}],[\"接下来把\",{\"1\":{\"82\":1}}],[\"接口类型\",{\"0\":{\"160\":1}}],[\"接口类型的方法调用是动态调度\",{\"1\":{\"105\":1}}],[\"接口嵌套\",{\"0\":{\"159\":1}}],[\"接口的方法\",{\"1\":{\"158\":2}}],[\"接口的类型作为参数\",{\"1\":{\"158\":1}}],[\"接口的数据结构有关\",{\"1\":{\"157\":1}}],[\"接口作为函数参数\",{\"0\":{\"158\":1}}],[\"接口定义\",{\"0\":{\"153\":1}}],[\"接口用来抽象一系列行为\",{\"1\":{\"152\":1}}],[\"接口\",{\"0\":{\"151\":1},\"1\":{\"45\":1,\"158\":2}}],[\"接收到push操作的阻塞键\",{\"1\":{\"266\":1}}],[\"接收到网络报文\",{\"1\":{\"45\":1}}],[\"接收\",{\"1\":{\"45\":1}}],[\"下面依次是b\",{\"1\":{\"116\":1}}],[\"下面内容会详细分析\",{\"1\":{\"112\":1}}],[\"下面创建一个名为\",{\"1\":{\"32\":1}}],[\"下载一个\",{\"1\":{\"59\":1}}],[\"下载镜像\",{\"0\":{\"57\":1},\"1\":{\"57\":1}}],[\"下\",{\"1\":{\"45\":1}}],[\"附加到\",{\"1\":{\"45\":1}}],[\"将其写到\",{\"1\":{\"235\":1}}],[\"将缓存在\",{\"1\":{\"232\":1}}],[\"将所有数据恢复到最新的状态\",{\"1\":{\"228\":1}}],[\"将本次对这个页修改后的数据状态以\",{\"1\":{\"227\":1}}],[\"将本地线程存储信息保存到cx寄存器中\",{\"1\":{\"117\":1}}],[\"将新值交换到\",{\"1\":{\"205\":1}}],[\"将新的\",{\"1\":{\"205\":1}}],[\"将原本为\",{\"1\":{\"199\":1}}],[\"将会处于一种不稳定的状态\",{\"1\":{\"194\":1}}],[\"将被\",{\"1\":{\"167\":1}}],[\"将返回值结果返回\",{\"1\":{\"165\":1}}],[\"将栈上存储的main函数的调用方的基地址恢复到bp\",{\"1\":{\"117\":1}}],[\"将局部变量r7传给寄存器ax\",{\"1\":{\"117\":1}}],[\"将局部变量r6传给寄存器ax\",{\"1\":{\"117\":1}}],[\"将局部变量r5传给寄存器ax\",{\"1\":{\"117\":1}}],[\"将局部变量r4传给寄存器ax\",{\"1\":{\"117\":1}}],[\"将局部变量r3传给寄存器ax\",{\"1\":{\"117\":1}}],[\"将局部变量r2传给寄存器ax\",{\"1\":{\"117\":1}}],[\"将局部变量r1传给寄存器ax\",{\"1\":{\"117\":1}}],[\"将main函数的基址存放到到bp寄存器\",{\"1\":{\"117\":1}}],[\"将值移动至更接近其使用点的位置\",{\"1\":{\"102\":1}}],[\"将\",{\"1\":{\"45\":2,\"192\":1,\"198\":1,\"205\":1,\"232\":1,\"241\":3,\"243\":1}}],[\"技术的特性可以保证无论哪一个\",{\"1\":{\"45\":1}}],[\"技术\",{\"1\":{\"45\":1,\"227\":1}}],[\"利用\",{\"1\":{\"44\":1,\"45\":1,\"246\":1}}],[\"无限循环\",{\"1\":{\"205\":1}}],[\"无锁更新\",{\"1\":{\"198\":1}}],[\"无锁\",{\"1\":{\"190\":1}}],[\"无法处理的请求的责任\",{\"1\":{\"186\":1}}],[\"无法用\",{\"1\":{\"183\":1}}],[\"无法捕获\",{\"1\":{\"166\":1}}],[\"无法看到主机上的进程\",{\"1\":{\"20\":1}}],[\"无论\",{\"1\":{\"157\":1}}],[\"无其他网卡\",{\"1\":{\"48\":1}}],[\"无\",{\"1\":{\"44\":2}}],[\"虚拟网桥\",{\"1\":{\"44\":1}}],[\"此时a和b拿到了相同的执行权限\",{\"1\":{\"255\":1}}],[\"此时可能虽然加锁成功\",{\"1\":{\"255\":1}}],[\"此时该状态并不需要持久化到磁盘\",{\"1\":{\"241\":1}}],[\"此时这些缓存页都是空闲的\",{\"1\":{\"224\":1}}],[\"此时\",{\"1\":{\"176\":1,\"190\":1,\"250\":1}}],[\"此时默认会绑定本地所有接口上的所有地址\",{\"1\":{\"39\":1}}],[\"此阶段的其他重要任务包括堆栈框架的布局\",{\"1\":{\"102\":1}}],[\"此过程将通用值转换成特定于机器的形式\",{\"1\":{\"102\":1}}],[\"此模式下容器只有\",{\"1\":{\"48\":1}}],[\"此模式会为每一个容器分配\",{\"1\":{\"44\":1}}],[\"默认是选择\",{\"1\":{\"266\":1}}],[\"默认是有\",{\"1\":{\"266\":1}}],[\"默认的同步模式\",{\"1\":{\"237\":1}}],[\"默认情况下\",{\"1\":{\"233\":1}}],[\"默认大小\",{\"1\":{\"231\":1}}],[\"默认开启\",{\"1\":{\"215\":1}}],[\"默认有break\",{\"1\":{\"138\":1}}],[\"默认模式\",{\"1\":{\"44\":1}}],[\"默认会一直存在\",{\"1\":{\"28\":1}}],[\"和参与者\",{\"1\":{\"240\":1}}],[\"和桥接模式一样\",{\"1\":{\"47\":1}}],[\"和\",{\"0\":{\"148\":1},\"1\":{\"45\":1,\"82\":1,\"89\":1,\"141\":1,\"167\":1,\"186\":2,\"194\":2,\"197\":1,\"198\":1,\"200\":1,\"203\":1,\"205\":3,\"219\":3,\"221\":1,\"233\":1,\"235\":1,\"239\":1,\"241\":1,\"259\":1,\"260\":1,\"262\":1,\"266\":1,\"268\":2}}],[\"和网桥连接\",{\"1\":{\"44\":1}}],[\"和端口\",{\"1\":{\"44\":1}}],[\"如关键点3所提到的\",{\"1\":{\"236\":1}}],[\"如何理解\",{\"1\":{\"250\":1}}],[\"如何保证事务的持久性\",{\"1\":{\"228\":1}}],[\"如何记录这个\",{\"1\":{\"228\":1}}],[\"如何记录和回滚\",{\"0\":{\"217\":1}}],[\"如何刷盘的\",{\"0\":{\"221\":1}}],[\"如何判断可见性\",{\"1\":{\"220\":1}}],[\"如何知道版本的可见性\",{\"1\":{\"219\":1}}],[\"如何解决\",{\"1\":{\"215\":1}}],[\"如innodb\",{\"1\":{\"210\":1}}],[\"如\",{\"1\":{\"162\":1}}],[\"如表达式\",{\"1\":{\"99\":1}}],[\"如内存的逃逸等\",{\"1\":{\"98\":1}}],[\"如此一来\",{\"1\":{\"45\":1,\"255\":1}}],[\"如分配\",{\"1\":{\"44\":1}}],[\"如果设置了过期时间\",{\"1\":{\"268\":1}}],[\"如果竞争者a\",{\"1\":{\"255\":1}}],[\"如果挂了2台redis\",{\"1\":{\"254\":1}}],[\"如果剩余时间已经为0\",{\"1\":{\"254\":1}}],[\"如果超过一半失败\",{\"1\":{\"254\":1}}],[\"如果对一致性的要求高一些\",{\"1\":{\"254\":1}}],[\"如果redis挂掉了\",{\"1\":{\"252\":1}}],[\"如果setnx获取锁之后\",{\"1\":{\"248\":1}}],[\"如果获取锁的服务挂掉了\",{\"1\":{\"248\":1}}],[\"如果key存在\",{\"1\":{\"247\":1}}],[\"如果key存在于read中\",{\"1\":{\"205\":1}}],[\"如果key不存在\",{\"1\":{\"247\":1}}],[\"如果任何一位拳击手\",{\"1\":{\"240\":1}}],[\"如果两位拳击手\",{\"1\":{\"240\":1}}],[\"如果没有自己还没有准备好\",{\"1\":{\"240\":1}}],[\"如果觉得自己准备好了\",{\"1\":{\"240\":1}}],[\"如果是更新操作\",{\"1\":{\"229\":1}}],[\"如果是\",{\"1\":{\"224\":1}}],[\"如果是碰见了\",{\"1\":{\"167\":1}}],[\"如果数据存在于\",{\"1\":{\"223\":2}}],[\"如果记录的\",{\"1\":{\"220\":2}}],[\"如果事务readview\",{\"1\":{\"220\":2}}],[\"如果不满足可见行\",{\"1\":{\"219\":1}}],[\"如果每次在事务执行过程中\",{\"1\":{\"215\":1}}],[\"如果查询缓存开启且命中缓存\",{\"1\":{\"210\":1}}],[\"如果操作成功\",{\"1\":{\"205\":1}}],[\"如果entry被移除\",{\"1\":{\"205\":1}}],[\"如果在将\",{\"1\":{\"239\":2}}],[\"如果在这个过程中有并发访问\",{\"1\":{\"194\":1}}],[\"如果在过程中遇到了最近的recover\",{\"1\":{\"167\":1}}],[\"如果这时候来了一个写\",{\"1\":{\"193\":1}}],[\"如果无法解决再交给\",{\"1\":{\"186\":1}}],[\"如果想要在最终的序列化结果中去掉空值字段\",{\"0\":{\"176\":1}}],[\"如果想要在序列化时忽略这些没有值的字段时\",{\"1\":{\"175\":1}}],[\"如果直至\",{\"1\":{\"167\":1}}],[\"如果一直到主函数\",{\"1\":{\"167\":1}}],[\"如果一个函数调用另外一个函数\",{\"1\":{\"114\":1}}],[\"如果一个函数返回了一个变量的引用\",{\"1\":{\"105\":1}}],[\"如果ok这个返回值不接受\",{\"1\":{\"157\":1}}],[\"如果x是nil接口值\",{\"1\":{\"157\":1}}],[\"如果你判断的时候是ok的\",{\"1\":{\"255\":1}}],[\"如果你想在json序列化\",{\"1\":{\"174\":1}}],[\"如果你有一个指向\",{\"1\":{\"147\":1}}],[\"如果你在容器内\",{\"1\":{\"35\":1}}],[\"如果有的属性不写\",{\"1\":{\"135\":1}}],[\"如果当前栈顶地址\",{\"1\":{\"117\":1}}],[\"如果函数外部存在引用\",{\"1\":{\"105\":1}}],[\"如果函数外部没有引用\",{\"1\":{\"105\":1}}],[\"如果频繁进行\",{\"1\":{\"105\":1}}],[\"如果变量从栈上逃逸\",{\"1\":{\"105\":1}}],[\"如果需要更多内容\",{\"1\":{\"86\":1}}],[\"如果\",{\"0\":{\"82\":1},\"1\":{\"75\":1,\"194\":1,\"203\":1,\"204\":1,\"205\":4,\"215\":1,\"220\":1}}],[\"如果要强制删除\",{\"1\":{\"63\":1}}],[\"如果容器希望外部访问能够访问到\",{\"1\":{\"43\":1}}],[\"创建一个新的只读缓存\",{\"1\":{\"204\":1}}],[\"创建一个数据卷\",{\"0\":{\"29\":1}}],[\"创建这个结构体或数组的一个完整副本\",{\"1\":{\"145\":1}}],[\"创建变量的一个新副本\",{\"1\":{\"143\":1}}],[\"创建了\",{\"1\":{\"89\":1}}],[\"创建\",{\"1\":{\"81\":1,\"89\":1}}],[\"创建的\",{\"1\":{\"45\":1}}],[\"创建的容器不会创建自己的网卡\",{\"1\":{\"44\":1}}],[\"而b却还在继续执行\",{\"1\":{\"249\":1}}],[\"而业务还会继续进行\",{\"1\":{\"249\":1}}],[\"而数据页可以稍后再写入\",{\"1\":{\"227\":1}}],[\"而内存总是不可靠\",{\"1\":{\"227\":1}}],[\"而使用到的物理内存空间却很小\",{\"1\":{\"224\":1}}],[\"而且磁盘的运行速度远慢于内存\",{\"1\":{\"231\":1}}],[\"而且执行一条\",{\"1\":{\"215\":1}}],[\"而且栈内存的分配和释放\",{\"1\":{\"105\":1}}],[\"而不经过上述大部分步骤\",{\"1\":{\"210\":1}}],[\"而不需要通过内部结构体的实例来访问\",{\"1\":{\"150\":1}}],[\"而不需要提前指定参数的个数\",{\"1\":{\"146\":1}}],[\"而不是其他\",{\"1\":{\"89\":1}}],[\"而不是和宿主机共享\",{\"1\":{\"47\":1}}],[\"而范围循环则被改写成for循环\",{\"1\":{\"101\":1}}],[\"而\",{\"1\":{\"45\":1,\"186\":2,\"190\":1,\"239\":3,\"268\":1}}],[\"而是先写日志文件\",{\"1\":{\"227\":1}}],[\"而是默认输出字段的类型零值\",{\"1\":{\"175\":1}}],[\"而是和宿主机共用一个\",{\"1\":{\"46\":1}}],[\"而是和一个指定的容器共享\",{\"1\":{\"44\":1,\"47\":1}}],[\"而是使用宿主机的\",{\"1\":{\"44\":1}}],[\"而容器带有运行时需要的可写文件层\",{\"1\":{\"20\":1}}],[\"等之后事务提交的时候\",{\"1\":{\"213\":1,\"235\":1}}],[\"等待所有\",{\"1\":{\"189\":1}}],[\"等待部分写操作完成\",{\"1\":{\"189\":1}}],[\"等\",{\"1\":{\"44\":3,\"210\":1}}],[\"ht\",{\"1\":{\"264\":1}}],[\"hobby\",{\"1\":{\"175\":3,\"176\":3,\"177\":13}}],[\"host最大的优势就是网络性能比较好\",{\"1\":{\"46\":1}}],[\"host\",{\"0\":{\"46\":1},\"1\":{\"44\":1,\"46\":4,\"47\":1}}],[\"height\",{\"1\":{\"158\":3}}],[\"hello\",{\"1\":{\"126\":2,\"150\":1}}],[\"held\",{\"1\":{\"82\":1}}],[\"help\",{\"1\":{\"53\":1}}],[\"hash运算\",{\"1\":{\"267\":1}}],[\"hashtable\",{\"1\":{\"266\":2}}],[\"hash\",{\"1\":{\"259\":1,\"267\":1}}],[\"ha\",{\"1\":{\"130\":3}}],[\"h\",{\"1\":{\"126\":2,\"130\":1}}],[\"hub\",{\"1\":{\"21\":1}}],[\"宿主机ip\",{\"1\":{\"43\":1}}],[\"访问容器\",{\"1\":{\"43\":1}}],[\"访问容器的时候就通过\",{\"1\":{\"43\":1}}],[\"访问到容器\",{\"1\":{\"43\":1}}],[\"外部结构体就可以直接访问内部结构体的字段和方法\",{\"1\":{\"150\":1}}],[\"外部主机是不可见的\",{\"1\":{\"45\":1}}],[\"外部网络是无法寻址到的\",{\"1\":{\"43\":1}}],[\"外部访问容器\",{\"0\":{\"39\":1}}],[\"59\",{\"1\":{\"78\":1,\"79\":1}}],[\"58\",{\"1\":{\"78\":1,\"79\":1}}],[\"57\",{\"1\":{\"78\":1,\"79\":1}}],[\"56\",{\"1\":{\"78\":1,\"79\":1}}],[\"55\",{\"1\":{\"78\":1,\"79\":1}}],[\"54\",{\"1\":{\"78\":1,\"79\":1}}],[\"53\",{\"1\":{\"78\":1,\"79\":1}}],[\"52\",{\"1\":{\"78\":1,\"79\":1}}],[\"51\",{\"1\":{\"78\":1,\"79\":1}}],[\"50\",{\"1\":{\"78\":1,\"79\":1,\"179\":1}}],[\"5000\",{\"1\":{\"39\":9}}],[\"5\",{\"0\":{\"64\":1,\"70\":1,\"127\":1,\"137\":1,\"138\":1,\"146\":1,\"157\":1,\"219\":1,\"231\":1,\"234\":1,\"235\":1,\"236\":1,\"237\":1,\"243\":1},\"1\":{\"77\":1,\"78\":1,\"79\":1,\"117\":17,\"130\":1,\"146\":1,\"158\":1,\"171\":3,\"179\":1,\"227\":1}}],[\"5b06d0d14b3312e589a411dd9ae15589dc9321f771e5615b7ae26e85017de080\",{\"1\":{\"66\":1}}],[\"5b\",{\"1\":{\"43\":1}}],[\"称为\",{\"1\":{\"43\":1}}],[\"地址与外界通信\",{\"1\":{\"46\":1}}],[\"地址\",{\"1\":{\"43\":1,\"44\":1}}],[\"网卡设备通信\",{\"1\":{\"47\":1}}],[\"网桥\",{\"1\":{\"45\":1}}],[\"网桥上\",{\"1\":{\"45\":1}}],[\"网桥以及\",{\"1\":{\"44\":1}}],[\"网桥是宿主机虚拟出来的\",{\"1\":{\"43\":1}}],[\"网桥是每个容器的默认网络网关\",{\"1\":{\"43\":1}}],[\"网桥的网段分配给容器一个\",{\"1\":{\"43\":1}}],[\"网络延迟\",{\"1\":{\"255\":1}}],[\"网络连接\",{\"1\":{\"162\":1}}],[\"网络的隔离性不好\",{\"1\":{\"46\":1}}],[\"网络的联通性\",{\"1\":{\"45\":1}}],[\"网络\",{\"0\":{\"46\":1},\"1\":{\"41\":1}}],[\"网络类型用于\",{\"1\":{\"41\":1}}],[\"网络类型\",{\"1\":{\"41\":1}}],[\"网络模式没有改善容器与宿主机以外世界通信的情况\",{\"1\":{\"47\":1}}],[\"网络模式是\",{\"1\":{\"47\":1}}],[\"网络模式\",{\"0\":{\"38\":1,\"42\":1,\"47\":1},\"1\":{\"44\":1,\"47\":1}}],[\"网络等信息\",{\"1\":{\"20\":1}}],[\"桥接网卡\",{\"1\":{\"43\":1}}],[\"端口范围等\",{\"1\":{\"47\":1}}],[\"端口范围\",{\"1\":{\"44\":1}}],[\"端口\",{\"1\":{\"39\":1}}],[\"端口映射\",{\"0\":{\"39\":1}}],[\"0xffe8\",{\"1\":{\"144\":1}}],[\"0xfff0\",{\"1\":{\"144\":2}}],[\"0x00b3\",{\"1\":{\"117\":1}}],[\"0x00af\",{\"1\":{\"117\":1}}],[\"0x00aa\",{\"1\":{\"117\":1}}],[\"0x00a5\",{\"1\":{\"117\":2}}],[\"0x00a0\",{\"1\":{\"117\":1}}],[\"0x009b\",{\"1\":{\"117\":1}}],[\"0x0096\",{\"1\":{\"117\":1}}],[\"0x0091\",{\"1\":{\"117\":1}}],[\"0x008c\",{\"1\":{\"117\":1}}],[\"0x0087\",{\"1\":{\"117\":1}}],[\"0x0082\",{\"1\":{\"117\":1}}],[\"0x007d\",{\"1\":{\"117\":1}}],[\"0x0078\",{\"1\":{\"117\":1}}],[\"0x0073\",{\"1\":{\"117\":1}}],[\"0x006e\",{\"1\":{\"117\":1}}],[\"0x0069\",{\"1\":{\"117\":1}}],[\"0x0065\",{\"1\":{\"117\":1}}],[\"0x0060\",{\"1\":{\"117\":1}}],[\"0x0057\",{\"1\":{\"117\":1}}],[\"0x004e\",{\"1\":{\"117\":1}}],[\"0x0045\",{\"1\":{\"117\":1}}],[\"0x003c\",{\"1\":{\"117\":1}}],[\"0x0033\",{\"1\":{\"117\":1}}],[\"0x002a\",{\"1\":{\"117\":1}}],[\"0x0021\",{\"1\":{\"117\":3}}],[\"0x001c\",{\"1\":{\"117\":1}}],[\"0x0017\",{\"1\":{\"117\":1}}],[\"0x0013\",{\"1\":{\"117\":2}}],[\"0x000d\",{\"1\":{\"117\":2}}],[\"0x0009\",{\"1\":{\"117\":1}}],[\"0x0000\",{\"1\":{\"117\":2}}],[\"0指定了调用方传入的参数\",{\"1\":{\"117\":1}}],[\"00179\",{\"1\":{\"117\":1}}],[\"00175\",{\"1\":{\"117\":1}}],[\"00170\",{\"1\":{\"117\":1}}],[\"00165\",{\"1\":{\"117\":2}}],[\"00160\",{\"1\":{\"117\":1}}],[\"00155\",{\"1\":{\"117\":1}}],[\"00150\",{\"1\":{\"117\":1}}],[\"00145\",{\"1\":{\"117\":1}}],[\"00140\",{\"1\":{\"117\":1}}],[\"00135\",{\"1\":{\"117\":1}}],[\"00130\",{\"1\":{\"117\":1}}],[\"00125\",{\"1\":{\"117\":1}}],[\"00120\",{\"1\":{\"117\":1}}],[\"00115\",{\"1\":{\"117\":1}}],[\"00110\",{\"1\":{\"117\":1}}],[\"00105\",{\"1\":{\"117\":1}}],[\"00101\",{\"1\":{\"117\":1}}],[\"00096\",{\"1\":{\"117\":1}}],[\"00087\",{\"1\":{\"117\":1}}],[\"00078\",{\"1\":{\"117\":1}}],[\"00069\",{\"1\":{\"117\":1}}],[\"00060\",{\"1\":{\"117\":1}}],[\"00051\",{\"1\":{\"117\":1}}],[\"00042\",{\"1\":{\"117\":1}}],[\"00033\",{\"1\":{\"117\":3}}],[\"00028\",{\"1\":{\"117\":1}}],[\"00023\",{\"1\":{\"117\":1}}],[\"00019\",{\"1\":{\"117\":2}}],[\"00013\",{\"1\":{\"117\":2}}],[\"00009\",{\"1\":{\"117\":1}}],[\"00000\",{\"1\":{\"117\":2}}],[\"00\",{\"1\":{\"68\":3}}],[\"09\",{\"1\":{\"68\":1}}],[\"02\",{\"1\":{\"43\":1}}],[\"0\",{\"1\":{\"39\":6,\"43\":1,\"68\":1,\"82\":3,\"109\":1,\"117\":2,\"124\":1,\"130\":4,\"134\":1,\"141\":1,\"146\":1,\"175\":1,\"184\":2,\"185\":2,\"189\":6,\"204\":2,\"206\":1,\"210\":1,\"232\":1,\"236\":1,\"262\":1,\"264\":1,\"266\":2}}],[\"当分布式锁获得返回包的时间过长\",{\"1\":{\"255\":1}}],[\"当主节点挂了\",{\"1\":{\"253\":1}}],[\"当一个竞争者在持有锁期间内\",{\"1\":{\"246\":1}}],[\"当一个函数发生panic后当前函数体的剩余代码不再执行\",{\"1\":{\"167\":1}}],[\"当有多个事务提交的时候\",{\"1\":{\"243\":1}}],[\"当有一条记录需要更新的时候\",{\"1\":{\"227\":1}}],[\"当客户端执行\",{\"1\":{\"241\":1}}],[\"当事务对数据库中的记录进行更新时\",{\"1\":{\"229\":1}}],[\"当事务需要回滚时\",{\"1\":{\"216\":1}}],[\"当系统崩溃时\",{\"1\":{\"228\":1}}],[\"当修改数据时\",{\"1\":{\"223\":1}}],[\"当读取数据时\",{\"1\":{\"223\":1}}],[\"当然是缓存起来好\",{\"1\":{\"223\":1}}],[\"当写多的时候\",{\"1\":{\"201\":1}}],[\"当请求访问\",{\"1\":{\"186\":1}}],[\"当某一种类型实现了所有这些声明的方法\",{\"1\":{\"152\":1}}],[\"当你传递一个结构体或数组给函数时\",{\"1\":{\"145\":1}}],[\"当程序准备好函数的入参之后\",{\"1\":{\"117\":1}}],[\"当ssa被\",{\"1\":{\"102\":1}}],[\"当\",{\"1\":{\"82\":2,\"175\":1,\"190\":1,\"198\":1,\"201\":1,\"232\":1,\"233\":2}}],[\"当数据包发送到一个接口时\",{\"1\":{\"45\":1}}],[\"当创建一个\",{\"1\":{\"45\":1}}],[\"当使用\",{\"1\":{\"39\":1}}],[\"当执行\",{\"1\":{\"26\":1}}],[\"或者网络延迟\",{\"1\":{\"249\":1}}],[\"或者进行某些常见的sql重写优化\",{\"1\":{\"210\":1}}],[\"或者是否是某个具体的类型\",{\"1\":{\"157\":1}}],[\"或者在结构体中嵌入指向其他结构体的指针\",{\"1\":{\"147\":1}}],[\"或者\",{\"1\":{\"140\":2,\"160\":1}}],[\"或\",{\"1\":{\"39\":1}}],[\"以为自己还持有锁\",{\"1\":{\"255\":1}}],[\"以为errors\",{\"1\":{\"160\":1}}],[\"以页作为磁盘和内存交互的基本单位\",{\"1\":{\"224\":1}}],[\"以来\",{\"1\":{\"203\":1}}],[\"以确保多个\",{\"1\":{\"185\":1}}],[\"以便实现更多功能\",{\"1\":{\"263\":1}}],[\"以便于判断数据的可见性\",{\"1\":{\"220\":1}}],[\"以便后面完成真正的更新操作\",{\"1\":{\"205\":1}}],[\"以便在函数之间共享和修改数据\",{\"1\":{\"147\":1}}],[\"以便编译器的其他部分可以更容易地使用\",{\"1\":{\"101\":1}}],[\"以下分析适合\",{\"1\":{\"141\":1}}],[\"以小写字母开头\",{\"1\":{\"121\":1}}],[\"以大写字母开头\",{\"1\":{\"121\":1}}],[\"以前版本\",{\"1\":{\"120\":1}}],[\"以前使用\",{\"1\":{\"35\":1}}],[\"以及\",{\"1\":{\"267\":1}}],[\"以及进行寄存器分配\",{\"1\":{\"102\":1}}],[\"以及删除未使用的代码分支\",{\"1\":{\"101\":1}}],[\"以及确定函数是否终止\",{\"1\":{\"100\":1}}],[\"以及每个表达式具有的类型\",{\"1\":{\"100\":1}}],[\"以通过\",{\"1\":{\"39\":1}}],[\"npc\",{\"1\":{\"255\":1}}],[\"nx表示具备setnx\",{\"1\":{\"248\":1}}],[\"nx\",{\"1\":{\"248\":1}}],[\"null\",{\"1\":{\"175\":1}}],[\"num++\",{\"1\":{\"165\":2}}],[\"nums\",{\"1\":{\"146\":5}}],[\"num\",{\"1\":{\"137\":1,\"146\":2,\"164\":5,\"165\":5}}],[\"number\",{\"1\":{\"67\":1}}],[\"nil\",{\"0\":{\"198\":1},\"1\":{\"81\":1,\"82\":2,\"124\":1,\"147\":1,\"171\":2,\"175\":2,\"177\":1,\"178\":1,\"179\":1,\"192\":1,\"193\":1,\"194\":3,\"197\":1,\"198\":6,\"199\":5,\"203\":2,\"204\":1,\"205\":8,\"206\":1}}],[\"n\",{\"0\":{\"77\":1,\"78\":1,\"79\":1},\"1\":{\"75\":5,\"81\":1,\"82\":15,\"117\":1,\"155\":1,\"157\":1,\"171\":4,\"175\":2,\"177\":2,\"178\":2,\"179\":2,\"188\":1,\"189\":2,\"201\":1,\"236\":1,\"255\":1}}],[\"nginx\",{\"1\":{\"66\":1}}],[\"n=1\",{\"1\":{\"61\":1}}],[\"n=\",{\"1\":{\"61\":1}}],[\"nat\",{\"1\":{\"44\":1,\"46\":2}}],[\"name3\",{\"1\":{\"125\":1}}],[\"name2\",{\"1\":{\"125\":2}}],[\"name1\",{\"1\":{\"125\":2}}],[\"name=\",{\"1\":{\"60\":1}}],[\"name\",{\"1\":{\"32\":1,\"35\":1,\"41\":1,\"44\":1,\"60\":1,\"106\":4,\"123\":1,\"124\":1,\"135\":2,\"150\":5,\"152\":1,\"171\":4,\"173\":2,\"174\":2,\"175\":4,\"176\":3,\"177\":13,\"178\":4,\"211\":1,\"239\":6}}],[\"namespace\",{\"1\":{\"26\":1,\"44\":3,\"45\":1,\"46\":2,\"47\":1,\"48\":1}}],[\"not\",{\"1\":{\"188\":1,\"271\":1}}],[\"none\",{\"0\":{\"48\":1},\"1\":{\"44\":1,\"48\":2}}],[\"noqueue\",{\"1\":{\"43\":1}}],[\"next\",{\"1\":{\"267\":1}}],[\"nestedstructdemo\",{\"1\":{\"177\":1}}],[\"need\",{\"1\":{\"156\":1}}],[\"net=bridge\",{\"1\":{\"44\":1}}],[\"net=none\",{\"1\":{\"44\":1}}],[\"net=container\",{\"1\":{\"44\":1}}],[\"net=host\",{\"1\":{\"44\":1}}],[\"net\",{\"1\":{\"41\":3}}],[\"network=none\",{\"1\":{\"48\":1}}],[\"network=container\",{\"1\":{\"47\":1}}],[\"network\",{\"1\":{\"41\":2,\"44\":4,\"46\":2,\"47\":1,\"48\":1,\"255\":2}}],[\"newentry\",{\"1\":{\"205\":1}}],[\"newvalue1\",{\"1\":{\"188\":1}}],[\"new\",{\"1\":{\"35\":2,\"106\":1,\"160\":2}}],[\"就可以一定程度解决网络延迟的问题\",{\"1\":{\"255\":1}}],[\"就像石沉大海\",{\"1\":{\"248\":1}}],[\"就立即返回数据给客户端\",{\"1\":{\"237\":1}}],[\"就创建一个新的文件继续写\",{\"1\":{\"235\":1}}],[\"就创建了在主机和所有容器之间一个虚拟共享网络\",{\"1\":{\"45\":1}}],[\"就好了\",{\"1\":{\"217\":1}}],[\"就不会让锁失效了\",{\"1\":{\"254\":1}}],[\"就不会发生\",{\"1\":{\"185\":1}}],[\"就不需要从磁盘获取数据了\",{\"1\":{\"223\":1}}],[\"就不用担心无法回滚到事务之前的数据\",{\"1\":{\"215\":1}}],[\"就相当于\",{\"1\":{\"201\":1}}],[\"就意味着\",{\"1\":{\"192\":1}}],[\"就是为redis配置从节点\",{\"1\":{\"253\":1}}],[\"就是通过cas将expunged态的entry变成nil态\",{\"1\":{\"205\":1}}],[\"就是标记\",{\"1\":{\"190\":1}}],[\"就是\",{\"1\":{\"186\":1,\"190\":1}}],[\"就是没有程序了\",{\"1\":{\"66\":1}}],[\"就算\",{\"1\":{\"164\":1,\"241\":1}}],[\"就需要实现内部嵌套的接口对应的所有方法\",{\"1\":{\"159\":1}}],[\"就要用断言\",{\"1\":{\"157\":1}}],[\"就被视为实现了该接口\",{\"1\":{\"151\":1}}],[\"就全变成\",{\"1\":{\"134\":1}}],[\"就足够\",{\"1\":{\"86\":1}}],[\"就开始从\",{\"1\":{\"82\":1}}],[\"就会释放锁\",{\"1\":{\"249\":1}}],[\"就会跟裁判说还没准备好\",{\"1\":{\"240\":1}}],[\"就会跟裁判说准备好了\",{\"1\":{\"240\":1}}],[\"就会默认提交上一个事务\",{\"1\":{\"236\":1}}],[\"就会顺着\",{\"1\":{\"219\":1}}],[\"就会出现问题\",{\"1\":{\"249\":1}}],[\"就会出现\",{\"1\":{\"194\":1}}],[\"就会从\",{\"1\":{\"193\":1}}],[\"就会被捕获\",{\"1\":{\"167\":1}}],[\"就会把部分\",{\"1\":{\"82\":1}}],[\"就会立刻停止\",{\"1\":{\"66\":1}}],[\"就会自动停止\",{\"1\":{\"66\":1}}],[\"就必须要有要一个前台进程\",{\"1\":{\"66\":1}}],[\"就挂载为只读了\",{\"1\":{\"35\":1}}],[\"就随之启动了\",{\"1\":{\"26\":1}}],[\"用变种拉链法来解决哈希冲突\",{\"1\":{\"267\":1}}],[\"用从节点顶包\",{\"1\":{\"253\":1}}],[\"用完之后\",{\"1\":{\"247\":1}}],[\"用于multi\",{\"1\":{\"266\":1}}],[\"用于内存淘汰\",{\"1\":{\"262\":1}}],[\"用于备份恢复\",{\"1\":{\"235\":1}}],[\"用于快速定位某条记录的大致位置\",{\"1\":{\"224\":1}}],[\"用于数据的复制和恢复\",{\"1\":{\"213\":1}}],[\"用于存储条目的值\",{\"1\":{\"190\":1,\"196\":1}}],[\"用户记录\",{\"1\":{\"224\":1}}],[\"用户可以认为改\",{\"1\":{\"198\":1}}],[\"用户也可以通过增加\",{\"1\":{\"35\":1}}],[\"用cas操作\",{\"1\":{\"190\":1}}],[\"用\",{\"1\":{\"163\":1}}],[\"用panic抛出异常\",{\"1\":{\"163\":1}}],[\"用途\",{\"1\":{\"147\":1}}],[\"用局部变量\",{\"1\":{\"141\":1}}],[\"用来描述有几个指针指向该对象\",{\"1\":{\"262\":1}}],[\"用来设置一个key的超时时间\",{\"1\":{\"248\":1}}],[\"用来检查接口变量的值是否实现了某个接口\",{\"1\":{\"157\":1}}],[\"用来简化内存管理并减少与指针相关的错误\",{\"1\":{\"147\":1}}],[\"用来存放a函数的\",{\"1\":{\"117\":1}}],[\"用来存储和分发\",{\"1\":{\"21\":1}}],[\"用来区分容器\",{\"1\":{\"60\":1}}],[\"现在假设有5个redis主节点\",{\"1\":{\"254\":1}}],[\"现在来模拟一下读\",{\"1\":{\"198\":1}}],[\"现在使用\",{\"1\":{\"35\":1}}],[\"现在可以免费用\",{\"1\":{\"12\":1}}],[\"会有一定时耗\",{\"1\":{\"254\":1}}],[\"会有磁盘上的页被加载缓存到\",{\"1\":{\"224\":1}}],[\"会提高人力成本\",{\"1\":{\"253\":1}}],[\"会释放掉服务\",{\"1\":{\"249\":1}}],[\"会同时维护\",{\"1\":{\"241\":1}}],[\"会宣布比赛暂停\",{\"1\":{\"240\":1}}],[\"会依次询问两位拳击手\",{\"1\":{\"240\":1}}],[\"会在中间确认两位拳击手的状态\",{\"1\":{\"240\":1}}],[\"会在更新记录之前\",{\"1\":{\"224\":1}}],[\"会导致磁盘的i\",{\"1\":{\"236\":1}}],[\"会写到\",{\"1\":{\"236\":1}}],[\"会切换回\",{\"1\":{\"233\":1}}],[\"会切换至\",{\"1\":{\"233\":1}}],[\"会触发落盘\",{\"1\":{\"232\":1}}],[\"会记录对数据页的修改操作细节\",{\"1\":{\"229\":1}}],[\"会为\",{\"1\":{\"224\":1}}],[\"会每秒刷盘\",{\"1\":{\"221\":1}}],[\"会先写入内核的缓冲区\",{\"1\":{\"236\":1}}],[\"会先写入到\",{\"1\":{\"231\":1}}],[\"会先生成一条\",{\"1\":{\"229\":1}}],[\"会先记录更新前的数据到\",{\"1\":{\"216\":1}}],[\"会先调度\",{\"1\":{\"82\":1}}],[\"会将多个\",{\"1\":{\"243\":1}}],[\"会将该事务执行过程中产生的所有\",{\"1\":{\"235\":1}}],[\"会将该事物执行过程中产生的所有\",{\"1\":{\"213\":1}}],[\"会将整个页加载进\",{\"1\":{\"224\":1}}],[\"会将对象分配在堆上\",{\"1\":{\"109\":1}}],[\"会降低性能\",{\"1\":{\"194\":1}}],[\"会通过锁找到\",{\"1\":{\"186\":1}}],[\"会尽量在\",{\"1\":{\"186\":1}}],[\"会拥有全量的数据\",{\"1\":{\"186\":1}}],[\"会让请求在\",{\"1\":{\"186\":1}}],[\"会\",{\"1\":{\"145\":1}}],[\"会拷贝原地址\",{\"1\":{\"142\":1}}],[\"会调用汇编指令call\",{\"1\":{\"117\":1}}],[\"会往下移动128个字节\",{\"1\":{\"117\":1}}],[\"会跑到堆上\",{\"1\":{\"105\":1}}],[\"会执行一系列与具体机器无关的优化步骤和规则\",{\"1\":{\"101\":1}}],[\"会被复制到从库\",{\"1\":{\"239\":2}}],[\"会被写入\",{\"1\":{\"229\":2}}],[\"会被当做\",{\"1\":{\"146\":1}}],[\"会被转换成静态单赋值\",{\"1\":{\"101\":1}}],[\"会被依次放入到\",{\"1\":{\"81\":1}}],[\"会造成延迟和额外的系统负载\",{\"1\":{\"89\":1}}],[\"会自动为\",{\"1\":{\"86\":1}}],[\"会自动为你创建一个文件夹\",{\"1\":{\"35\":1}}],[\"会去全局队列中拿一批\",{\"1\":{\"82\":1}}],[\"会把存储的数据划分为若干个页\",{\"1\":{\"224\":1}}],[\"会把\",{\"1\":{\"82\":1}}],[\"会指向最新切换进来的协程\",{\"1\":{\"81\":1}}],[\"会随机映射一个\",{\"1\":{\"39\":1}}],[\"会显示如下错误\",{\"1\":{\"35\":1}}],[\"会报错\",{\"1\":{\"35\":1}}],[\"会创建\",{\"1\":{\"26\":1}}],[\"比较函数\",{\"1\":{\"264\":1}}],[\"比较当前栈顶地址\",{\"1\":{\"117\":1}}],[\"比较长\",{\"1\":{\"76\":1}}],[\"比如发生gc\",{\"1\":{\"255\":1}}],[\"比如为每个节点配置哨兵模式\",{\"1\":{\"254\":1}}],[\"比如redis的redlock\",{\"1\":{\"254\":1}}],[\"比如多台不同机器上的进程\",{\"1\":{\"246\":1}}],[\"比如拳套还没有带好\",{\"1\":{\"240\":1}}],[\"比如一主二从的集群\",{\"1\":{\"237\":1}}],[\"比如有很多条语句\",{\"1\":{\"236\":1}}],[\"比如这条待执行的\",{\"1\":{\"211\":1}}],[\"比如需要访问\",{\"1\":{\"201\":1}}],[\"比如结构体中的关联实体\",{\"1\":{\"176\":1}}],[\"比如函数a调用b\",{\"1\":{\"116\":1}}],[\"比如用常数替换特定表达式\",{\"1\":{\"101\":1}}],[\"比如用户可以放置一些程序到本地目录中\",{\"1\":{\"35\":1}}],[\"比如当\",{\"1\":{\"89\":1}}],[\"比如\",{\"1\":{\"61\":1,\"66\":1,\"148\":1,\"217\":1,\"224\":1,\"235\":1}}],[\"比comate处理能力强\",{\"1\":{\"12\":1}}],[\"目的是避免有其他\",{\"1\":{\"203\":1}}],[\"目的主机的路径\",{\"1\":{\"71\":1}}],[\"目标文件除了包含机器代码外\",{\"1\":{\"102\":1}}],[\"目录下\",{\"1\":{\"98\":1}}],[\"目录新建文件\",{\"1\":{\"35\":1}}],[\"目录到容器的\",{\"1\":{\"35\":1}}],[\"目录挂载\",{\"0\":{\"34\":1}}],[\"目录\",{\"1\":{\"32\":1,\"35\":1}}],[\"目前\",{\"1\":{\"21\":1}}],[\"目前首选\",{\"1\":{\"12\":1}}],[\"目前使用ing\",{\"1\":{\"5\":1}}],[\"并返回1\",{\"1\":{\"247\":1}}],[\"并保证后续其它竞争者也能加锁\",{\"1\":{\"246\":1}}],[\"并清空binlog\",{\"1\":{\"236\":1}}],[\"并在适当的时机\",{\"1\":{\"229\":1}}],[\"并在内存中进行修改\",{\"1\":{\"229\":1}}],[\"并在中间阶段对代码进行多次优化\",{\"1\":{\"97\":1}}],[\"并提交了事务\",{\"1\":{\"219\":1}}],[\"并选择其中的最优计划\",{\"1\":{\"210\":1}}],[\"并将\",{\"1\":{\"204\":1}}],[\"并将容器连接到一个\",{\"1\":{\"44\":1}}],[\"并发访问的多个版本通过快照控制\",{\"1\":{\"219\":1}}],[\"并发冲突\",{\"1\":{\"194\":1}}],[\"并发调用\",{\"1\":{\"185\":1}}],[\"并发读操作\",{\"1\":{\"184\":1,\"185\":1}}],[\"并发写操作\",{\"1\":{\"184\":1,\"185\":1}}],[\"并添加omitemptytag\",{\"1\":{\"178\":1}}],[\"并没有传统面向对象语言中的继承概念\",{\"1\":{\"149\":1}}],[\"并没有对其进行任何网络设置\",{\"1\":{\"44\":1}}],[\"并不会深入到实际数据\",{\"1\":{\"129\":1}}],[\"并不是真实存在的网络设备\",{\"1\":{\"43\":1}}],[\"并执行\",{\"1\":{\"117\":1}}],[\"并生成最终的目标文件\",{\"1\":{\"102\":1}}],[\"并进行指针活动分析\",{\"1\":{\"102\":1}}],[\"并为每个源构造语法树文件\",{\"1\":{\"99\":1}}],[\"并且记录对于的\",{\"1\":{\"229\":1}}],[\"并且支持原子性的读写操作\",{\"1\":{\"190\":1,\"196\":1}}],[\"并且会权衡整体操作性能的并发安全\",{\"1\":{\"186\":1}}],[\"并且不携带任何堆栈信息\",{\"1\":{\"160\":1}}],[\"并且可以根据需要实现不同的接口\",{\"1\":{\"154\":1}}],[\"并且将内部结构体实例作为方法的接收者\",{\"1\":{\"150\":1}}],[\"并且这些字段会被初始化为内部结构体的实例\",{\"1\":{\"150\":1}}],[\"并且这几\",{\"1\":{\"86\":1}}],[\"并且恢复默认记数\",{\"1\":{\"130\":1}}],[\"并且\",{\"1\":{\"89\":1,\"203\":2}}],[\"并且容器中的进程属于运行状态\",{\"1\":{\"20\":1}}],[\"并退出\",{\"1\":{\"62\":1}}],[\"并被改名为\",{\"1\":{\"45\":1}}],[\"并加载一个\",{\"1\":{\"32\":1}}],[\"watched\",{\"1\":{\"266\":1}}],[\"wal\",{\"1\":{\"227\":2,\"228\":1}}],[\"wait\",{\"1\":{\"75\":1,\"189\":1}}],[\"waitgroup\",{\"1\":{\"75\":1,\"189\":1}}],[\"where\",{\"1\":{\"211\":1,\"239\":1}}],[\"writing\",{\"1\":{\"159\":2}}],[\"write\",{\"1\":{\"159\":3,\"184\":1,\"227\":1,\"236\":4,\"241\":1}}],[\"writer\",{\"1\":{\"159\":2}}],[\"width\",{\"1\":{\"158\":3}}],[\"wg\",{\"1\":{\"75\":4,\"189\":10}}],[\"weight\",{\"1\":{\"171\":4,\"173\":1,\"174\":1}}],[\"wepapp\",{\"1\":{\"32\":1,\"35\":1}}],[\"website\",{\"1\":{\"177\":1}}],[\"webapp\",{\"1\":{\"32\":3,\"35\":6}}],[\"web\",{\"1\":{\"32\":2,\"35\":1,\"36\":1}}],[\"workdir\",{\"1\":{\"26\":1}}],[\"workbench\",{\"1\":{\"3\":1}}],[\"挂载一个本地主机文件作为数据卷\",{\"0\":{\"37\":1}}],[\"挂载一个主机目录作为数据卷\",{\"0\":{\"35\":1}}],[\"挂载到容器里\",{\"1\":{\"32\":1}}],[\"挂载主机目录的默认权限是读写\",{\"1\":{\"35\":1}}],[\"挂载主机目录\",{\"1\":{\"27\":1}}],[\"在组织形式上会有所差异\",{\"1\":{\"268\":1}}],[\"在全景图的\",{\"1\":{\"268\":1}}],[\"在内存里的存储形式为\",{\"1\":{\"262\":1}}],[\"在内存中修改\",{\"1\":{\"229\":1}}],[\"在5台分布式机器上都加上锁\",{\"1\":{\"255\":1}}],[\"在gc回来之后\",{\"1\":{\"255\":1}}],[\"在真实的分布式场景中\",{\"1\":{\"249\":1}}],[\"在两阶段提交的流程基础上\",{\"1\":{\"242\":1}}],[\"在主从架构中\",{\"1\":{\"239\":2}}],[\"在完成一条更新操作后\",{\"1\":{\"235\":1}}],[\"在进行更新操作之前\",{\"1\":{\"229\":1}}],[\"在事务提交的时候\",{\"1\":{\"236\":1}}],[\"在事务提交时\",{\"1\":{\"227\":1,\"228\":1}}],[\"在事务没提交之前\",{\"1\":{\"216\":1}}],[\"在启动事务时生成一个\",{\"1\":{\"219\":1}}],[\"在还没有提交事务之前\",{\"1\":{\"215\":1}}],[\"在发生\",{\"1\":{\"199\":1}}],[\"在下一次更新\",{\"1\":{\"199\":1}}],[\"在逻辑上已经删除了\",{\"1\":{\"198\":1}}],[\"在复制的过程中\",{\"1\":{\"194\":1}}],[\"在等待锁释放时被阻塞\",{\"1\":{\"185\":1}}],[\"在tag中添加omitempty忽略空值\",{\"1\":{\"176\":1}}],[\"在执行完panic之后\",{\"1\":{\"166\":1}}],[\"在程序中加入recover机制\",{\"1\":{\"166\":1}}],[\"在64位系统上是64位的\",{\"1\":{\"148\":1}}],[\"在32位系统上是32位的\",{\"1\":{\"148\":1}}],[\"在函数内部\",{\"1\":{\"146\":1}}],[\"在函数内部返回一个局部变量指针\",{\"1\":{\"105\":1}}],[\"在上面的示例中\",{\"1\":{\"146\":1}}],[\"在初始化时以属性\",{\"1\":{\"135\":1}}],[\"在不发生内存逃逸的情况下\",{\"1\":{\"127\":1}}],[\"在一个事务在执行过程中\",{\"1\":{\"215\":1}}],[\"在一个函数调用链中\",{\"1\":{\"116\":1}}],[\"在一次\",{\"1\":{\"32\":1}}],[\"在创建切片的时候\",{\"1\":{\"109\":1}}],[\"在编译期间很难确定参数具体类型\",{\"1\":{\"108\":1}}],[\"在编译的第一阶段\",{\"1\":{\"99\":1}}],[\"在某些情况下\",{\"1\":{\"105\":1}}],[\"在栈里声明临时变量分配内存\",{\"1\":{\"105\":1}}],[\"在ssa生成阶段完成时\",{\"1\":{\"102\":1}}],[\"在amd64架构中\",{\"1\":{\"102\":1}}],[\"在ast转换为ssa的过程中\",{\"1\":{\"101\":1}}],[\"在转换过程中\",{\"1\":{\"101\":1}}],[\"在此阶段\",{\"1\":{\"101\":1}}],[\"在\",{\"1\":{\"89\":1,\"92\":1,\"100\":1,\"130\":1,\"141\":1,\"146\":2,\"149\":1,\"152\":1,\"154\":1,\"167\":2,\"198\":1,\"199\":2,\"217\":3,\"220\":1,\"224\":2,\"241\":1,\"259\":1,\"263\":1,\"268\":1}}],[\"在接着调度\",{\"1\":{\"82\":1}}],[\"在运行时\",{\"1\":{\"81\":1}}],[\"在宿主机上创建两个虚拟网络接口设备\",{\"1\":{\"45\":1}}],[\"在宿主机虚拟一个docker\",{\"1\":{\"43\":1}}],[\"在用\",{\"1\":{\"32\":1}}],[\"在容器创建时使用\",{\"1\":{\"47\":1}}],[\"在容器中管理数据主要有两种方式\",{\"1\":{\"27\":1}}],[\"在容器内部\",{\"1\":{\"20\":1}}],[\"对称性\",{\"0\":{\"251\":1},\"1\":{\"246\":1}}],[\"对两阶段提交加强\",{\"0\":{\"243\":1}}],[\"对添加到\",{\"1\":{\"205\":1}}],[\"对用一个\",{\"1\":{\"198\":1}}],[\"对象的指针\",{\"1\":{\"268\":1}}],[\"对象类型零值是\",{\"1\":{\"175\":1}}],[\"对象\",{\"1\":{\"160\":1,\"259\":1,\"266\":2,\"267\":1,\"268\":1}}],[\"对副本的任何修改都不会影响原始变量\",{\"1\":{\"143\":1}}],[\"对于读提交和可重复读隔离级别的事务来说\",{\"1\":{\"219\":1}}],[\"对于\",{\"1\":{\"186\":2,\"242\":1}}],[\"对于内部结构体的方法\",{\"1\":{\"150\":1}}],[\"对于内部结构体的字段\",{\"1\":{\"150\":1}}],[\"对于引用类型和指针\",{\"1\":{\"144\":1}}],[\"对于基础数据类型\",{\"1\":{\"143\":1}}],[\"对于性能要求高且访问频次高的函数调用\",{\"1\":{\"109\":1}}],[\"对包外不可见\",{\"1\":{\"121\":1}}],[\"对应0\",{\"1\":{\"265\":1}}],[\"对应的事务状态设置为\",{\"1\":{\"241\":1}}],[\"对应事务中的回滚操作\",{\"1\":{\"240\":1}}],[\"对应同一块\",{\"1\":{\"186\":1}}],[\"对应到虚拟地址空间的栈\",{\"1\":{\"114\":1}}],[\"对应于源的各种元素的节点\",{\"1\":{\"99\":1}}],[\"对\",{\"1\":{\"28\":2,\"100\":1,\"221\":1,\"243\":1,\"266\":3}}],[\"垫片\",{\"1\":{\"26\":1}}],[\"充当\",{\"1\":{\"26\":1}}],[\"时钟漂移\",{\"1\":{\"255\":1}}],[\"时\",{\"1\":{\"26\":1,\"185\":2,\"220\":2,\"231\":1}}],[\"命令docker\",{\"1\":{\"66\":1}}],[\"命令参数可选项\",{\"1\":{\"61\":1}}],[\"命令的时候\",{\"1\":{\"32\":1}}],[\"命令\",{\"1\":{\"26\":1,\"53\":1,\"68\":1,\"261\":1},\"2\":{\"73\":1}}],[\"update\",{\"0\":{\"211\":1},\"1\":{\"211\":3,\"215\":1,\"217\":1,\"224\":1,\"239\":1}}],[\"u1\",{\"1\":{\"175\":2,\"177\":2,\"178\":3}}],[\"unsigned\",{\"1\":{\"262\":3,\"266\":1}}],[\"unsafe\",{\"0\":{\"148\":1},\"1\":{\"129\":3,\"148\":5}}],[\"undo页\",{\"1\":{\"224\":1}}],[\"undo\",{\"1\":{\"221\":3,\"224\":1,\"229\":3}}],[\"undolog日志文件\",{\"1\":{\"216\":1}}],[\"undolog\",{\"0\":{\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1,\"221\":1,\"229\":1},\"1\":{\"211\":1,\"213\":2,\"215\":1,\"216\":1,\"217\":1,\"218\":2,\"219\":2,\"221\":1,\"224\":3,\"229\":6}}],[\"unexpungelocked\",{\"1\":{\"205\":1}}],[\"unlock\",{\"1\":{\"203\":1,\"205\":1,\"206\":1}}],[\"unmarsha\",{\"1\":{\"179\":1}}],[\"unmarshal\",{\"0\":{\"171\":1},\"1\":{\"171\":2,\"179\":1}}],[\"user\",{\"1\":{\"175\":2,\"176\":1,\"177\":5,\"178\":4,\"211\":1,\"239\":2}}],[\"use\",{\"1\":{\"156\":1}}],[\"usr\",{\"1\":{\"26\":1}}],[\"ult\",{\"1\":{\"43\":1}}],[\"udp\",{\"1\":{\"39\":3}}],[\"ufs\",{\"1\":{\"28\":1}}],[\"uintptr是一个可变长的整数类型\",{\"1\":{\"148\":1}}],[\"uintptr指针算术\",{\"1\":{\"148\":1}}],[\"uintptr\",{\"0\":{\"148\":1},\"1\":{\"129\":1,\"148\":1}}],[\"uid\",{\"1\":{\"68\":1}}],[\"ui\",{\"0\":{\"4\":1}}],[\"void\",{\"1\":{\"262\":1,\"264\":1}}],[\"vol\",{\"1\":{\"31\":1,\"32\":2,\"33\":1,\"35\":1}}],[\"volume\",{\"1\":{\"29\":1,\"30\":1,\"31\":1,\"33\":1}}],[\"volumes\",{\"1\":{\"27\":1}}],[\"v的实体\",{\"1\":{\"190\":1}}],[\"v2\",{\"1\":{\"144\":2}}],[\"version\",{\"1\":{\"53\":1,\"140\":2,\"141\":1,\"219\":1}}],[\"vethaqi2qt\",{\"1\":{\"45\":1}}],[\"veth1\",{\"1\":{\"45\":2}}],[\"veth0\",{\"1\":{\"45\":4}}],[\"veth\",{\"1\":{\"44\":1,\"45\":5}}],[\"vm1\",{\"1\":{\"47\":2}}],[\"vmware\",{\"1\":{\"46\":1}}],[\"vxlan\",{\"1\":{\"44\":1}}],[\"val\",{\"1\":{\"157\":4}}],[\"value2\",{\"1\":{\"172\":1,\"188\":1}}],[\"value1\",{\"1\":{\"172\":1,\"188\":1}}],[\"value\",{\"1\":{\"124\":1,\"128\":1,\"140\":3,\"156\":1,\"157\":1,\"186\":2,\"188\":4,\"189\":6,\"190\":1,\"195\":1,\"198\":1,\"203\":2,\"205\":7,\"206\":1,\"247\":1,\"248\":1,\"259\":2,\"261\":1,\"263\":1,\"266\":2,\"268\":2}}],[\"valid\",{\"1\":{\"43\":1}}],[\"variable\",{\"1\":{\"156\":2}}],[\"variadic\",{\"1\":{\"146\":1}}],[\"var\",{\"1\":{\"26\":4,\"117\":1,\"123\":1,\"124\":1,\"125\":3,\"148\":1,\"154\":3,\"156\":3,\"157\":1,\"159\":1,\"164\":1,\"165\":1,\"171\":1,\"179\":1,\"189\":2}}],[\"v\",{\"1\":{\"32\":1,\"35\":2,\"124\":1,\"125\":5,\"141\":10,\"171\":3,\"175\":1,\"177\":1,\"178\":1,\"179\":2,\"197\":4,\"201\":1,\"203\":4,\"205\":9,\"206\":2,\"262\":1,\"265\":1,\"266\":1,\"267\":3}}],[\"v1\",{\"1\":{\"26\":1,\"141\":3,\"144\":1}}],[\"vs\",{\"1\":{\"11\":1}}],[\"vscode\",{\"0\":{\"2\":1,\"3\":1},\"1\":{\"6\":1,\"13\":1},\"2\":{\"14\":1,\"15\":1,\"168\":1,\"169\":1}}],[\"|\",{\"1\":{\"26\":6,\"132\":1}}],[\"later\",{\"1\":{\"266\":1}}],[\"latest\",{\"1\":{\"57\":1}}],[\"lfu\",{\"1\":{\"262\":2}}],[\"lft\",{\"1\":{\"43\":2}}],[\"lru\",{\"1\":{\"262\":6}}],[\"lua\",{\"0\":{\"250\":1},\"1\":{\"250\":1}}],[\"least\",{\"1\":{\"262\":1}}],[\"leaq\",{\"1\":{\"117\":1}}],[\"length\",{\"1\":{\"109\":4}}],[\"len\",{\"1\":{\"82\":4,\"129\":2,\"204\":1}}],[\"level\",{\"1\":{\"26\":1}}],[\"long\",{\"1\":{\"266\":3}}],[\"loaded\",{\"1\":{\"205\":4}}],[\"loadreadonly\",{\"1\":{\"203\":2,\"205\":2,\"206\":2}}],[\"load\",{\"0\":{\"203\":1},\"1\":{\"188\":1,\"189\":1,\"203\":4,\"205\":1,\"206\":1}}],[\"locals=0x80\",{\"1\":{\"117\":1}}],[\"localhost\",{\"1\":{\"47\":1}}],[\"lock\",{\"1\":{\"82\":2,\"203\":1,\"205\":1,\"206\":1}}],[\"lo\",{\"1\":{\"47\":1,\"48\":1}}],[\"logfile1\",{\"1\":{\"233\":3}}],[\"logfile0\",{\"1\":{\"233\":4}}],[\"log文件意味着写入到了操作系统的文件缓存\",{\"1\":{\"232\":1}}],[\"logging\",{\"1\":{\"227\":1}}],[\"logs\",{\"1\":{\"67\":1}}],[\"log\",{\"1\":{\"26\":1,\"227\":3,\"228\":1,\"229\":4,\"230\":1,\"231\":8,\"232\":17,\"233\":1,\"237\":1,\"239\":5,\"241\":6,\"242\":1}}],[\"ls\",{\"1\":{\"30\":1}}],[\"l\",{\"1\":{\"26\":1,\"117\":1}}],[\"link\",{\"1\":{\"43\":1}}],[\"linux\",{\"1\":{\"26\":2,\"43\":1,\"59\":1}}],[\"library\",{\"0\":{\"278\":1},\"1\":{\"57\":1}}],[\"lib\",{\"1\":{\"26\":1}}],[\"list\",{\"1\":{\"3\":1,\"153\":6,\"259\":1,\"266\":1}}],[\"镜\",{\"1\":{\"26\":1}}],[\"镜像来测试学习\",{\"1\":{\"59\":1}}],[\"镜像id\",{\"1\":{\"58\":4}}],[\"镜像名\",{\"1\":{\"57\":1,\"66\":1}}],[\"镜像的大小\",{\"1\":{\"55\":1}}],[\"镜像的创建时间\",{\"1\":{\"55\":1}}],[\"镜像的id\",{\"1\":{\"55\":1}}],[\"镜像的标签\",{\"1\":{\"55\":1}}],[\"镜像的仓库源\",{\"1\":{\"55\":1}}],[\"镜像命令\",{\"0\":{\"54\":1}}],[\"镜像创建并启动容器\",{\"1\":{\"26\":1}}],[\"镜像仓库分为公共镜像仓库和私有镜像仓库\",{\"1\":{\"21\":1}}],[\"镜像是静态的只读文件\",{\"1\":{\"20\":1}}],[\"镜像\",{\"0\":{\"18\":1},\"1\":{\"21\":1}}],[\"然后锁超时\",{\"1\":{\"255\":1}}],[\"然后拳击手听到后做出应答\",{\"1\":{\"240\":1}}],[\"然后马上执行\",{\"1\":{\"236\":1}}],[\"然后在适当时机批量写入磁盘\",{\"1\":{\"230\":1}}],[\"然后在\",{\"1\":{\"229\":1}}],[\"然后在合适的时间再将新的记录写到磁盘上\",{\"1\":{\"227\":1}}],[\"然后在内存中修改这条记录\",{\"1\":{\"223\":1}}],[\"然后把这条\",{\"1\":{\"224\":1}}],[\"然后按照默认的\",{\"1\":{\"224\":1}}],[\"然后将\",{\"1\":{\"241\":2}}],[\"然后将其页设置为脏页\",{\"1\":{\"223\":1}}],[\"然后将客户端的请求转化为\",{\"1\":{\"24\":1}}],[\"然后整个事务期间都在用这个\",{\"1\":{\"219\":1}}],[\"然后\",{\"1\":{\"192\":1,\"227\":1}}],[\"然后可能将其转换回原来的类型或不同的类型\",{\"1\":{\"148\":1}}],[\"然后改变当前的栈指针\",{\"1\":{\"117\":1}}],[\"然后再在\",{\"1\":{\"82\":1}}],[\"然后被调度执行\",{\"1\":{\"81\":1}}],[\"然后启动容器的真正进程\",{\"1\":{\"26\":1}}],[\"然后停止\",{\"1\":{\"26\":1}}],[\"秒\",{\"1\":{\"26\":1,\"232\":1}}],[\"即对象\",{\"1\":{\"259\":1}}],[\"即函数栈\",{\"1\":{\"114\":1}}],[\"即多线程访问同一资源需要加锁进行保证互斥\",{\"1\":{\"89\":1}}],[\"即使主库宕机\",{\"1\":{\"237\":1}}],[\"即使没有显式输入begin开启事务和commit提交事务\",{\"1\":{\"215\":1}}],[\"即使有协程阻塞\",{\"1\":{\"86\":1}}],[\"即使容器被删除\",{\"1\":{\"28\":1}}],[\"即\",{\"1\":{\"45\":1,\"190\":1}}],[\"即通过\",{\"1\":{\"43\":1}}],[\"即等待\",{\"1\":{\"26\":1}}],[\"即容器运行着真正的应用进程\",{\"1\":{\"20\":1}}],[\"这点redlock是无法解决的\",{\"1\":{\"255\":1}}],[\"这行数据的\",{\"1\":{\"239\":2}}],[\"这时可能会发生哈希冲突\",{\"1\":{\"267\":1}}],[\"这时候竞争者b拿到了锁\",{\"1\":{\"255\":1}}],[\"这时候gc回来了\",{\"1\":{\"255\":1}}],[\"这时候\",{\"1\":{\"249\":1}}],[\"这时更新操作就算完成了\",{\"1\":{\"227\":1}}],[\"这时会发生内存逃逸\",{\"1\":{\"105\":1}}],[\"这也是\",{\"1\":{\"223\":1}}],[\"这也意味着外部网络无法通过直接\",{\"1\":{\"43\":1}}],[\"这将加速提升\",{\"1\":{\"203\":1}}],[\"这两个日志的刷盘先后顺序可能会导致下面两种情况\",{\"1\":{\"239\":1}}],[\"这两个\",{\"1\":{\"186\":1}}],[\"这两种方式返回的\",{\"1\":{\"160\":1}}],[\"这带来了更高的灵活性\",{\"1\":{\"148\":1}}],[\"这是默认值\",{\"1\":{\"232\":1}}],[\"这是因为只有这些虚拟内存被访问后\",{\"1\":{\"224\":1}}],[\"这是一个线性时间复杂度\",{\"1\":{\"201\":1}}],[\"这是一个故意的设计选择\",{\"1\":{\"147\":1}}],[\"这是\",{\"1\":{\"148\":1}}],[\"这是容器与直接运行在主机上进程的本质区别\",{\"1\":{\"20\":1}}],[\"这意味着\",{\"1\":{\"147\":1}}],[\"这里有两个问题\",{\"1\":{\"255\":1}}],[\"这里涉及磁盘i\",{\"1\":{\"236\":1}}],[\"这里不涉及磁盘i\",{\"1\":{\"236\":1}}],[\"这里附上一张更具体的图来辅助理解\",{\"1\":{\"224\":1}}],[\"这里会考虑索引的使用\",{\"1\":{\"210\":1}}],[\"这里会涉及到数据的双向流转机制\",{\"1\":{\"186\":1}}],[\"这里是重点\",{\"1\":{\"177\":1}}],[\"这里打印的是切片v的索引\",{\"1\":{\"141\":1}}],[\"这里可行\",{\"1\":{\"126\":1}}],[\"这里没有入参\",{\"1\":{\"117\":1}}],[\"这一通下操作都不是原子化的\",{\"1\":{\"250\":1}}],[\"这一点要尽可能保证\",{\"1\":{\"246\":1}}],[\"这一步就是让dirty也能有这个key和entry\",{\"1\":{\"205\":1}}],[\"这一步骤为局部变量分配堆栈偏移量\",{\"1\":{\"102\":1}}],[\"这一个地址最终指向的是\",{\"1\":{\"141\":1}}],[\"这一底层阶段执行了所有针对特定机器的重写规则\",{\"1\":{\"102\":1}}],[\"这些信息会先写入\",{\"1\":{\"229\":1}}],[\"这些副本是独立的\",{\"1\":{\"143\":1}}],[\"这些指令随后被传递给装载器cmd\",{\"1\":{\"102\":1}}],[\"这些通用优化过程包括移除死代码\",{\"1\":{\"101\":1}}],[\"这些步骤和规则不特定于任何一种计算机架构\",{\"1\":{\"101\":1}}],[\"这种情况几乎无解\",{\"1\":{\"255\":1}}],[\"这种多机模式都可以使用\",{\"1\":{\"254\":1}}],[\"这种模式的好处在于\",{\"1\":{\"254\":1}}],[\"这种锁机制会导致其他\",{\"1\":{\"185\":1}}],[\"这种致命错误是会导致程序直接崩溃\",{\"1\":{\"166\":1}}],[\"这种灵活性允许一个类型定义多种行为\",{\"1\":{\"154\":1}}],[\"这种形式的标识符对象可以被外部包的代码所使用\",{\"1\":{\"121\":1}}],[\"这种程序可能是可执行文件\",{\"1\":{\"97\":1}}],[\"这种编译器被称为三阶段编译器\",{\"1\":{\"97\":1}}],[\"这就是\",{\"1\":{\"227\":1}}],[\"这就叫\",{\"1\":{\"219\":1}}],[\"这就代表read和dirty都有个nil的entry\",{\"1\":{\"205\":1}}],[\"这就形成了激烈的锁竞争\",{\"1\":{\"89\":1}}],[\"这就降低了编程的难度\",{\"1\":{\"86\":1}}],[\"这就能在有限的内存空间内支持大量\",{\"1\":{\"86\":1}}],[\"这段\",{\"1\":{\"81\":1}}],[\"这样的设计可以省却很多麻烦\",{\"1\":{\"255\":1}}],[\"这样可以保证\",{\"1\":{\"232\":1}}],[\"这样可以减少磁盘的寻道时间和旋转延迟\",{\"1\":{\"230\":1}}],[\"这样下次有查询语句命中了这条记录\",{\"1\":{\"223\":1}}],[\"这样就造成两份日志之间的逻辑不一致\",{\"1\":{\"239\":1}}],[\"这样就保证了在事务期间读到的数据都是事务启动前的记录\",{\"1\":{\"219\":1}}],[\"这样就无法做到数据隔离的\",{\"1\":{\"194\":1}}],[\"这样回滚时再把这些列\",{\"1\":{\"217\":1}}],[\"这样回滚时再把由这些内容组成的记录\",{\"1\":{\"217\":1}}],[\"这样回滚时只需要把这个主键值对应的记录\",{\"1\":{\"217\":1}}],[\"这样\",{\"1\":{\"150\":1,\"254\":1}}],[\"这样子会增加gc的负担\",{\"1\":{\"106\":1}}],[\"这样两个容器之间可以使用\",{\"1\":{\"47\":1}}],[\"这样容器之间就能够通过容器的\",{\"1\":{\"43\":1}}],[\"这对接口一端在容器内\",{\"1\":{\"45\":1}}],[\"这个可以在做业务之前\",{\"1\":{\"255\":1}}],[\"这个可以作为判断依据\",{\"1\":{\"254\":1}}],[\"这个命令的语法是\",{\"1\":{\"247\":1}}],[\"这个策略可由\",{\"1\":{\"232\":1}}],[\"这个操作是为了保证在事务回滚时能够恢复到原始状态\",{\"1\":{\"229\":1}}],[\"这个问题该如何解决呢\",{\"1\":{\"252\":1}}],[\"这个问题需要了解一个\",{\"1\":{\"224\":1}}],[\"这个问题请关注我的go语言学习专栏吧\",{\"1\":{\"176\":1}}],[\"这个链表就被称为版本链\",{\"1\":{\"218\":1}}],[\"这个流转的可以理解为\",{\"1\":{\"192\":1}}],[\"这个指针可以安全地在不同的\",{\"1\":{\"190\":1,\"196\":1}}],[\"这个指令首先会将\",{\"1\":{\"117\":1}}],[\"这个时候服务a恢复过来并做完了业务\",{\"1\":{\"249\":1}}],[\"这个时候就需要加锁\",{\"1\":{\"246\":1}}],[\"这个时候就需要在\",{\"1\":{\"199\":1}}],[\"这个时候可以在结构体tag中添加string来告诉json包从字符串中解析相应字段的数据\",{\"1\":{\"179\":1}}],[\"这个时候我们就可以使用创建另外一个结构体publicuser匿名嵌套原user\",{\"1\":{\"178\":1}}],[\"这个\",{\"1\":{\"150\":1,\"229\":1}}],[\"这个过程包括进行另一轮的死代码消除\",{\"1\":{\"102\":1}}],[\"这个模式指定新创建的容器和已经存在的一个容器共享一个\",{\"1\":{\"47\":1}}],[\"这个功能在进行测试\",{\"1\":{\"35\":1}}],[\"这个容器会在后台运行一个简单的sleep任务\",{\"1\":{\"26\":1}}],[\"blpop\",{\"1\":{\"266\":1}}],[\"blocking\",{\"1\":{\"266\":1}}],[\"bits\",{\"1\":{\"262\":3}}],[\"binlog与\",{\"1\":{\"241\":1}}],[\"binlog文件\",{\"1\":{\"213\":1}}],[\"binlog\",{\"0\":{\"234\":1,\"235\":1,\"236\":1,\"237\":1},\"1\":{\"211\":1,\"213\":4,\"235\":8,\"236\":15,\"237\":9,\"239\":9,\"241\":7,\"242\":1,\"243\":4}}],[\"bind\",{\"1\":{\"27\":1}}],[\"bin\",{\"1\":{\"26\":1,\"62\":1,\"70\":1}}],[\"binary\",{\"1\":{\"26\":1}}],[\"bbb数据页\",{\"1\":{\"228\":1}}],[\"byte\",{\"1\":{\"179\":1}}],[\"bytes\",{\"1\":{\"117\":1}}],[\"bool\",{\"1\":{\"143\":1,\"157\":1,\"188\":1,\"189\":1,\"190\":1,\"203\":1,\"205\":2,\"206\":1}}],[\"bool类型\",{\"1\":{\"124\":1}}],[\"b\",{\"1\":{\"128\":2,\"129\":2,\"130\":3,\"134\":1,\"154\":5,\"156\":1,\"171\":3,\"175\":2,\"177\":2,\"178\":2,\"249\":1}}],[\"bp寄存器存放的是main函数caller的基址\",{\"1\":{\"117\":1}}],[\"bp\",{\"1\":{\"117\":4}}],[\"b调用c\",{\"1\":{\"116\":1}}],[\"begin\",{\"1\":{\"236\":1}}],[\"be\",{\"1\":{\"82\":1}}],[\"between\",{\"1\":{\"9\":1}}],[\"basis\",{\"0\":{\"279\":1,\"283\":1}}],[\"bash\",{\"1\":{\"62\":1,\"70\":1}}],[\"back\",{\"0\":{\"273\":1}}],[\"batch\",{\"1\":{\"82\":1}}],[\"bucket\",{\"1\":{\"266\":1}}],[\"buffe\",{\"1\":{\"223\":1}}],[\"buffer\",{\"0\":{\"222\":1,\"223\":1,\"224\":1,\"225\":1,\"232\":1},\"1\":{\"221\":1,\"223\":2,\"227\":4,\"228\":1,\"229\":5,\"230\":1,\"231\":5,\"232\":7,\"239\":1}}],[\"bufferpool\",{\"0\":{\"212\":1},\"1\":{\"223\":3,\"224\":7,\"229\":2}}],[\"build\",{\"1\":{\"106\":1}}],[\"but\",{\"1\":{\"82\":1}}],[\"busybox2\",{\"1\":{\"41\":1}}],[\"busybox\",{\"1\":{\"26\":3,\"41\":1}}],[\"break\",{\"1\":{\"206\":1}}],[\"brd\",{\"1\":{\"43\":2}}],[\"bridge\",{\"0\":{\"45\":1},\"1\":{\"41\":2,\"44\":2}}],[\"真正管理了容器的生命周期\",{\"1\":{\"25\":1}}],[\"启动时默认开启\",{\"1\":{\"265\":1}}],[\"启动完成的时候\",{\"1\":{\"224\":1}}],[\"启动多个并发删除操作\",{\"1\":{\"189\":1}}],[\"启动多个并发读操作\",{\"1\":{\"189\":1}}],[\"启动多个并发写操作\",{\"1\":{\"189\":1}}],[\"启动\",{\"1\":{\"75\":1}}],[\"启动容器\",{\"1\":{\"64\":1}}],[\"启动容器使用\",{\"1\":{\"46\":1}}],[\"启动和停止容器的操作\",{\"0\":{\"64\":1}}],[\"启动的时候\",{\"1\":{\"26\":1,\"224\":1}}],[\"启动一个容器时会根据\",{\"1\":{\"43\":1}}],[\"启动一个挂载数据卷的容器\",{\"0\":{\"32\":1}}],[\"启动一个\",{\"1\":{\"26\":1,\"189\":1}}],[\"启动并管理\",{\"1\":{\"25\":1}}],[\"启用工作台列表的平滑滚动效果\",{\"1\":{\"3\":1}}],[\"⬇️辅助理解\",{\"1\":{\"213\":1}}],[\"⬇️\",{\"1\":{\"25\":1}}],[\"图解redis\",{\"1\":{\"258\":1}}],[\"图示\",{\"1\":{\"227\":1,\"233\":1}}],[\"图上有\",{\"1\":{\"25\":1}}],[\"图标包\",{\"0\":{\"6\":1}}],[\"通常是奇数个\",{\"1\":{\"254\":1}}],[\"通道\",{\"1\":{\"144\":1}}],[\"通用的重写规则主要关注表达式\",{\"1\":{\"101\":1}}],[\"通信\",{\"1\":{\"24\":1}}],[\"通过时间\",{\"1\":{\"255\":1}}],[\"通过setnx加锁\",{\"1\":{\"247\":1}}],[\"通过将数据页首先写入缓冲池\",{\"1\":{\"230\":1}}],[\"通过维护数据的多个版本来实现并发访问\",{\"1\":{\"219\":1}}],[\"通过存储引擎接口调用具体的存储引擎\",{\"1\":{\"210\":1}}],[\"通过估算不同执行计划的代价\",{\"1\":{\"210\":1}}],[\"通过mysql连接器处理后\",{\"1\":{\"210\":1}}],[\"通过无锁的\",{\"1\":{\"186\":1}}],[\"通过定义接口和实现接口的方式\",{\"1\":{\"151\":1}}],[\"通过在一个结构体中嵌入另一个匿名结构体\",{\"1\":{\"150\":1}}],[\"通过这种方式\",{\"1\":{\"45\":1}}],[\"通过\",{\"1\":{\"24\":1,\"25\":1,\"26\":1,\"44\":1,\"117\":1,\"198\":1,\"218\":2,\"219\":1,\"239\":1}}],[\"与主库的值不一致\",{\"1\":{\"239\":2}}],[\"与json\",{\"0\":{\"171\":1}}],[\"与本地线程存储的栈顶地址\",{\"1\":{\"117\":1}}],[\"与宿主机在同一个网络中\",{\"1\":{\"46\":1}}],[\"与\",{\"0\":{\"183\":1,\"229\":1},\"1\":{\"24\":1,\"26\":1,\"161\":1,\"220\":1,\"229\":1}}],[\"gc卡顿等原因\",{\"1\":{\"249\":1}}],[\"gclocals\",{\"1\":{\"117\":2}}],[\"gcflags\",{\"1\":{\"106\":1}}],[\"gc\",{\"1\":{\"98\":1,\"100\":1,\"101\":1,\"102\":1,\"255\":2}}],[\"gm\",{\"0\":{\"89\":1}}],[\"gm符号概念\",{\"0\":{\"88\":1}}],[\"gm模型\",{\"0\":{\"87\":1}}],[\"gmp符号定义\",{\"0\":{\"91\":1}}],[\"gmp\",{\"0\":{\"92\":1,\"274\":1},\"1\":{\"81\":1,\"82\":2},\"2\":{\"84\":1,\"94\":1}}],[\"gmp模型是\",{\"1\":{\"85\":1}}],[\"gmp模型\",{\"0\":{\"74\":1,\"85\":1,\"90\":1}}],[\"gp1\",{\"1\":{\"82\":2}}],[\"gp\",{\"1\":{\"82\":2}}],[\"globrunqget\",{\"1\":{\"82\":1}}],[\"global\",{\"1\":{\"43\":1,\"82\":5,\"262\":1}}],[\"get\",{\"1\":{\"82\":1}}],[\"g9\",{\"1\":{\"81\":1}}],[\"g3\",{\"1\":{\"81\":2,\"82\":1}}],[\"g248\",{\"1\":{\"82\":1}}],[\"g258\",{\"1\":{\"82\":3}}],[\"g256\",{\"1\":{\"82\":4}}],[\"g257\",{\"1\":{\"82\":5}}],[\"g2\",{\"1\":{\"81\":3,\"82\":1}}],[\"g189\",{\"1\":{\"82\":1}}],[\"g188\",{\"1\":{\"82\":1}}],[\"g128\",{\"1\":{\"82\":1}}],[\"g129\",{\"1\":{\"82\":1}}],[\"g1\",{\"1\":{\"81\":5,\"82\":4}}],[\"g10\",{\"1\":{\"81\":3}}],[\"g\",{\"1\":{\"81\":4,\"82\":12,\"89\":11,\"126\":2,\"130\":1}}],[\"go库\",{\"2\":{\"181\":1}}],[\"goland很多库的源代码都会以空接口作为参数\",{\"1\":{\"155\":1}}],[\"go没有专门的枚举类型\",{\"1\":{\"129\":1}}],[\"go基础语法\",{\"0\":{\"120\":1}}],[\"goarch=amd64\",{\"1\":{\"117\":1}}],[\"goos=linux\",{\"1\":{\"117\":1}}],[\"go汇编\",{\"1\":{\"117\":1}}],[\"go中参数传递都是值传递\",{\"1\":{\"142\":1}}],[\"go中\",{\"1\":{\"117\":1}}],[\"go中没有一个关键字或者函数可以让变量被编译器分配到堆上\",{\"1\":{\"105\":1}}],[\"go1\",{\"0\":{\"117\":1},\"1\":{\"116\":1,\"117\":1}}],[\"go的多值返回\",{\"0\":{\"118\":1}}],[\"go的多值返回如何实现\",{\"1\":{\"112\":1}}],[\"go的函数调用\",{\"0\":{\"113\":1}}],[\"go的函数调用过程\",{\"1\":{\"112\":1}}],[\"go的函数调用时参数是通过栈传递还是寄存器传递\",{\"1\":{\"112\":1}}],[\"go的变量如果能在编译器编译过程中证明确认在函数返回后不会再被引用\",{\"1\":{\"105\":1}}],[\"go函数调用过程\",{\"0\":{\"111\":1}}],[\"go函数已被转换成一系列的obj\",{\"1\":{\"102\":1}}],[\"go内存逃逸\",{\"0\":{\"105\":1}}],[\"go语言跟其他语言一样\",{\"1\":{\"130\":1}}],[\"go语言函数调用过程\",{\"1\":{\"111\":1}}],[\"go语言内存逃逸的场景\",{\"1\":{\"105\":1}}],[\"go语言编译器有一些特殊的设计\",{\"1\":{\"98\":1}}],[\"go语言编译器一般缩写为小写的gc\",{\"1\":{\"98\":1}}],[\"go语言的编译器遵循了主流编译器采用的经典策略及相似的处理流程和优化规则\",{\"1\":{\"98\":1}}],[\"go最终能被编译成特定机器上的可执行文件\",{\"1\":{\"96\":1}}],[\"go为后缀的utf\",{\"1\":{\"96\":1}}],[\"go大致编译过程\",{\"0\":{\"95\":1}}],[\"go\",{\"0\":{\"86\":1,\"96\":1,\"98\":1,\"114\":1,\"116\":1,\"147\":1,\"275\":1},\"1\":{\"75\":1,\"85\":2,\"86\":1,\"92\":1,\"98\":3,\"106\":2,\"117\":41,\"120\":2,\"140\":2,\"141\":1,\"146\":1,\"147\":2,\"148\":1,\"149\":2,\"150\":1,\"152\":1,\"154\":1,\"160\":1,\"183\":1,\"184\":2,\"185\":2,\"186\":1,\"189\":4,\"194\":1},\"2\":{\"83\":1,\"84\":1,\"93\":1,\"94\":1,\"103\":1,\"110\":1,\"119\":1,\"180\":1,\"207\":1}}],[\"goroutine\",{\"0\":{\"86\":1},\"1\":{\"75\":1,\"86\":7,\"92\":2,\"185\":3,\"189\":2,\"190\":1,\"196\":1,\"203\":1}}],[\"gomaxprocs\",{\"1\":{\"75\":1,\"81\":1,\"82\":3}}],[\"grammar\",{\"0\":{\"277\":1}}],[\"group\",{\"1\":{\"43\":1,\"233\":1,\"236\":1,\"243\":1}}],[\"grpc\",{\"1\":{\"24\":1}}],[\"github\",{\"1\":{\"12\":1}}],[\"git\",{\"1\":{\"11\":1}}],[\"gitlens\",{\"1\":{\"11\":1}}],[\"git可视化\",{\"0\":{\"11\":1}}],[\"所指向的\",{\"1\":{\"268\":1}}],[\"所有的\",{\"1\":{\"263\":1}}],[\"所有存储引擎都可以使用\",{\"1\":{\"235\":1}}],[\"所有类型都实现了空接口\",{\"1\":{\"155\":1}}],[\"所有后台服务的统称\",{\"1\":{\"24\":1}}],[\"所以是不会重复占用内存\",{\"1\":{\"268\":1}}],[\"所以锁剩余持有时间\",{\"1\":{\"254\":1}}],[\"所以我们可以进一步给出解决方案\",{\"1\":{\"249\":1}}],[\"所以只让一个竞争者持有锁\",{\"1\":{\"246\":1}}],[\"所以每当执行一个\",{\"1\":{\"236\":1}}],[\"所以写入\",{\"1\":{\"232\":1}}],[\"所以查询一条记录的时候\",{\"1\":{\"224\":1}}],[\"所以可以观察到使用的虚拟内存空间很大\",{\"1\":{\"224\":1}}],[\"所以该版本的记录对当前事务\",{\"1\":{\"220\":4}}],[\"所以不再继续运行\",{\"1\":{\"167\":1}}],[\"所以空接口可以存储任意类型的数值\",{\"1\":{\"155\":1}}],[\"所以就不能确定其内存大小\",{\"1\":{\"109\":1}}],[\"所以传递指针不一定是高效的\",{\"1\":{\"106\":1}}],[\"所以全局\",{\"1\":{\"89\":1}}],[\"所以\",{\"1\":{\"82\":1,\"105\":1,\"167\":1,\"231\":1,\"239\":1,\"248\":1}}],[\"所以当\",{\"1\":{\"82\":1}}],[\"所以创建的协程\",{\"1\":{\"81\":1}}],[\"所以你想启动一个容器\",{\"1\":{\"19\":1}}],[\"所属的\",{\"1\":{\"45\":1}}],[\"roll\",{\"1\":{\"218\":2,\"219\":1}}],[\"root\",{\"1\":{\"26\":1,\"58\":3,\"62\":1,\"66\":1,\"68\":1}}],[\"rw\",{\"1\":{\"159\":4}}],[\"r\",{\"1\":{\"158\":5}}],[\"r7+64\",{\"1\":{\"117\":2}}],[\"r7\",{\"1\":{\"117\":2}}],[\"r6+72\",{\"1\":{\"117\":2}}],[\"r6\",{\"1\":{\"117\":2}}],[\"r5+80\",{\"1\":{\"117\":2}}],[\"r5\",{\"1\":{\"117\":2}}],[\"r4+88\",{\"1\":{\"117\":2}}],[\"r4\",{\"1\":{\"117\":2}}],[\"r3+96\",{\"1\":{\"117\":2}}],[\"r3\",{\"1\":{\"117\":2}}],[\"r2+104\",{\"1\":{\"117\":2}}],[\"r2\",{\"1\":{\"117\":2}}],[\"r1+112\",{\"1\":{\"117\":2}}],[\"r1\",{\"1\":{\"117\":2}}],[\"raed\",{\"1\":{\"205\":1}}],[\"radius\",{\"1\":{\"151\":3,\"158\":4}}],[\"range\",{\"0\":{\"140\":1,\"141\":1,\"206\":1},\"1\":{\"107\":2,\"140\":3,\"141\":7,\"146\":1,\"188\":1,\"189\":2,\"206\":4}}],[\"rainbow\",{\"1\":{\"8\":3}}],[\"rehashidx\",{\"1\":{\"264\":1}}],[\"relative\",{\"1\":{\"262\":1}}],[\"relay\",{\"1\":{\"237\":1}}],[\"refcount\",{\"1\":{\"262\":2}}],[\"redlock也不能扛住npc的挑战\",{\"1\":{\"255\":1}}],[\"redlock算做了些考量\",{\"1\":{\"255\":1}}],[\"redlock\",{\"0\":{\"255\":1}}],[\"redlcok\",{\"1\":{\"254\":1}}],[\"redo\",{\"1\":{\"227\":3,\"228\":1,\"229\":4,\"230\":1,\"231\":7,\"232\":13,\"233\":1,\"239\":5,\"241\":5,\"242\":1}}],[\"redolog和\",{\"1\":{\"239\":1}}],[\"redolog与数据分开写入磁盘的必要性\",{\"0\":{\"230\":1}}],[\"redolog\",{\"0\":{\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"231\":1,\"232\":1,\"233\":1},\"1\":{\"211\":1,\"213\":2,\"221\":3,\"227\":1,\"228\":3,\"229\":6,\"233\":2,\"241\":2}}],[\"redisdb\",{\"0\":{\"265\":1,\"266\":1,\"268\":1},\"1\":{\"264\":1,\"265\":2,\"266\":3,\"268\":1}}],[\"redisobject\",{\"0\":{\"259\":1,\"260\":1,\"262\":1},\"1\":{\"261\":1,\"262\":2,\"263\":2,\"264\":1,\"266\":3}}],[\"redis数据在内存中的组织过程\",{\"0\":{\"258\":1}}],[\"redis还有个特性\",{\"1\":{\"250\":1}}],[\"redis+lua\",{\"1\":{\"250\":1}}],[\"redis考虑到了这种场景\",{\"1\":{\"248\":1}}],[\"redis中有expire命令\",{\"1\":{\"248\":1}}],[\"redis实现分布式锁的方式\",{\"1\":{\"246\":1}}],[\"redis实现分布式锁\",{\"0\":{\"246\":1}}],[\"redis\",{\"0\":{\"267\":1,\"282\":1},\"1\":{\"56\":1,\"68\":1,\"246\":1,\"258\":4,\"259\":2,\"260\":1,\"261\":1,\"262\":1,\"263\":2,\"264\":1,\"265\":1,\"266\":3,\"267\":2},\"2\":{\"256\":1,\"257\":1,\"269\":1,\"270\":1}}],[\"revocer\",{\"1\":{\"167\":1}}],[\"recover捕获异常\",{\"1\":{\"163\":1}}],[\"recover\",{\"0\":{\"163\":1},\"1\":{\"167\":7,\"183\":1}}],[\"rectangle\",{\"1\":{\"158\":3}}],[\"res++\",{\"1\":{\"165\":1}}],[\"res\",{\"1\":{\"141\":10,\"165\":7}}],[\"result\",{\"1\":{\"129\":1,\"141\":2,\"156\":1,\"157\":1,\"164\":1,\"165\":3,\"184\":1}}],[\"restart\",{\"1\":{\"64\":1}}],[\"rest\",{\"1\":{\"23\":1}}],[\"ret\",{\"1\":{\"117\":1}}],[\"return并非一个原子操作\",{\"1\":{\"165\":1}}],[\"return\",{\"0\":{\"165\":1},\"1\":{\"82\":2,\"106\":1,\"117\":1,\"146\":1,\"148\":1,\"151\":1,\"153\":3,\"158\":2,\"161\":1,\"164\":1,\"165\":3,\"171\":2,\"175\":1,\"177\":1,\"178\":1,\"179\":1,\"188\":1,\"189\":1,\"203\":2,\"204\":1,\"205\":5}}],[\"representation\",{\"1\":{\"97\":1}}],[\"repository\",{\"1\":{\"55\":1}}],[\"ready\",{\"1\":{\"266\":1}}],[\"readview\",{\"0\":{\"219\":1,\"220\":1},\"1\":{\"219\":6,\"220\":8}}],[\"read中获取\",{\"1\":{\"203\":1}}],[\"readmap没有的\",{\"1\":{\"190\":1}}],[\"readmap\",{\"1\":{\"186\":5,\"190\":1,\"192\":1,\"193\":1,\"198\":2,\"199\":1,\"203\":1}}],[\"reading\",{\"1\":{\"159\":2}}],[\"readwriter\",{\"1\":{\"159\":2}}],[\"reader\",{\"1\":{\"159\":2}}],[\"read\",{\"0\":{\"192\":1,\"193\":1},\"1\":{\"35\":1,\"159\":3,\"184\":1,\"186\":2,\"189\":1,\"190\":5,\"192\":2,\"193\":1,\"194\":5,\"198\":2,\"199\":5,\"200\":2,\"201\":1,\"203\":16,\"204\":3,\"205\":13,\"206\":8}}],[\"readonly\",{\"1\":{\"35\":2,\"190\":3,\"203\":1,\"204\":1,\"205\":1,\"206\":1}}],[\"rmi\",{\"0\":{\"58\":1},\"1\":{\"58\":3}}],[\"rm\",{\"1\":{\"33\":1,\"41\":1,\"63\":4}}],[\"runqput\",{\"1\":{\"82\":1}}],[\"runq\",{\"1\":{\"82\":4}}],[\"runqsize\",{\"1\":{\"82\":5}}],[\"runnable\",{\"1\":{\"82\":1}}],[\"runnext\",{\"1\":{\"81\":5,\"82\":3}}],[\"runtime\",{\"1\":{\"26\":3,\"75\":2,\"81\":1,\"82\":1,\"86\":2}}],[\"run\",{\"1\":{\"26\":5,\"32\":3,\"35\":1,\"39\":5,\"41\":1,\"60\":1,\"62\":1,\"66\":2}}],[\"runc\",{\"1\":{\"25\":3,\"26\":1}}],[\"种\",{\"1\":{\"23\":1}}],[\"有客户端等待数据的键\",{\"1\":{\"266\":1}}],[\"有两种方法\",{\"1\":{\"252\":1}}],[\"有了结构化\",{\"1\":{\"266\":1}}],[\"有了buffer\",{\"1\":{\"223\":1}}],[\"有了recover之后\",{\"1\":{\"166\":1}}],[\"有数据在\",{\"1\":{\"190\":1}}],[\"有时候\",{\"1\":{\"179\":1}}],[\"有问题就报panic\",{\"1\":{\"157\":1}}],[\"有些运算符拥有较高的优先级\",{\"1\":{\"133\":1}}],[\"有多个\",{\"1\":{\"89\":1}}],[\"有一个个的槽位\",{\"1\":{\"224\":1}}],[\"有一个\",{\"1\":{\"81\":1}}],[\"有\",{\"1\":{\"23\":1,\"41\":1,\"190\":2,\"224\":1}}],[\"有类似语法提示的效果\",{\"1\":{\"10\":1}}],[\"客户端会执行以下操作\",{\"1\":{\"254\":1}}],[\"客户端就会直接读取\",{\"1\":{\"223\":1}}],[\"客户端发送sql语句\",{\"1\":{\"210\":1}}],[\"客户端发起的连接请求\",{\"1\":{\"210\":1}}],[\"客户端将sql查询语句发送到服务器\",{\"1\":{\"210\":1}}],[\"客户端的请求\",{\"1\":{\"24\":1}}],[\"客户端\",{\"0\":{\"23\":1}}],[\"客户端负责发送操作指令\",{\"1\":{\"22\":1}}],[\"主库提交事务的线程不会等待\",{\"1\":{\"237\":1}}],[\"主库提交事务的线程要等待所有从库的同步成功\",{\"1\":{\"237\":1}}],[\"主库会创建一个\",{\"1\":{\"237\":1}}],[\"主库修改数据后\",{\"1\":{\"237\":1}}],[\"主从容灾\",{\"0\":{\"253\":1},\"1\":{\"252\":1}}],[\"主从同步过程\",{\"1\":{\"237\":1}}],[\"主从同步模型\",{\"0\":{\"237\":1}}],[\"主从复制等\",{\"1\":{\"235\":1}}],[\"主要有两个方面的影响\",{\"1\":{\"242\":1}}],[\"主要的几个刷盘时机\",{\"1\":{\"232\":1}}],[\"主要关注用户记录\",{\"1\":{\"224\":1}}],[\"主要用于数据备份和主从复制\",{\"1\":{\"213\":1}}],[\"主要用于掉电等故障恢复\",{\"1\":{\"213\":1}}],[\"主要用于事务回滚和mvcc\",{\"1\":{\"213\":1}}],[\"主要专注于理解源程序\",{\"1\":{\"97\":1}}],[\"主要由客户端和服务端两大部分组成\",{\"1\":{\"22\":1}}],[\"主机端口\",{\"1\":{\"60\":2}}],[\"主机可以跟容器通信\",{\"1\":{\"45\":1}}],[\"主题\",{\"0\":{\"5\":1}}],[\"框架架构\",{\"0\":{\"22\":1}}],[\"框架与核心\",{\"0\":{\"17\":1}}],[\"的地址\",{\"1\":{\"266\":1}}],[\"的地方\",{\"1\":{\"266\":1}}],[\"的地方做了\",{\"1\":{\"228\":1}}],[\"的组织形式\",{\"1\":{\"266\":1}}],[\"的层层理解\",{\"1\":{\"266\":1}}],[\"的重点字段\",{\"1\":{\"265\":1}}],[\"的所有键值对都会存储在这里\",{\"1\":{\"264\":1}}],[\"的图示\",{\"1\":{\"261\":2}}],[\"的思路简单理解\",{\"1\":{\"258\":1}}],[\"的流程\",{\"1\":{\"250\":1}}],[\"的次数\",{\"1\":{\"243\":1}}],[\"的次数足够多时\",{\"1\":{\"190\":1}}],[\"的状态还是\",{\"1\":{\"241\":1}}],[\"的状态解读\",{\"0\":{\"195\":1}}],[\"的情况下\",{\"1\":{\"241\":1}}],[\"的频率由参数\",{\"1\":{\"236\":1}}],[\"的场景\",{\"1\":{\"235\":1}}],[\"的作用\",{\"0\":{\"235\":1},\"1\":{\"241\":2}}],[\"的方式工作的\",{\"1\":{\"233\":1}}],[\"的方法\",{\"1\":{\"150\":1}}],[\"的后台线程每隔\",{\"1\":{\"232\":1}}],[\"的刷盘时机\",{\"0\":{\"232\":1}}],[\"的刷盘策略\",{\"0\":{\"231\":1}}],[\"的刷盘策略是一样的\",{\"1\":{\"221\":1}}],[\"的持久化如下图\",{\"1\":{\"231\":1}}],[\"的写入拆成了两个步骤\",{\"1\":{\"241\":1}}],[\"的写入是顺序写入\",{\"1\":{\"230\":1}}],[\"的写操作并不是立刻写到磁盘上\",{\"1\":{\"227\":1}}],[\"的配合\",{\"0\":{\"229\":1}}],[\"的日志内容\",{\"1\":{\"228\":1}}],[\"的核心思想\",{\"1\":{\"227\":1}}],[\"的核心数\",{\"1\":{\"81\":1}}],[\"的脏页刷新到磁盘里\",{\"1\":{\"227\":1}}],[\"的形式记录下来并写入\",{\"1\":{\"227\":1}}],[\"的大小划分出一个个的页\",{\"1\":{\"224\":1}}],[\"的意义\",{\"0\":{\"223\":1},\"1\":{\"223\":1}}],[\"的事务id\",{\"1\":{\"220\":1}}],[\"的四个字段\",{\"1\":{\"220\":1}}],[\"的比对\",{\"1\":{\"219\":1}}],[\"的时机不同\",{\"1\":{\"219\":1}}],[\"的时候\",{\"1\":{\"82\":3,\"236\":1,\"267\":1}}],[\"的时候十分方便\",{\"1\":{\"35\":1}}],[\"的过程\",{\"1\":{\"201\":1,\"203\":1}}],[\"的不足\",{\"0\":{\"201\":1}}],[\"的nil\",{\"1\":{\"200\":1}}],[\"的底层原理\",{\"0\":{\"200\":1}}],[\"的值\",{\"1\":{\"213\":2}}],[\"的值为\",{\"1\":{\"198\":1}}],[\"的值变成\",{\"1\":{\"198\":1}}],[\"的三个状态\",{\"0\":{\"197\":1}}],[\"的数据对象以及底层编码方式作深入展开\",{\"1\":{\"258\":1}}],[\"的数据在内存中的组织过程\",{\"1\":{\"258\":2}}],[\"的数据都是存在磁盘中的\",{\"1\":{\"223\":1}}],[\"的数据状态\",{\"1\":{\"213\":2}}],[\"的数据不全\",{\"1\":{\"203\":2}}],[\"的数据不一致\",{\"1\":{\"199\":1}}],[\"的数据流转过程\",{\"1\":{\"201\":1}}],[\"的数据\",{\"1\":{\"199\":1}}],[\"的数据过来\",{\"1\":{\"193\":1}}],[\"的数据双向流转机制\",{\"0\":{\"191\":1}}],[\"的封装\",{\"1\":{\"190\":2}}],[\"的顶层封装\",{\"1\":{\"190\":1}}],[\"的使用\",{\"0\":{\"187\":1}}],[\"的\",{\"0\":{\"268\":1},\"1\":{\"186\":1,\"199\":3,\"219\":1,\"228\":1,\"235\":1,\"241\":1,\"268\":1}}],[\"的执行顺序\",{\"1\":{\"185\":1}}],[\"的并发读写\",{\"0\":{\"184\":1}}],[\"的基本用法\",{\"0\":{\"171\":1}}],[\"的非原子性\",{\"0\":{\"165\":1}}],[\"的快照读\",{\"0\":{\"164\":1}}],[\"的关系\",{\"1\":{\"161\":1}}],[\"的栈什么时机会执行\",{\"1\":{\"161\":1}}],[\"的栈只占几\",{\"1\":{\"86\":1}}],[\"的操作\",{\"1\":{\"157\":1,\"200\":1}}],[\"的一层封装\",{\"1\":{\"266\":2}}],[\"的一个普通的接口\",{\"1\":{\"160\":1}}],[\"的一个类型别名\",{\"1\":{\"148\":1}}],[\"的一半\",{\"1\":{\"82\":1}}],[\"的类型系统\",{\"1\":{\"148\":1}}],[\"的指针\",{\"1\":{\"147\":1,\"268\":1}}],[\"的内存位置可能是\",{\"1\":{\"144\":1}}],[\"的结构\",{\"0\":{\"139\":1,\"190\":1,\"196\":1}}],[\"的结果展开讨论\",{\"1\":{\"81\":1}}],[\"的返回值始终是\",{\"1\":{\"129\":1}}],[\"的返回值一直都是16\",{\"1\":{\"129\":1}}],[\"的返回地址\",{\"1\":{\"117\":1}}],[\"的函数调用过程\",{\"0\":{\"117\":1}}],[\"的函数栈帧布局\",{\"0\":{\"116\":1}}],[\"的实体\",{\"1\":{\"92\":1,\"195\":1}}],[\"的协程\",{\"0\":{\"86\":1}}],[\"的待执行的\",{\"1\":{\"82\":1}}],[\"的模拟过程\",{\"1\":{\"82\":1}}],[\"的本地队列中\",{\"1\":{\"81\":2}}],[\"的常用命令\",{\"0\":{\"52\":1}}],[\"的端口到内部容器开放的网络端口\",{\"1\":{\"39\":1}}],[\"的容器\",{\"1\":{\"32\":1}}],[\"的更新\",{\"1\":{\"28\":1}}],[\"的修改会立马生效\",{\"1\":{\"28\":1}}],[\"的具体操作\",{\"1\":{\"24\":1}}],[\"的镜像仓库类似于代码仓库\",{\"1\":{\"21\":1}}],[\"的框架与核心概念\",{\"1\":{\"17\":1}}],[\"环境变量\",{\"1\":{\"20\":1}}],[\"暂停和删除五种状态\",{\"1\":{\"20\":1}}],[\"停止当前正在运行的容器\",{\"1\":{\"64\":1}}],[\"停止\",{\"1\":{\"20\":1}}],[\"是新客户端\",{\"1\":{\"250\":1}}],[\"是要有归属的\",{\"1\":{\"249\":1}}],[\"是的\",{\"1\":{\"241\":1}}],[\"是默认值\",{\"1\":{\"236\":1}}],[\"是不能被拆开的\",{\"1\":{\"236\":1}}],[\"是不可以直接进行比较的\",{\"1\":{\"160\":1}}],[\"是追加写\",{\"1\":{\"235\":1}}],[\"是专门用来缓存文件数据的\",{\"1\":{\"232\":1}}],[\"是用来在系统崩溃后进行数据恢复的\",{\"1\":{\"229\":1}}],[\"是物理日志\",{\"1\":{\"228\":1}}],[\"是基于内存的\",{\"1\":{\"227\":1}}],[\"是什么\",{\"1\":{\"224\":1}}],[\"是否准备好了\",{\"1\":{\"240\":1}}],[\"是否在\",{\"1\":{\"220\":1}}],[\"是否数据缺失\",{\"1\":{\"190\":1}}],[\"是一张哈希表\",{\"1\":{\"263\":1}}],[\"是一种数据库管理技术\",{\"1\":{\"219\":1}}],[\"是一个耗时的操作\",{\"1\":{\"194\":1}}],[\"是一个特殊的常量\",{\"1\":{\"130\":1}}],[\"是一个非常小巧的\",{\"1\":{\"26\":1}}],[\"是一个非常重要的后台管理进程\",{\"1\":{\"24\":1}}],[\"是一个用来运行容器的轻量级工具\",{\"1\":{\"25\":1}}],[\"是一个主题包\",{\"1\":{\"5\":1}}],[\"是由\",{\"1\":{\"215\":1}}],[\"是innodb存储引擎层生成的日志\",{\"1\":{\"213\":2}}],[\"是可以挡住删除的流量的\",{\"1\":{\"198\":1}}],[\"是可以共享的\",{\"1\":{\"194\":1}}],[\"是通过\",{\"1\":{\"219\":1}}],[\"是通过加锁来做了限流保护的\",{\"1\":{\"186\":1}}],[\"是通过无锁的\",{\"1\":{\"186\":1}}],[\"是相关的\",{\"1\":{\"89\":1}}],[\"是如何实现的\",{\"0\":{\"89\":1}}],[\"是真正用来运行容器的\",{\"1\":{\"25\":1}}],[\"是\",{\"1\":{\"21\":1,\"148\":2,\"186\":1,\"193\":1,\"195\":1,\"213\":1,\"229\":1,\"235\":1,\"259\":1}}],[\"是容器启动的基础\",{\"1\":{\"19\":1}}],[\"它可以保证多个逻辑操作要不全部成功\",{\"1\":{\"240\":1}}],[\"它们的快照读\",{\"1\":{\"219\":1}}],[\"它们确定哪个对象属于哪个标识符\",{\"1\":{\"100\":1}}],[\"它本质是采用空间换时间的思想\",{\"1\":{\"186\":1}}],[\"它会获取一个锁\",{\"1\":{\"185\":1}}],[\"它返回值的两倍\",{\"1\":{\"148\":1}}],[\"它提供了一种方式来暂时存储指针值\",{\"1\":{\"148\":1}}],[\"它用于表示一个无类型的指针或将一个\",{\"1\":{\"148\":1}}],[\"它非常轻量\",{\"1\":{\"86\":1}}],[\"它负责管理\",{\"1\":{\"85\":1}}],[\"它负责响应和处理来自\",{\"1\":{\"24\":1}}],[\"它绕过\",{\"1\":{\"28\":1}}],[\"它包含了容器运行时所需要的所有基础文件和配置信息\",{\"1\":{\"19\":1}}],[\"它是一个只读的文件和文件夹组合\",{\"1\":{\"19\":1}}],[\"仓库\",{\"0\":{\"18\":1}}],[\"db\",{\"1\":{\"265\":1,\"266\":1}}],[\"drift\",{\"1\":{\"255\":2}}],[\"drawio\",{\"1\":{\"224\":1,\"266\":1}}],[\"dracula\",{\"1\":{\"5\":1}}],[\"dump\",{\"1\":{\"237\":1}}],[\"dirtylocked\",{\"1\":{\"205\":1}}],[\"dirtymap\",{\"1\":{\"186\":6,\"190\":1,\"192\":2,\"203\":1}}],[\"dirty\",{\"0\":{\"192\":1,\"193\":1},\"1\":{\"186\":2,\"190\":5,\"192\":2,\"193\":4,\"194\":6,\"198\":4,\"199\":5,\"200\":2,\"201\":1,\"203\":8,\"204\":5,\"205\":10,\"206\":2}}],[\"dictentry\",{\"1\":{\"266\":2,\"267\":1}}],[\"dictht\",{\"1\":{\"264\":1}}],[\"dicttype\",{\"1\":{\"264\":1}}],[\"dict+\",{\"1\":{\"263\":1}}],[\"dict\",{\"0\":{\"263\":1,\"264\":1},\"1\":{\"263\":5,\"264\":3,\"265\":4,\"266\":8,\"267\":1,\"268\":5}}],[\"dic\",{\"1\":{\"137\":1}}],[\"ddd的更新\",{\"1\":{\"228\":1}}],[\"ddd\",{\"1\":{\"136\":1}}],[\"d是字符串\",{\"1\":{\"130\":1}}],[\"data\",{\"1\":{\"129\":1,\"159\":4,\"262\":1}}],[\"daemon\",{\"1\":{\"26\":1,\"45\":4}}],[\"delay\",{\"1\":{\"255\":2}}],[\"delete\",{\"1\":{\"188\":1,\"189\":1,\"217\":1}}],[\"derfer\",{\"1\":{\"164\":2}}],[\"derferrun\",{\"1\":{\"164\":1}}],[\"declaration\",{\"1\":{\"156\":1}}],[\"developer\",{\"1\":{\"150\":1}}],[\"defrag\",{\"1\":{\"266\":1}}],[\"deferrun\",{\"1\":{\"165\":6}}],[\"defer\",{\"0\":{\"164\":1},\"1\":{\"75\":1,\"161\":3,\"163\":1,\"164\":1,\"165\":3,\"183\":1,\"189\":4}}],[\"defa\",{\"1\":{\"43\":1}}],[\"demo\",{\"0\":{\"75\":1},\"1\":{\"75\":1,\"81\":1}}],[\"demo演示\",{\"0\":{\"74\":1}}],[\"d14d20507073e5743e607efd616571c834f1a914f903db6279b8de4b5ba3a45a\",{\"1\":{\"26\":1}}],[\"d\",{\"1\":{\"26\":1,\"32\":1,\"35\":1,\"39\":5,\"41\":2,\"60\":1,\"66\":2,\"130\":1,\"152\":1,\"157\":1,\"164\":1,\"189\":8}}],[\"dog\",{\"1\":{\"152\":3}}],[\"double\",{\"1\":{\"148\":3,\"203\":1,\"205\":1}}],[\"done\",{\"1\":{\"75\":1,\"189\":4}}],[\"down\",{\"1\":{\"43\":1}}],[\"dokcer\",{\"0\":{\"44\":1},\"1\":{\"17\":1}}],[\"docker0\",{\"1\":{\"43\":2,\"44\":2,\"45\":2}}],[\"dockerd\",{\"1\":{\"24\":2,\"26\":3}}],[\"docker\",{\"0\":{\"17\":1,\"18\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"27\":1,\"38\":1,\"51\":1,\"52\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"272\":1},\"1\":{\"21\":4,\"22\":1,\"23\":2,\"24\":4,\"26\":6,\"29\":1,\"30\":1,\"31\":1,\"32\":3,\"33\":1,\"35\":4,\"36\":1,\"39\":6,\"40\":1,\"41\":3,\"43\":5,\"44\":1,\"45\":9,\"46\":1,\"47\":2,\"48\":1,\"53\":3,\"56\":1,\"57\":4,\"58\":4,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":6,\"64\":4,\"66\":4,\"67\":1,\"68\":2,\"69\":1,\"70\":4,\"71\":1},\"2\":{\"49\":1,\"50\":1,\"72\":1,\"73\":1}}],[\"带个框好看点\",{\"1\":{\"13\":1}}],[\"电子宠物\",{\"1\":{\"13\":1}}],[\"五\",{\"0\":{\"13\":1,\"191\":1}}],[\"学生认证可免费使用\",{\"1\":{\"12\":1}}],[\"体验蛮好还\",{\"1\":{\"12\":1}}],[\"官方提供的一个并发安全的一个\",{\"1\":{\"186\":1}}],[\"官方提供了一个并发安全的\",{\"1\":{\"183\":1}}],[\"官方的公开镜像仓库\",{\"1\":{\"21\":1}}],[\"官方的图标包\",{\"1\":{\"6\":1}}],[\"官方申请\",{\"1\":{\"12\":1}}],[\"响应速度快\",{\"1\":{\"12\":1}}],[\"百度\",{\"1\":{\"12\":1}}],[\"四种方式\",{\"1\":{\"60\":1}}],[\"四\",{\"0\":{\"12\":1,\"38\":1,\"190\":1}}],[\"49\",{\"1\":{\"78\":1,\"79\":1}}],[\"49000~49900\",{\"1\":{\"39\":1}}],[\"48\",{\"1\":{\"78\":1,\"79\":1,\"117\":1}}],[\"46\",{\"1\":{\"78\":1,\"79\":1}}],[\"45\",{\"1\":{\"78\":1,\"79\":1}}],[\"44\",{\"1\":{\"78\":1,\"79\":1}}],[\"43\",{\"1\":{\"78\":1,\"79\":1}}],[\"41\",{\"1\":{\"78\":1,\"79\":1}}],[\"4147\",{\"1\":{\"26\":1}}],[\"404\",{\"1\":{\"271\":1}}],[\"40\",{\"1\":{\"78\":1,\"79\":1,\"117\":1}}],[\"47\",{\"1\":{\"68\":1,\"78\":1,\"79\":1}}],[\"42\",{\"1\":{\"43\":1,\"78\":1,\"79\":1}}],[\"4\",{\"0\":{\"11\":1,\"26\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":2,\"58\":1,\"63\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":2,\"70\":1,\"71\":1,\"117\":1,\"126\":1,\"135\":1,\"136\":1,\"145\":1,\"156\":1,\"164\":1,\"199\":1,\"206\":1,\"218\":1,\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":2,\"231\":1,\"232\":1,\"233\":1,\"242\":1,\"252\":1,\"267\":1,\"268\":1},\"1\":{\"43\":1,\"77\":1,\"78\":1,\"79\":1,\"117\":8,\"130\":1,\"146\":1,\"157\":1,\"158\":1,\"224\":1,\"227\":1,\"261\":1,\"262\":2}}],[\"clock\",{\"1\":{\"255\":2,\"262\":1}}],[\"cli\",{\"1\":{\"23\":1}}],[\"client\",{\"1\":{\"10\":1}}],[\"ccc偏移量\",{\"1\":{\"228\":1}}],[\"check\",{\"1\":{\"203\":1,\"205\":1}}],[\"chan\",{\"1\":{\"124\":1}}],[\"creator\",{\"1\":{\"220\":1}}],[\"created\",{\"1\":{\"55\":1}}],[\"create\",{\"1\":{\"29\":1,\"41\":1}}],[\"crud\",{\"0\":{\"188\":1}}],[\"c1\",{\"1\":{\"179\":5}}],[\"circle\",{\"1\":{\"151\":2,\"158\":3}}],[\"cache\",{\"1\":{\"232\":2,\"235\":2,\"236\":8,\"241\":1,\"243\":1}}],[\"cas的监视键\",{\"1\":{\"266\":1}}],[\"cas交换值\",{\"1\":{\"205\":2}}],[\"cas在\",{\"1\":{\"205\":1}}],[\"cas\",{\"1\":{\"186\":2,\"198\":3,\"200\":1}}],[\"case\",{\"0\":{\"138\":1},\"1\":{\"138\":1}}],[\"card\",{\"1\":{\"179\":3}}],[\"cannot\",{\"1\":{\"156\":1}}],[\"called\",{\"1\":{\"154\":4}}],[\"callee函数返回值通过caller的栈传递\",{\"1\":{\"117\":1}}],[\"callee\",{\"1\":{\"114\":1}}],[\"call\",{\"1\":{\"117\":1}}],[\"cmpq\",{\"1\":{\"117\":1}}],[\"cmd\",{\"1\":{\"68\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":2,\"102\":2}}],[\"cx\",{\"1\":{\"117\":2}}],[\"c的函数栈帧\",{\"1\":{\"116\":1}}],[\"cpu\",{\"1\":{\"81\":1,\"89\":1}}],[\"cp\",{\"1\":{\"71\":1}}],[\"ctrl+p+q\",{\"1\":{\"62\":1}}],[\"centos\",{\"1\":{\"59\":2,\"62\":1,\"66\":1}}],[\"c\",{\"1\":{\"22\":1,\"68\":1,\"129\":2,\"130\":3,\"151\":3,\"158\":5,\"255\":1}}],[\"coordinator\",{\"1\":{\"240\":1}}],[\"copy\",{\"1\":{\"194\":1,\"199\":3}}],[\"copilot\",{\"1\":{\"12\":2}}],[\"commit\",{\"1\":{\"232\":5,\"236\":1,\"240\":1,\"241\":5,\"243\":5}}],[\"compareandswap\",{\"1\":{\"205\":2}}],[\"completed\",{\"1\":{\"189\":1}}],[\"compile\",{\"1\":{\"98\":1,\"99\":1,\"100\":1,\"101\":2,\"102\":1,\"117\":1}}],[\"compiler\",{\"1\":{\"97\":1,\"98\":1}}],[\"comate\",{\"1\":{\"12\":2}}],[\"concurrency\",{\"1\":{\"219\":1}}],[\"concurrent\",{\"1\":{\"184\":1}}],[\"control\",{\"1\":{\"219\":1}}],[\"continue\",{\"1\":{\"206\":1}}],[\"container\",{\"0\":{\"47\":1},\"1\":{\"43\":3,\"44\":1,\"45\":3,\"47\":1}}],[\"containerd\",{\"1\":{\"24\":1,\"25\":4,\"26\":14}}],[\"condition\",{\"1\":{\"139\":3}}],[\"const中每新增加一行常量声明将使iota计数一次\",{\"1\":{\"130\":1}}],[\"const\",{\"1\":{\"128\":4,\"129\":1,\"130\":5}}],[\"config\",{\"1\":{\"26\":1}}],[\"codesnap\",{\"1\":{\"13\":1}}],[\"code\",{\"1\":{\"11\":1}}],[\"cursor\",{\"1\":{\"266\":1}}],[\"cursorblinking\",{\"1\":{\"3\":1}}],[\"cursorsmoothcaretanimation\",{\"1\":{\"3\":1}}],[\"备注\",{\"1\":{\"10\":1}}],[\"备忘\",{\"1\":{\"10\":1}}],[\"39\",{\"1\":{\"78\":1,\"79\":1}}],[\"38\",{\"1\":{\"78\":1,\"79\":1}}],[\"37\",{\"1\":{\"78\":1,\"79\":1}}],[\"36\",{\"1\":{\"78\":1,\"79\":1}}],[\"3600\",{\"1\":{\"26\":4}}],[\"35\",{\"1\":{\"78\":1,\"79\":1}}],[\"34\",{\"1\":{\"78\":1,\"79\":1}}],[\"33cdeccccebe80329f1fdbee7f5874cb\",{\"1\":{\"117\":2}}],[\"33\",{\"1\":{\"78\":1,\"79\":1,\"136\":1}}],[\"32\",{\"1\":{\"78\":1,\"79\":1,\"117\":1}}],[\"31\",{\"1\":{\"78\":1,\"79\":1}}],[\"30\",{\"1\":{\"43\":1,\"78\":1,\"79\":1}}],[\"3000\",{\"1\":{\"39\":1}}],[\"3\",{\"0\":{\"10\":1,\"21\":1,\"25\":1,\"28\":1,\"34\":1,\"41\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":2,\"63\":1,\"64\":1,\"68\":1,\"91\":1,\"92\":1,\"106\":1,\"107\":1,\"108\":2,\"109\":2,\"116\":1,\"125\":1,\"131\":1,\"132\":1,\"133\":2,\"134\":2,\"141\":1,\"144\":1,\"152\":1,\"155\":1,\"161\":1,\"163\":1,\"194\":1,\"198\":1,\"205\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":2,\"218\":1,\"219\":1,\"220\":1,\"221\":1,\"222\":2,\"223\":2,\"224\":2,\"225\":3,\"226\":1,\"227\":1,\"228\":1,\"229\":2,\"230\":1,\"231\":1,\"232\":1,\"233\":1,\"234\":1,\"235\":1,\"236\":1,\"237\":2,\"238\":1,\"239\":1,\"240\":1,\"241\":2,\"242\":1,\"243\":1,\"250\":1,\"251\":1,\"261\":1,\"262\":1,\"265\":1,\"266\":1},\"1\":{\"23\":1,\"77\":1,\"78\":1,\"79\":1,\"117\":12,\"129\":1,\"130\":1,\"139\":1,\"140\":1,\"141\":2,\"146\":2,\"151\":1,\"158\":2,\"165\":1,\"219\":1,\"227\":1,\"261\":1}}],[\"ptr\",{\"1\":{\"262\":2}}],[\"publicuser\",{\"1\":{\"178\":2}}],[\"pull\",{\"0\":{\"57\":1},\"1\":{\"57\":3,\"59\":1}}],[\"person\",{\"1\":{\"150\":9,\"171\":4,\"173\":1,\"174\":1}}],[\"pets\",{\"1\":{\"13\":1}}],[\"p7\",{\"1\":{\"117\":2}}],[\"p6\",{\"1\":{\"117\":2}}],[\"p5\",{\"1\":{\"117\":2}}],[\"p4\",{\"1\":{\"117\":2}}],[\"p3\",{\"1\":{\"117\":2}}],[\"p2\",{\"1\":{\"117\":2,\"171\":5}}],[\"p1\",{\"1\":{\"117\":2,\"171\":2}}],[\"pcdata\",{\"1\":{\"117\":4}}],[\"pc\",{\"1\":{\"117\":1}}],[\"phase\",{\"1\":{\"97\":1}}],[\"pp\",{\"1\":{\"82\":4}}],[\"ppid\",{\"1\":{\"68\":1}}],[\"pid\",{\"1\":{\"68\":1}}],[\"ps发现centos停止了\",{\"1\":{\"66\":1}}],[\"ps\",{\"1\":{\"61\":1,\"63\":2}}],[\"pstree\",{\"1\":{\"26\":1}}],[\"p或\",{\"1\":{\"43\":1}}],[\"privdata\",{\"1\":{\"264\":1}}],[\"printarea\",{\"1\":{\"158\":3}}],[\"printf\",{\"1\":{\"157\":1,\"164\":1,\"171\":4,\"175\":2,\"177\":2,\"178\":2,\"179\":2,\"188\":1,\"189\":2}}],[\"println\",{\"1\":{\"75\":1,\"106\":1,\"129\":1,\"141\":2,\"146\":2,\"148\":1,\"150\":1,\"152\":2,\"154\":2,\"155\":1,\"158\":1,\"159\":2,\"165\":3,\"185\":5,\"188\":2,\"189\":1}}],[\"prepare\",{\"1\":{\"240\":1,\"241\":4,\"243\":1}}],[\"previous\",{\"1\":{\"205\":4}}],[\"preferred\",{\"1\":{\"43\":1}}],[\"process\",{\"1\":{\"255\":2}}],[\"profile\",{\"1\":{\"177\":10}}],[\"prog指令\",{\"1\":{\"102\":1}}],[\"projects\",{\"1\":{\"9\":1}}],[\"project\",{\"1\":{\"9\":1}}],[\"pool的奥妙\",{\"1\":{\"225\":1}}],[\"pool后\",{\"1\":{\"223\":1}}],[\"pool\",{\"0\":{\"222\":1,\"223\":1,\"224\":1,\"225\":1},\"1\":{\"221\":1,\"223\":3,\"227\":4,\"228\":1,\"229\":2,\"230\":1,\"239\":1}}],[\"pointer\",{\"0\":{\"148\":1},\"1\":{\"148\":2,\"190\":3,\"196\":2,\"218\":2,\"219\":1}}],[\"post\",{\"1\":{\"139\":2}}],[\"postman\",{\"1\":{\"10\":1}}],[\"pop\",{\"1\":{\"82\":2}}],[\"port\",{\"1\":{\"40\":1}}],[\"py\",{\"1\":{\"32\":1,\"35\":1}}],[\"python\",{\"1\":{\"32\":1,\"35\":1}}],[\"p\",{\"1\":{\"32\":1,\"35\":1,\"39\":10,\"43\":1,\"60\":5,\"75\":1,\"81\":8,\"82\":11,\"150\":2,\"190\":2,\"196\":2,\"205\":7,\"255\":1}}],[\"pause\",{\"1\":{\"255\":2}}],[\"page\",{\"1\":{\"232\":2,\"236\":1,\"241\":1}}],[\"participant\",{\"1\":{\"240\":1}}],[\"parse\",{\"1\":{\"210\":1}}],[\"parameter\",{\"1\":{\"146\":1,\"153\":3}}],[\"password\",{\"1\":{\"178\":5}}],[\"painc\",{\"0\":{\"166\":1},\"1\":{\"167\":1}}],[\"pair\",{\"1\":{\"44\":1,\"45\":3}}],[\"panic的传递\",{\"0\":{\"167\":1}}],[\"panic\",{\"0\":{\"163\":1},\"1\":{\"166\":1,\"167\":8}}],[\"package\",{\"1\":{\"75\":1,\"106\":1,\"107\":2,\"109\":1,\"117\":1,\"129\":1,\"146\":1,\"148\":1,\"154\":1,\"157\":1,\"158\":1,\"159\":1,\"165\":3,\"184\":1,\"185\":1,\"189\":1}}],[\"path\",{\"1\":{\"10\":1}}],[\"palettes\",{\"1\":{\"8\":1}}],[\"项目管理\",{\"0\":{\"9\":1}}],[\"使得mysql能够高效地处理各种查询请求\",{\"1\":{\"210\":1}}],[\"使得外部结构体可以直接访问这些字段和方法\",{\"1\":{\"150\":1}}],[\"使其显示为网络上的物理设备\",{\"1\":{\"44\":1}}],[\"使用完成之后\",{\"1\":{\"254\":1}}],[\"使用与存储引擎一样的基本单位\",{\"1\":{\"224\":1}}],[\"使用同一个底层\",{\"1\":{\"194\":1}}],[\"使用两个\",{\"1\":{\"186\":1}}],[\"使用omitempty\",{\"0\":{\"176\":1}}],[\"使用json\",{\"0\":{\"173\":1},\"1\":{\"173\":1,\"174\":1}}],[\"使用场景\",{\"0\":{\"162\":1,\"163\":1}}],[\"使用命令\",{\"1\":{\"106\":1}}],[\"使用交互式运行\",{\"1\":{\"60\":1}}],[\"使用\",{\"1\":{\"8\":1,\"32\":1,\"35\":1,\"40\":1,\"43\":1,\"46\":1,\"48\":1,\"148\":1,\"190\":1,\"196\":1}}],[\"使代码建议不会被片段补全中断\",{\"1\":{\"3\":1}}],[\"搭配\",{\"1\":{\"8\":1}}],[\"缩进着色\",{\"1\":{\"8\":1}}],[\"ib\",{\"1\":{\"233\":7}}],[\"ibd\",{\"1\":{\"227\":1}}],[\"is\",{\"1\":{\"150\":1,\"157\":4,\"164\":2}}],[\"ir\",{\"1\":{\"97\":1}}],[\"if\",{\"0\":{\"137\":1},\"1\":{\"82\":4,\"137\":1,\"171\":2,\"175\":1,\"177\":1,\"178\":1,\"179\":1,\"188\":1,\"189\":1,\"203\":3,\"204\":1,\"205\":11,\"206\":4}}],[\"i++\",{\"1\":{\"75\":1,\"109\":1,\"184\":2,\"185\":2,\"189\":3}}],[\"i\",{\"1\":{\"75\":5,\"109\":4,\"130\":1,\"141\":3,\"156\":3,\"184\":7,\"185\":9,\"189\":15,\"205\":2,\"231\":1,\"242\":1,\"243\":1}}],[\"import\",{\"1\":{\"75\":1,\"106\":1,\"129\":1,\"146\":1,\"148\":1,\"154\":1,\"157\":1,\"158\":1,\"159\":1,\"165\":3,\"185\":1,\"189\":1}}],[\"image\",{\"1\":{\"55\":1,\"60\":1}}],[\"images\",{\"0\":{\"55\":1},\"1\":{\"55\":1,\"58\":1}}],[\"id<记录的\",{\"1\":{\"220\":1}}],[\"ids\",{\"1\":{\"220\":4}}],[\"identifier\",{\"1\":{\"128\":1}}],[\"id\",{\"1\":{\"44\":1,\"55\":1,\"135\":2,\"179\":4,\"211\":1,\"218\":2,\"219\":1,\"220\":12,\"239\":4,\"241\":1,\"265\":1,\"266\":1}}],[\"iptable\",{\"1\":{\"44\":1}}],[\"ip\",{\"1\":{\"43\":5,\"44\":6,\"46\":1,\"47\":2,\"48\":2,\"60\":1}}],[\"iterators\",{\"1\":{\"264\":1}}],[\"it\",{\"1\":{\"41\":1,\"60\":1,\"62\":1,\"70\":1}}],[\"iota为\",{\"1\":{\"130\":4}}],[\"iota\",{\"0\":{\"130\":1},\"1\":{\"130\":9}}],[\"io\",{\"1\":{\"26\":1,\"57\":1,\"231\":1}}],[\"insert\",{\"1\":{\"217\":1}}],[\"inspect\",{\"1\":{\"31\":1,\"36\":1,\"69\":1}}],[\"innodb中磁盘与内存的交互基本单位\",{\"1\":{\"224\":1}}],[\"innodb引擎层\",{\"1\":{\"223\":1}}],[\"innodb\",{\"1\":{\"213\":1,\"215\":1,\"217\":1,\"224\":4,\"227\":2,\"229\":4,\"231\":1,\"232\":6,\"233\":1,\"241\":2,\"243\":1}}],[\"init\",{\"1\":{\"139\":2}}],[\"index\",{\"1\":{\"107\":6,\"140\":1}}],[\"indent\",{\"1\":{\"8\":3}}],[\"intandstringdemo\",{\"1\":{\"179\":1}}],[\"int64\",{\"1\":{\"117\":3,\"171\":1,\"173\":1,\"174\":1,\"179\":1}}],[\"interfce\",{\"1\":{\"160\":1}}],[\"interfacename\",{\"1\":{\"153\":1}}],[\"interface\",{\"1\":{\"151\":1,\"153\":1,\"154\":2,\"155\":1,\"156\":2,\"157\":1,\"158\":1,\"159\":3,\"188\":1,\"189\":1}}],[\"internal\",{\"1\":{\"98\":1,\"99\":1,\"100\":1,\"101\":2,\"102\":3}}],[\"intermediate\",{\"1\":{\"97\":1}}],[\"intellisense\",{\"1\":{\"10\":1}}],[\"int32\",{\"1\":{\"82\":3}}],[\"int\",{\"1\":{\"75\":1,\"106\":2,\"107\":2,\"109\":1,\"125\":1,\"129\":1,\"135\":3,\"141\":3,\"143\":1,\"146\":7,\"147\":2,\"148\":3,\"155\":1,\"156\":3,\"157\":1,\"165\":4,\"184\":2,\"185\":2,\"189\":3,\"190\":1,\"262\":1,\"264\":2,\"266\":1}}],[\"inet\",{\"1\":{\"43\":1}}],[\"info\",{\"1\":{\"26\":1,\"53\":1}}],[\"in\",{\"1\":{\"11\":1,\"156\":1}}],[\"icons\",{\"1\":{\"6\":2}}],[\"icon\",{\"1\":{\"5\":1}}],[\"编号\",{\"1\":{\"265\":1,\"266\":1}}],[\"编译器在生成代码时会进行以下操作\",{\"1\":{\"150\":1}}],[\"编译器可以根据变量的值来推断类型\",{\"1\":{\"128\":1}}],[\"编译器有4个伪寄存器\",{\"1\":{\"117\":1}}],[\"编译器会在外部结构体中创建同名的方法\",{\"1\":{\"150\":1}}],[\"编译器会在外部结构体中创建相同名字的字段\",{\"1\":{\"150\":1}}],[\"编译器会分析代码的特征和生命周期\",{\"1\":{\"105\":1}}],[\"编译器会使用多个ir阶段\",{\"1\":{\"97\":1}}],[\"编译器用于决定变量分配到堆上还是栈上的一种行为\",{\"1\":{\"105\":1}}],[\"编译器的机器相关阶段从\",{\"1\":{\"102\":1}}],[\"编译器的中间阶段离不开编译器前端记录的细节\",{\"1\":{\"97\":1}}],[\"编译器的中间阶段\",{\"1\":{\"97\":1}}],[\"编译器能够识别并将代码中的特定函数替换为高效的代码片段\",{\"1\":{\"101\":1}}],[\"编译器相关源代码位置\",{\"1\":{\"98\":1}}],[\"编译器执行流程\",{\"1\":{\"98\":1}}],[\"编译器后端\",{\"1\":{\"97\":2}}],[\"编译器前端\",{\"1\":{\"97\":2}}],[\"编译器\",{\"0\":{\"96\":1,\"98\":1},\"2\":{\"104\":1}}],[\"编程类\",{\"0\":{\"7\":1}}],[\"编辑器中的平滑滚动效果\",{\"1\":{\"3\":1}}],[\"三种主从同步模式\",{\"1\":{\"237\":1}}],[\"三种日志的主要作用\",{\"0\":{\"213\":1}}],[\"三种日志\",{\"0\":{\"212\":1}}],[\"三\",{\"0\":{\"7\":1,\"27\":1,\"80\":1,\"90\":1,\"187\":1,\"212\":1}}],[\"好文章\",{\"1\":{\"120\":1}}],[\"好看好看好看好看\",{\"1\":{\"6\":1}}],[\"好用好看好玩的vscode插件\",{\"1\":{\"2\":1}}],[\"etcd\",{\"1\":{\"254\":1}}],[\"eth0\",{\"1\":{\"45\":4}}],[\"ether\",{\"1\":{\"43\":1}}],[\"end\",{\"0\":{\"273\":1}}],[\"encoding\",{\"1\":{\"260\":2,\"262\":2}}],[\"enrty\",{\"0\":{\"195\":1}}],[\"entry是共享的\",{\"1\":{\"205\":1}}],[\"entry\",{\"0\":{\"196\":1,\"197\":1},\"1\":{\"186\":3,\"190\":4,\"194\":1,\"195\":1,\"196\":1,\"200\":1,\"205\":3}}],[\"else\",{\"1\":{\"188\":1,\"205\":2}}],[\"errorf\",{\"1\":{\"160\":1}}],[\"error是\",{\"1\":{\"160\":1}}],[\"error\",{\"0\":{\"160\":1},\"1\":{\"155\":1,\"160\":4,\"183\":1,\"184\":1}}],[\"err\",{\"1\":{\"155\":1,\"171\":8,\"175\":4,\"177\":4,\"178\":4,\"179\":4}}],[\"email\",{\"1\":{\"175\":3,\"176\":2,\"177\":8}}],[\"emp\",{\"1\":{\"150\":2}}],[\"employee\",{\"1\":{\"150\":3}}],[\"emoji\",{\"1\":{\"6\":1}}],[\"e是字符串\",{\"1\":{\"130\":1}}],[\"e\",{\"1\":{\"130\":1,\"203\":4,\"205\":11,\"206\":2}}],[\"expires\",{\"0\":{\"268\":1},\"1\":{\"265\":1,\"266\":2,\"268\":6}}],[\"expunged状态下的entry\",{\"1\":{\"205\":1}}],[\"expunged状态设计\",{\"1\":{\"200\":1}}],[\"expunged\",{\"0\":{\"199\":1},\"1\":{\"197\":1,\"199\":3,\"205\":3}}],[\"ex表示增加了过期时间\",{\"1\":{\"248\":1}}],[\"ex\",{\"1\":{\"248\":1}}],[\"except\",{\"1\":{\"141\":1}}],[\"exec\",{\"1\":{\"70\":2,\"266\":1}}],[\"exit\",{\"1\":{\"62\":1}}],[\"ef\",{\"1\":{\"43\":1}}],[\"easily\",{\"1\":{\"9\":1}}],[\"editor\",{\"1\":{\"3\":5}}],[\"29\",{\"1\":{\"78\":1,\"79\":1}}],[\"28\",{\"1\":{\"78\":1,\"79\":1,\"158\":1}}],[\"27\",{\"1\":{\"78\":1,\"79\":1}}],[\"26\",{\"1\":{\"78\":1,\"79\":1,\"158\":1}}],[\"239\",{\"1\":{\"78\":1,\"79\":1}}],[\"238\",{\"1\":{\"78\":1,\"79\":1}}],[\"237\",{\"1\":{\"78\":1,\"79\":1}}],[\"236\",{\"1\":{\"78\":1,\"79\":1}}],[\"235\",{\"1\":{\"78\":1,\"79\":1}}],[\"234\",{\"1\":{\"78\":1,\"79\":1}}],[\"233\",{\"1\":{\"78\":1,\"79\":1}}],[\"232\",{\"1\":{\"78\":1,\"79\":1}}],[\"231\",{\"1\":{\"78\":1,\"79\":1}}],[\"230\",{\"1\":{\"78\":1,\"79\":1}}],[\"23\",{\"1\":{\"78\":1,\"79\":1}}],[\"229\",{\"1\":{\"78\":1,\"79\":1}}],[\"228\",{\"1\":{\"78\":1,\"79\":1}}],[\"227\",{\"1\":{\"78\":1,\"79\":1}}],[\"226\",{\"1\":{\"78\":1,\"79\":1}}],[\"225\",{\"1\":{\"78\":1,\"79\":1}}],[\"224\",{\"1\":{\"78\":1,\"79\":1}}],[\"223\",{\"1\":{\"78\":1,\"79\":1}}],[\"222\",{\"1\":{\"78\":1,\"79\":1}}],[\"221\",{\"1\":{\"78\":1,\"79\":1}}],[\"220\",{\"1\":{\"78\":1,\"79\":1}}],[\"22\",{\"1\":{\"78\":1,\"79\":1,\"120\":1,\"140\":2,\"141\":1}}],[\"219\",{\"1\":{\"78\":1,\"79\":1}}],[\"218\",{\"1\":{\"78\":1,\"79\":1}}],[\"217\",{\"1\":{\"78\":1,\"79\":1}}],[\"216\",{\"1\":{\"78\":1,\"79\":1}}],[\"215\",{\"1\":{\"78\":1,\"79\":1}}],[\"214\",{\"1\":{\"78\":1,\"79\":1}}],[\"213\",{\"1\":{\"78\":1,\"79\":1}}],[\"212\",{\"1\":{\"78\":1,\"79\":1}}],[\"211\",{\"1\":{\"78\":1,\"79\":1}}],[\"210\",{\"1\":{\"78\":1,\"79\":1}}],[\"21\",{\"1\":{\"78\":1,\"79\":1}}],[\"209\",{\"1\":{\"78\":1,\"79\":1}}],[\"208\",{\"1\":{\"78\":1,\"79\":1}}],[\"207\",{\"1\":{\"78\":1,\"79\":1}}],[\"206\",{\"1\":{\"78\":1,\"79\":1}}],[\"205\",{\"1\":{\"78\":1,\"79\":1}}],[\"204\",{\"1\":{\"78\":1,\"79\":1}}],[\"203\",{\"1\":{\"78\":1,\"79\":1}}],[\"20240603010701\",{\"1\":{\"243\":1}}],[\"20240603005031\",{\"1\":{\"241\":1}}],[\"20240603001559\",{\"1\":{\"236\":1}}],[\"20240424173111\",{\"1\":{\"166\":1}}],[\"20240424155622\",{\"1\":{\"132\":1}}],[\"20240424155614\",{\"1\":{\"131\":1}}],[\"20240208155716\",{\"1\":{\"117\":1}}],[\"20240127155408\",{\"1\":{\"254\":1}}],[\"20240127155359\",{\"1\":{\"253\":1}}],[\"20240127155324\",{\"1\":{\"249\":1}}],[\"20240127155314\",{\"1\":{\"248\":1}}],[\"20240127155257\",{\"1\":{\"247\":1}}],[\"20240115164427\",{\"1\":{\"108\":1}}],[\"20240115164413\",{\"1\":{\"107\":1}}],[\"20240131144909\",{\"1\":{\"91\":1}}],[\"20240131144616\",{\"1\":{\"88\":1}}],[\"202\",{\"1\":{\"78\":1,\"79\":1}}],[\"201\",{\"1\":{\"78\":1,\"79\":1}}],[\"200\",{\"1\":{\"78\":1,\"79\":1}}],[\"20\",{\"1\":{\"78\":1,\"79\":1,\"106\":1,\"148\":1,\"158\":1}}],[\"254\",{\"1\":{\"78\":1,\"79\":1}}],[\"253\",{\"1\":{\"78\":1,\"79\":1}}],[\"252\",{\"1\":{\"78\":1,\"79\":1}}],[\"251\",{\"1\":{\"78\":1,\"79\":1}}],[\"250\",{\"1\":{\"78\":1,\"79\":1}}],[\"25\",{\"1\":{\"78\":1,\"79\":1}}],[\"256\",{\"1\":{\"78\":1,\"79\":1,\"82\":1}}],[\"258\",{\"0\":{\"79\":1,\"82\":1},\"1\":{\"75\":1,\"79\":1,\"82\":4}}],[\"257\",{\"0\":{\"78\":1,\"82\":1},\"1\":{\"75\":1,\"79\":1,\"82\":5}}],[\"25eb9d70b2b4\",{\"1\":{\"68\":1}}],[\"255\",{\"1\":{\"43\":2,\"78\":1,\"79\":1}}],[\"249\",{\"1\":{\"78\":1,\"79\":1}}],[\"248\",{\"1\":{\"78\":1,\"79\":1}}],[\"247\",{\"1\":{\"78\":1,\"79\":1}}],[\"246\",{\"1\":{\"78\":1,\"79\":1}}],[\"245\",{\"1\":{\"78\":1,\"79\":1}}],[\"244\",{\"1\":{\"78\":1,\"79\":1}}],[\"243\",{\"1\":{\"78\":1,\"79\":1}}],[\"242\",{\"1\":{\"78\":1,\"79\":1}}],[\"241\",{\"1\":{\"78\":1,\"79\":1}}],[\"240\",{\"1\":{\"78\":1,\"79\":1}}],[\"24\",{\"1\":{\"43\":1,\"78\":1,\"79\":1,\"117\":1}}],[\"2\",{\"0\":{\"6\":1,\"8\":1,\"9\":2,\"10\":1,\"11\":1,\"20\":1,\"23\":1,\"24\":2,\"25\":1,\"26\":1,\"34\":1,\"40\":1,\"54\":1,\"55\":1,\"56\":2,\"57\":1,\"58\":1,\"61\":1,\"67\":1,\"88\":1,\"89\":2,\"92\":1,\"107\":1,\"115\":1,\"122\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"130\":1,\"132\":1,\"136\":1,\"138\":1,\"140\":1,\"143\":1,\"148\":1,\"151\":1,\"154\":1,\"162\":1,\"163\":1,\"167\":1,\"185\":1,\"189\":1,\"193\":1,\"197\":1,\"204\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":1,\"220\":1,\"221\":1,\"224\":1,\"228\":1,\"236\":1,\"240\":1,\"249\":1,\"260\":1,\"263\":1,\"264\":2,\"266\":1,\"268\":1},\"1\":{\"77\":1,\"78\":1,\"79\":1,\"82\":4,\"117\":2,\"130\":3,\"136\":1,\"139\":1,\"140\":2,\"141\":12,\"146\":2,\"148\":1,\"164\":2,\"165\":1,\"167\":1,\"219\":1,\"232\":1,\"233\":1,\"240\":1,\"250\":2,\"260\":1,\"264\":1}}],[\"蛮多人用\",{\"1\":{\"5\":1}}],[\"也许会说\",{\"1\":{\"255\":1}}],[\"也没有关系\",{\"1\":{\"241\":1}}],[\"也有外部\",{\"1\":{\"241\":1}}],[\"也有自己的缓存\",{\"1\":{\"231\":1}}],[\"也要保证一次性写入\",{\"1\":{\"236\":1}}],[\"也意味着\",{\"1\":{\"219\":1}}],[\"也不是直接写入磁盘的\",{\"1\":{\"231\":1}}],[\"也不存在于\",{\"1\":{\"205\":1}}],[\"也不会再继续执行\",{\"1\":{\"167\":1}}],[\"也不一定要一致\",{\"1\":{\"122\":1}}],[\"也能产生逃逸\",{\"1\":{\"108\":1}}],[\"也会自动隐式开启事务\",{\"1\":{\"215\":1}}],[\"也会跟着一起变化\",{\"1\":{\"164\":1}}],[\"也会相当于快照一样保存那个地址\",{\"1\":{\"164\":1}}],[\"也会分配到堆上\",{\"1\":{\"105\":1}}],[\"也会算到这\",{\"1\":{\"82\":1}}],[\"也可能是需要进一步处理的中间形态obj文件\",{\"1\":{\"97\":1}}],[\"也可以查看到绑定的地址\",{\"1\":{\"40\":1}}],[\"也可以直接改\",{\"1\":{\"3\":1}}],[\"也造成了很差的局部性\",{\"1\":{\"89\":1}}],[\"也放到全局队列\",{\"1\":{\"82\":1}}],[\"也就是前面所说的锁剩余持有时间\",{\"1\":{\"255\":1}}],[\"也就是3个redis返回成功\",{\"1\":{\"254\":1}}],[\"也就是哨兵模式\",{\"1\":{\"253\":1}}],[\"也就是生成一条\",{\"1\":{\"229\":1}}],[\"也就是会导致两个\",{\"1\":{\"199\":1}}],[\"也就是\",{\"1\":{\"141\":1}}],[\"也就是完整调度了\",{\"1\":{\"82\":1}}],[\"也就是只有一个\",{\"1\":{\"81\":1}}],[\"也就是说\",{\"1\":{\"20\":1,\"249\":1}}],[\"也是不错的\",{\"1\":{\"5\":1}}],[\"ttl\",{\"1\":{\"266\":2}}],[\"tty\",{\"1\":{\"68\":1}}],[\"t是什么类型\",{\"1\":{\"157\":1}}],[\"t\",{\"1\":{\"157\":2,\"211\":1,\"239\":2}}],[\"title\",{\"1\":{\"150\":2}}],[\"timestamp\",{\"1\":{\"268\":1}}],[\"time\",{\"1\":{\"68\":1,\"189\":3,\"262\":2}}],[\"testpanic3\",{\"1\":{\"167\":4}}],[\"testpanic3panic\",{\"1\":{\"167\":1}}],[\"testpanic2\",{\"1\":{\"167\":6}}],[\"testpanic1\",{\"1\":{\"167\":2}}],[\"temp变量\",{\"1\":{\"141\":1}}],[\"temp\",{\"1\":{\"140\":2,\"141\":1}}],[\"text\",{\"1\":{\"117\":1}}],[\"tls\",{\"1\":{\"117\":1}}],[\"type\",{\"1\":{\"106\":1,\"123\":1,\"125\":1,\"128\":2,\"129\":1,\"135\":1,\"148\":1,\"150\":3,\"151\":2,\"152\":2,\"153\":4,\"154\":3,\"156\":2,\"158\":3,\"159\":4,\"160\":1,\"171\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":5,\"178\":2,\"179\":1,\"190\":3,\"196\":1,\"260\":2,\"262\":2,\"264\":1}}],[\"type=bind\",{\"1\":{\"35\":1}}],[\"tf\",{\"1\":{\"67\":2}}],[\"table\",{\"1\":{\"266\":1}}],[\"tail\",{\"1\":{\"67\":2}}],[\"tag值\",{\"1\":{\"176\":1}}],[\"tag指定json序列化与反序列化时的行为\",{\"1\":{\"174\":1}}],[\"tag指定序列化与反序列化时的行为\",{\"1\":{\"173\":1}}],[\"tag指定字段名\",{\"0\":{\"173\":1}}],[\"tag在结构体字段的后方定义\",{\"1\":{\"172\":1}}],[\"tag是结构体的元信息\",{\"1\":{\"172\":1}}],[\"tag\",{\"1\":{\"55\":1,\"57\":1,\"175\":1,\"179\":2}}],[\"target=\",{\"1\":{\"32\":1,\"35\":1}}],[\"txt\",{\"1\":{\"35\":2}}],[\"to\",{\"1\":{\"262\":1}}],[\"total\",{\"1\":{\"146\":3}}],[\"tool\",{\"1\":{\"117\":1}}],[\"token\",{\"1\":{\"99\":1}}],[\"top\",{\"1\":{\"68\":2}}],[\"touch\",{\"1\":{\"35\":2}}],[\"toml\",{\"1\":{\"26\":1}}],[\"todo\",{\"1\":{\"10\":1}}],[\"three\",{\"1\":{\"97\":1}}],[\"the\",{\"1\":{\"82\":1}}],[\"theme\",{\"1\":{\"5\":1}}],[\"thunder\",{\"1\":{\"10\":1}}],[\"transaction\",{\"1\":{\"236\":1}}],[\"training\",{\"1\":{\"32\":1,\"35\":1}}],[\"trx\",{\"1\":{\"218\":2,\"219\":1,\"220\":13,\"232\":5,\"241\":1}}],[\"tryswap\",{\"1\":{\"205\":2}}],[\"try\",{\"1\":{\"82\":1}}],[\"tree\",{\"1\":{\"10\":1,\"210\":1}}],[\"true\",{\"1\":{\"3\":3,\"157\":1,\"188\":1,\"189\":1,\"190\":2,\"205\":9}}],[\"mb\",{\"1\":{\"231\":1}}],[\"mvcc\",{\"0\":{\"212\":1,\"219\":1},\"1\":{\"219\":3},\"2\":{\"245\":1}}],[\"missssss\",{\"0\":{\"204\":1}}],[\"misslocked\",{\"0\":{\"204\":1},\"1\":{\"203\":1,\"204\":2}}],[\"miss\",{\"1\":{\"203\":1,\"204\":1}}],[\"misses++\",{\"1\":{\"204\":1}}],[\"misses\",{\"1\":{\"190\":3,\"204\":5,\"206\":1}}],[\"min\",{\"1\":{\"82\":2,\"220\":3}}],[\"multi\",{\"1\":{\"219\":1}}],[\"mutex\",{\"1\":{\"190\":1,\"201\":1}}],[\"mu\",{\"1\":{\"190\":1,\"203\":2,\"205\":2,\"206\":2}}],[\"must\",{\"1\":{\"82\":1}}],[\"methodb\",{\"1\":{\"154\":5}}],[\"methoda\",{\"1\":{\"154\":5}}],[\"methodname3\",{\"1\":{\"153\":1}}],[\"methodname2\",{\"1\":{\"153\":1}}],[\"methodname1\",{\"1\":{\"153\":1}}],[\"m\",{\"1\":{\"82\":1,\"89\":9,\"106\":1,\"148\":2,\"154\":2,\"159\":2,\"184\":3,\"185\":5,\"188\":6,\"189\":5,\"190\":1,\"203\":9,\"204\":9,\"205\":16,\"206\":11,\"220\":4}}],[\"mtu\",{\"1\":{\"43\":1}}],[\"myisam等\",{\"1\":{\"210\":1}}],[\"myint\",{\"1\":{\"148\":6}}],[\"mystruct\",{\"1\":{\"154\":4,\"159\":4}}],[\"mysql采用了多种机制来确保并发安全和一致性\",{\"1\":{\"236\":1}}],[\"mysql之内存篇\",{\"1\":{\"225\":1}}],[\"mysql一条查询语句的执行过程可以概括为\",{\"1\":{\"210\":1}}],[\"mysql会直接从缓存中返回结果\",{\"1\":{\"210\":1}}],[\"mysql的执行器根据优化器选择的执行计划\",{\"1\":{\"210\":1}}],[\"mysql使用一种基于成本的优化算法\",{\"1\":{\"210\":1}}],[\"mysql日志系统\",{\"0\":{\"209\":1}}],[\"mysql\",{\"0\":{\"280\":1},\"1\":{\"57\":2,\"210\":1,\"215\":2,\"216\":1,\"223\":1,\"224\":3,\"227\":1,\"228\":1,\"231\":1,\"232\":2,\"235\":2,\"236\":2,\"237\":1,\"239\":3,\"241\":4,\"243\":1},\"2\":{\"244\":1}}],[\"my\",{\"1\":{\"31\":1,\"32\":1,\"33\":1,\"35\":1,\"41\":3,\"150\":1}}],[\"myvolname\",{\"1\":{\"29\":1}}],[\"most\",{\"1\":{\"262\":1}}],[\"movq这条指令是将main函数caller的基址入栈\",{\"1\":{\"117\":1}}],[\"movq\",{\"1\":{\"117\":24}}],[\"mode\",{\"1\":{\"41\":1}}],[\"mount\",{\"1\":{\"32\":2,\"35\":3,\"37\":1}}],[\"mounts\",{\"1\":{\"27\":1}}],[\"mousewheelzoom\",{\"1\":{\"3\":1}}],[\"moby\",{\"1\":{\"26\":2}}],[\"marshal\",{\"0\":{\"171\":1},\"1\":{\"171\":2,\"175\":3,\"177\":2,\"178\":2}}],[\"map将被提升为\",{\"1\":{\"190\":1}}],[\"map\",{\"0\":{\"183\":2,\"184\":1,\"186\":1,\"187\":1,\"190\":1,\"191\":1,\"192\":2,\"193\":2,\"200\":1,\"201\":1,\"202\":1},\"1\":{\"140\":4,\"183\":2,\"184\":4,\"185\":2,\"186\":10,\"189\":1,\"190\":10,\"193\":2,\"194\":5,\"199\":5,\"200\":2,\"201\":4,\"203\":2,\"204\":1,\"205\":2,\"206\":2}}],[\"make\",{\"1\":{\"107\":2,\"109\":1,\"184\":1,\"185\":1}}],[\"makeslice\",{\"1\":{\"107\":4,\"109\":2}}],[\"max\",{\"1\":{\"82\":4,\"220\":3}}],[\"main就会终止\",{\"1\":{\"167\":1}}],[\"main函数局部变量r7入栈\",{\"1\":{\"117\":1}}],[\"main函数局部变量r6入栈\",{\"1\":{\"117\":1}}],[\"main函数局部变量r5入栈\",{\"1\":{\"117\":1}}],[\"main函数局部变量r4入栈\",{\"1\":{\"117\":1}}],[\"main函数局部变量r3入栈\",{\"1\":{\"117\":1}}],[\"main函数局部变量r2入栈\",{\"1\":{\"117\":1}}],[\"main函数局部变量r1入栈\",{\"1\":{\"117\":1}}],[\"main函数定义\",{\"1\":{\"117\":1}}],[\"main\",{\"1\":{\"75\":2,\"106\":2,\"107\":4,\"109\":2,\"117\":44,\"126\":1,\"129\":2,\"130\":1,\"135\":1,\"141\":1,\"146\":3,\"148\":2,\"150\":1,\"154\":2,\"156\":1,\"157\":2,\"158\":2,\"159\":2,\"164\":1,\"165\":6,\"167\":2,\"171\":2,\"179\":1,\"184\":2,\"185\":2,\"189\":2}}],[\"mac\",{\"1\":{\"44\":1}}],[\"macvlan\",{\"1\":{\"44\":1}}],[\"manager\",{\"1\":{\"9\":1}}],[\"material\",{\"1\":{\"5\":1}}],[\"owner\",{\"1\":{\"249\":1,\"250\":2}}],[\"o\",{\"1\":{\"201\":1,\"223\":1,\"231\":1,\"236\":3,\"242\":1,\"243\":1}}],[\"operations\",{\"1\":{\"189\":1}}],[\"opt\",{\"1\":{\"35\":3}}],[\"omitpassworddemo\",{\"1\":{\"178\":1}}],[\"omitempty\",{\"1\":{\"176\":3,\"177\":10,\"178\":1}}],[\"omitemptydemo\",{\"1\":{\"175\":1}}],[\"ok\",{\"1\":{\"137\":2,\"157\":6,\"188\":2,\"189\":2,\"203\":7,\"205\":8,\"206\":2}}],[\"object\",{\"1\":{\"261\":2,\"262\":1}}],[\"obj\",{\"1\":{\"102\":2}}],[\"of\",{\"1\":{\"82\":1,\"156\":1}}],[\"official\",{\"1\":{\"5\":1}}],[\"or\",{\"1\":{\"44\":1,\"262\":1}}],[\"overlay\",{\"1\":{\"41\":2,\"44\":1}}],[\"ontainer\",{\"1\":{\"47\":1}}],[\"only\",{\"1\":{\"35\":1}}],[\"on\",{\"1\":{\"3\":1}}],[\"1之前版本\",{\"1\":{\"117\":1}}],[\"199\",{\"1\":{\"78\":1,\"79\":1}}],[\"198\",{\"1\":{\"78\":1,\"79\":1}}],[\"197\",{\"1\":{\"78\":1,\"79\":1}}],[\"196\",{\"1\":{\"78\":1,\"79\":1}}],[\"195\",{\"1\":{\"78\":1,\"79\":1}}],[\"194\",{\"1\":{\"78\":1,\"79\":1}}],[\"193\",{\"1\":{\"78\":1,\"79\":1}}],[\"192\",{\"1\":{\"78\":1,\"79\":1}}],[\"191\",{\"1\":{\"78\":1,\"79\":1}}],[\"190\",{\"1\":{\"78\":1,\"79\":1}}],[\"19\",{\"1\":{\"78\":1,\"79\":1}}],[\"189\",{\"1\":{\"78\":1,\"79\":1}}],[\"188\",{\"1\":{\"78\":1,\"79\":1,\"82\":1}}],[\"187\",{\"1\":{\"78\":1,\"79\":1}}],[\"186\",{\"1\":{\"78\":1,\"79\":1}}],[\"185\",{\"1\":{\"78\":1,\"79\":1}}],[\"184\",{\"1\":{\"78\":1,\"79\":1}}],[\"183\",{\"1\":{\"78\":1,\"79\":1}}],[\"182\",{\"1\":{\"78\":1,\"79\":1}}],[\"181\",{\"1\":{\"78\":1,\"79\":1}}],[\"181422\",{\"1\":{\"68\":1}}],[\"181442\",{\"1\":{\"68\":1}}],[\"180\",{\"1\":{\"78\":1,\"79\":1,\"117\":1}}],[\"18\",{\"1\":{\"78\":1,\"79\":1,\"171\":3}}],[\"159\",{\"1\":{\"78\":1,\"79\":1}}],[\"158\",{\"1\":{\"78\":1,\"79\":1}}],[\"157\",{\"1\":{\"78\":1,\"79\":1}}],[\"156\",{\"1\":{\"78\":1,\"79\":1}}],[\"155\",{\"1\":{\"78\":1,\"79\":1}}],[\"154\",{\"1\":{\"78\":1,\"79\":1}}],[\"153\",{\"1\":{\"78\":1,\"79\":1}}],[\"152\",{\"1\":{\"78\":1,\"79\":1}}],[\"151\",{\"1\":{\"78\":1,\"79\":1}}],[\"150\",{\"1\":{\"78\":1,\"79\":1}}],[\"1500\",{\"1\":{\"43\":1}}],[\"15\",{\"0\":{\"117\":1,\"166\":1,\"167\":1},\"1\":{\"78\":1,\"79\":1,\"146\":1,\"265\":1,\"266\":1}}],[\"149\",{\"1\":{\"78\":1,\"79\":1}}],[\"148\",{\"1\":{\"78\":1,\"79\":1}}],[\"147\",{\"1\":{\"78\":1,\"79\":1}}],[\"146\",{\"1\":{\"78\":1,\"79\":1}}],[\"145\",{\"1\":{\"78\":1,\"79\":1}}],[\"144\",{\"1\":{\"78\":1,\"79\":1}}],[\"143\",{\"1\":{\"78\":1,\"79\":1}}],[\"142\",{\"1\":{\"78\":1,\"79\":1}}],[\"141\",{\"1\":{\"78\":1,\"79\":1}}],[\"140\",{\"1\":{\"78\":1,\"79\":1}}],[\"14\",{\"0\":{\"165\":1},\"1\":{\"78\":1,\"79\":1,\"151\":1,\"158\":1}}],[\"139\",{\"1\":{\"78\":1,\"79\":1}}],[\"138\",{\"1\":{\"78\":1,\"79\":1}}],[\"137\",{\"1\":{\"78\":1,\"79\":1}}],[\"136\",{\"1\":{\"78\":1,\"79\":1}}],[\"135\",{\"1\":{\"78\":1,\"79\":1}}],[\"134\",{\"1\":{\"78\":1,\"79\":1}}],[\"133\",{\"1\":{\"78\":1,\"79\":1}}],[\"132\",{\"1\":{\"78\":1,\"79\":1}}],[\"131\",{\"1\":{\"78\":1,\"79\":1}}],[\"130\",{\"1\":{\"78\":1,\"79\":1}}],[\"13\",{\"0\":{\"161\":1,\"162\":1,\"163\":1,\"164\":1},\"1\":{\"78\":1,\"79\":1}}],[\"129\",{\"1\":{\"78\":1,\"79\":1,\"82\":2}}],[\"128表示将分配的main函数的栈帧大小\",{\"1\":{\"117\":1}}],[\"128\",{\"1\":{\"78\":1,\"79\":1,\"82\":2,\"117\":2}}],[\"126\",{\"1\":{\"78\":1,\"79\":1}}],[\"125\",{\"1\":{\"78\":1,\"79\":1}}],[\"124\",{\"1\":{\"78\":1,\"79\":1}}],[\"1234567\",{\"1\":{\"179\":2}}],[\"123456\",{\"1\":{\"178\":1}}],[\"123\",{\"1\":{\"78\":1,\"79\":1,\"126\":2}}],[\"122\",{\"1\":{\"78\":1,\"79\":1}}],[\"121\",{\"1\":{\"78\":1,\"79\":1}}],[\"120\",{\"1\":{\"78\":1,\"79\":1,\"117\":3}}],[\"12\",{\"0\":{\"160\":1},\"1\":{\"78\":1,\"79\":1}}],[\"127\",{\"1\":{\"39\":3,\"78\":1,\"79\":1}}],[\"119\",{\"1\":{\"78\":1,\"79\":1}}],[\"118\",{\"1\":{\"78\":1,\"79\":1}}],[\"117\",{\"1\":{\"78\":1,\"79\":1}}],[\"116\",{\"1\":{\"78\":1,\"79\":1}}],[\"115\",{\"1\":{\"78\":1,\"79\":1}}],[\"114\",{\"1\":{\"78\":1,\"79\":1}}],[\"113\",{\"1\":{\"78\":1,\"79\":1}}],[\"112\",{\"1\":{\"78\":1,\"79\":1}}],[\"111\",{\"1\":{\"78\":1,\"79\":1,\"128\":1}}],[\"110\",{\"1\":{\"78\":1,\"79\":1}}],[\"11\",{\"0\":{\"153\":1,\"154\":1,\"155\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1},\"1\":{\"78\":1,\"79\":1,\"157\":1}}],[\"109\",{\"1\":{\"78\":1,\"79\":1}}],[\"108\",{\"1\":{\"78\":1,\"79\":1}}],[\"107\",{\"1\":{\"78\":1,\"79\":1}}],[\"106\",{\"1\":{\"78\":1,\"79\":1}}],[\"105\",{\"1\":{\"78\":1,\"79\":1}}],[\"104\",{\"1\":{\"78\":1,\"79\":1}}],[\"103\",{\"1\":{\"78\":1,\"79\":1}}],[\"102\",{\"1\":{\"78\":1,\"79\":1}}],[\"101\",{\"1\":{\"78\":1,\"79\":1,\"136\":1}}],[\"10086\",{\"1\":{\"211\":1}}],[\"1000\",{\"1\":{\"189\":3,\"261\":2}}],[\"1000000\",{\"1\":{\"184\":2,\"185\":2}}],[\"10000\",{\"1\":{\"107\":2}}],[\"100\",{\"1\":{\"78\":1,\"79\":1,\"107\":2,\"130\":1,\"135\":1}}],[\"10\",{\"0\":{\"77\":1,\"150\":1,\"151\":1,\"152\":1},\"1\":{\"75\":1,\"77\":1,\"78\":1,\"79\":1,\"81\":2,\"148\":1,\"189\":3,\"262\":1}}],[\"16kb\",{\"1\":{\"224\":2}}],[\"169\",{\"1\":{\"78\":1,\"79\":1}}],[\"168\",{\"1\":{\"78\":1,\"79\":1}}],[\"167\",{\"1\":{\"78\":1,\"79\":1}}],[\"166\",{\"1\":{\"78\":1,\"79\":1}}],[\"165\",{\"1\":{\"78\":1,\"79\":1}}],[\"164\",{\"1\":{\"78\":1,\"79\":1}}],[\"163\",{\"1\":{\"78\":1,\"79\":1}}],[\"162\",{\"1\":{\"78\":1,\"79\":1}}],[\"161\",{\"1\":{\"78\":1,\"79\":1}}],[\"160\",{\"1\":{\"78\":1,\"79\":1}}],[\"16\",{\"1\":{\"43\":1,\"78\":1,\"79\":1,\"117\":2,\"129\":2,\"231\":1,\"262\":1,\"265\":1,\"266\":1}}],[\"17以前的版本\",{\"1\":{\"116\":1}}],[\"179\",{\"1\":{\"78\":1,\"79\":1}}],[\"178\",{\"1\":{\"78\":1,\"79\":1}}],[\"177\",{\"1\":{\"78\":1,\"79\":1}}],[\"176\",{\"1\":{\"78\":1,\"79\":1}}],[\"175\",{\"1\":{\"78\":1,\"79\":1}}],[\"174\",{\"1\":{\"78\":1,\"79\":1}}],[\"173\",{\"1\":{\"78\":1,\"79\":1}}],[\"171\",{\"1\":{\"78\":1,\"79\":1}}],[\"1707147895527\",{\"1\":{\"98\":1}}],[\"1707147903867\",{\"1\":{\"97\":1}}],[\"170\",{\"1\":{\"78\":1,\"79\":1}}],[\"17\",{\"1\":{\"43\":2,\"78\":1,\"79\":1,\"117\":1}}],[\"172\",{\"1\":{\"43\":2,\"78\":1,\"79\":1}}],[\"1\",{\"0\":{\"5\":2,\"6\":1,\"8\":1,\"19\":2,\"20\":1,\"21\":1,\"23\":1,\"28\":1,\"39\":1,\"53\":1,\"55\":1,\"60\":1,\"66\":1,\"88\":1,\"91\":1,\"106\":1,\"114\":2,\"115\":1,\"116\":1,\"117\":1,\"121\":2,\"122\":1,\"123\":1,\"131\":1,\"135\":1,\"137\":1,\"139\":1,\"142\":1,\"147\":1,\"149\":1,\"150\":1,\"153\":1,\"160\":1,\"161\":1,\"162\":1,\"165\":1,\"166\":1,\"184\":1,\"188\":1,\"192\":1,\"196\":1,\"203\":1,\"213\":1,\"215\":1,\"223\":1,\"227\":1,\"235\":1,\"239\":1,\"248\":1,\"259\":2,\"260\":1,\"261\":1,\"262\":1,\"263\":1,\"265\":1,\"267\":1},\"1\":{\"39\":3,\"43\":1,\"75\":2,\"77\":1,\"78\":1,\"79\":1,\"81\":1,\"82\":8,\"109\":1,\"117\":2,\"120\":1,\"130\":3,\"139\":1,\"140\":2,\"141\":9,\"146\":2,\"156\":1,\"164\":3,\"165\":5,\"189\":5,\"232\":2,\"233\":1,\"236\":2,\"239\":4,\"241\":2,\"249\":1,\"264\":1}}],[\"类型断言都会失败\",{\"1\":{\"157\":1}}],[\"类型断言接口操作\",{\"1\":{\"157\":1}}],[\"类型的定义和绑定在它上面的方法的定义可以不放置在同一个文件中\",{\"1\":{\"149\":1}}],[\"类型的一个方法\",{\"1\":{\"148\":1}}],[\"类型的变量i赋值给整形变量b\",{\"1\":{\"156\":1}}],[\"类型的变量\",{\"1\":{\"147\":1}}],[\"类型不安全\",{\"1\":{\"148\":1}}],[\"类型安全可以防止许多常见的编程错误\",{\"1\":{\"147\":1}}],[\"类型安全\",{\"1\":{\"147\":1}}],[\"类型参数\",{\"1\":{\"146\":1}}],[\"类型\",{\"1\":{\"121\":1,\"124\":1,\"148\":1,\"157\":1,\"190\":1,\"196\":1}}],[\"类型检查包括某些额外的检查\",{\"1\":{\"100\":1}}],[\"类型检查\",{\"1\":{\"100\":1}}],[\"类似于问你准备好了吗\",{\"1\":{\"240\":1}}],[\"类似protected\",{\"1\":{\"121\":1}}],[\"类似\",{\"1\":{\"10\":1}}],[\"类\",{\"0\":{\"4\":1,\"12\":1}}],[\"二元运算待的运算方向均是从左至右\",{\"1\":{\"133\":1}}],[\"二\",{\"0\":{\"4\":1,\"22\":1,\"76\":1,\"87\":1,\"118\":1,\"186\":1,\"211\":1}}],[\"feature\",{\"0\":{\"276\":1}}],[\"frequency\",{\"1\":{\"262\":1}}],[\"from\",{\"1\":{\"82\":1}}],[\"fsync\",{\"1\":{\"236\":6,\"242\":1,\"243\":1}}],[\"flush\",{\"1\":{\"232\":5,\"241\":1,\"243\":1}}],[\"float64\",{\"1\":{\"151\":3,\"158\":6,\"171\":1,\"173\":1,\"174\":1,\"179\":1}}],[\"float\",{\"1\":{\"143\":1}}],[\"found\",{\"1\":{\"188\":1,\"271\":1}}],[\"form提交时忽略实体\",{\"1\":{\"176\":1}}],[\"for\",{\"0\":{\"139\":1,\"140\":1,\"141\":1},\"1\":{\"75\":1,\"82\":1,\"107\":2,\"109\":1,\"138\":1,\"139\":3,\"140\":4,\"141\":7,\"146\":1,\"184\":2,\"185\":2,\"189\":6,\"205\":1,\"206\":1}}],[\"forever\",{\"1\":{\"43\":2}}],[\"failed\",{\"1\":{\"171\":2,\"175\":1,\"177\":1,\"178\":1,\"179\":1}}],[\"fatal\",{\"0\":{\"184\":1,\"185\":1},\"1\":{\"166\":1,\"183\":1,\"184\":2,\"185\":1}}],[\"false\",{\"1\":{\"3\":1,\"82\":1,\"124\":1,\"203\":2,\"205\":4}}],[\"fp\",{\"1\":{\"117\":1}}],[\"funcdata\",{\"1\":{\"117\":2}}],[\"funcdata用于go汇编额外信息\",{\"1\":{\"117\":1}}],[\"func\",{\"1\":{\"75\":2,\"82\":1,\"106\":2,\"107\":4,\"109\":2,\"117\":2,\"126\":1,\"129\":1,\"130\":1,\"135\":1,\"141\":1,\"146\":2,\"148\":2,\"150\":2,\"151\":1,\"152\":2,\"154\":3,\"155\":1,\"156\":1,\"157\":1,\"158\":4,\"159\":3,\"164\":2,\"165\":9,\"167\":1,\"171\":1,\"175\":1,\"177\":1,\"178\":1,\"179\":1,\"184\":3,\"185\":3,\"188\":1,\"189\":6,\"203\":1,\"204\":1,\"205\":3,\"206\":2}}],[\"fmt包下的print系列\",{\"1\":{\"155\":1}}],[\"fmt\",{\"1\":{\"75\":2,\"106\":2,\"141\":2,\"146\":3,\"148\":2,\"150\":1,\"152\":2,\"154\":3,\"157\":2,\"158\":2,\"159\":3,\"160\":1,\"164\":1,\"165\":6,\"171\":4,\"175\":2,\"177\":2,\"178\":2,\"179\":2,\"185\":6,\"188\":3,\"189\":7}}],[\"f\",{\"1\":{\"58\":3,\"63\":2,\"130\":1,\"206\":2}}],[\"ff\",{\"1\":{\"43\":6}}],[\"file\",{\"1\":{\"6\":1,\"35\":1}}],[\"files\",{\"1\":{\"3\":1}}],[\"光标闪烁效果设为平滑\",{\"1\":{\"3\":1}}],[\"光标移动时的平滑动画效果\",{\"1\":{\"3\":1}}],[\"光标异常丝滑\",{\"1\":{\"3\":1}}],[\"sql解析器首先会对查询语句进行语法和词法分析\",{\"1\":{\"210\":1}}],[\"sql解析器\",{\"1\":{\"210\":1}}],[\"sql\",{\"1\":{\"209\":1,\"237\":1}}],[\"significant\",{\"1\":{\"262\":2}}],[\"site\",{\"1\":{\"177\":4}}],[\"sizeof\",{\"1\":{\"129\":4}}],[\"size=190\",{\"1\":{\"117\":1}}],[\"size\",{\"1\":{\"55\":1,\"231\":1}}],[\"sayhello\",{\"1\":{\"150\":2}}],[\"slogan\",{\"1\":{\"177\":5}}],[\"slice\",{\"1\":{\"140\":1,\"146\":1}}],[\"sleep\",{\"1\":{\"26\":3,\"189\":1}}],[\"srtuct\",{\"1\":{\"129\":1}}],[\"src\",{\"1\":{\"35\":2,\"98\":1}}],[\"sprintf\",{\"1\":{\"189\":3}}],[\"speaks\",{\"1\":{\"152\":2}}],[\"speak\",{\"1\":{\"152\":2}}],[\"sp~sp+48\",{\"1\":{\"117\":1}}],[\"sp+56\",{\"1\":{\"117\":1}}],[\"sp+64~sp+112\",{\"1\":{\"117\":1}}],[\"sp寄存器存放的\",{\"1\":{\"117\":2}}],[\"sp\",{\"1\":{\"117\":29}}],[\"sb\",{\"1\":{\"117\":6}}],[\"ss\",{\"1\":{\"106\":2}}],[\"ssa是一种低级别的中间表示法\",{\"1\":{\"101\":1}}],[\"ssa\",{\"0\":{\"101\":1},\"1\":{\"101\":3,\"102\":1}}],[\"score\",{\"1\":{\"135\":1,\"179\":4}}],[\"scope\",{\"1\":{\"43\":1}}],[\"sched\",{\"1\":{\"82\":9}}],[\"syntax\",{\"1\":{\"99\":1}}],[\"syncmap\",{\"1\":{\"182\":1},\"2\":{\"208\":1}}],[\"syncmap包的源码学习\",{\"0\":{\"182\":1}}],[\"sync\",{\"0\":{\"183\":1,\"186\":1,\"187\":1,\"190\":1,\"200\":1,\"201\":1,\"202\":1},\"1\":{\"75\":2,\"183\":1,\"186\":3,\"189\":3,\"190\":1,\"194\":1,\"201\":3,\"236\":4,\"241\":1,\"243\":1}}],[\"systemd+\",{\"1\":{\"68\":1}}],[\"system\",{\"1\":{\"35\":1}}],[\"store\",{\"0\":{\"205\":1},\"1\":{\"188\":3,\"189\":1,\"204\":1,\"205\":3,\"206\":1}}],[\"stop\",{\"1\":{\"64\":1}}],[\"st\",{\"1\":{\"135\":1,\"136\":1}}],[\"stext\",{\"1\":{\"117\":1}}],[\"str\",{\"1\":{\"171\":2,\"175\":2,\"176\":1,\"177\":5,\"178\":2}}],[\"string类型零值是\",{\"1\":{\"175\":1}}],[\"stringtype\",{\"1\":{\"129\":2}}],[\"stringheader\",{\"1\":{\"129\":1}}],[\"string\",{\"1\":{\"106\":2,\"125\":1,\"128\":1,\"135\":1,\"143\":1,\"150\":3,\"152\":1,\"160\":1,\"171\":3,\"173\":1,\"174\":1,\"175\":4,\"176\":3,\"177\":15,\"178\":2,\"179\":2,\"259\":2,\"268\":1}}],[\"struct\",{\"1\":{\"106\":1,\"135\":1,\"150\":3,\"151\":1,\"152\":2,\"154\":1,\"158\":2,\"159\":1,\"171\":3,\"173\":1,\"174\":1,\"175\":3,\"176\":1,\"177\":5,\"178\":3,\"179\":1,\"190\":3,\"196\":1,\"262\":1,\"264\":1,\"266\":1}}],[\"studentregister\",{\"1\":{\"106\":2}}],[\"student\",{\"1\":{\"106\":3,\"135\":2,\"136\":1}}],[\"stime\",{\"1\":{\"68\":1}}],[\"start\",{\"1\":{\"64\":1,\"236\":1}}],[\"state\",{\"1\":{\"43\":1}}],[\"setnx\",{\"1\":{\"247\":1}}],[\"set\",{\"1\":{\"211\":1,\"239\":1,\"248\":1,\"259\":1,\"261\":1}}],[\"settings\",{\"1\":{\"3\":2}}],[\"seconds\",{\"1\":{\"248\":1}}],[\"second\",{\"1\":{\"189\":1}}],[\"select\",{\"0\":{\"210\":1},\"1\":{\"184\":1,\"185\":1,\"211\":1,\"219\":2,\"223\":1,\"235\":1}}],[\"server层\",{\"1\":{\"213\":1}}],[\"server\",{\"1\":{\"68\":1,\"213\":2,\"223\":1,\"235\":3}}],[\"search\",{\"0\":{\"56\":1},\"1\":{\"56\":1}}],[\"show\",{\"1\":{\"235\":1}}],[\"shape\",{\"1\":{\"151\":1,\"158\":7}}],[\"sh\",{\"1\":{\"41\":1}}],[\"shim\",{\"1\":{\"25\":1,\"26\":2}}],[\"swaplocked\",{\"1\":{\"205\":2}}],[\"swap\",{\"1\":{\"205\":3}}],[\"swarm\",{\"1\":{\"41\":1}}],[\"switch\",{\"0\":{\"138\":1},\"1\":{\"9\":1}}],[\"source=\",{\"1\":{\"35\":1}}],[\"source=my\",{\"1\":{\"32\":1}}],[\"sock\",{\"1\":{\"26\":1}}],[\"sdk\",{\"1\":{\"23\":1}}],[\"s\",{\"1\":{\"22\":1,\"82\":2,\"106\":5,\"107\":6,\"117\":1,\"154\":3,\"158\":2,\"171\":1,\"175\":1,\"177\":1,\"178\":1,\"188\":2,\"189\":2}}],[\"sum\",{\"1\":{\"146\":6}}],[\"subq\",{\"1\":{\"117\":1}}],[\"sudo\",{\"1\":{\"26\":1}}],[\"supercharge\",{\"1\":{\"11\":1}}],[\"suggest\",{\"1\":{\"3\":1}}],[\"snippetspreventquicksuggestions\",{\"1\":{\"3\":1}}],[\"smooth\",{\"1\":{\"3\":1}}],[\"smoothscrolling\",{\"1\":{\"3\":2}}],[\"avg\",{\"1\":{\"266\":1}}],[\"access\",{\"1\":{\"262\":1}}],[\"ace8fbfdc7ab04f9e7f20bae079cd91\",{\"1\":{\"115\":1}}],[\"aaa表空间\",{\"1\":{\"228\":1}}],[\"ahead\",{\"1\":{\"227\":1}}],[\"autocommit\",{\"1\":{\"215\":1}}],[\"autosave\",{\"1\":{\"3\":1}}],[\"at\",{\"1\":{\"232\":5,\"241\":1}}],[\"atomic\",{\"1\":{\"190\":3,\"196\":2}}],[\"attach\",{\"1\":{\"70\":2}}],[\"amended\",{\"1\":{\"190\":3,\"203\":2,\"205\":2,\"206\":2}}],[\"all\",{\"1\":{\"189\":1}}],[\"any\",{\"1\":{\"190\":4,\"196\":2,\"203\":2,\"205\":5,\"206\":1}}],[\"and\",{\"1\":{\"184\":1,\"262\":1}}],[\"animal\",{\"1\":{\"152\":4}}],[\"area\",{\"1\":{\"151\":2,\"158\":7}}],[\"arr\",{\"1\":{\"141\":6}}],[\"args=0x0\",{\"1\":{\"117\":1}}],[\"ab都为1的位\",{\"1\":{\"134\":1}}],[\"abc\",{\"1\":{\"128\":2,\"129\":2}}],[\"abiinternal\",{\"1\":{\"117\":1}}],[\"a函数\",{\"1\":{\"117\":1}}],[\"ax\",{\"1\":{\"117\":14}}],[\"a的栈帧在上面\",{\"1\":{\"116\":1}}],[\"age\",{\"1\":{\"106\":4,\"135\":1,\"171\":4,\"173\":1,\"174\":1}}],[\"assertion\",{\"1\":{\"156\":1}}],[\"assertlockheld\",{\"1\":{\"82\":1}}],[\"as\",{\"1\":{\"156\":1}}],[\"ast\",{\"1\":{\"100\":2,\"101\":1}}],[\"ast变换\",{\"1\":{\"100\":1}}],[\"addq\",{\"1\":{\"117\":1}}],[\"add\",{\"1\":{\"75\":1,\"189\":4}}],[\"address\",{\"1\":{\"26\":1,\"43\":1}}],[\"aq\",{\"1\":{\"58\":1,\"63\":1}}],[\"application\",{\"0\":{\"281\":1}}],[\"apple\",{\"1\":{\"137\":1}}],[\"append\",{\"1\":{\"141\":4}}],[\"app\",{\"1\":{\"32\":1,\"35\":1}}],[\"api\",{\"1\":{\"23\":1}}],[\"a\",{\"1\":{\"26\":2,\"61\":1,\"63\":1,\"82\":1,\"109\":2,\"117\":6,\"128\":1,\"129\":4,\"130\":3,\"134\":1,\"148\":2,\"152\":1,\"154\":5,\"155\":1,\"156\":2,\"249\":1}}],[\"ai\",{\"0\":{\"12\":1}}],[\"afterdelay\",{\"1\":{\"3\":1}}],[\"一文带你快速入门\",{\"1\":{\"254\":1}}],[\"一文go起来\",{\"1\":{\"120\":1}}],[\"一次是\",{\"1\":{\"242\":1}}],[\"一次调度流程是怎么样的\",{\"0\":{\"81\":1},\"1\":{\"75\":1}}],[\"一样会被认为事务已经执行成功\",{\"1\":{\"241\":1}}],[\"一条记录的每一次更新操作产生的\",{\"1\":{\"218\":1}}],[\"一条记录时\",{\"1\":{\"217\":3}}],[\"一条查询语句执行的过程\",{\"1\":{\"210\":1}}],[\"一条\",{\"0\":{\"210\":1,\"211\":1}}],[\"一份全量数据给\",{\"1\":{\"194\":1}}],[\"一直向上传递\",{\"1\":{\"167\":1}}],[\"一直存在\",{\"1\":{\"26\":1}}],[\"一种循环方式\",{\"1\":{\"138\":1}}],[\"一种特殊\",{\"1\":{\"47\":1}}],[\"一些节点会简化为更基本的元素\",{\"1\":{\"101\":1}}],[\"一些节点基于类型信息被细化\",{\"1\":{\"100\":1}}],[\"一般来说\",{\"1\":{\"252\":1}}],[\"一般会依托第三方组件实现\",{\"1\":{\"246\":1}}],[\"一般为赋值表达式\",{\"1\":{\"139\":2}}],[\"一般用于声明全局变量\",{\"1\":{\"125\":1}}],[\"一般将编译器分为\",{\"1\":{\"97\":1}}],[\"一般编译器\",{\"0\":{\"97\":1}}],[\"一个事务的\",{\"1\":{\"236\":1}}],[\"一个页空间会被划分成许多部分\",{\"1\":{\"224\":1}}],[\"一个页的默认大小为\",{\"1\":{\"224\":1}}],[\"一个接口中包含了其他接口\",{\"1\":{\"159\":1}}],[\"一个简单的例子\",{\"1\":{\"154\":1}}],[\"一个类型可以实现多个接口\",{\"1\":{\"154\":1}}],[\"一个结构体只要实现了某个接口定义的所有方法\",{\"1\":{\"151\":1}}],[\"一个\",{\"1\":{\"86\":1}}],[\"一批是多少\",{\"1\":{\"82\":1}}],[\"一\",{\"0\":{\"3\":1,\"18\":1,\"75\":1,\"86\":1,\"113\":1,\"183\":1,\"210\":1}}]],\"version\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
