const{entries:V}=Object,{fromEntries:et}=Object,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":1088,\"nextId\":1088,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"3\",\"3\":\"3#一、vscode-设置\",\"4\":\"3#二、ui-类\",\"5\":\"3#_1-1-主题\",\"6\":\"3#_1-2-图标包\",\"7\":\"3#三、编程类\",\"8\":\"3#_2-1-代码视觉优化\",\"9\":\"3#_2-2-项目管理\",\"10\":\"3#_2-3-开发实用\",\"11\":\"3#_2-4-git可视化\",\"12\":\"3#四、ai-类\",\"13\":\"3#五、没啥用but安装了类\",\"14\":\"3@0\",\"15\":\"3@1\",\"16\":\"4\",\"17\":\"5\",\"18\":\"5@0\",\"19\":\"5@1\",\"20\":\"6\",\"21\":\"6@0\",\"22\":\"6@1\",\"23\":\"7\",\"24\":\"7@0\",\"25\":\"7@1\",\"26\":\"8\",\"27\":\"8@0\",\"28\":\"8@1\",\"29\":\"9\",\"30\":\"10\",\"31\":\"10@0\",\"32\":\"10@1\",\"33\":\"11\",\"34\":\"11@0\",\"35\":\"11@1\",\"36\":\"12\",\"37\":\"12@0\",\"38\":\"12@1\",\"39\":\"13\",\"40\":\"14\",\"41\":\"14#_1-二分红蓝染色法概述\",\"42\":\"14#_2-应用场景\",\"43\":\"14#_2-1-查找元素首次出现位置\",\"44\":\"14#_2-2-寻找循环排序数组的最小值\",\"45\":\"14#_3-实现方法\",\"46\":\"14#_3-1-闭区间简洁模板\",\"47\":\"14@0\",\"48\":\"14@1\",\"49\":\"15\",\"50\":\"15#_1-基本原理\",\"51\":\"15#_1-1-分类\",\"52\":\"15#_1-2-api操作\",\"53\":\"15#_2-实现方式\",\"54\":\"15#_2-1-链式-麻烦\",\"55\":\"15#_2-2-数组\",\"56\":\"15@0\",\"57\":\"15@1\",\"58\":\"16\",\"59\":\"16#_1-常见二叉树类型\",\"60\":\"16#_1-1-满二叉树\",\"61\":\"16#_1-2-完全二叉树\",\"62\":\"16#_1-3-二叉搜索树\",\"63\":\"16#_2-实现方式\",\"64\":\"16#_2-1-链式结构\",\"65\":\"16#_2-2-数组结构\",\"66\":\"16@0\",\"67\":\"16@1\",\"68\":\"17\",\"69\":\"17#_1-哈希算法基础\",\"70\":\"17#_1-1-定义\",\"71\":\"17#_2-哈希算法应用\",\"72\":\"17#_2-1-安全加密\",\"73\":\"17#常见的加密算法\",\"74\":\"17#鸽巢原理\",\"75\":\"17#_2-2-唯一标识\",\"76\":\"17#_2-3-数据检验\",\"77\":\"17#_2-4-分布式问题-负载均衡\",\"78\":\"17#_2-5-数据分片\",\"79\":\"17#如何统计-关键词-出现的次数\",\"80\":\"17#如何快速判断图片是否在图库中\",\"81\":\"17#_2-6-分布式存储\",\"82\":\"17#一致性哈希算法\",\"83\":\"17@0\",\"84\":\"17@1\",\"85\":\"18\",\"86\":\"18#_1-滑动窗口基本概念\",\"87\":\"18#_2-滑动窗口算法框架\",\"88\":\"18#_2-1-基本实现\",\"89\":\"18@0\",\"90\":\"18@1\",\"91\":\"19\",\"92\":\"20\",\"93\":\"20@0\",\"94\":\"20@1\",\"95\":\"21\",\"96\":\"21#一、docker-镜像、容器、仓库\",\"97\":\"21#_1-1-镜像\",\"98\":\"21#_1-2-容器\",\"99\":\"21#_1-3-仓库\",\"100\":\"21#二、docker-框架架构\",\"101\":\"21#_2-1-docker-客户端\",\"102\":\"21#_2-2-docker-服务端\",\"103\":\"21#_2-3-docker-重要组件\",\"104\":\"21#_2-4-docker-各组件之间的关系\",\"105\":\"21#三、docker-数据管理\",\"106\":\"21#_3-1-数据卷\",\"107\":\"21#创建一个数据卷\",\"108\":\"21#查看所有数据卷\",\"109\":\"21#查看指定数据卷的信息\",\"110\":\"21#启动一个挂载数据卷的容器\",\"111\":\"21#删除数据卷\",\"112\":\"21#_3-2-目录挂载\",\"113\":\"21#挂载一个主机目录作为数据卷\",\"114\":\"21#查看容器的数据卷具体信息\",\"115\":\"21#挂载一个本地主机文件作为数据卷\",\"116\":\"21#四、docker-网络模式\",\"117\":\"21#_4-1-端口映射-外部访问容器\",\"118\":\"21#_4-2-查看端口映射配置\",\"119\":\"21#_4-3-容器互联\",\"120\":\"21#_4-4-网络模式\",\"121\":\"21#基础理论\",\"122\":\"21#dokcer-支持的网络模式\",\"123\":\"21#bridge-模式\",\"124\":\"21#host-网络\",\"125\":\"21#container-网络模式\",\"126\":\"21#none-模式\",\"127\":\"21@0\",\"128\":\"21@1\",\"129\":\"22\",\"130\":\"23\",\"131\":\"23#docker-的常用命令\",\"132\":\"23#_1-帮助命令\",\"133\":\"23#_2-镜像命令\",\"134\":\"23#_2-1-docker-images\",\"135\":\"23#_2-2-docker-search-搜索镜像\",\"136\":\"23#_2-3-docker-pull-下载镜像\",\"137\":\"23#_2-4-docker-rmi-删除镜像\",\"138\":\"23#_3-容器命令\",\"139\":\"23#_3-1-新建容器并启动\",\"140\":\"23#_3-2-列出所有运行的容器\",\"141\":\"23#_3-3-退出容器\",\"142\":\"23#_3-4-删除容器\",\"143\":\"23#_3-5-启动和停止容器的操作\",\"144\":\"23#_4-常用其他命令\",\"145\":\"23#_4-1-后台启动容器\",\"146\":\"23#_4-2-查看日志\",\"147\":\"23#_4-3-查看容器中进程的信息\",\"148\":\"23#_4-4-查看镜像的元数据\",\"149\":\"23#_4-5-进入当前正在运行的容器\",\"150\":\"23#_4-6-从容器内拷贝文件到主机\",\"151\":\"23@0\",\"152\":\"23@1\",\"153\":\"24\",\"154\":\"25\",\"155\":\"26\",\"156\":\"26#一、整体架构\",\"157\":\"26#二、服务层的内部架构\",\"158\":\"26#三、producer\",\"159\":\"26#四、server\",\"160\":\"26#五、consumer\",\"161\":\"26#_1-消费形式\",\"162\":\"26#_2-消费是主动拉取\",\"163\":\"26#_3-offset-消息偏移\",\"164\":\"26#_4-消费者组\",\"165\":\"26#_5-消费者组的分配策略、再平衡策略\",\"166\":\"26@0\",\"167\":\"26@1\",\"168\":\"27\",\"169\":\"27#一、kafka-的副本机制\",\"170\":\"27#_1-kafka-副本的概念\",\"171\":\"27#_2-易混淆的概念\",\"172\":\"27#_2-1-分区和副本\",\"173\":\"27#_2-2-leader-节点和-follower-节点\",\"174\":\"27#_2-3-leader-副本和-follower-副本\",\"175\":\"27#_2-4-leader-副本只能存储在-leader-节点上\",\"176\":\"27#_3-kafka-的副本机制优势\",\"177\":\"27#_4-为用户的消息创建多副本\",\"178\":\"27#_5-为kafka内部的topic配置多副本\",\"179\":\"27#二、多副本的写入机制\",\"180\":\"27#_1-写入机制\",\"181\":\"27#_2-副本管理机制\",\"182\":\"27#_3-isr-的动态调整\",\"183\":\"27#_4-isr-为空-新-leader-如何选举\",\"184\":\"27#三、副本间的同步机制\",\"185\":\"27#四、副本间的同步机制-优化\",\"186\":\"27@0\",\"187\":\"27@1\",\"188\":\"28\",\"189\":\"29\",\"190\":\"30\",\"191\":\"30@0\",\"192\":\"30@1\",\"193\":\"31\",\"194\":\"31#_1-系统监控命令\",\"195\":\"31#_1-1-查看cpu占用率和进程pid\",\"196\":\"31#_1-2-查看进程的线程\",\"197\":\"31#_1-3-查看端口被哪个进程占用\",\"198\":\"31#_1-4-查看进程占用的端口\",\"199\":\"31#_1-5-查看tcp状态\",\"200\":\"31#_2-目录和文件操作命令\",\"201\":\"31#_2-1-目录操作\",\"202\":\"31#_2-2-文件操作\",\"203\":\"31#_3-系统管理命令\",\"204\":\"31#_3-1-关机重启命令\",\"205\":\"31#_3-2-用户登录、注销和切换\",\"206\":\"31#_4-用户和用户组管理\",\"207\":\"31#_4-1-用户管理\",\"208\":\"31#_4-2-用户组管理\",\"209\":\"31#_5-文件目录操作指令\",\"210\":\"31#_6-时间日期命令\",\"211\":\"31#_7-搜索查找命令\",\"212\":\"31@0\",\"213\":\"31@1\",\"214\":\"32\",\"215\":\"32@0\",\"216\":\"32@1\",\"217\":\"33\",\"218\":\"33@0\",\"219\":\"33@1\",\"220\":\"34\",\"221\":\"34@0\",\"222\":\"34@1\",\"223\":\"35\",\"224\":\"35@0\",\"225\":\"35@1\",\"226\":\"36\",\"227\":\"36@0\",\"228\":\"36@1\",\"229\":\"37\",\"230\":\"37@0\",\"231\":\"37@1\",\"232\":\"38\",\"233\":\"38@0\",\"234\":\"38@1\",\"235\":\"39\",\"236\":\"40\",\"237\":\"41\",\"238\":\"41@0\",\"239\":\"41@1\",\"240\":\"42\",\"241\":\"42@0\",\"242\":\"42@1\",\"243\":\"43\",\"244\":\"43@0\",\"245\":\"43@1\",\"246\":\"44\",\"247\":\"44@0\",\"248\":\"44@1\",\"249\":\"45\",\"250\":\"45@0\",\"251\":\"45@1\",\"252\":\"46\",\"253\":\"47\",\"254\":\"47#_1-channel简介\",\"255\":\"47#_2-channel的分类\",\"256\":\"47#_2-1-有缓冲channel\",\"257\":\"47#_2-2-无缓冲channel\",\"258\":\"47#_3-channel的数据结构\",\"259\":\"47#_3-1-sendq和recvq字段\",\"260\":\"47#waitq结构\",\"261\":\"47#_3-2-sudog结构\",\"262\":\"47#_4-channel操作\",\"263\":\"47#_4-1-channel初始化\",\"264\":\"47#_4-2-channel写入\",\"265\":\"47#_4-3-channel读取\",\"266\":\"47#_5-参考资料\",\"267\":\"47@0\",\"268\":\"47@1\",\"269\":\"48\",\"270\":\"48#_1-context简介\",\"271\":\"48#_2-context的底层实现\",\"272\":\"48#_2-1-接口定义\",\"273\":\"48#_2-2-实现类型\",\"274\":\"48#_2-3-提供的方法\",\"275\":\"48#_3-接口详解\",\"276\":\"48#_3-1-context接口\",\"277\":\"48#_3-2-canceler接口\",\"278\":\"48#_4-context实现类型\",\"279\":\"48#_4-1-emptyctx\",\"280\":\"48#_4-2-cancelctx\",\"281\":\"48#_4-3-timerctx\",\"282\":\"48#_4-4-valuectx\",\"283\":\"48#_5-参考资料\",\"284\":\"48@0\",\"285\":\"48@1\",\"286\":\"49\",\"287\":\"49#_1-defer底层数据结构\",\"288\":\"49#_2-defer执行过程\",\"289\":\"49#_3-defer内存分配方式\",\"290\":\"49#_3-1-defer结构体的分配\",\"291\":\"49#_3-2-堆上分配\",\"292\":\"49#_3-3-栈上分配\",\"293\":\"49#_4-defer的优化-开放编码\",\"294\":\"49#_5-defer函数的执行机制\",\"295\":\"49@0\",\"296\":\"49@1\",\"297\":\"50\",\"298\":\"50#_1-接口基础概念\",\"299\":\"50#_2-空接口-interface\",\"300\":\"50#_2-1-概念与用途\",\"301\":\"50#_2-2-空接口的结构\",\"302\":\"50#_2-3-type字段解析\",\"303\":\"50#_2-4-动态类型和动态值\",\"304\":\"50#_3-非空接口\",\"305\":\"50#_3-1-概念\",\"306\":\"50#_3-2-非空接口结构\",\"307\":\"50#_3-3-itab结构详解\",\"308\":\"50#_3-4-interfacetype结构\",\"309\":\"50#_4-接口赋值过程\",\"310\":\"50#_4-1-接口赋值示例\",\"311\":\"50#_4-2-赋值前后的结构变化\",\"312\":\"50#_5-itab缓存机制\",\"313\":\"50#_5-1-itab复用\",\"314\":\"50#_5-2-itabtable实现\",\"315\":\"50#_6-参考资料\",\"316\":\"50@0\",\"317\":\"50@1\",\"318\":\"51\",\"319\":\"51#_1-map概念基础\",\"320\":\"51#_1-1-哈希冲突\",\"321\":\"51#_1-2-解决哈希冲突的方法\",\"322\":\"51#拉链法\",\"323\":\"51#开放地址法\",\"324\":\"51#_2-map底层数据结构\",\"325\":\"51#_2-1-整体结构\",\"326\":\"51#_2-2-hmap结构体\",\"327\":\"51#_2-3-mapextra结构体\",\"328\":\"51#_2-4-bmap结构体\",\"329\":\"51#_3-map工作原理\",\"330\":\"51#_3-1-tophash机制\",\"331\":\"51#_3-2-map访问原理\",\"332\":\"51#_3-3-map赋值原理\",\"333\":\"51#_4-参考资料\",\"334\":\"51@0\",\"335\":\"51@1\",\"336\":\"52\",\"337\":\"52#_1-切片基本概念\",\"338\":\"52#_2-切片的数据结构\",\"339\":\"52#_3-切片操作\",\"340\":\"52#_3-1-切片初始化\",\"341\":\"52#_3-2-切片截取\",\"342\":\"52#_3-3-切片复制\",\"343\":\"52#_4-切片扩容机制\",\"344\":\"52#_4-1-扩容示例\",\"345\":\"52#_4-2-扩容规则\",\"346\":\"52#_5-切片完全复制\",\"347\":\"52@0\",\"348\":\"52@1\",\"349\":\"53\",\"350\":\"53#_1-字符串基本概念\",\"351\":\"53#_1-1-源代码定义\",\"352\":\"53#_1-2-字符串本质\",\"353\":\"53#_2-字符串数据结构\",\"354\":\"53#_2-1-stringstruct的使用\",\"355\":\"53#_3-字符串操作\",\"356\":\"53#_3-1-string和-byte的相互转换\",\"357\":\"53#_3-2-转换原理\",\"358\":\"53#byte切片转化为string\",\"359\":\"53#string转化为byte切片\",\"360\":\"53#转化是否一定发生内存拷贝\",\"361\":\"53#_4-字符串表示方式\",\"362\":\"53#_5-字符串拼接\",\"363\":\"53#_5-1-性能分析\",\"364\":\"53@0\",\"365\":\"53@1\",\"366\":\"54\",\"367\":\"54#一、demo-代码\",\"368\":\"54#二、输出结果\",\"369\":\"54#n-10\",\"370\":\"54#n-257\",\"371\":\"54#n-258\",\"372\":\"54#三、问题解答\",\"373\":\"54#为什么先打印它-一次调度流程是怎么样的\",\"374\":\"54#如果-n-设置为-257、258-打印输出的规律是什么\",\"375\":\"54@0\",\"376\":\"54@1\",\"377\":\"55\",\"378\":\"55#_1-go-的协程-goroutine\",\"379\":\"55#_2-旧-gm模型\",\"380\":\"55#_2-1-gm符号概念\",\"381\":\"55#_2-2-废弃的调度器模型-gm-是如何实现的\",\"382\":\"55#_3-新-gmp模型\",\"383\":\"55#_3-1-gmp符号定义\",\"384\":\"55#_3-2-gmp-模型\",\"385\":\"55@0\",\"386\":\"55@1\",\"387\":\"56\",\"388\":\"56#_1-编译器基础知识\",\"389\":\"56#_1-1-编译器工作流程\",\"390\":\"56#_2-go-编译命令解析\",\"391\":\"56#_2-1-常用命令\",\"392\":\"56#_2-2-编译标记说明\",\"393\":\"56#_3-go-编译器架构\",\"394\":\"56#_3-1-大致架构\",\"395\":\"56#_3-2-具体编译过程\",\"396\":\"56#_3-3-编译器命令行流程\",\"397\":\"56#_4-优化选项\",\"398\":\"56#_4-1-gcflags参数\",\"399\":\"56#_4-2-逃逸分析\",\"400\":\"56#_5-总结\",\"401\":\"56@0\",\"402\":\"56@1\",\"403\":\"57\",\"404\":\"57#_1-逃逸是什么\",\"405\":\"57#_1-1-发生逃逸的时机\",\"406\":\"57#_2-逃逸过程\",\"407\":\"57#_2-1-基本逃逸分析原则\",\"408\":\"57#_3-逃逸情景\",\"409\":\"57#_3-1-指针逃逸\",\"410\":\"57#示例代码\",\"411\":\"57#_3-2-栈空间不足逃逸\",\"412\":\"57#栈空间足够时-没有逃逸\",\"413\":\"57#容量增大后-发生逃逸\",\"414\":\"57#_3-3-动态类型逃逸\",\"415\":\"57#_3-4-变量大小不确定\",\"416\":\"57#_4-避免逃逸\",\"417\":\"57#_5-总结\",\"418\":\"57@0\",\"419\":\"58\",\"420\":\"58#_1-多返回值简介\",\"421\":\"58#_2-多返回值的实现\",\"422\":\"58#_2-1-基本实现原理\",\"423\":\"58#_2-2-汇编实现分析\",\"424\":\"58#_3-多返回值应用场景\",\"425\":\"58#_3-1-错误处理\",\"426\":\"58#_3-2-多值返回\",\"427\":\"58#_3-3-命名返回值\",\"428\":\"58#_4-多返回值的性能考量\",\"429\":\"58#_4-1-避免返回大型结构体\",\"430\":\"58#_5-总结\",\"431\":\"58@0\",\"432\":\"59\",\"433\":\"59#_1-1-标识符大小写\",\"434\":\"59#_1-2-文件结构\",\"435\":\"59#_2-1-基本规范\",\"436\":\"59#_2-2-单变量声明\",\"437\":\"59#_2-3-多变量声明\",\"438\":\"59#_2-4-注意\",\"439\":\"59#_2-5-变量的生命周期\",\"440\":\"59#_2-6-常量\",\"441\":\"59#_2-7-常量用作枚举\",\"442\":\"59#_2-8-iota\",\"443\":\"59#_3-1-逻辑运算符\",\"444\":\"59#_3-2-位运算符\",\"445\":\"59#_3-3-运算符优先级\",\"446\":\"59#_3-3-特殊运算符\",\"447\":\"59#_4-1-键值对初始化\",\"448\":\"59#_4-2-值列表初始化\",\"449\":\"59#_5-1-if\",\"450\":\"59#_5-2-switch-case\",\"451\":\"59#_6-1-理解-for-的结构\",\"452\":\"59#_6-2-for-range\",\"453\":\"59#_6-3-for-range-陷阱\",\"454\":\"59#_7-1-参数传递\",\"455\":\"59#_7-2-基本类型\",\"456\":\"59#_7-3-引用类型和指针\",\"457\":\"59#_7-4-结构体和数组\",\"458\":\"59#_7-5-可变参数\",\"459\":\"59#_8-1-go-普通指针特性\",\"460\":\"59#_8-2-unsafe-包中的-uintptr-和-pointer\",\"461\":\"59#_9-1-自定义方法的位置\",\"462\":\"59#_10-1-组合实现继承\",\"463\":\"59#_10-2-接口\",\"464\":\"59#_10-3-方法重写\",\"465\":\"59#_11-1-接口定义\",\"466\":\"59#_11-2-实现多个接口\",\"467\":\"59#_11-3-空接口\",\"468\":\"59#_11-4-断言陷阱\",\"469\":\"59#_11-5-断言原理\",\"470\":\"59#_11-6-接口作为函数参数\",\"471\":\"59#_11-7-接口嵌套\",\"472\":\"59#_12-1-error-接口类型\",\"473\":\"59#_13-1-需要思考的-3-个问题\",\"474\":\"59#_13-2-使用场景-1-资源的释放\",\"475\":\"59#_13-3-使用场景-2-配合-recover-处理-panic\",\"476\":\"59#_13-4-defer-的快照读\",\"477\":\"59#_14-1-return-的非原子性\",\"478\":\"59#_15-1-painc-捕获方式\",\"479\":\"59#_15-2-panic的传递\",\"480\":\"59@0\",\"481\":\"59@1\",\"482\":\"60\",\"483\":\"60#json-marshal-序列化-与json-unmarshal-反序列化-的基本用法。\",\"484\":\"60#结构体tag介绍\",\"485\":\"60#使用json-tag指定字段名\",\"486\":\"60#忽略某个字段\",\"487\":\"60#忽略空值字段\",\"488\":\"60#如果想要在最终的序列化结果中去掉空值字段-可以像下面这样定义结构体-使用omitempty\",\"489\":\"60#忽略嵌套结构体空值字段\",\"490\":\"60#不修改原结构体忽略空值字段\",\"491\":\"60#优雅处理字符串格式的数字\",\"492\":\"60@0\",\"493\":\"60@1\",\"494\":\"61\",\"495\":\"61#_1-基础字符串操作\",\"496\":\"61#_1-1-字符串比较\",\"497\":\"61#_1-2-字符串查找\",\"498\":\"61#_2-字符串转换与修改\",\"499\":\"61#_2-1-大小写转换\",\"500\":\"61#_2-2-字符串修剪\",\"501\":\"61#_3-字符串分割与连接\",\"502\":\"61#_3-1-字符串分割\",\"503\":\"61#_3-2-字符串连接\",\"504\":\"61#_4-高效的字符串构建\",\"505\":\"61#_4-1-strings-builder-的使用\",\"506\":\"61@0\",\"507\":\"61@1\",\"508\":\"62\",\"509\":\"62#一、map-与-sync-map\",\"510\":\"62#_1-模拟-map-的并发读写-fatal\",\"511\":\"62#_2-盲点-加上打印却可以避免-fatal\",\"512\":\"62#二、sync-map-简介\",\"513\":\"62#三、sync-map-的使用\",\"514\":\"62#_1-基本的-crud\",\"515\":\"62#_2-验证并发安全\",\"516\":\"62#四、sync-map-的结构\",\"517\":\"62#五、两个-map-的数据双向流转机制\",\"518\":\"62#_1-dirty-map-read-map\",\"519\":\"62#_2-read-map-dirty-map\",\"520\":\"62#_3-为什么要双向流转\",\"521\":\"62#六、enrty-的状态解读\",\"522\":\"62#_1-entry-的结构\",\"523\":\"62#_2-entry-的三个状态\",\"524\":\"62#_3-nil-状态\",\"525\":\"62#_4-expunged-状态\",\"526\":\"62#七、回顾-sync-map-的底层原理\",\"527\":\"62#八、sync-map-的不足\",\"528\":\"62#九、sync-map-源码走读\",\"529\":\"62#_1-load-读\",\"530\":\"62#_2-misslocked-missssss\",\"531\":\"62#_3-store-写\",\"532\":\"62#_4-range-读\",\"533\":\"62@0\",\"534\":\"62@1\",\"535\":\"63\",\"536\":\"63#_1-异常基础\",\"537\":\"63#_1-1-异常的概念\",\"538\":\"63#_1-2-异常的分类\",\"539\":\"63#_2-异常处理机制\",\"540\":\"63#_2-1-try-catch-finally\",\"541\":\"63#_2-2-try-with-resources\",\"542\":\"63#_2-3-throws声明\",\"543\":\"63#_2-4-throw关键字\",\"544\":\"63#_3-自定义异常\",\"545\":\"63#_3-1-创建自定义异常\",\"546\":\"63#_3-2-使用自定义异常\",\"547\":\"63@0\",\"548\":\"63@1\",\"549\":\"64\",\"550\":\"64#_1-反射基础\",\"551\":\"64#_1-1-反射的概念\",\"552\":\"64#_1-2-反射的优缺点\",\"553\":\"64#_2-获取class对象\",\"554\":\"64#_3-反射的主要api\",\"555\":\"64#_3-1-检查类信息\",\"556\":\"64#_3-2-构造函数操作\",\"557\":\"64#_3-3-字段操作\",\"558\":\"64#_3-4-方法操作\",\"559\":\"64#_4-动态代理\",\"560\":\"64@0\",\"561\":\"64@1\",\"562\":\"65\",\"563\":\"65#一、java语言特性\",\"564\":\"65#_1-1-java的特点\",\"565\":\"65#_1-2-jvm、jdk、jre\",\"566\":\"65#_1-3-字节码\",\"567\":\"65#二、基本语法\",\"568\":\"65#_2-1-关键字\",\"569\":\"65#_2-2-位移运算符\",\"570\":\"65#_2-3-final关键字的作用\",\"571\":\"65#_2-4-成员变量与局部变量\",\"572\":\"65#三、方法\",\"573\":\"65#_3-1-静态方法不能调用非静态成员\",\"574\":\"65@0\",\"575\":\"65@1\",\"576\":\"66\",\"577\":\"66#_1-filter概述\",\"578\":\"66#_1-1-什么是filter\",\"579\":\"66#_1-2-filter的作用\",\"580\":\"66#_2-filter快速入门\",\"581\":\"66#_2-1-环境准备\",\"582\":\"66#_2-2-创建第一个filter\",\"583\":\"66#_2-2-1-添加依赖\",\"584\":\"66#_2-2-2-创建filter类\",\"585\":\"66#_2-2-3-urlpattern配置详解\",\"586\":\"66#_2-2-3-1-使用-webfilter注解配置\",\"587\":\"66#_2-2-3-2-url模式匹配规则\",\"588\":\"66#_2-2-4-配置web-xml-可选\",\"589\":\"66#_3-filter生命周期\",\"590\":\"66#_3-1-初始化阶段\",\"591\":\"66#_3-2-过滤阶段\",\"592\":\"66#_3-3-销毁阶段\",\"593\":\"66#_4-filter链\",\"594\":\"66#_4-1-filter链的概念\",\"595\":\"66#_4-2-filter链的执行顺序\",\"596\":\"66#_4-3-filter链示例\",\"597\":\"66#_5-常见应用场景\",\"598\":\"66#_5-1-身份验证filter\",\"599\":\"66#_5-2-字符编码filter\",\"600\":\"66#_5-3-性能监控filter\",\"601\":\"66#_5-4-cors-filter\",\"602\":\"66#_6-最佳实践\",\"603\":\"66#_6-1-性能考虑\",\"604\":\"66#_6-2-安全考虑\",\"605\":\"66#_6-3-可维护性考虑\",\"606\":\"66#_7-常见问题与解决方案\",\"607\":\"66#_7-1-filter不生效\",\"608\":\"66#_7-2-filter执行顺序问题\",\"609\":\"66#_7-3-请求参数读取问题\",\"610\":\"66@0\",\"611\":\"66@1\",\"612\":\"67\",\"613\":\"67#_1-listener概述\",\"614\":\"67#_1-1-什么是listener\",\"615\":\"67#_1-2-listener的作用\",\"616\":\"67#_2-listener快速入门\",\"617\":\"67#_2-1-环境准备\",\"618\":\"67#_2-2-listener的分类\",\"619\":\"67#_2-2-1-servletcontext相关监听器\",\"620\":\"67#_2-2-2-httpsession相关监听器\",\"621\":\"67#_2-2-3-servletrequest相关监听器\",\"622\":\"67#_2-3-创建第一个listener\",\"623\":\"67#_2-3-1-添加依赖\",\"624\":\"67#_2-3-2-创建servletcontextlistener\",\"625\":\"67#_2-3-3-创建httpsessionlistener\",\"626\":\"67#_2-3-4-创建servletrequestlistener\",\"627\":\"67#_2-3-5-配置web-xml-可选\",\"628\":\"67#_3-listener生命周期\",\"629\":\"67#_3-1-servletcontextlistener生命周期\",\"630\":\"67#_3-2-httpsessionlistener生命周期\",\"631\":\"67#_3-3-servletrequestlistener生命周期\",\"632\":\"67#_4-属性监听器\",\"633\":\"67#_4-1-servletcontextattributelistener\",\"634\":\"67#_4-2-httpsessionattributelistener\",\"635\":\"67#_4-3-servletrequestattributelistener\",\"636\":\"67#_5-特殊监听器\",\"637\":\"67#_5-1-httpsessionbindinglistener\",\"638\":\"67#_5-2-httpsessionactivationlistener\",\"639\":\"67#_6-常见应用场景\",\"640\":\"67#_6-1-应用初始化和资源管理\",\"641\":\"67#_6-2-在线用户统计\",\"642\":\"67@0\",\"643\":\"67@1\",\"644\":\"68\",\"645\":\"68#_1-servlet概述\",\"646\":\"68#_1-1-什么是servlet\",\"647\":\"68#_1-2-servlet的作用\",\"648\":\"68#_2-servlet快速入门\",\"649\":\"68#_2-1-环境准备\",\"650\":\"68#_2-2-创建第一个servlet\",\"651\":\"68#_2-2-1-添加依赖\",\"652\":\"68#_2-2-2-创建servlet类\",\"653\":\"68#_2-2-3-urlpattern配置详解\",\"654\":\"68#_2-2-3-1-使用-webservlet注解配置\",\"655\":\"68#_2-2-3-2-url模式匹配规则\",\"656\":\"68#_2-2-3-3-匹配优先级\",\"657\":\"68#_2-2-3-4-注意事项\",\"658\":\"68#_2-2-4-配置web-xml-可选\",\"659\":\"68#_2-3-部署和访问\",\"660\":\"68#_3-servlet执行流程与生命周期\",\"661\":\"68#_3-1-执行流程\",\"662\":\"68#_3-2-生命周期\",\"663\":\"68#_4-servlet方法介绍与体系结构\",\"664\":\"68#_4-1-servlet接口\",\"665\":\"68#_4-2-genericservlet抽象类\",\"666\":\"68#_4-3-httpservlet抽象类\",\"667\":\"68#_4-4-servlet体系结构\",\"668\":\"68#_5-请求和响应对象\",\"669\":\"68#_5-1-httpservletrequest\",\"670\":\"68#_5-1-1-获取请求参数\",\"671\":\"68#_5-1-2-获取请求头\",\"672\":\"68#_5-1-3-获取请求路径\",\"673\":\"68#_5-1-4-获取会话和cookie\",\"674\":\"68#_5-2-httpservletresponse\",\"675\":\"68#_5-2-1-设置响应头\",\"676\":\"68#_5-2-2-设置响应状态\",\"677\":\"68#_5-2-3-输出响应内容\",\"678\":\"68#_5-2-4-重定向\",\"679\":\"68#_6-servlet高级特性\",\"680\":\"68#_6-1-请求转发与重定向\",\"681\":\"68#_6-1-1-请求转发\",\"682\":\"68#_6-1-2-重定向\",\"683\":\"68#_6-2-过滤器-filter\",\"684\":\"68#_6-3-监听器-listener\",\"685\":\"68#_7-常见问题与解决方案\",\"686\":\"68#_7-1-中文乱码问题\",\"687\":\"68#_7-1-1-请求乱码\",\"688\":\"68#_7-1-2-响应乱码\",\"689\":\"68#_7-2-线程安全问题\",\"690\":\"68#_7-3-会话管理问题\",\"691\":\"68#_7-3-1-会话超时\",\"692\":\"68#_7-3-2-会话安全\",\"693\":\"68#_7-4-文件上传问题\",\"694\":\"68@0\",\"695\":\"68@1\",\"696\":\"69\",\"697\":\"69#简介\",\"698\":\"69#核心特性\",\"699\":\"69#依赖注入示例\",\"700\":\"69#spring-boot\",\"701\":\"69@0\",\"702\":\"69@1\",\"703\":\"70\",\"704\":\"70#一、消费消息的语义\",\"705\":\"70#_1-常见的消费语义\",\"706\":\"70#_2-实现-精确一次-的困难\",\"707\":\"70#二、如何保证消息不丢失\",\"708\":\"70#_1-消息在什么环节可能发生丢失\",\"709\":\"70#_2-生产阶段\",\"710\":\"70#_3-存储阶段\",\"711\":\"70#_4-消费阶段\",\"712\":\"70#三、如何保证消息不重复\",\"713\":\"70#_1-发生重复消费的场景\",\"714\":\"70#_2-常见防重实现思路\",\"715\":\"70#_3-流量优化\",\"716\":\"70#四、如何保证消息准确消费一次\",\"717\":\"70#_1-简单实现\",\"718\":\"70#五、如何保证消息有序\",\"719\":\"70#_1-什么场景需要有序\",\"720\":\"70#_2-思路1-业务单分区\",\"721\":\"70#_3-思路2-业务内多分区\",\"722\":\"70#_3-1-子业务分区\",\"723\":\"70#_3-2-客户分区\",\"724\":\"70#_3-3-大小客户分区\",\"725\":\"70@0\",\"726\":\"70@1\",\"727\":\"71\",\"728\":\"71@0\",\"729\":\"71@1\",\"730\":\"72\",\"731\":\"72@0\",\"732\":\"72@1\",\"733\":\"73\",\"734\":\"73#_1-一条-select-语句的执行过程\",\"735\":\"73#_2-一条-update-语句的执行过程\",\"736\":\"73#_3-三种日志、mvcc、bufferpool-之间的相互配合\",\"737\":\"73#_3-1-三种日志的主要作用\",\"738\":\"73#_3-2-undolog-回滚日志\",\"739\":\"73#_3-2-1-为什么需要-undolog\",\"740\":\"73#_3-2-2-认识-undolog-机制\",\"741\":\"73#_3-2-3-undolog-如何记录和回滚\",\"742\":\"73#_3-2-4-undolog-日志的格式\",\"743\":\"73#_3-2-5-undolog-readview-实现-mvcc\",\"744\":\"73#_3-2-6-readview-机制\",\"745\":\"73#_3-2-7-undolog-如何刷盘的\",\"746\":\"73#_3-3-buffer-pool-缓冲池\",\"747\":\"73#_3-3-1-buffer-pool-的意义\",\"748\":\"73#_3-3-2-buffer-pool-缓存什么\",\"749\":\"73#_3-3-3-buffer-pool-刷盘策略\",\"750\":\"73#_3-4-redolog-重做日志\",\"751\":\"73#_3-4-1-为什么需要-redolog\",\"752\":\"73#_3-4-2-认识-redolog-机制\",\"753\":\"73#_3-4-3-redolog-与-undolog-的配合\",\"754\":\"73#_3-4-4-redolog与数据分开写入磁盘的必要性\",\"755\":\"73#_3-4-5-redolog-的刷盘策略\",\"756\":\"73#_3-4-6-redolog-buffer-的刷盘时机\",\"757\":\"73#_3-4-7-redolog-日志重写\",\"758\":\"73#_3-5-binlog-重做日志\",\"759\":\"73#_3-5-1-binlog-的作用\",\"760\":\"73#_3-5-2-binlog-刷盘策略\",\"761\":\"73#_3-5-3-binlog-主从同步模型\",\"762\":\"73#_3-6-两阶段提交\",\"763\":\"73#_3-6-1-两阶段提交的提出\",\"764\":\"73#_3-6-2-两阶段提交的概念\",\"765\":\"73#_3-6-3-两阶段提交的过程\",\"766\":\"73#_3-6-4-两阶段提交有什么问题\",\"767\":\"73#_3-6-5-对两阶段提交加强-加入组提交\",\"768\":\"73@0\",\"769\":\"73@1\",\"770\":\"74\",\"771\":\"74@0\",\"772\":\"74@1\",\"773\":\"75\",\"774\":\"75#_1-事务的acid特性\",\"775\":\"75#_1-1-innodb-如何保证-acid\",\"776\":\"75#_2-并行事务引发的问题\",\"777\":\"75#_2-1-脏读-dirty-read\",\"778\":\"75#_2-2-不可重复读-non-repeatable-read\",\"779\":\"75#_2-3-幻读-phantom-read\",\"780\":\"75#_2-3-1-幻读的另一种解释\",\"781\":\"75#_3-事务隔离级别\",\"782\":\"75#_3-1-四种隔离级别\",\"783\":\"75#_3-2-mysql-默认-rr-是否解决幻读\",\"784\":\"75#_3-3-四种隔离级别的实现方式\",\"785\":\"75#_3-4-开启事务命令的区别\",\"786\":\"75#_4-mvcc-机制\",\"787\":\"75#_4-1-read-view-的四个字段\",\"788\":\"75#_4-2-聚集索引记录中和事务有关的两个隐藏列\",\"789\":\"75#_4-3-事务访问数据的可见性判断\",\"790\":\"75#_5-可重复读与幻读问题\",\"791\":\"75#_5-1-可重复读的工作原理\",\"792\":\"75#_5-2-可重复读是否完全解决幻读\",\"793\":\"75#_5-2-1-幻读场景1\",\"794\":\"75#_5-2-2-幻读场景2\",\"795\":\"75#_5-3-解决幻读的方法\",\"796\":\"75#_6-读提交隔离级别的工作原理\",\"797\":\"75@0\",\"798\":\"75@1\",\"799\":\"76\",\"800\":\"76#_1-基础架构\",\"801\":\"76#_2-事务机制\",\"802\":\"76#_3-日志系统\",\"803\":\"76#_4-索引体系\",\"804\":\"76#_5-优化机制\",\"805\":\"76@0\",\"806\":\"76@1\",\"807\":\"77\",\"808\":\"77@0\",\"809\":\"77@1\",\"810\":\"78\",\"811\":\"78@0\",\"812\":\"78@1\",\"813\":\"79\",\"814\":\"79@0\",\"815\":\"79@1\",\"816\":\"80\",\"817\":\"80#_1-mysql架构概述\",\"818\":\"80@0\",\"819\":\"80@1\",\"820\":\"81\",\"821\":\"81@0\",\"822\":\"81@1\",\"823\":\"82\",\"824\":\"82@0\",\"825\":\"82@1\",\"826\":\"83\",\"827\":\"83@0\",\"828\":\"83@1\",\"829\":\"84\",\"830\":\"84@0\",\"831\":\"84@1\",\"832\":\"85\",\"833\":\"85#_1-mysql服务管理\",\"834\":\"85#_1-1-启动-停止mysql服务器\",\"835\":\"85#_1-1-1-linux系统\",\"836\":\"85#_1-1-2-windows系统\",\"837\":\"85#_2-用户管理\",\"838\":\"85#_2-1-创建用户\",\"839\":\"85#_2-2-删除用户\",\"840\":\"85#_2-3-重命名用户\",\"841\":\"85#_2-4-修改用户密码\",\"842\":\"85#_2-5-列出用户\",\"843\":\"85#_2-6-锁定用户账户\",\"844\":\"85#_2-7-解锁用户\",\"845\":\"85#_3-权限管理\",\"846\":\"85#_3-1-用户授权\",\"847\":\"85#_3-2-撤销用户权限\",\"848\":\"85#_3-3-显示用户权限\",\"849\":\"85#_4-角色管理\",\"850\":\"85#_4-1-角色概述\",\"851\":\"85#_4-2-角色操作语法\",\"852\":\"85#_4-3-角色操作示例\",\"853\":\"85#_5-数据库备份与恢复\",\"854\":\"85#_5-1-备份数据库\",\"855\":\"85#_5-2-恢复数据库\",\"856\":\"85@0\",\"857\":\"85@1\",\"858\":\"86\",\"859\":\"86@0\",\"860\":\"86@1\",\"861\":\"87\",\"862\":\"87@0\",\"863\":\"87@1\",\"864\":\"88\",\"865\":\"88@0\",\"866\":\"88@1\",\"867\":\"89\",\"868\":\"89@0\",\"869\":\"89@1\",\"870\":\"90\",\"871\":\"90@0\",\"872\":\"90@1\",\"873\":\"91\",\"874\":\"91@0\",\"875\":\"91@1\",\"876\":\"92\",\"877\":\"92@0\",\"878\":\"92@1\",\"879\":\"93\",\"880\":\"93@0\",\"881\":\"93@1\",\"882\":\"94\",\"883\":\"94@0\",\"884\":\"94@1\",\"885\":\"95\",\"886\":\"95@0\",\"887\":\"95@1\",\"888\":\"96\",\"889\":\"96@0\",\"890\":\"96@1\",\"891\":\"97\",\"892\":\"97@0\",\"893\":\"97@1\",\"894\":\"98\",\"895\":\"98@0\",\"896\":\"98@1\",\"897\":\"99\",\"898\":\"99@0\",\"899\":\"99@1\",\"900\":\"100\",\"901\":\"100@0\",\"902\":\"100@1\",\"903\":\"101\",\"904\":\"101@0\",\"905\":\"101@1\",\"906\":\"102\",\"907\":\"102@0\",\"908\":\"102@1\",\"909\":\"103\",\"910\":\"103#最简化版本\",\"911\":\"103#升级-1-支持过期时间\",\"912\":\"103#升级-2-超时-锁归属\",\"913\":\"103#升级-3-引入-lua\",\"914\":\"103#升级-3-满足-对称性-安全性-互斥性\",\"915\":\"103#升级-4-可靠性的保证\",\"916\":\"103#主从容灾\",\"917\":\"103#多机部署\",\"918\":\"103#redlock-可靠性探索\",\"919\":\"103@0\",\"920\":\"103@1\",\"921\":\"104\",\"922\":\"104@0\",\"923\":\"104@1\",\"924\":\"105\",\"925\":\"105@0\",\"926\":\"105@1\",\"927\":\"106\",\"928\":\"106@0\",\"929\":\"106@1\",\"930\":\"107\",\"931\":\"107@0\",\"932\":\"107@1\",\"933\":\"108\",\"934\":\"108@0\",\"935\":\"108@1\",\"936\":\"109\",\"937\":\"109#_1-1-存储形式为-redisobject\",\"938\":\"109#_1-2-redisobject-结构\",\"939\":\"109#_1-3-实际例子\",\"940\":\"109#_1-3-redisobject-代码\",\"941\":\"109#_2-1-dict-结构\",\"942\":\"109#_2-2-dict-代码\",\"943\":\"109#_3-1-redisdb-结构\",\"944\":\"109#_3-2-redisdb-代码\",\"945\":\"109#_4-1-redis-哈希冲突如何解决\",\"946\":\"109#_4-2-redisdb-的-expires\",\"947\":\"109@0\",\"948\":\"109@1\",\"949\":\"110\",\"950\":\"110@0\",\"951\":\"110@1\",\"952\":\"111\",\"953\":\"111@0\",\"954\":\"111@1\",\"955\":\"112\",\"956\":\"112#_1-zap特点\",\"957\":\"112#_2-基本使用\",\"958\":\"112@0\",\"959\":\"112@1\",\"960\":\"113\",\"961\":\"113#_1-kratos项目结构\",\"962\":\"113#_1-1-目录结构\",\"963\":\"113#_2-kratos项目初始化运行\",\"964\":\"113#_2-1-创建项目\",\"965\":\"113#_2-2-代码生成\",\"966\":\"113#_2-3-运行项目\",\"967\":\"113#_3-kratos-cli工具使用\",\"968\":\"113#_3-1-安装与升级\",\"969\":\"113#_3-2-proto文件操作\",\"970\":\"113#_3-3-常用命令\",\"971\":\"113@0\",\"972\":\"113@1\",\"973\":\"114\",\"974\":\"114#_1-gorm简介\",\"975\":\"114#_2-数据库连接\",\"976\":\"114#_2-1-建立数据库连接\",\"977\":\"114#_2-2-配置连接选项\",\"978\":\"114#_2-2-1-事务配置\",\"979\":\"114#_2-2-2-命名策略\",\"980\":\"114#_2-2-3-日志配置\",\"981\":\"114#_3-模型定义\",\"982\":\"114#_3-1-自动生成表结构\",\"983\":\"114#_3-2-字段属性配置\",\"984\":\"114#_4-单表操作\",\"985\":\"114#_4-1-添加记录\",\"986\":\"114#_4-2-批量插入\",\"987\":\"114#_4-3-查询单条记录\",\"988\":\"114#_4-3-1-基本查询函数\",\"989\":\"114#_4-3-2-主键查询\",\"990\":\"114#_4-3-3-条件查询\",\"991\":\"114#_4-3-4-结构体查询\",\"992\":\"114#_4-3-5-查询结果处理\",\"993\":\"114#_4-4-查询多条记录\",\"994\":\"114#_4-4-1-主键列表查询\",\"995\":\"114#_4-4-2-条件列表查询\",\"996\":\"114#_4-5-更新记录\",\"997\":\"114#_4-5-1-save保存所有字段\",\"998\":\"114#_4-5-2-更新指定字段\",\"999\":\"114#_4-5-3-批量删除\",\"1000\":\"114#_5-高级查询\",\"1001\":\"114#_5-1-where条件查询\",\"1002\":\"114#_5-1-1-结构体查询\",\"1003\":\"114#_5-1-2-map查询\",\"1004\":\"114#_5-1-3-not条件\",\"1005\":\"114#_5-1-4-or条件\",\"1006\":\"114#_5-2-select选择字段\",\"1007\":\"114#_5-3-排序\",\"1008\":\"114#_5-4-分页查询\",\"1009\":\"114#_5-5-去重查询\",\"1010\":\"114#_5-6-分组查询\",\"1011\":\"114#_5-7-原生sql执行\",\"1012\":\"114#_5-8-子查询\",\"1013\":\"114#_6-事务管理\",\"1014\":\"114#_6-1-自动事务\",\"1015\":\"114#_6-2-手动事务\",\"1016\":\"114@0\",\"1017\":\"114@1\",\"1018\":\"115\",\"1019\":\"115#_1-内置的-http-库\",\"1020\":\"115#_1-1-不方便的地方\",\"1021\":\"115#_1-2-启动一个-web-服务端\",\"1022\":\"115#_2-gin-的初始化\",\"1023\":\"115#_2-1-安装-gin-库\",\"1024\":\"115#_2-2-hello-world\",\"1025\":\"115#_2-3-知识扩展\",\"1026\":\"115#内网运行\",\"1027\":\"115#关闭日志的debug输出\",\"1028\":\"115#_3-gin-响应\",\"1029\":\"115#_3-1-json-响应\",\"1030\":\"115#_3-2-封装业务状态码\",\"1031\":\"115#_3-3-html-响应\",\"1032\":\"115#_3-4-响应文件\",\"1033\":\"115#_3-5-配置静态文件\",\"1034\":\"115#_4-获取请求参数\",\"1035\":\"115#_4-1-查询参数\",\"1036\":\"115#_4-2-动态参数\",\"1037\":\"115#_4-3-表单参数\",\"1038\":\"115#_5-bind-绑定器\",\"1039\":\"115#_5-1-查询参数\",\"1040\":\"115#_5-2-路径参数\",\"1041\":\"115#_5-3-表单参数\",\"1042\":\"115#_5-4-json-参数\",\"1043\":\"115#_5-5-header-参数\",\"1044\":\"115@0\",\"1045\":\"115@1\",\"1046\":\"116\",\"1047\":\"116#_1-密码安全概述\",\"1048\":\"116#_1-1-攻击密码的主要方法\",\"1049\":\"116#_1-2-彩虹表\",\"1050\":\"116#_2-密码加密策略\",\"1051\":\"116#_2-1-加密与加盐\",\"1052\":\"116#_2-2-加盐的安全性\",\"1053\":\"116#_2-3-暴力破解\",\"1054\":\"116#_2-4-传统加密算法的局限\",\"1055\":\"116#_3-bcrypt加密原理\",\"1056\":\"116#_3-1-bcrypt哈希字符串的组成\",\"1057\":\"116#_4-go语言中使用bcrypt\",\"1058\":\"116#_4-1-bcrypt包介绍\",\"1059\":\"116#_4-2-使用示例\",\"1060\":\"116@0\",\"1061\":\"116@1\",\"1062\":\"117\",\"1063\":\"118\",\"1064\":\"119\",\"1065\":\"120\",\"1066\":\"121\",\"1067\":\"122\",\"1068\":\"123\",\"1069\":\"124\",\"1070\":\"125\",\"1071\":\"126\",\"1072\":\"127\",\"1073\":\"128\",\"1074\":\"129\",\"1075\":\"130\",\"1076\":\"131\",\"1077\":\"132\",\"1078\":\"133\",\"1079\":\"134\",\"1080\":\"135\",\"1081\":\"136\",\"1082\":\"137\",\"1083\":\"138\",\"1084\":\"139\",\"1085\":\"140\",\"1086\":\"141\",\"1087\":\"142\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,1],\"1\":[2],\"2\":[3,2],\"3\":[3,30],\"4\":[3],\"5\":[2,11],\"6\":[3,7],\"7\":[2],\"8\":[3,7],\"9\":[2,7],\"10\":[3,15],\"11\":[3,7],\"12\":[3,12],\"13\":[2,7],\"14\":[null,null,1],\"15\":[null,null,3],\"16\":[1],\"17\":[1,2],\"18\":[null,null,2],\"19\":[null,null,2],\"20\":[1,141],\"21\":[null,null,3],\"22\":[null,null,4],\"23\":[1,294],\"24\":[null,null,3],\"25\":[null,null,4],\"26\":[1,2],\"27\":[null,null,3],\"28\":[null,null,5],\"29\":[1,2],\"30\":[1,103],\"31\":[null,null,2],\"32\":[null,null,4],\"33\":[1,633],\"34\":[null,null,2],\"35\":[null,null,4],\"36\":[1,109],\"37\":[null,null,2],\"38\":[null,null,4],\"39\":[1,2],\"40\":[1,2],\"41\":[2,4],\"42\":[2],\"43\":[3,4],\"44\":[2,2],\"45\":[2],\"46\":[3,25],\"47\":[null,null,2],\"48\":[null,null,3],\"49\":[1,3],\"50\":[2,4],\"51\":[2,10],\"52\":[3,21],\"53\":[2],\"54\":[5,3],\"55\":[2,3],\"56\":[null,null,2],\"57\":[null,null,3],\"58\":[1,3],\"59\":[2],\"60\":[2,2],\"61\":[3,3],\"62\":[3,4],\"63\":[2],\"64\":[3,4],\"65\":[2,3],\"66\":[null,null,2],\"67\":[null,null,3],\"68\":[1,3],\"69\":[2],\"70\":[2,4],\"71\":[2],\"72\":[3,5],\"73\":[1,8],\"74\":[1,8],\"75\":[2,29],\"76\":[3,10],\"77\":[4,15],\"78\":[3],\"79\":[4,36],\"80\":[2,3],\"81\":[3,11],\"82\":[1,3],\"83\":[null,null,2],\"84\":[null,null,3],\"85\":[1,2],\"86\":[2,5],\"87\":[2],\"88\":[3,46],\"89\":[null,null,2],\"90\":[null,null,3],\"91\":[1,2],\"92\":[1,49],\"93\":[null,null,2],\"94\":[null,null,4],\"95\":[1,2],\"96\":[5],\"97\":[1,6],\"98\":[2,19],\"99\":[2,9],\"100\":[3,9],\"101\":[4,9],\"102\":[3,14],\"103\":[4,13],\"104\":[2,64],\"105\":[3,7],\"106\":[3,14],\"107\":[1,4],\"108\":[1,3],\"109\":[1,5],\"110\":[1,31],\"111\":[1,5],\"112\":[3],\"113\":[1,55],\"114\":[1,3],\"115\":[1,3],\"116\":[3],\"117\":[4,31],\"118\":[3,6],\"119\":[3,26],\"120\":[2],\"121\":[1,70],\"122\":[2,59],\"123\":[2,61],\"124\":[2,25],\"125\":[2,38],\"126\":[2,21],\"127\":[null,null,3],\"128\":[null,null,4],\"129\":[1,2],\"130\":[1,3],\"131\":[2],\"132\":[2,9],\"133\":[2],\"134\":[4,13],\"135\":[5,3],\"136\":[6,11],\"137\":[6,14],\"138\":[2,8],\"139\":[3,26],\"140\":[3,13],\"141\":[2,15],\"142\":[3,14],\"143\":[3,10],\"144\":[2],\"145\":[3,22],\"146\":[3,8],\"147\":[3,27],\"148\":[2,3],\"149\":[3,15],\"150\":[3,5],\"151\":[null,null,2],\"152\":[null,null,4],\"153\":[1,2],\"154\":[1,2],\"155\":[2,4],\"156\":[2,30],\"157\":[2,32],\"158\":[2,2],\"159\":[2,2],\"160\":[2,3],\"161\":[2,9],\"162\":[2,10],\"163\":[3,12],\"164\":[2,20],\"165\":[3,52],\"166\":[null,null,1],\"167\":[null,null,3],\"168\":[2,4],\"169\":[3,4],\"170\":[3,22],\"171\":[2],\"172\":[3,16],\"173\":[5,8],\"174\":[6,10],\"175\":[5,10],\"176\":[3,28],\"177\":[2,42],\"178\":[2,2],\"179\":[2],\"180\":[2,21],\"181\":[2,43],\"182\":[3,9],\"183\":[6,15],\"184\":[2,2],\"185\":[3,2],\"186\":[null,null,1],\"187\":[null,null,3],\"188\":[1,2],\"189\":[1,2],\"190\":[2,132],\"191\":[null,null,2],\"192\":[null,null,4],\"193\":[1,3],\"194\":[2],\"195\":[2,4],\"196\":[3,6],\"197\":[3,7],\"198\":[3,5],\"199\":[3,7],\"200\":[2],\"201\":[3,29],\"202\":[2,22],\"203\":[2],\"204\":[3,17],\"205\":[4,6],\"206\":[2],\"207\":[3,18],\"208\":[3,12],\"209\":[2,45],\"210\":[2,14],\"211\":[2,29],\"212\":[null,null,2],\"213\":[null,null,4],\"214\":[1,19],\"215\":[null,null,2],\"216\":[null,null,4],\"217\":[1,406],\"218\":[null,null,2],\"219\":[null,null,4],\"220\":[1,42],\"221\":[null,null,2],\"222\":[null,null,4],\"223\":[1,308],\"224\":[null,null,2],\"225\":[null,null,4],\"226\":[1,519],\"227\":[null,null,2],\"228\":[null,null,5],\"229\":[2,369],\"230\":[null,null,2],\"231\":[null,null,4],\"232\":[1,2],\"233\":[null,null,2],\"234\":[null,null,4],\"235\":[1,2],\"236\":[1,2],\"237\":[1,221],\"238\":[null,null,2],\"239\":[null,null,4],\"240\":[1,154],\"241\":[null,null,2],\"242\":[null,null,4],\"243\":[1,146],\"244\":[null,null,2],\"245\":[null,null,4],\"246\":[1,72],\"247\":[null,null,2],\"248\":[null,null,4],\"249\":[1,1229],\"250\":[null,null,2],\"251\":[null,null,5],\"252\":[1,2],\"253\":[1,2],\"254\":[2,12],\"255\":[2,2],\"256\":[3,7],\"257\":[2,6],\"258\":[2,8],\"259\":[3,9],\"260\":[1,1],\"261\":[3,6],\"262\":[2],\"263\":[3,23],\"264\":[3,30],\"265\":[3,111],\"266\":[2,3],\"267\":[null,null,3],\"268\":[null,null,4],\"269\":[1,2],\"270\":[2,4],\"271\":[2,4],\"272\":[3,2],\"273\":[2,2],\"274\":[3,2],\"275\":[2],\"276\":[3,2],\"277\":[3,2],\"278\":[2],\"279\":[3,3],\"280\":[3,2],\"281\":[3,2],\"282\":[2,2],\"283\":[2,3],\"284\":[null,null,2],\"285\":[null,null,4],\"286\":[1,2],\"287\":[2,2],\"288\":[2,2],\"289\":[2],\"290\":[3,2],\"291\":[3,3],\"292\":[2,4],\"293\":[3,2],\"294\":[2,2],\"295\":[null,null,2],\"296\":[null,null,4],\"297\":[1,2],\"298\":[2,4],\"299\":[4],\"300\":[3,3],\"301\":[2,2],\"302\":[3,13],\"303\":[3,2],\"304\":[2],\"305\":[3,2],\"306\":[3,2],\"307\":[2,36],\"308\":[3,2],\"309\":[2],\"310\":[3,2],\"311\":[3,7],\"312\":[2],\"313\":[3,3],\"314\":[3,2],\"315\":[2,4],\"316\":[null,null,2],\"317\":[null,null,4],\"318\":[1,2],\"319\":[2,5],\"320\":[2,2],\"321\":[3],\"322\":[1,2],\"323\":[1,2],\"324\":[2],\"325\":[3,10],\"326\":[2,3],\"327\":[3,3],\"328\":[3,5],\"329\":[2],\"330\":[3,18],\"331\":[3,3],\"332\":[2,3],\"333\":[2,8],\"334\":[null,null,2],\"335\":[null,null,4],\"336\":[1,4],\"337\":[2,7],\"338\":[2,7],\"339\":[2],\"340\":[3,4],\"341\":[3,3],\"342\":[2,4],\"343\":[2],\"344\":[3,17],\"345\":[3,2],\"346\":[2,7],\"347\":[null,null,2],\"348\":[null,null,4],\"349\":[1,2],\"350\":[2],\"351\":[2,13],\"352\":[3,5],\"353\":[2,11],\"354\":[3,4],\"355\":[2],\"356\":[4,9],\"357\":[3,4],\"358\":[1,1],\"359\":[1,1],\"360\":[1,4],\"361\":[2,3],\"362\":[2,4],\"363\":[3,2],\"364\":[null,null,2],\"365\":[null,null,4],\"366\":[2],\"367\":[3,46],\"368\":[2,2],\"369\":[3,11],\"370\":[3,257],\"371\":[3,259],\"372\":[2],\"373\":[3,51],\"374\":[6,158],\"375\":[null,null,1],\"376\":[null,null,2],\"377\":[1,2],\"378\":[4,31],\"379\":[3],\"380\":[3,1],\"381\":[4,41],\"382\":[3],\"383\":[3,1],\"384\":[4,9],\"385\":[null,null,2],\"386\":[null,null,3],\"387\":[1,2],\"388\":[2,3],\"389\":[2,6],\"390\":[3,3],\"391\":[3,26],\"392\":[2,15],\"393\":[3],\"394\":[3,13],\"395\":[3,13],\"396\":[2,10],\"397\":[2,3],\"398\":[3,12],\"399\":[3,8],\"400\":[2,9],\"401\":[null,null,2],\"402\":[null,null,3],\"403\":[1,2],\"404\":[2,1],\"405\":[2,26],\"406\":[2,5],\"407\":[3,10],\"408\":[2,12],\"409\":[3,14],\"410\":[1,27],\"411\":[3],\"412\":[2,13],\"413\":[2,13],\"414\":[2,4],\"415\":[3,22],\"416\":[2,5],\"417\":[2,6],\"418\":[null,null,1],\"419\":[1,2],\"420\":[2,3],\"421\":[2],\"422\":[3,4],\"423\":[2,31],\"424\":[2],\"425\":[3,30],\"426\":[3,17],\"427\":[2,22],\"428\":[2,7],\"429\":[3,9],\"430\":[2,6],\"431\":[null,null,2],\"432\":[1,9],\"433\":[2,13],\"434\":[3,6],\"435\":[3,6],\"436\":[2,21],\"437\":[3,11],\"438\":[3,12],\"439\":[3,5],\"440\":[3,23],\"441\":[3,40],\"442\":[3,47],\"443\":[3,1],\"444\":[3,7],\"445\":[2,4],\"446\":[2,12],\"447\":[3,20],\"448\":[3,16],\"449\":[3,9],\"450\":[4,8],\"451\":[5,14],\"452\":[4,34],\"453\":[5,57],\"454\":[3,9],\"455\":[3,10],\"456\":[3,19],\"457\":[3,6],\"458\":[3,50],\"459\":[4,22],\"460\":[7,59],\"461\":[3,13],\"462\":[3,47],\"463\":[3,18],\"464\":[3,23],\"465\":[3,11],\"466\":[3,36],\"467\":[3,15],\"468\":[3,25],\"469\":[3,46],\"470\":[3,41],\"471\":[3,30],\"472\":[4,23],\"473\":[5,8],\"474\":[5,8],\"475\":[8,5],\"476\":[4,24],\"477\":[4,31],\"478\":[4,22],\"479\":[3,63],\"480\":[null,null,1],\"481\":[null,null,3],\"482\":[1,1],\"483\":[8,37],\"484\":[1,17],\"485\":[2,19],\"486\":[1,21],\"487\":[1,47],\"488\":[3,32],\"489\":[1,51],\"490\":[1,41],\"491\":[1,42],\"492\":[null,null,1],\"493\":[null,null,1],\"494\":[1,4],\"495\":[2],\"496\":[2,28],\"497\":[3,33],\"498\":[2],\"499\":[3,17],\"500\":[2,22],\"501\":[2],\"502\":[3,26],\"503\":[3,22],\"504\":[2],\"505\":[5,37],\"506\":[null,null,1],\"507\":[null,null,3],\"508\":[1,2],\"509\":[5,16],\"510\":[5,28],\"511\":[4,43],\"512\":[4,64],\"513\":[4],\"514\":[3,34],\"515\":[2,63],\"516\":[4,66],\"517\":[4],\"518\":[5,21],\"519\":[5,23],\"520\":[2,39],\"521\":[3,6],\"522\":[3,16],\"523\":[3,21],\"524\":[3,54],\"525\":[3,42],\"526\":[5,21],\"527\":[4,26],\"528\":[4],\"529\":[3,77],\"530\":[3,35],\"531\":[3,106],\"532\":[3,41],\"533\":[null,null,1],\"534\":[null,null,1],\"535\":[1,4],\"536\":[2,3],\"537\":[2,7],\"538\":[3,29],\"539\":[2],\"540\":[5,39],\"541\":[4,32],\"542\":[3,36],\"543\":[3,34],\"544\":[2],\"545\":[3,15],\"546\":[3,32],\"547\":[null,null,1],\"548\":[null,null,2],\"549\":[1,4],\"550\":[2,8],\"551\":[2,6],\"552\":[3,11],\"553\":[2,31],\"554\":[2],\"555\":[3,35],\"556\":[3,44],\"557\":[2,53],\"558\":[3,59],\"559\":[2,66],\"560\":[null,null,1],\"561\":[null,null,2],\"562\":[1],\"563\":[2],\"564\":[2,14],\"565\":[5,9],\"566\":[3,10],\"567\":[2],\"568\":[3,46],\"569\":[2,6],\"570\":[3,5],\"571\":[3,31],\"572\":[2],\"573\":[3,10],\"574\":[null,null,1],\"575\":[null,null,2],\"576\":[1,14],\"577\":[2],\"578\":[2,25],\"579\":[3,24],\"580\":[2],\"581\":[3,13],\"582\":[2],\"583\":[3,26],\"584\":[2,68],\"585\":[3,6],\"586\":[5,17],\"587\":[3,21],\"588\":[6,33],\"589\":[2,3],\"590\":[3,32],\"591\":[3,40],\"592\":[2,15],\"593\":[2],\"594\":[3,7],\"595\":[3,17],\"596\":[3,42],\"597\":[2],\"598\":[3,60],\"599\":[3,43],\"600\":[3,62],\"601\":[4,43],\"602\":[2],\"603\":[3,9],\"604\":[3,10],\"605\":[3,10],\"606\":[2],\"607\":[3,10],\"608\":[3,13],\"609\":[3,9],\"610\":[null,null,1],\"611\":[null,null,3],\"612\":[1,19],\"613\":[2],\"614\":[2,22],\"615\":[3,25],\"616\":[2],\"617\":[3,13],\"618\":[2,4],\"619\":[3,5],\"620\":[2,9],\"621\":[3,5],\"622\":[3],\"623\":[4,26],\"624\":[3,53],\"625\":[3,65],\"626\":[4,64],\"627\":[7,20],\"628\":[2],\"629\":[3,13],\"630\":[3,11],\"631\":[2,11],\"632\":[2],\"633\":[3,43],\"634\":[3,47],\"635\":[3,57],\"636\":[2],\"637\":[3,69],\"638\":[3,74],\"639\":[2],\"640\":[3,66],\"641\":[3,72],\"642\":[null,null,1],\"643\":[null,null,3],\"644\":[1,20],\"645\":[2],\"646\":[2,25],\"647\":[3,7],\"648\":[2],\"649\":[3,13],\"650\":[2],\"651\":[3,26],\"652\":[2,63],\"653\":[3,5],\"654\":[5,14],\"655\":[3,24],\"656\":[3,22],\"657\":[4,9],\"658\":[6,49],\"659\":[3,11],\"660\":[2],\"661\":[3,20],\"662\":[3,50],\"663\":[2],\"664\":[3,18],\"665\":[3,8],\"666\":[3,22],\"667\":[2,6],\"668\":[2],\"669\":[3,3],\"670\":[3,21],\"671\":[4,13],\"672\":[4,18],\"673\":[4,11],\"674\":[3,3],\"675\":[4,14],\"676\":[3,14],\"677\":[4,15],\"678\":[4,6],\"679\":[2],\"680\":[3],\"681\":[3,16],\"682\":[4,22],\"683\":[5,35],\"684\":[5,20],\"685\":[2],\"686\":[3],\"687\":[3,18],\"688\":[4,10],\"689\":[3,35],\"690\":[3],\"691\":[4,18],\"692\":[4,21],\"693\":[3,68],\"694\":[null,null,1],\"695\":[null,null,3],\"696\":[1],\"697\":[1,4],\"698\":[1,7],\"699\":[1,26],\"700\":[2,17],\"701\":[null,null,2],\"702\":[null,null,3],\"703\":[2,5],\"704\":[2],\"705\":[2,25],\"706\":[4,25],\"707\":[2],\"708\":[2,14],\"709\":[2,22],\"710\":[2,63],\"711\":[2,12],\"712\":[2,8],\"713\":[2,11],\"714\":[2,34],\"715\":[2,11],\"716\":[2],\"717\":[2,6],\"718\":[2],\"719\":[2,26],\"720\":[3,15],\"721\":[3,2],\"722\":[3,18],\"723\":[3,81],\"724\":[2,2],\"725\":[null,null,1],\"726\":[null,null,3],\"727\":[1,61],\"728\":[null,null,2],\"729\":[null,null,4],\"730\":[1,103],\"731\":[null,null,2],\"732\":[null,null,4],\"733\":[1,5],\"734\":[4,73],\"735\":[4,23],\"736\":[5],\"737\":[3,43],\"738\":[4],\"739\":[5,29],\"740\":[5,10],\"741\":[4,25],\"742\":[5,18],\"743\":[8,59],\"744\":[5,55],\"745\":[5,19],\"746\":[4],\"747\":[5,46],\"748\":[5,85],\"749\":[4,6],\"750\":[4],\"751\":[5,65],\"752\":[6,34],\"753\":[6,55],\"754\":[3,19],\"755\":[5,34],\"756\":[7,51],\"757\":[5,39],\"758\":[4],\"759\":[5,33],\"760\":[5,83],\"761\":[4,45],\"762\":[3],\"763\":[4,62],\"764\":[4,46],\"765\":[3,72],\"766\":[4,28],\"767\":[5,37],\"768\":[null,null,2],\"769\":[null,null,6],\"770\":[1,923],\"771\":[null,null,2],\"772\":[null,null,4],\"773\":[1,5],\"774\":[2,28],\"775\":[4,12],\"776\":[2,6],\"777\":[6,5],\"778\":[6,5],\"779\":[6,5],\"780\":[4,21],\"781\":[2],\"782\":[3,13],\"783\":[6,32],\"784\":[2,22],\"785\":[3,19],\"786\":[3,6],\"787\":[5,15],\"788\":[3,18],\"789\":[3,39],\"790\":[2],\"791\":[3,5],\"792\":[3,4],\"793\":[4,50],\"794\":[3,32],\"795\":[3,11],\"796\":[2,5],\"797\":[null,null,2],\"798\":[null,null,4],\"799\":[1,2],\"800\":[2,9],\"801\":[2,6],\"802\":[2,8],\"803\":[2,5],\"804\":[2,7],\"805\":[null,null,2],\"806\":[null,null,2],\"807\":[1,422],\"808\":[null,null,2],\"809\":[null,null,4],\"810\":[1,1563],\"811\":[null,null,2],\"812\":[null,null,6],\"813\":[1,916],\"814\":[null,null,2],\"815\":[null,null,4],\"816\":[1,2],\"817\":[2,662],\"818\":[null,null,2],\"819\":[null,null,3],\"820\":[1,1181],\"821\":[null,null,2],\"822\":[null,null,4],\"823\":[2,27],\"824\":[null,null,2],\"825\":[null,null,4],\"826\":[1,49],\"827\":[null,null,2],\"828\":[null,null,4],\"829\":[2,68],\"830\":[null,null,2],\"831\":[null,null,3],\"832\":[1,4],\"833\":[2],\"834\":[3],\"835\":[2,19],\"836\":[3,43],\"837\":[2],\"838\":[3,43],\"839\":[2,9],\"840\":[3,38],\"841\":[3,26],\"842\":[3,18],\"843\":[3,30],\"844\":[3,7],\"845\":[2],\"846\":[3,44],\"847\":[3,18],\"848\":[2,7],\"849\":[2],\"850\":[3,16],\"851\":[3,11],\"852\":[3,5],\"853\":[2],\"854\":[3,55],\"855\":[3,14],\"856\":[null,null,2],\"857\":[null,null,4],\"858\":[1,2],\"859\":[null,null,2],\"860\":[null,null,3],\"861\":[2,1],\"862\":[null,null,2],\"863\":[null,null,4],\"864\":[1,167],\"865\":[null,null,2],\"866\":[null,null,4],\"867\":[2,112],\"868\":[null,null,2],\"869\":[null,null,4],\"870\":[2,67],\"871\":[null,null,2],\"872\":[null,null,4],\"873\":[2,224],\"874\":[null,null,2],\"875\":[null,null,4],\"876\":[2,62],\"877\":[null,null,2],\"878\":[null,null,4],\"879\":[1,291],\"880\":[null,null,2],\"881\":[null,null,4],\"882\":[1,73],\"883\":[null,null,2],\"884\":[null,null,4],\"885\":[1,108],\"886\":[null,null,2],\"887\":[null,null,4],\"888\":[1,93],\"889\":[null,null,2],\"890\":[null,null,4],\"891\":[1,43],\"892\":[null,null,2],\"893\":[null,null,4],\"894\":[1,49],\"895\":[null,null,2],\"896\":[null,null,2],\"897\":[1,105],\"898\":[null,null,2],\"899\":[null,null,4],\"900\":[1,73],\"901\":[null,null,2],\"902\":[null,null,4],\"903\":[2,86],\"904\":[null,null,2],\"905\":[null,null,4],\"906\":[2,126],\"907\":[null,null,2],\"908\":[null,null,4],\"909\":[1,27],\"910\":[1,20],\"911\":[3,29],\"912\":[5,41],\"913\":[4,29],\"914\":[6],\"915\":[3,10],\"916\":[1,13],\"917\":[1,48],\"918\":[2,64],\"919\":[null,null,2],\"920\":[null,null,4],\"921\":[1,274],\"922\":[null,null,2],\"923\":[null,null,4],\"924\":[1,117],\"925\":[null,null,2],\"926\":[null,null,4],\"927\":[1,222],\"928\":[null,null,2],\"929\":[null,null,4],\"930\":[1,446],\"931\":[null,null,2],\"932\":[null,null,4],\"933\":[1,12],\"934\":[null,null,2],\"935\":[null,null,4],\"936\":[1,11],\"937\":[3,20],\"938\":[4,13],\"939\":[3,17],\"940\":[4,53],\"941\":[4,17],\"942\":[3,39],\"943\":[4,20],\"944\":[4,73],\"945\":[4,23],\"946\":[5,32],\"947\":[null,null,2],\"948\":[null,null,4],\"949\":[2,83],\"950\":[null,null,2],\"951\":[null,null,4],\"952\":[1,287],\"953\":[null,null,2],\"954\":[null,null,4],\"955\":[2,22],\"956\":[2,42],\"957\":[2,583],\"958\":[null,null,2],\"959\":[null,null,4],\"960\":[1,2],\"961\":[2,7],\"962\":[2,91],\"963\":[2],\"964\":[3,4],\"965\":[2,5],\"966\":[3,25],\"967\":[3],\"968\":[3,13],\"969\":[3,24],\"970\":[2,8],\"971\":[null,null,3],\"972\":[null,null,4],\"973\":[1,11],\"974\":[2,3],\"975\":[2,10],\"976\":[3,49],\"977\":[2],\"978\":[3,12],\"979\":[2,43],\"980\":[3,52],\"981\":[2],\"982\":[3,28],\"983\":[3,67],\"984\":[2],\"985\":[3,25],\"986\":[3,26],\"987\":[3],\"988\":[4,21],\"989\":[4,16],\"990\":[3,23],\"991\":[3,14],\"992\":[4,29],\"993\":[2,20],\"994\":[3,14],\"995\":[3,9],\"996\":[3,1],\"997\":[4,15],\"998\":[4,19],\"999\":[4,15],\"1000\":[2],\"1001\":[3,39],\"1002\":[3,16],\"1003\":[4,21],\"1004\":[4,12],\"1005\":[4,15],\"1006\":[3,11],\"1007\":[3,14],\"1008\":[3,29],\"1009\":[2,14],\"1010\":[3,22],\"1011\":[3,12],\"1012\":[3,21],\"1013\":[2,25],\"1014\":[3,33],\"1015\":[3,43],\"1016\":[null,null,2],\"1017\":[null,null,4],\"1018\":[1,2],\"1019\":[4],\"1020\":[2,4],\"1021\":[5,49],\"1022\":[3],\"1023\":[5,6],\"1024\":[3,28],\"1025\":[3],\"1026\":[1,11],\"1027\":[1,10],\"1028\":[3,4],\"1029\":[4,12],\"1030\":[3,18],\"1031\":[3,35],\"1032\":[3,44],\"1033\":[3,13],\"1034\":[2],\"1035\":[3,32],\"1036\":[3,19],\"1037\":[3,75],\"1038\":[3,8],\"1039\":[3,34],\"1040\":[3,43],\"1041\":[3,44],\"1042\":[4,20],\"1043\":[3,17],\"1044\":[null,null,2],\"1045\":[null,null,3],\"1046\":[1,2],\"1047\":[2],\"1048\":[2,4],\"1049\":[3,3],\"1050\":[2],\"1051\":[3,7],\"1052\":[2,10],\"1053\":[3,2],\"1054\":[3,15],\"1055\":[2],\"1056\":[3,29],\"1057\":[2],\"1058\":[3,18],\"1059\":[3,55],\"1060\":[null,null,2],\"1061\":[null,null,4],\"1062\":[1,3],\"1063\":[2],\"1064\":[2],\"1065\":[1],\"1066\":[1],\"1067\":[1],\"1068\":[1],\"1069\":[1],\"1070\":[1],\"1071\":[1],\"1072\":[1],\"1073\":[2],\"1074\":[1],\"1075\":[1],\"1076\":[1],\"1077\":[2],\"1078\":[2],\"1079\":[1],\"1080\":[1],\"1081\":[1],\"1082\":[1],\"1083\":[1],\"1084\":[2],\"1085\":[1],\"1086\":[1],\"1087\":[1]},\"averageFieldLength\":[2.565978104932794,36.29286722714004,1.9813720620998392],\"storedFields\":{\"0\":{\"h\":\"关于\",\"t\":[\"hi\"]},\"1\":{\"h\":\"配置&插件\"},\"2\":{\"h\":\"Vscode 插件&配置\",\"t\":[\"好用好看好玩的vscode插件。\"]},\"3\":{\"h\":\"一、Vscode 设置\",\"t\":[\"可以在vsc的设置里面搜索，也可以直接改 settings.json\",\"settings.json：平滑效果smooth开启后，光标异常丝滑。\",\"{ // 设置在一段延迟后自动保存文件 \\\"files.autoSave\\\": \\\"afterDelay\\\", // 启用工作台列表的平滑滚动效果 \\\"workbench.list.smoothScrolling\\\": true, // 光标移动时的平滑动画效果 \\\"editor.cursorSmoothCaretAnimation\\\": \\\"on\\\", // 编辑器中的平滑滚动效果 \\\"editor.smoothScrolling\\\": true, // 光标闪烁效果设为平滑 \\\"editor.cursorBlinking\\\": \\\"smooth\\\", // 允许使用鼠标滚轮进行编辑器字体缩放 \\\"editor.mouseWheelZoom\\\": true, // 使代码建议不会被片段补全中断 \\\"editor.suggest.snippetsPreventQuickSuggestions\\\": false, }\"]},\"4\":{\"h\":\"二、UI 类\"},\"5\":{\"h\":\"1.1 主题\",\"t\":[\"Dracula Official：目前使用ing \",\"Material Icon Theme ：也是不错的，蛮多人用，是一个主题包，能切换多种主题 \"]},\"6\":{\"h\":\"1.2 图标包\",\"t\":[\"Emoji File Icons： 好看好看好看好看 \",\"vscode-icons ：官方的图标包\"]},\"7\":{\"h\":\"三、编程类\"},\"8\":{\"h\":\"2.1 代码视觉优化\",\"t\":[\"Indent-Rainbow：缩进着色 \",\"Indent Rainbow Palettes：搭配 Indent-Rainbow 使用 \"]},\"9\":{\"h\":\"2.2 项目管理\",\"t\":[\"Project Manager：Easily switch between projects \"]},\"10\":{\"h\":\"2.3 开发实用\",\"t\":[\"Todo Tree：打标签，方便定位、备忘、备注 \",\"Thunder Client：类似 postman \",\"Path Intellisense：写文件路径时，有类似语法提示的效果 \"]},\"11\":{\"h\":\"2.4 Git可视化\",\"t\":[\"GitLens：Supercharge Git in VS Code \"]},\"12\":{\"h\":\"四、AI 类\",\"t\":[\"百度： Comate\",\"GitHub：Copilot\",\"Comate：响应速度快，现在可以免费用，官方申请。（目前首选，体验蛮好还） Copilot：比Comate处理能力强，学生认证可免费使用。\"]},\"13\":{\"h\":\"五、没啥用But安装了类\",\"t\":[\"vscode-pets：电子宠物 \",\"CodeSnap：代码选择截图，带个框好看点 \"]},\"14\":{\"c\":[\"vscode\"]},\"15\":{\"c\":[\"插件\",\"vscode 配置\"]},\"16\":{\"h\":\"前端\"},\"17\":{\"h\":\"后端优化场景\",\"t\":[\"本系列包含后端优化场景相关的技术文档和学习笔记。\"]},\"18\":{\"c\":[\"后端开发\",\"性能优化\"]},\"19\":{\"c\":[\"性能优化\",\"最佳实践\"]},\"20\":{\"h\":\"海量数据处理技术与方案\",\"t\":[\"海量数据处理\",\"海量数据处理\",\"...\",\"1.1 什么是数据处理\",\"数据的存储 + 计算\",\"1.2 什么是海量数据处理\",\"数据量太大，无法在短时间内迅速解决，或者是数据太大，导致无法一次性装入内存的数据处理\",\"1.3 海量数据处理的常用方法\",\"巧用数据结构（bitmap、hash、布隆过滤器、堆）\",\"分治法：把规模大的数据转化为规模小的数据，逐个击破\",\"海量数据处理场景\",\"40亿个QQ号，如何判断一个QQ号是否存在?\",\"给定1000万个整数，内存限制1MB，如何对他们进行排序?\",\"给定1GB单词，内存限制1MB，如何找到出现频率最高的100个单词?\",\"内存限制4GB，如何对100亿URL查重?\",\"1000万字符串，其中有些是重复的，需要去重，保留没有重复的字符串。请怎么设计和实现?\",\"给定10亿个手机号，如何快速判断一个手机号是否存在?\",\"海量数据处理方法应用\",\"3.1 bitmap 方法\",\"3.1.1 问题拆解\",\"问题场景\",\"40亿个QQ号，如何判断一个QQ号是否存在?\",\"问题拆解\",\"40亿QQ号存储位置：文件\",\"查找QQ号的时间要求：快速，1s内\",\"3.1.2 问题思路\",\"问题思路 1：hash结构\",\"要快，用hash结构存储QQ号码，O(1) 时间内查找到某个QQ 号码\",\"...\",\"QQ号码无符号整数 uint\",\"hash存储结构，key：号码，value：次数\",\"所需内存：4byte * 40亿 / 1024 / 1024 / 1024 ≈ 14.9GB\",\"思路缺点：需要较大的内存成本\",\"如果条件限制是：内存限制为 1G 呢？\",\"问题思路 2：Bitmap\",\"只存储必要信息(QQ号码一定要存吗？)\",\"字节存储 ---> 位存储\",\"3.1.3 解决方案\",\"整体思路\",\"只存储QQ号码存在与否(0/1)\",\"建立QQ号码与二进制位之间的映射\",\"bitmap(二进制数组) 如何表示QQ号码\",\"...\",\"key (数组索引下标)： QQ号码\",\"value： key这个索引对应的数组的 bit 值 (0/1)\",\"索引可以理解为地址，不用额外存储，不占用内存地址\",\"所需内存\",\"最大qq号码：4个字节的最大无符号整数 = 2^32 - 1 ≈ 43 亿\",\"所需内存 = 43 亿 / 8 / 1024 / 1024 / 1024 ≈ 521 MB\",\"实现流程\",\"申请长度为 43 亿的二进制位数组\",\"遍历文件中的40亿个QQ号码，将二进制位数组中的对应值设置为 1\",\"根据给定QQ号码，到二进制数组中查找对应索引位置的值，若为 1 则存在，否则不存在\",\"3.1.4 问题变形\",\"利用bitmap去重\",\"...\",\"利用bitmap进行排序\",\"...\",\"3.1.5 bitmap 具体实现\",\"如何定位号码在数组中的位置\",\"需要多大的数组： size = (max_value + 8) / 8\",\"对应第几个数组： byteIndex = num / 8\",\"在字节的第几位： bitIndex = num % 8\",\"比如现在有一堆号码\",\"需要找到号码 8 的具体位置\",\"...\",\"如何将二进制位设置为 1\",\"byte[byteIndex] | 1 << bitIndex\",\"将号码 8 对应的二进制位设置为 1\",\"...\",\"如何判断号码对应的二进制位是否为 1\",\"byte[byteIndex] & 1 << bitIndex\",\"...\",\"3.2 外部排序\",\"。。\"]},\"21\":{\"c\":[\"后端\",\"大数据\",\"算法\"]},\"22\":{\"c\":[\"海量数据\",\"Bitmap\",\"分治法\",\"数据结构\"]},\"23\":{\"h\":\"防重设计与接口幂等设计详解\",\"t\":[\"防重设计与接口幂等设计\",\"一、防重设计与接口幂等性区别\",\"防重设计\",\"防重设计主要是为了防止重复操作或重复请求导致数据的重复处理或存储。\",\"其核心目的是：确保操作的唯一性和数据的准确性。\",\"例如，在电商系统中，防止用户重复提交订单是典型的防重设计应用场景。\",\"常见的防重设计方法有：\",\"唯一性约束：数据库层面通过设置唯一键来防止重复数据的插入。\",\"业务层防重：在业务逻辑层面通过各种手段（如分布式锁、唯一标识符等）来防止重复操作。\",\"前端防重：通过前端页面按钮禁用等方式防止用户重复提交。\",\"幂等性设计\",\"接口幂等性指的是某个操作无论执行多少次，其结果都是相同的。\",\"幂等性是分布式系统、微服务架构中设计接口时的重要原则，确保系统在多次重复调用同一个接口时不会产生副作用。\",\"幂等性常见的实现方法：\",\"GET请求：通常是天然幂等的，因为它只是读取数据而不修改数据。\",\"PUT请求：更新操作，重复执行多次结果不变。\",\"DELETE请求：删除操作，删除某个资源多次结果一致。\",\"POST请求的幂等性：通过引入唯一请求ID（如UUID）来确保多次提交的结果一致。\",\"二、防重设计\",\"数据库唯一性约束\",\"唯一键：通过在数据库表中设置唯一键来防止重复数据的插入。例如，可以在订单表中设置订单号（Order ID）为唯一键，这样在插入重复订单时会报错。\",\"唯一索引：在数据库中设置唯一索引，确保特定字段组合的唯一性。\",\"业务逻辑层防重\",\"分布式锁：在分布式系统中，可以使用分布式锁（如Redis、Zookeeper等）来防止多个实例同时处理同一个请求。\",\"唯一请求ID：在每次请求中生成唯一的请求ID（如UUID），在处理请求时首先检查该ID是否已经处理过，如果处理过则直接返回结果。\",\"状态标识：在业务逻辑中设置状态标识，例如订单状态字段，确保同一订单在不同状态下不能重复处理。\",\"前端防重\",\"按钮禁用：在前端页面中，用户提交请求后立即禁用提交按钮，防止用户重复点击。\",\"防重复提交机制：在前端和后端之间进行防重复提交的交互，例如通过Token机制，每次提交表单时附带一个唯一的Token，服务器验证Token的有效性。\",\"三、接口幂等性设计\",\"一、接口幂等性的必要性\",\"\\\\1. 接口幂等性的定义\",\"一个接口在多次调用的结果和调用一次的结果相同。\",\"一个幂等性的接口，无论重读调用多少次，系统的状态都保持一致，不会因为多次调用而导致不一样的结果。幂等性可以增加系统的可靠性。\",\"在Web开发中，由于重试机制或者网络不稳定，经常导致对接口重复调度用\",\"\\\\2. 非幂等性接口的危害场景\",\"在线支付场景，用户购买商品下单，跳转到支付页面，点击了支付按钮进行扣款，假设系统在返回支付结果的时候出现网络异常，此时后台已经完成扣款，但是用户没有看到支付成功的结果，再次点击支付按钮，会进行二次扣款，造成用户的钱多扣了。\",\"二、常见的重复请求场景\",\"3.1 前端的表单重复提交\",\"类似上面的支付场景，前端表单在提交时遇到网络波动，没有及时对用户做出提交成功响应，导致用户认为没有提交成功，然后一直点提交按钮，这时就会发生重复提交表单请求。\",\"3.2 接口超时重试\",\"很多http、rpc请求在实现的时候都会添加超时重试机制，为了防止网络波动超时等造成请求失败，这样就可能出现一次请求变成多次请求。\",\"3.3 消息重复消费\",\"当使用MQ消息中间件时候，如果Consumer消费超时 或者 producer 发送了消息，但是由于网络原因没有收到ACK导致消息重发，都会出现重复请求\",\"3.4 恶意攻击\",\"比如网上投票，黑客会针对一个用户进行重复提交投票，这样会导致接口接收到用户重复提交的投票信息，这样会使投票结果与事实严重不符。\",\"三、哪些接口需要幂等\",\"接口幂等性的验证和实施需要消耗一定的资源，因此并非每个接口都应该被赋予幂等性验证。\",\"相反，这种决策应该基于实际业务需求和操作类型进行区分。\",\"以查询和删除操作为例，这两种操作通常不需要进行幂等性验证。\",\"在查询操作中，无论执行一次还是多次，结果都是一致的，因此无需进行幂等性验证。\",\"对于删除操作，无论是执行一次还是多次，都是将相关数据进行删除(这里指的是有条件的删除而不是删除所有数据)，因此也无需进行幂等性验证。\",\"后台的业务接口无非就是增删改查四种接口，幂等性如下表:\",\"接口类型\",\"描述\",\"是否幂等\",\"新增操作\",\"新增操作每次执行都会往db新增数据\",\"✖\",\"更新操作\",\"修改在大多场景下结果一样,但是如果是增量修改是需要保证幂等性的,如下例子:\",\"1. 把表中id为XXX的记录的A字段值设置为1,这种操作不管执行多少次都是幂等的\",\"2. 把表中id为XXX的记录的A字段值增加1,这种操作就不是冪等的\",\"分情况\",\"查询操作\",\"查询用于根据条件获取资源，并不会对当前系统资源进行改变\",\"✅\",\"删除操作\",\"删除一次和多次删除都是把数据删除，效果一致\",\"✅\",\"四、幂等性常见解决方案\",\"\\\\1. 乐观锁\",\"通过新增一个 version 字段来记录当前记录的版本号，发起接口请求的时候要携带版本号。\",\"比如当前有一个商品记录：\",\"Id = 1； name = iphone； price = 9000； version = 2\",\"现在我需要调整价格，更新前查询到 version = 2，调整完之后对 version+1：\",\"Update t set price = 9999，version = version + 1 where id = 1 AND version = 10\",\"多次请求只要verison被执行了一次，其他的sql就不会生效。\",\"\\\\2. 防重Token令牌\",\"为了应对客户端连续点击或调用方的超时重试等情况，例如在提交订单时，可以通过 Token 机制来防止重复提交。简而言之，调用方在调用接口之前会首先向后端请求一个全局ID(Token)，并在请求时将该全局ID与其他数据一同发送(最好将Token放置在Headers中)。\",\"后端会将该Token作为键，用户信息作为值存储在Redis中进行键值内容校验如果该键存在且值匹配，就会执行删除命令（用lua脚本保证原子性），然后正常执行后续的业务逻辑。\",\"如果找不到对应的键或值不匹配，则表明是重复请求，不会再执行业务逻辑，直接返回重复请求信息，从而确保幂等性操作。\",\"...\",\"2.1 注意事项\",\"检查token是否在redis中 + 删除key 这两步建议用lua脚本实现，保证原子性\",\"全局唯一ID可用 业界的唯一ID生成算法生成 美团Leaf、、、、\",\"2.2 问题分析\",\"通过redis + token的方式虽然绕开了db层面来进行幂等性的校验，总的效率来说会高很多，但是却存在着不够精准的场景，不能够做到完全幂等性保证。\",\"假设某个客户端第一次发起请求，然后服务端收到后将token从Redis中删除，接着去执行业务逻辑，但是业务逻辑执行失败了，此时有两种可能:\",\"此时服务端可能会向客户端返回执行失败，客户端收到该返回后自动重新请求一个token，然后再次发起请求重试，这种场景下是正常请求，不存在幂等性问题\",\"如果此时服务端向客户端返回执行失败的过程中，由于网络或其他什么原因导致 客户端无法接收到 执行失败 响应。那么此时客户端会再次使用 第一次申请的token 再次向服务端发送请求，但是此时服务端返回的确却是 重复请求 或 执行成功（这个是业务去定义的）\",\"但综合效率以及网络故障概率等因素总体来说，这种方案实用性较强没有明显的缺陷。\",\"如果在使用这种方式的基础上想要保证严格意义上的幂等性，可以结合业务场景，在db层加上我们之前的三种方案进行兜底。\",\"2.3 思考：防重token 和 分布式锁\",\"token防重令牌的方式跟分布式锁的方式很像，都是维护一个全局资源，类似于一个全局锁，获取到了才有资格进行请求处理，那用分布式锁来处理幂等性可以吗，加锁成功执行请求处理，加锁失败说明请求已经在处理了，直接返回?\",\"答案是不合适的\",\"思考下面三种情况\",\"客户端连续发起两次请求(比如用户快速点击按钮的情况)，第一次请求先到达服务端，然后第二次请求由于某些原因过了一会儿才到达服务端。等第二次请求达到服务端的时候，第一次请求已经执行完毕并且释放了锁。此时第二次请求仍然能加锁成功，并且执行业务逻辑。这种情况下幂等性失效。\",\"客户端发起第一次请求，服务端正常执行完毕并释放了分布式锁但由于网络原因客户端没有正常收到服务端的响应，此时客户端再次发起请求。由于第一次请求所加的分布式锁已经过期所以第二次请求仍然能够加锁成功，然后执行业务逻辑。此时幂等性失效\",\"客户端连续发起多次请求，这多次请求同时到达服务端，此时开始争抢锁，谁抢到锁谁就执行，其他没有抢到锁的请求都统统不执行。这种情况能保证幂等性。\"]},\"24\":{\"c\":[\"后端\",\"系统设计\",\"架构\"]},\"25\":{\"c\":[\"幂等性\",\"分布式系统\",\"防重设计\",\"接口设计\"]},\"26\":{\"h\":\"GCC与GDB工具使用指南\",\"t\":[\"GCC、GDB\"]},\"27\":{\"c\":[\"C++\",\"工具\",\"开发环境\"]},\"28\":{\"c\":[\"GCC\",\"GDB\",\"编译器\",\"调试器\",\"C++\"]},\"29\":{\"h\":\"C++\",\"t\":[\"本系列包含C++相关的技术文档和学习笔记。\"]},\"30\":{\"h\":\"C++特性详解\",\"t\":[\"c++特性\",\"cpp的拓展\",\"结构体声明变量省去struct\",\"struct stu{ int a; char b; } //C的风格 struct stu s1 = {1，’x‘}; //C++风格 stu s1 = {1，’x‘};\",\"引用\",\"C语言和C均使用& 符号表示变量的地址。 而C赋予了&一个引用含义，即起别名 引用必须初始化 系统不会为引用 开辟空间\",\"基本数据类型引用\",\"int a = 10; int &b = a; // b只是a的一个别名，指向同一片内存单元（地址一样），代表同一值，不会为b单独开辟一个内存空间 //操作a等于操作b\",\"数组的引用\",\"int arr[5] = {1,2,3,4,5} int (&myarr)[5] = arr;\",\"指针变量的引用\",\"int num = 10; int \\\\*p = # int\\\\* &myp = p; //p 和myp一样\",\"函数的引用\",\"void func1(void){ cout<<\\\"fun1\\\"<<endl; }; void (&myfunc1)(void) = func1;\",\"作为函数的参数\",\"void swap1(int \\\\*a, int \\\\*b){ int temp = \\\\*a; \\\\*a = \\\\*b; \\\\*b = temp; } void swap2(int &a, int &b){ int temp = a; a = b; b = temp; } int main(){ int a = 10 int b = 20; swap1(&a,&b);//得传地址，麻烦死了 swap2(a,b);// 直接代表引用类型！牛逼 }\",\"引用作为函数返回值类型\",\"不要返回普通局部变量的引用\",\"int& getData(void){ int num = 10; //是局部变量 return num; } int main(){ int &b = getData(); //getData()返回一个num的引用，故用&b去接收它的返回值，b就是num的别名 } 但是num是局部变量，会被释放掉，会造成空指针错误\",\"返回值类型是引用类型，可以完成链式操作\",\"struct stu{ stu& printStu(Stu &ob, int value){ cout<<value<<\\\" \\\"; return ob; } }; int main(){ stu ob1; ob1.printStu(ob1,100).printStu(ob1,200).printStu(ob1,300); } //调用ob1的函数返回了一个结构体类型的变量，又可以继续调用函数\",\"给常量取别名，不能通过常引用 修改 内容\",\"int &a = 10; //错误，因为10 是const int const int &a = 10;//a是10的别名，不可以修改\",\"常引用 作为函数的参数：防止函数内部修改外部的值\",\"void printInt(const int &a){ // 加了const可以只读令引用梦类型 cout<<\\\"a = \\\"<<a<<endl; } int main(){ int num = 100; printInt(num);//打印100 }\"]},\"31\":{\"c\":[\"C++\",\"编程语言\"]},\"32\":{\"c\":[\"C++\",\"引用\",\"语言特性\",\"面向对象\"]},\"33\":{\"h\":\"C++基础知识复习\",\"t\":[\"基础复习\",\"基础知识\",\"\\\\1. 指针和引用的区别\",\"指针是一个变量，存储一个地址，大小为 4（32位）、8（64位）字节，可以有多级指针，指针可以初始化为空，可以被多次改变，sizeof(指针)得到指针的大小，指针作为参数传递的时候有一个形参向函数栈帧拷贝数据的过程，拷贝的是一个固定字节的地址变量， 4 或 8 字节。（相当于传递地址值）\",\"引用原变量的别名，与原变量实际是同一个东西，只能有一级，初始化时不能为null，必须初始化为另一具体的变量，初始化后不能再改变。sizeof(引用)得到引用所指向的变量大小。\",\"\\\\2. 区别指针类型\",\"int\\\\* p[10] int (\\\\*p)[10] int \\\\*p(int) int (\\\\*p)(int)\",\"**int *p[10]**表示指针的数组，强调数组概念，是一个数组变量，数组大小为10，其元素都是指针类型。\",\"**int (*p)[10]**表示数组的指针，强调是一个指向数组的指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。\",\"**int *p(int)**是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。\",\"**int (*p)(int)**是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的\",\"\\\\3. 值传递、指针传递、引用传递的区别和效率\",\"**值传递:**有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或是大的结构体对象，将耗费一定的时间和空间。(传值)\",\"**指针传递:**同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。 (传值，传递的是地址值)\",\"**引用传递:**同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。(传地址)\",\"效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰，指针传递的话要解引用。\",\"引用必须在声明时初始化，不能为空，这就避免了空指针的问题。\",\"引用一旦绑定到一个对象，就不能再重新绑定到其他对象，这提高了代码的稳定性。\",\"\\\\4. 堆和栈的区别\",\"申请方式不同：栈由系统自动分配，堆需要手动申请和释放\",\"申请大小限制不同：栈顶和栈底是提前预设好的，栈是高地址向底地址拓展，可以通过ulimit-a查看，ulimit-s修改。\",\"...\",\"申请效率不同：\",\"栈由系统分配，速度快，不会有碎片。\",\"堆由程序员分配，速度慢，且会有碎片。\",\"\\\\5. new 和 delete 如何实现\",\"内存管理\",\"new的实现过程是:\",\"分配内存：new 操作符首先调用内存分配函数（通常是 malloc 或者操作系统提供的其他内存分配函数）来分配足够的内存，以容纳所需的对象。\",\"调用构造函数：在内存分配成功后，new 操作符会在分配的内存上调用对象的构造函数，以初始化对象。\",\"返回指针：最终，new 操作符返回一个指向新分配和初始化对象的指针。\",\"delete的实现过程:\",\"调用析构函数：delete 操作符首先调用对象的析构函数，以清理对象占用的资源。\",\"释放内存：在析构函数调用完成后，delete 操作符会调用内存释放函数（通常是 free）来释放之前分配的内存。\",\"\\\\6. malloc申请的内存能用delete释放吗\",\"不能，因为不安全）\",\"new和delete会自动进行检查其类型和大小，而malloc/free不能执行构造函数和析构函数，所以动态对象它是不行的。\",\"但是理论上malloc的内存可以被delete释放，但是不要这么写。\",\"#include <iostream> #include <cstdlib> class MyClass { public: MyClass() { std::cout << \\\"Constructor called\\\" << std::endl; } ~MyClass() { std::cout << \\\"Destructor called\\\" << std::endl; } void sayHello() { std::cout << \\\"Hello from MyClass\\\" << std::endl; } }; int main() { // 使用 new 和 delete std::cout << \\\"Using new and delete:\\\" << std::endl; MyClass\\\\* obj1 = new MyClass(); obj1->sayHello(); delete obj1; std::cout << \\\"\\\\nUsing malloc and free:\\\" << std::endl; // 使用 malloc 和 free MyClass\\\\* obj2 = (MyClass\\\\*)malloc(sizeof(MyClass)); // 注意：这里不会调用构造函数 obj2->sayHello(); // 这可能导致未定义行为 free(obj2); // 这里不会调用析构函数 std::cout << \\\"\\\\nMixing malloc and delete (not recommended):\\\" << std::endl; // 混合使用 malloc 和 delete （不推荐） MyClass\\\\* obj3 = (MyClass\\\\*)malloc(sizeof(MyClass)); delete obj3; // 这可能导致未定义行为 return 0; }\",\"...\",\"\\\\7. 宏定义和函数的区别\",\"宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快; 函数调用在运行时需要跳转到具体调用函数。\",\"宏定义属于在结构中插入代码，没有返回值;函数调用具有返回值，\",\"宏定义参数没有类型，不进行类型检查; 函数参数具有类型，需要检查类型，\",\"宏定义不要在最后加分号。\",\"#include <iostream> #include <chrono> // 宏定义 #define SQUARE(x) ((x) \\\\* (x)) // 函数定义 int square(int x) { return x \\\\* x; } // 用于测量执行时间的宏 #define MEASURE\\\\_TIME(func) \\\\ do { \\\\ auto start = std::chrono::high\\\\_resolution\\\\_clock::now(); \\\\ func; \\\\ auto end = std::chrono::high\\\\_resolution\\\\_clock::now(); \\\\ std::chrono::duration<double, std::milli> elapsed = end - start; \\\\ std::cout << #func << \\\" took \\\" << elapsed.count() << \\\" ms\\\\n\\\"; \\\\ } while(0) int main() { int x = 5; // 1. 执行速度比较 MEASURE\\\\_TIME(for(int i = 0; i < 1000000; ++i) { int y = SQUARE(x); }); MEASURE\\\\_TIME(for(int i = 0; i < 1000000; ++i) { int y = square(x); }); // 2. 返回值 // 宏没有返回值，直接插入代码 int macro\\\\_result = SQUARE(x); // 函数有返回值 int func\\\\_result = square(x); std::cout << \\\"Macro result: \\\" << macro\\\\_result << std::endl; std::cout << \\\"Function result: \\\" << func\\\\_result << std::endl; // 3. 类型检查 double d = 2.5; // 宏不进行类型检查 std::cout << \\\"Macro with double: \\\" << SQUARE(d) << std::endl; // 函数会进行类型检查（这里会有隐式类型转换） std::cout << \\\"Function with double: \\\" << square(d) << std::endl; // 4. 宏的潜在问题 int a = 5; std::cout << \\\"SQUARE(a++): \\\" << SQUARE(a++) << std::endl; std::cout << \\\"a after macro: \\\" << a << std::endl; a = 5; std::cout << \\\"square(a++): \\\" << square(a++) << std::endl; std::cout << \\\"a after function: \\\" << a << std::endl; return 0; }\",\"...\",\"\\\\8. 函数传参时，什么时候用指针 or 引用\",\"需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的\",\"对栈空间大小比较敏感(比如递归)的时候使用引用。使用引用传递不需要创建临时变量，开销要更小\",\"类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式\",\"\\\\9. 宏定义和 typedef 的区别\",\"宏 主要用于定义常量及书写复杂的内容。宏替换发生在编译阶段之前，属于文本插入替换。宏不检查类型，宏不是语句，不在最后加分号;\",\"typedef 主要用于定义类型别名，typedef是编译的一部分。typedef 会检查数据类型，typedef是语句，要加分号标识结束。\",\"注意对指针的操作，typedef char* p_char和#define p_char char*区别巨大。\",\"\\\\10. Sizeof 和 strlen 的区别\",\"因为sizeof值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小。\",\"sizeof 是运算符，并不是函数，结果在编译时得到而非运行中获得；sizeof参数可以是任何数据的类型或者数据\",\"strlen是字符处理的库函数。strlen的参数只能是字符指针且结尾是\\\"\\\\0'的字符串。\",\"\\\\11. 怎么判断两个浮点数相等\",\"浮点数不能用 == 判断。\",\"方法：\",\"自定义精度 EPS: abs(a - b) < ESP\",\"if ( !( a > b || b > a )) 如果浮点数a、b不想等，那么 !(xxx || xxx ) 一定是 (! 1) == 0\",\"\\\\12. C++的内存分区\",\"...\",\"\\\\13. 初始化和赋值的区别\",\"对于简单类型来说，初始化和赋值没什么区别\",\"对于类和复杂数据类型来说，这两者的区别就大了。\",\"\\\\14. Extern \\\"C\\\" 的用法\",\"在程序中加上extern \\\"C\\\"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；\",\"（1）C++调用C函数：\",\"//xx.h extern int add(...) //xx.c int add(){ } //xx.cpp extern \\\"C\\\" { #include \\\"xx.h\\\" }\",\"（2）C调用C++函数\",\"//xx.h extern \\\"C\\\"{ int add(); } //xx.cpp int add(){ } //xx.c extern int add();\",\"\\\\15. 野指针和悬空指针\",\"野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。\",\"悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空\",\"避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。\",\"\\\\16. 浅拷贝和深拷贝\",\"浅拷贝\",\"浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。\",\"深拷贝\",\"深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。\",\"在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。\",\"#include <iostream> #include <string.h> using namespace std; class Student { private: int num; char \\\\*name; public: Student(){ name = new char(20); cout << \\\"Student\\\" << endl; }; ~Student(){ cout << \\\"~Student \\\" << &name << endl; delete name; name = NULL; }; Student(const Student &s){//拷贝构造函数 //浅拷贝，当对象的name和传入对象的name指向相同的地址 name = s.name; //深拷贝 //name = new char(20); //memcpy(name, s.name, strlen(s.name)); cout << \\\"copy Student\\\" << endl; }; }; int main() { {// 花括号让s1和s2变成局部对象，方便测试 Student s1; Student s2(s1);// 复制对象 } system(\\\"pause\\\"); return 0; } //浅拷贝执行结果： //Student //copy Student //~Student 0x7fffed0c3ec0 //~Student 0x7fffed0c3ed0 //\\\\*\\\\*\\\\* Error in /tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 \\\\*\\\\*\\\\* //深拷贝执行结果： //Student //copy Student //~Student 0x7fffebca9fb0 //~Student 0x7fffebca9fc0\",\"\\\\17. 智能指针（c++11）\",\"\\\\1. shared_ptr\",\"采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。\",\"\\\\2. unique_ptr\",\"unique_ptr采用独享所有权语义，一个非空的unique_ptr始终拥有其指向的资源。\",\"转移一个unique_ptr时，所有权会从源指针完全转移到目标指针，源指针会被置空。因此，unique_ptr不支持普通的拷贝和赋值操作，无法直接用于STL标准容器中，除非是局部变量的返回值（因为编译器知道返回的对象即将被销毁）。\",\"如果尝试拷贝一个unique_ptr，会导致两个指针指向同一资源，从而在销毁时对同一内存进行多次释放，导致程序崩溃。\",\"\\\\3. weak_ptr\",\"weak_ptr（弱引用）用于解决引用计数中的环形引用问题。环形引用会导致相互引用的内存无法释放。为了解决这一问题，引入了weak_ptr，它是一种不影响对象生命周期的智能指针，专门用于配合shared_ptr使用。\",\"weak_ptr指向由shared_ptr管理的对象，但不增加引用计数。即使有weak_ptr引用该对象，当所有shared_ptr被销毁后，内存仍会被释放。因此，weak_ptr不保证其指向的内存一定有效。在使用weak_ptr之前，应该调用lock()函数来检查它是否为空指针。\",\"\\\\4. 智能指针的循环引用\",\"环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。\",\"弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。\",\"\\\\5. 手写实现智能指针需要哪些函数\",\"一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数\",\"智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。\",\"它会自动记录SmartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。\",\"除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。\",\"通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1\",\"\\\\18. ++i 和 i++ 哪个好\",\"++i 返回一个引用，\",\"i++ 返回一个对象值，并在过程中产生临时对象，导致效率降低\",\"\\\\19. 内存对齐以及原因\",\"分配内存的顺序是按照声明的顺序。\",\"每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。\",\"最后整个结构体的大小必须是里面变量类型最大值的整数倍。\",\"类\",\"\\\\1. 重载、重写、隐藏的区别\",\"重载 Overload\",\"重载和函数成员是否是虚函数无关。\",\"特点是函数名相同，参数类型和数目有所不同。\",\"不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。\",\"class A{ ... virtual int fun(); void fun(int); void fun(double, double); static int fun(char); ... }\",\"重写 Override\",\"派生类中覆盖基类中的同名函数。\",\"重写就是重写函数体，要求基类函数必须是虚函数\",\"//父类 class A{ public: virtual int fun(int a){} } //子类 class B : public A{ public: //重写,一般加override可以确保是重写父类的函数 virtual int fun(int a) override{} }\",\"隐藏 hide\",\"派生类中的函数屏蔽了基类中的同名函数，包括以下情况：\",\"两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数\",\"两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。\",\"\\\\2. 虚函数和纯虚函数\",\"**虚函数：**virtual return_type function_name(parameters) { /* 可以有实现 */ }\",\"定义一个函数为虚函数，不代表函数为不被实现的函数。\",\"定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。\",\"**纯虚函数：**virtual return_type function_name(parameters) = 0;\",\"定义一个函数为纯虚函数，才代表函数没有被实现。\",\"定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。\",\"\\\\3. 面向对象的三大特性\",\"继承\",\"**定义：**让某种类型对象获得另一个类型对象的属性和方法。\",\"实现方式：\",\"实现继承：指使用基类的属性和方法而无需额外编码的能力\",\"接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力\",\"封装\",\"**定义：**将数据和代码捆绑在一起避免外界干扰和不确定性访问。把客观事物封装成抽象类，用访问修饰符划分访问权限。\",\"多态\",\"**定义：**同一事物变现出不同事物的能力\",\"**实现方式：**多态性通常通过继承和虚函数来实现。重载（实现编译时多态）、重写（实现运行时多态）\",\"\\\\4. Const 和 static 、volatile 的作用\",\"const 用于定义不可变的常量。\",\"static 控制变量或函数的生命周期和作用域。\",\"volatile 告诉编译器不要优化这个变量，因为它可能在程序的其他部分或外部环境中被改变。\",\"const关键字\",\"常量定义：可以定义不可更改的常量，比如const int PI = 3.14;。\",\"指针和引用：可以创建指向常量的指针或引用，以及常量指针或引用。\",\"const int* ptr指针所指向的整数是常量，不能通过这个指针修改它所指向的整数，但指针本身是可以修改的。\",\"int* const ptr指针本身是常量，初始化后不能修改它所指向的地址，但可以通过这个指针修改它所指向的整数。\",\"函数参数和返回值：可以在函数参数和返回值前加上const，以表明这些参数和返回值在函数内部不能被修改。\",\"成员函数：在成员函数声明前加上const关键字，表示该成员函数不会修改该类的任何成员变量。这对于类的接口设计非常重要，因为可以让使用者清楚地知道哪些成员函数是安全的，不会导致数据的改变。\",\"static关键字\",\"全局变量：可以使全局变量具有内部链接性，即该变量只能在定义它的文件中访问。\",\"局部静态变量：可以使局部变量在函数调用结束后仍然保留其值，即具有静态存储持续性。\",\"静态成员变量：定义类中的静态成员变量，表示这个变量是所有对象共享的，而不是每个对象独立的。\",\"静态成员函数：定义类中的静态成员函数，这个函数属于类，而不是类的任何特定对象。静态成员函数没有this指针，因此无法访问非静态成员变量和函数。\",\"\\\\5. Final\",\"用于类: 防止该类被继承\",\"用于虚函数: 防止该虚函数在子类中被重写\",\"\\\\6. 有几种构造函数\",\"无参构造函数\",\"有参构造函数\",\"拷贝构造函数\",\".......\",\"析构函数 ~\"]},\"34\":{\"c\":[\"C++\",\"编程语言\"]},\"35\":{\"c\":[\"C++\",\"基础知识\",\"语法\",\"复习\"]},\"36\":{\"h\":\"C++预编译详解\",\"t\":[\"预编译\",\"define宏定义\",\"被定义为\\\"宏\\\"的标识符称为\\\"宏名\\\"。在编译预处理时，对程序中所有出现的\\\"宏名\\\"，都用宏定义中的字符串去代换，这称为\\\"宏代换\\\"或\\\"宏展开\\\"。\",\"优点：\",\"(1) 方便程序的修改。这个就不多说了。\",\"(2） 提高程序的运行效率。\",\"使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。\",\"正如C语言中所讲，函数的使用可以使程序更加模块化，便于组织，而且可重复利用，但在发生函数调用时，需要保留调用函数的现场，以便子函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间\",\"如果子函数执行的操作比较多，这种转换时间开销可以忽略，但如果子函数完成的功能比较少，甚至于只完成一点操作，如一个乘法语句的操作，则这部分转换开销就相对较大了，但使用带参数的宏定义就不会出现这个问题，因为它是在预处理阶段即进行了宏展开，在执行时不需要转换，即在当地执行。\",\"宏定义可完成简单的操作，但复杂的操作还是要由函数调用来完成，而且宏定义所占用的目标代码空间相对较大。所以在使用时要依据具体情况来决定是否使用宏定义。\",\"带参宏和不带参宏\",\"//带参 #define MAX(a,b) (a<b)? b:a int main(){ int a=6,b=2; int c=MAX(a,b); } //不带参数 #define OK 1\",\"#include 包含头文件\",\"预处理阶段进行的替换工作，将头文件.h中的内容替换到.c文件\",\"#包含头文件就是为了将声明或者源代码替换到当前.c文件中\",\" #incldude<iostream> 在预处理的时候，会先对#进行预处理，将<iostream>文件的代码替换掉 #incldude<iostream>这一行代码 而iostream文件中有50000多行代码，所以预处理后的文件，会加上这5w行代码\",\"#if和#endif 是否执行该代码段\",\"在预处理阶段进行\",\"//会执行 #if 1 int add(int a, int b){ } #endif ///////////////////////////////////////////////////////////////////// //不会执行 #if 0 int add(int a, int b){ } #endif\",\"ifndef防止头文件的重复包含和编译\",\"它是if not define 的简写，是宏定义的一种，实际上确切的说，这应该是预处理功能三种（宏定义、文件包含、条件编译）中的一种----条件编译。 条件指示符#ifndef 的最主要目的是防止头文件的重复包含和编译。\",\"#ifndef x //先测试x是否被宏定义过 #define x 程序段1 //如果x没有被宏定义过，定义x，并编译程序段 1 #endif 程序段2 //如果x已经定义过了则编译程序段2的语句，\\\"忽视\\\"程序段 1\"]},\"37\":{\"c\":[\"C++\",\"编译原理\"]},\"38\":{\"c\":[\"预编译\",\"宏定义\",\"C++\",\"条件编译\"]},\"39\":{\"h\":\"算法\",\"t\":[\"本系列包含算法相关的技术文档和学习笔记。\"]},\"40\":{\"h\":\"二分红蓝染色法详解\",\"t\":[\"本文详细介绍二分红蓝染色法的原理及应用场景。\"]},\"41\":{\"h\":\"1. 二分红蓝染色法概述\",\"t\":[\"二分红蓝染色法是二分查找的一种实现思路，通过将搜索空间染色为红蓝两部分，来定位目标值。\"]},\"42\":{\"h\":\"2. 应用场景\"},\"43\":{\"h\":\"2.1 查找元素首次出现位置\",\"t\":[\"查找元素 8 出现的第一个位置索引：\",\"...\"]},\"44\":{\"h\":\"2.2 寻找循环排序数组的最小值\",\"t\":[\"寻找循环排序数组中的最小值：\",\"...\"]},\"45\":{\"h\":\"3. 实现方法\"},\"46\":{\"h\":\"3.1 闭区间简洁模板\",\"t\":[\"func bsearch(a []int, value int) int { low := 0 high := len(a) - 1 for low <= high { mid := low + (high-low)/2 if a[mid] > value { high = mid - 1 } else if a[mid] < value { low = mid + 1 } else { if (mid == len(a)-1) || (a[mid+1]!= value) { return mid } else { high = mid - 1 } } } return -1 }\"]},\"47\":{\"c\":[\"算法\",\"二分查找\"]},\"48\":{\"c\":[\"二分查找\",\"染色法\",\"算法\"]},\"49\":{\"h\":\"二叉堆详解\",\"t\":[\"本文详细介绍二叉堆的基本原理、分类及实现方式。\"]},\"50\":{\"h\":\"1. 基本原理\",\"t\":[\"二叉堆是一种特殊的二叉树。能动态排序的数据结构主要有两种：二叉堆和二叉搜索树。\"]},\"51\":{\"h\":\"1.1 分类\",\"t\":[\"二叉堆主要分为两类：\",\"小顶堆\",\"大顶堆\",\"对于小顶堆，每个节点下方的所有节点的值都比它大，那么不难想象根节点就是整棵树上的最小值。\",\"同理，大顶堆的根节点就是整棵树上的最大值。所以二叉堆可以辅助我们快速找到最大值或最小值。\"]},\"52\":{\"h\":\"1.2 API操作\",\"t\":[\"二叉堆的主要操作包括：\",\"sink() - 下沉操作\",\"swim() - 上浮操作\",\"peek() - 查看堆顶元素\",\"Push 插入新元素，直接放在底层的最右节点，保持完全二叉树的特点。再通过swim()上浮到合适位置。\",\"Pop 删除新元素，把堆顶元素删除，把二叉树底层的最右侧元素摘除并移动到堆顶，保持完全二叉树特点。在通过sink()下沉到合适位置。\"]},\"53\":{\"h\":\"2. 实现方式\"},\"54\":{\"h\":\"2.1 链式（麻烦）\",\"t\":[\"链式实现需要通过遍历找到最底层的最右节点，实现较为复杂。\"]},\"55\":{\"h\":\"2.2 数组\",\"t\":[\"数组实现可以方便地定位最底层的最右节点，是二叉堆的常用实现方式。\"]},\"56\":{\"c\":[\"数据结构\",\"算法\"]},\"57\":{\"c\":[\"二叉堆\",\"优先队列\",\"堆\"]},\"58\":{\"h\":\"二叉树详解\",\"t\":[\"本文详细介绍二叉树的基本概念、常见类型及实现方式。\"]},\"59\":{\"h\":\"1. 常见二叉树类型\"},\"60\":{\"h\":\"1.1 满二叉树\",\"t\":[\"每一层节点都是满的。\",\"...\"]},\"61\":{\"h\":\"1.2 完全二叉树\",\"t\":[\"最后一层的节点左边都是满的，最后一层以外的每一层都是满的。\",\"...\"]},\"62\":{\"h\":\"1.3 二叉搜索树\",\"t\":[\"左小右大，左子树所有节点的值小于根节点，右子树所有节点的值大于根节点。\"]},\"63\":{\"h\":\"2. 实现方式\"},\"64\":{\"h\":\"2.1 链式结构\",\"t\":[\"每个节点通过指针指向左右子节点，适合频繁插入、删除操作的场景。\"]},\"65\":{\"h\":\"2.2 数组结构\",\"t\":[\"通过下标关系表示节点间的父子关系，适合完全二叉树的存储。\"]},\"66\":{\"c\":[\"数据结构\",\"算法\"]},\"67\":{\"c\":[\"二叉树\",\"树\",\"数据结构\"]},\"68\":{\"h\":\"哈希算法详解\",\"t\":[\"本文详细介绍哈希算法的定义、原理及其广泛的应用场景。\"]},\"69\":{\"h\":\"1. 哈希算法基础\"},\"70\":{\"h\":\"1.1 定义\",\"t\":[\"将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。\"]},\"71\":{\"h\":\"2. 哈希算法应用\"},\"72\":{\"h\":\"2.1 安全加密\",\"t\":[\"哈希算法有很多，但对于用于加密的哈希算法来说，有两点格外重要：\",\"很难逆推原始数据\",\"hash冲突概率小\"]},\"73\":{\"h\":\"常见的加密算法\",\"t\":[\"MD5 消息摘要算法\",\"SHA 安全散列算法\",\"DES 数据加密标准\",\"AES 高级加密标准\"]},\"74\":{\"h\":\"鸽巢原理\",\"t\":[\"没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。\",\"哈希算法因哈希值长度有限而无法避免冲突，但因其冲突概率极低在有限资源下很难破解，且实际开发中要权衡加密算法的破解难度和计算时间来选择合适算法。\"]},\"75\":{\"h\":\"2.2 唯一标识\",\"t\":[\"如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。\",\"任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。\",\"以给每一个图片取一个唯一标识，或者说信息摘要。\",\"比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。\",\"通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。\"]},\"76\":{\"h\":\"2.3 数据检验\",\"t\":[\"网络传输文件的时候往往会分片成一个个文件块，等所有文件快下载完成后，在合成一个完整的文件，如何检验文件块的安全、正确、完整？\",\"传输前对每个文件块分别取哈希值，传输完成后用同一个哈希算法计算，对比两次哈希值。\"]},\"77\":{\"h\":\"2.4 分布式问题：负载均衡\",\"t\":[\"负载均衡算法有很多，比如轮询、随机、加权轮询等。\",\"我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。\",\"通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。\"]},\"78\":{\"h\":\"2.5 数据分片\"},\"79\":{\"h\":\"如何统计\\\"关键词\\\"出现的次数？\",\"t\":[\"在1TB的日志文件里记录了用户的搜索关键词，快速统计每个关键字被搜索的次数。\",\"两个难点，第一个是文件大，没有办法一次性放入一台机器的内存中处理；第二个是如果只用一台机器来处理这么巨大的数据，时间久。\",\"针对这两个难点，可以先对数据进行分片，然后采用多台机器处理，提高处理速度。\",\"具体思路：\",\"在整个数据处理的前期准备阶段，就已经规划好通过某种方式让每台机器都能获取到一部分分片后的日志数据。\",\"每台机器都会从分配给自己的那部分日志数据中依次读取每个搜索关键词，然后各自在本机上对读取到的关键词进行哈希函数运算，得到哈希值后再与 n 取模，以此确定这个关键词应该在本机进行后续处理还是要发送给其他机器。\",\"一台机器确定某个关键词是要在自己这里处理（也就是取模结果对应的是本机编号）时，它就会对收到的这个关键词进行计数统计。如果之前没出现过，就初始化为 1 次；如果已经出现过了，就把对应的计数加 1。\",\"在每台机器都完成了对各自所负责的那部分数据中的关键词的统计处理之后，再通过特定的机制将每台机器统计出来的结果进行合并汇总，最终得到整个 1T 日志文件中每个关键词被搜索的总次数。\"]},\"80\":{\"h\":\"如何快速判断图片是否在图库中？\",\"t\":[\"这个问题可以通过哈希算法给每张图片生成唯一标识，然后通过分布式存储系统快速检索。\"]},\"81\":{\"h\":\"2.6 分布式存储\",\"t\":[\"分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。\",\"该如何决定将哪个数据放到哪个机器上呢？我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。\"]},\"82\":{\"h\":\"一致性哈希算法\",\"t\":[\"一致性哈希算法是解决分布式系统中数据分布问题的一种重要方法，特别适用于节点动态变化的场景。\"]},\"83\":{\"c\":[\"算法\",\"密码学\"]},\"84\":{\"c\":[\"哈希\",\"算法\",\"密码学\"]},\"85\":{\"h\":\"滑动窗口算法详解\",\"t\":[\"本文详细介绍滑动窗口算法的原理及实现方法。\"]},\"86\":{\"h\":\"1. 滑动窗口基本概念\",\"t\":[\"滑动窗口是一种常见的双指针技术，维护一个左闭右开的区间，时间复杂度为O(n)。\"]},\"87\":{\"h\":\"2. 滑动窗口算法框架\"},\"88\":{\"h\":\"2.1 基本实现\",\"t\":[\"/* 滑动窗口算法框架 */ func slidingWindow(s string) { // 用合适的数据结构记录窗口中的数据，根据具体场景变通 // 比如说，我想记录窗口中元素出现的次数，就用 map // 我想记录窗口中的元素和，就用 int window := make(map[rune]int) left, right := 0, 0 for right < len(s) { // c 是将移入窗口的字符 var c rune = rune(s[right]) window[c]++ // 增大窗口 right++ // 进行窗口内数据的一系列更新 // ... // 去掉调试信息 // 你的代码中不应该有打印，因为它可能会阻止你的解决方案通过 // fmt.Printf(\\\"window: [%d, %d)\\\\n\\\", left, right) // 判断左侧窗口是否要收缩 for ; left < right; { // 增加一个判断条件来计算哪种情况会使窗口需要缩小 // if window needs shrink { // d 是将移出窗口的字符 var d rune = rune(s[left]) window[d]-- // 缩小窗口 left++ // 进行窗口内数据的一系列更新 // ... // } } } }\"]},\"89\":{\"c\":[\"算法\",\"数据结构\"]},\"90\":{\"c\":[\"滑动窗口\",\"双指针\",\"算法\"]},\"91\":{\"h\":\"分布式\",\"t\":[\"本系列包含分布式系统相关的技术文档和学习笔记。\"]},\"92\":{\"h\":\"雪花算法详解\",\"t\":[\"雪花算法\",\"...\",\"雪花算法（Snowflake Algorithm）是一种用于生成分布式系统中唯一ID的算法。\",\"它的核心思想是在分布式环境下生成ID，保证每个ID都是唯一的，并且具有一定的有序性。\",\"雪花算法的实现主要由以下几个组成部分：\",\"时间戳（Timestamp）：使用一个长度为41位的时间戳，表示生成ID的时间。由于使用的是毫秒级时间戳，所以雪花算法可以支持一定的未来时间。剩余的位数用来表示时间戳的偏移量。\",\"机器ID（Machine ID）：为了在分布式系统中保证每个机器生成的ID的唯一性，需要为每台机器分配一个唯一的机器ID。通常，可以根据机器的网络地址或其他唯一标识来生成机器ID。\",\"序列号（Sequence）：为了解决在同一毫秒内生成多个ID时的冲突问题，使用一个序列号来保证ID的唯一性。序列号占用的位数根据需求可以灵活调整。\",\"具体的生成过程如下：\",\"雪花算法将时间戳、机器ID和序列号组合成一个64位的二进制数。\",\"生成的ID是一个64位的整数，被划分成多个部分：时间戳、机器ID和序列号。\",\"最高位是符号位，通常为0。\",\"接下来的41位是时间戳，记录生成ID的时间。\",\"然后是机器ID，占用的位数根据具体情况而定。\",\"最后是序列号，占用的位数也根据具体情况而定。\",\"生成的ID可以根据需要进行进一步编码和转换，例如转为字符串或使用其他格式存储和传输。\",\"通过这种方式，雪花算法可以在分布式环境中生成唯一的ID，并且ID的生成是有序的。\",\"这种有序性可以提高数据库索引的效率，便于数据的分片和分布式系统的处理。\"]},\"93\":{\"c\":[\"分布式系统\",\"算法\"]},\"94\":{\"c\":[\"雪花算法\",\"分布式ID\",\"唯一标识\",\"分布式系统\"]},\"95\":{\"h\":\"Docker框架与核心原理\",\"t\":[\"dokcer 的框架与核心概念\"]},\"96\":{\"h\":\"一、docker 镜像、容器、仓库\"},\"97\":{\"h\":\"1.1\",\"t\":[\"它是一个只读的文件和文件夹组合。它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。\",\"所以你想启动一个容器，那首先必须要有一个镜像。\"]},\"98\":{\"h\":\"1.2\",\"t\":[\"容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。\",\"即容器运行着真正的应用进程。容器有初建、运行、停止、暂停和删除五种状态。\",\"虽然容器的本质是主机上运行的一个进程，但是**容器有自己独立的命名空间隔离和资源限制。**也就是说，在容器内部，无法看到主机上的进程、环境变量、网络等信息，这是容器与直接运行在主机上进程的本质区别。\"]},\"99\":{\"h\":\"1.3\",\"t\":[\"Docker 的镜像仓库类似于代码仓库，用来存储和分发 Docker 镜像。\",\"镜像仓库分为公共镜像仓库和私有镜像仓库。目前，Docker Hub 是 Docker 官方的公开镜像仓库\"]},\"100\":{\"h\":\"二、docker 框架架构\",\"t\":[\"Docker 整体架构采用 C/S 模式，主要由客户端和服务端两大部分组成。\",\"客户端负责发送操作指令，服务端负责接收和处理指令。\"]},\"101\":{\"h\":\"2.1 docker 客户端\",\"t\":[\"有 3 种\",\"Docker cli\",\"Docker rest api\",\"语言的 SDK\"]},\"102\":{\"h\":\"2.2 docker 服务端\",\"t\":[\"Docker 服务端是 Docker 所有后台服务的统称。\",\"dockerd 是一个非常重要的后台管理进程，它负责响应和处理来自 Docker 客户端的请求，然后将客户端的请求转化为 Docker 的具体操作。\",\"dockerd 通过 grpc 与 containerd 通信\"]},\"103\":{\"h\":\"2.3 docker 重要组件\",\"t\":[\"图上有 ⬇️\",\"runc：runC 是一个用来运行容器的轻量级工具，是真正用来运行容器的。\",\"containerd：containerd 通过 containerd-shim 启动并管理 runC，可以说 containerd 真正管理了容器的生命周期。\"]},\"104\":{\"h\":\"2.4\",\"t\":[\"docker run -d busybox sleep 3600 #这个容器会在后台运行一个简单的sleep任务，即等待 3600 秒，然后停止。\",\"启动一个 busybox 容器(是一个非常小巧的 Linux 镜)，查看进程的父子关系：\",\"sudo pstree -l -a -A 4147 dockerd |-containerd --config /var/run/docker/containerd/containerd.toml --log-level info | |-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/d14d20507073e5743e607efd616571c834f1a914f903db6279b8de4b5ba3a45a -address /var/run/docker/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc | | |-sleep 3600\",\"dockerd 启动的时候， containerd 就随之启动了，dockerd 与 containerd 一直存在。\",\"当执行 docker run 命令（通过 busybox 镜像创建并启动容器）时，containerd 会创建 containerd-shim 充当 \\\"垫片\\\" 进程，然后启动容器的真正进程 sleep 3600 。\"]},\"105\":{\"h\":\"三、docker 数据管理\",\"t\":[\"在容器中管理数据主要有两种方式：\",\"数据卷（Volumes）\",\"挂载主机目录 (Bind mounts)\"]},\"106\":{\"h\":\"3.1 数据卷\",\"t\":[\"数据卷是一个可供一个或多个容器使用 的特殊目录，它绕过 UFS，可以提供很多有用的特性：\",\"数据卷 可以在容器之间共享和重用。\",\"对 数据卷 的修改会立马生效。\",\"对 数据卷 的更新，不会影响镜像 。\",\"数据卷 默认会一直存在，即使容器被删除。\"]},\"107\":{\"h\":\"创建一个数据卷\",\"t\":[\"docker volume create myVolName\"]},\"108\":{\"h\":\"查看所有数据卷\",\"t\":[\"docker volume ls\"]},\"109\":{\"h\":\"查看指定数据卷的信息\",\"t\":[\"docker volume inspect my-vol\"]},\"110\":{\"h\":\"启动一个挂载数据卷的容器\",\"t\":[\"在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。\",\"在一次 docker run 中可以挂载多个 数据卷 。\",\"下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。\",\"docker run -d -P \\\\ --name web \\\\ #-v my-vol:/wepapp \\\\ --mount source=my-vol, target=/webapp \\\\ training/webapp \\\\ python app.py\"]},\"111\":{\"h\":\"删除数据卷\",\"t\":[\"docker volume rm my-vol\"]},\"112\":{\"h\":\"3.2 目录挂载\"},\"113\":{\"h\":\"挂载一个主机目录作为数据卷\",\"t\":[\"使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。\",\"docker run -d -P \\\\ --name web \\\\ #-v my-vol:/wepapp \\\\ --mount type=bind,source=/src/webapp,target=/opt/webapp \\\\ training/webapp \\\\ python app.py\",\"上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录。\",\"这个功能在进行测试 的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。\",\"本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。\",\"Docker 挂载主机目录的默认权限是读写 ，用户也可以通过增加 readonly 指定为 只读 。\",\"加了 readonly 之后，就挂载为只读了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误\",\"touch new.txt touch: new.txt: Read-only file system\"]},\"114\":{\"h\":\"查看容器的数据卷具体信息\",\"t\":[\"docker inspect web\"]},\"115\":{\"h\":\"挂载一个本地主机文件作为数据卷\",\"t\":[\"--mount 标记也可以从主机挂载单个文件到容器中\"]},\"116\":{\"h\":\"四、docker 网络模式\"},\"117\":{\"h\":\"4.1 端口映射 外部访问容器\",\"t\":[\"以通过 -P 或 -p 参数来指定端口映射。注意大小写。\",\"当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。\",\"例子：\",\"docker run -d -p 5000:5000 此时默认会绑定本地所有接口上的所有地址。\",\"docker run -d -p 127.0.0.1:5000:5000 映射到指定地址的指定端口\",\"docker run -d -p 127.0.0.1::5000 映射到指定地址的任意端口\",\"docker run -d -p 127.0.0.1:5000:5000/udp 还可以使用 udp 标记来指定 udp 端口\",\"-p 标记还可以多次使用来绑定多个端口：\",\"docker run -d \\\\ -p 5000:5000 \\\\ -p 3000:80 \\\\\"]},\"118\":{\"h\":\"4.2 查看端口映射配置\",\"t\":[\"使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址。\"]},\"119\":{\"h\":\"4.3 容器互联\",\"t\":[\"新建容器网络，-d 参数指定 Docker 网络类型，有 bridge 、overlay。\",\"其中 overlay 网络类型用于 Swarm mode。\",\"docker network create -d bridge my-net # 运行一个容器并加入到 my-net 网络 docker run -it --rm --name busybox2 --network my-net busybox sh\"]},\"120\":{\"h\":\"4.4 网络模式\"},\"121\":{\"h\":\"基础理论\",\"t\":[\"docker 使用 Linux 桥接网卡，在宿主机虚拟一个docker 容器网桥docker0。\",\"docker 启动一个容器时会根据 docker 网桥的网段分配给容器一个 IP 地址，称为 Container-IP，同时 Docker 网桥是每个容器的默认网络网关。\",\"ip address 4: docker0: mtu 1500 qdisc noqueue state DOWN group defa ult link/ether 02:42:ef:30:24:5b brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever\",\"因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP 直接通信。\",\"docker 网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接 Container-IP 访问到容器。\",\"如果容器希望外部访问能够访问到，可以通过端口映射，即通过 -p或-P 参数来启用，访问容器的时候就通过 宿主机IP:容器端口 访问容器。\"]},\"122\":{\"h\":\"Dokcer 支持的网络模式\",\"t\":[\"Docker 网络模式\",\"配置\",\"说明\",\"host 模式\",\"-net=host\",\"容器和宿主机共享 Network namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。\",\"container 模式\",\"-net=container:NAME_or_ID\",\"容器和另外一个容器共享 Network namespace。创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围。\",\"none 模式\",\"-net=none\",\"容器有独立的 Network namespace，并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，配置 IP 等。该模式关闭了容器的网络功能。\",\"bridge 模式\",\"-net=bridge\",\"(默认模式)。此模式会为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0 虚拟网桥，通过 docker0 网桥以及 Iptable nat 表配置与宿主机通信\",\"Macvlan network\",\"无\",\"容器具备 Mac 地址，使其显示为网络上的物理设备\",\"Overlay\",\"无\",\"(覆盖网络)：利用 VXLAN 实现的 bridge 模式\"]},\"123\":{\"h\":\"Bridge 模式\",\"t\":[\"容器的默认的网络模式。该模式下的容器只有宿主机可以直接访问,外部主机是不可见的。\",\"提示\",\"Docker Daemon 利用 veth pair 技术，在宿主机上创建两个虚拟网络接口设备，假设为 veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。\",\"Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0 网桥上。保证宿主机的网络报 文可以发往 veth0;\",\"Docker Daemon 将 veth1 添加到 Docker Container 所属的 namespace 下，并被改名为 eth0。 如此一来，保证宿主机的网络报文若发往 veth0 则立即会被 eth0 接收，实现宿主机到 Docker Container 网络的联通性;同时也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性。\",\"提示\",\"当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。 这对接口一端在容器内，即 eth0 ；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT ）。\",\"通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。\"]},\"124\":{\"h\":\"Host 网络\",\"t\":[\"host 模式相当于 Vmware 中的 NAT 模式，与宿主机在同一个网络中，但 没有独立IP地址。\",\"启动容器使用 host 模式，容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。\",\"使用 host 模式的容器可以直接使用宿主机的 IP 地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行 NAT，host最大的优势就是网络性能比较好，docker host 上已经使用的端口就不能再用了，网络的隔离性不好。\"]},\"125\":{\"h\":\"Container 网络模式\",\"t\":[\"一种特殊 host 网络模式， ontainer 网络模式是 Docker 中一种较为特别的网络的模式。\",\"在容器创建时使用 – network=container:vm1 指定。(vm1 指定的是运行的容器名)处于这个模式下的 Docker 容器会共享一个网络环境,这样两个容器之间可以使用 localhost 高效快速通信。\",\"Container 网络模式没有改善容器与宿主机以外世界通信的情况(和桥接模式一样，不能连接宿主机以外的其他设备)。\",\"这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。\",\"新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。\"]},\"126\":{\"h\":\"None 模式\",\"t\":[\"none 模式可以在容器创建时通过 -- network=none 来指定。\",\"使用 none 模式，Docker 容器有自己的 Network Namespace，但不进行任何网络配置。容器无网卡、IP、路由等信息，需自行添加网卡、配置 IP。此模式下容器只有 lo 回环网络，无其他网卡。\"]},\"127\":{\"c\":[\"Docker\",\"容器技术\",\"系统架构\"]},\"128\":{\"c\":[\"Docker\",\"容器架构\",\"数据卷\",\"系统设计\"]},\"129\":{\"h\":\"Docker\",\"t\":[\"本系列包含Docker相关的技术文档和学习笔记。\"]},\"130\":{\"h\":\"Docker常用命令详解\",\"t\":[\"description: 详细介绍Docker的常用命令、容器操作及实用技巧\"]},\"131\":{\"h\":\"Docker 的常用命令\"},\"132\":{\"h\":\"1 帮助命令\",\"t\":[\"docker version # 显示docker的版本信息 docker info # 显示docker的系统信息，包括镜像和容器的数量 docker 命令 --help # 帮助命令\"]},\"133\":{\"h\":\"2 镜像命令\"},\"134\":{\"h\":\"2.1 docker images\",\"t\":[\"images 列表标签说明：\",\"REPOSITORY 镜像的仓库源\",\"TAG 镜像的标签\",\"IMAGE ID 镜像的id\",\"CREATED 镜像的创建时间\",\"SIZE 镜像的大小\"]},\"135\":{\"h\":\"2.2 docker search（搜索镜像）\",\"t\":[\"docker search redis\"]},\"136\":{\"h\":\"2.3 docker pull（下载镜像）\",\"t\":[\"# 下载镜像：docker pull 镜像名[:tag] # 两个命令是等价的 docker pull mysql docker pull docker.io/library/mysql:latest\"]},\"137\":{\"h\":\"2.4 docker rmi（删除镜像）\",\"t\":[\"[root@kryiea //]：docker rmi -f 镜像id # 删除指定的镜像 [root@kryiea //]：docker rmi -f 镜像id 镜像id 镜像id # 删除多个镜像（空格分隔） [root@kryiea //]：docker rmi -f $(docker images -aq) # 删除全部的镜像\"]},\"138\":{\"h\":\"3. 容器命令\",\"t\":[\"说明：我们有了镜像才可以创建容器， linux ，下载一个 centos 镜像来测试学习。\",\"docker pull centos\"]},\"139\":{\"h\":\"3.1 新建容器并启动\",\"t\":[\"docker run [可选参数] image # 参数说明 --name=\\\"name\\\" 容器名字：用来区分容器 -d 后台方式运行：相当于nohup -it 使用交互式运行：进入容器查看内容 -p 指定容器的端口（四种方式）小写字母p -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 容器端口 -P 随机指定端口（大写字母P）\"]},\"140\":{\"h\":\"3.2 列出所有运行的容器\",\"t\":[\"docker ps # 列出当前正在运行的容器 # 命令参数可选项 -a # 列出当前正在运行的容器+历史运行过的容器 -n=? # 显示最近创建的容器（可以指定显示几条，比如-n=1） -q # 只显示容器的编号\"]},\"141\":{\"h\":\"3.3 退出容器\",\"t\":[\"exit # 容器直接停止，并退出 ctrl+P+Q # 容器不停止，退出 [root@kryiea //]# docker run -it centos /bin/bash //交互式进入\"]},\"142\":{\"h\":\"3.4 删除容器\",\"t\":[\"docker rm 容器id # 删除容器（不能删除正在运行的容器）如果要强制删除：docker rm -f 容器id docker rm -f $(docker ps -aq) # 删除全部容器 docker ps -a -q|xargs docker rm # 删除所有容器\"]},\"143\":{\"h\":\"3.5 启动和停止容器的操作\",\"t\":[\"docker start 容器id # 启动容器 docker restart 容器id # 重启容器 docker stop 容器id # 停止当前正在运行的容器 docker kill 容器id # 强制停止当前容器\"]},\"144\":{\"h\":\"4 常用其他命令\"},\"145\":{\"h\":\"4.1 后台启动容器\",\"t\":[\"常见的坑：docker 容器使用后台运行，就必须要有要一个前台进程，docker 发现没有应用，就会自动停止。 比如：nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了\",\"# 命令docker run -d 镜像名 [root@kryiea //] docker run -d centos 5b06d0d14b3312e589a411dd9ae15589dc9321f771e5615b7ae26e85017de080 # 问题：docker ps发现centos停止了\"]},\"146\":{\"h\":\"4.2 查看日志\",\"t\":[\"docker logs -tf --tail 容器id # 显示日志 -tf # 显示日志 --tail number # 要显示的日志条数\"]},\"147\":{\"h\":\"4.3 查看容器中进程的信息\",\"t\":[\"# 命令 docker top 容器id [root@kryiea ~] docker top 25eb9d70b2b4 UID PID PPID C STIME TTY TIME CMD systemd+ 181442 181422 0 09:47 ? 00:00:00 redis-server *:6379\"]},\"148\":{\"h\":\"4.4 查看镜像的元数据\",\"t\":[\"docker inspect 容器id\"]},\"149\":{\"h\":\"4.5 进入当前正在运行的容器\",\"t\":[\"# 方式一 docker exec -it 容器id /bin/bash # 方式二 docker attach 容器id docker exec # 进入容器后开启一个新的终端，可以再里面操作（常用） docker attach # 进入容器正在执行的终端，不会启动新的进程。\"]},\"150\":{\"h\":\"4.6 从容器内拷贝文件到主机\",\"t\":[\"docker cp 容器id:容器内路径 目的主机的路径\"]},\"151\":{\"c\":[\"Docker\",\"容器技术\"]},\"152\":{\"c\":[\"Docker\",\"命令行\",\"容器管理\",\"DevOps\"]},\"153\":{\"h\":\"Go\",\"t\":[\"本系列包含Go语言相关的技术文档和学习笔记。\"]},\"154\":{\"h\":\"Java\",\"t\":[\"本系列包含Java相关的技术文档和学习笔记。\"]},\"155\":{\"h\":\"Kafka 架构\",\"t\":[\"本文详细介绍了Kafka的整体架构设计，包括生产者、服务层和消费者的工作原理。\"]},\"156\":{\"h\":\"一、整体架构\",\"t\":[\"可以把 Kafka 宏观分成3层：生产者、服务层、消费者\",\"Producer：很好理解，就是生产者，在Kafka中，Producer负责创建消息并将其发送到Kafka服务器。Producer是消息的源头，它们将消息发送到特定的主题中，以供Consumer订阅和消费。\",\"Server：即Kafka服务，可以认为是消息的中转站，因为消息不是从生产者直接发送到消费者的，而是先经过一个中转站存放，就像生活中的菜鸟驿站一样Kafka的服务端就担任了菜鸟驿站的角色，但跟菜鸟驿站不同的一点是Server会持久化存储信息，不是说消费了就没有了。\",\"Consumer：即消费者，是Kafka中的另一个重要角色，它们负责订阅主题并消费其中的消息，当生产者向Server传递了消息之后，如果是消费者订阅了对应的主题，那么消费者就会从Server拉取消息做业务处理。\",\"Kafka整体架构图\"]},\"157\":{\"h\":\"二、服务层的内部架构\",\"t\":[\"服务层的内部组成比较丰富：\",\"Broker：可以理解为机器或者节点吧，也可以理解为就是运行Kafka程序的服务器。\",\"Topic：主题是Kafka中的一个核心概念，它是对消息进行分类的一种方式。生产者将消息发送到特定的主题中，而消费者则通过订阅主题来接收相关的消息。但是要注意的是，主题是一个逻辑概念，实际上，一个主题可以被分为多个分区(Partition)，以实现消息的并行处理和负载均衡，数据是存储在Partition这个级别的。\",\"Partition：分区是Kafka中的一个重要概念，它是主题的物理存储单位。每个分区都是一个有序的、不可变的消息序列，可以被独立地读写。分区在物理上对应一个文件夹及文件夹下面的文件，分区的命名规则为主题名称后接\\\"一\\\"连接符，之后再接分区编号，比如TopicA-1就表示主题A得1号分区，每个分区又可以有一至多个副本(Replica)，以提高可用性。\"]},\"158\":{\"h\":\"三、Producer\",\"t\":[\"提示\",\"待补充Producer相关内容\"]},\"159\":{\"h\":\"四、Server\",\"t\":[\"提示\",\"待补充Server相关内容\"]},\"160\":{\"h\":\"五、Consumer\",\"t\":[\"消费者通过订阅topic，主动拉取消息，消费信息\"]},\"161\":{\"h\":\"1. 消费形式\",\"t\":[\"不同消费者可以在同一时间对同一主题进行消费\",\"同一消费者可以同一时间从同一主题的不同分片读取信息\",\"如果一个消费者，同时消费多个分片下，无法保证消息之间的先后顺序\",\"如果一个消费者，只消费一个分片，消费顺序即生产顺序，符合队列的先入先出特性\",\"消费形式示意图\"]},\"162\":{\"h\":\"2. 消费是主动拉取\",\"t\":[\"Kafka是需要消费者主动去Broker拉取消息回来消费的。\",\"这样可以让消费者按照自身情况来控制消费速度，根据自身的资源利用情况、业务需要等等因素合理拉取消息。\",\"消费者拉取的频率：max.poll.records，这个参数限制每次拉取返回的消息数量。\"]},\"163\":{\"h\":\"3. Offset 消息偏移\",\"t\":[\"每条消息在Kafka中会有Partition ID以及OFFSET，通过这两个信息就可以定位到一条消息。\",\"消费者消费消息之后会提交它在某个Partition对应的OFFSET，这样子下一次就可以从这个位置开始消费。\",\"同时，如果一个指定的offset被确认，那么它之前的信息就相当于都确认了，下次消费是从它的下一条消息开始消费。\",\"提交的动作可以是自动周期性进行，也就是每个周期会提交最新的已处理消息。\",\"Offset消息偏移示意图\"]},\"164\":{\"h\":\"4. 消费者组\",\"t\":[\"Kafka 支持组消费\",\"消费者组的意思是将多个消费者组织在一起工作，构成一个小组\",\"一个组由一个groupID唯一标识，由消费者这边指定\",\"组消费的情况：\",\"同一个消费组中，每个分片只会分配给一个消费者\",\"同一个消费组中，消费者可以被指派多个分片\",\"不同消费组可以同一时间消费同一个主题\",\"消费者组示意图\",\"使用消费者组的优势\",\"当不使用消费者组时，Kafka不会自动管理分区和消费者之间的关系，需要手动指定消费者要消费的分区，这就意味着如果Partition数量变了，消费者代码就得跟着升级，没法做到自动切换。\"]},\"165\":{\"h\":\"5. 消费者组的分配策略、再平衡策略\",\"t\":[\"一个消费者组里有多个消费者，分区是按什么规则来分配给这些消费者的呢?\",\"我们可以关注消费端partition.assignment.strategy这个配置，这个参数就是分区的策略，它有如下几种选择:\",\"Range Assignor：基于范围的分配策略，将分区按照范围分配给消费者\",\"RoundRobin Assignor：基于轮询的分配策略，分区均匀地分配给消费者\",\"Sticky Assignor：优先保持当前的分配状态，并尽量减少在再平衡过程中的分区移动\",\"CooperativeStickyAssignor：和Sticky Assignor的策略是一样，区别在于未受变动的消费者可以继续消费主题\",\"触发再平衡的情况\",\"新消费者加入： 当一个新的消费者加入消费者组时，Kafka需要重新分配分区，以包括新的消费者\",\"消费者离开： 当一个消费者离开(无论是正常关闭还是崩溃)时，需要重新分配该消费者负责的分区给其他消费者\",\"主题分区变化： 当主题的分区数量发生变化时(例如，增加新的分区)Kafka需要重新分配这些分区\",\"再平衡过程\",\"暂停消费： 在再平衡过程中，消费者会暂停对消息的消费，以防止在重新分配期间发生数据丢失或重复\",\"触发再平衡： 由消费者组协调器(通常是Kafka集群中的一个Broker)触发再平衡\",\"重新分配分区： 协调器根据当前消费者组的成员重新分配主题的分区\",\"通知消费者： 重新分配完成后，协调器会通知所有消费者新的分配情况\",\"恢复消费： 消费者收到新的分配后，恢复消费，开始处理被分配到的新分区\"]},\"166\":{\"c\":[\"消息队列\"]},\"167\":{\"c\":[\"Kafka\",\"架构设计\",\"分布式系统\"]},\"168\":{\"h\":\"Kafka 高可用\",\"t\":[\"本文详细介绍了Kafka的副本机制、高可用架构及数据同步原理，帮助读者深入理解Kafka的容灾能力。\"]},\"169\":{\"h\":\"一、Kafka 的副本机制\",\"t\":[\"Kafka 是天然提供容灾解决方案的，通过多副本机制来实现容灾。\"]},\"170\":{\"h\":\"1. Kafka 副本的概念\",\"t\":[\"Replica： Replica是指Kafka集群中的一个副本，它可以是Leader的副本或者Follower的副本的一种。每个分区都有多个副本，其中一个是Leader的副本，其余的是Follower的副本。每个副本都保存了分区的完整数据，以保证数据的可靠性和高可用性。\",\"Leader： Leader是指Kafka集群中的一个分区副本，它负责处理该分区的所有读写请求。Leader副本是唯一可以自主向分区写入数据的副本，它将写入的数据都会同步到所有的Folower副本中，以保证数据的可靠性和一致性。leader副本必须在leader节点中。\",\"Folower： Follower是指Kafka集群中的一个分区副本，Follower副本不能直接向分区写入数据，它只能从Leader副本中复制数据，并将数据同步到本地的副本中，以保证数据的可靠性和一致性。在Leader副本挂掉的时候Follower副本有机会被选举为新的leader副本从而保证分区的可用性。\"]},\"171\":{\"h\":\"2. 易混淆的概念\"},\"172\":{\"h\":\"2.1 分区和副本\",\"t\":[\"分区（Partition）：Kafka中的每个主题（Topic）可以被划分为多个分区。每个分区内是一个有序的、不可变的消息序列，这些消息存储在Kafka集群的不同节点（broker）上。\",\"副本（Replica）：为了实现高可用性和数据冗余，每个分区的数据会被复制到多个节点上。每个分区的副本包括一个Leader副本和多个Follower副本。\"]},\"173\":{\"h\":\"2.2 Leader 节点和 Follower 节点\",\"t\":[\"Leader 节点：负责处理读写请求的分区主节点。\",\"Follower 节点：从 Leader副本 复制数据的分区从节点。\"]},\"174\":{\"h\":\"2.3 Leader 副本和 Follower 副本\",\"t\":[\"Leader副本：这是当前分区的主副本，负责处理所有的读写请求。Leader副本存储在被选为该分区Leader的节点上。\",\"Follower副本：这是从副本，从Leader副本复制数据，以保持数据的一致性和冗余。Follower副本存储在其他节点上。\"]},\"175\":{\"h\":\"2.4 Leader 副本只能存储在 Leader 节点上\",\"t\":[\"集中处理：Leader节点负责处理所有的写请求和读请求，这样可以集中管理数据的更新和读取，简化了数据一致性管理。\",\"减少延迟：由于读写请求直接由Leader节点处理，避免了在多个节点之间进行额外的网络通信，从而减少了延迟，提高了性能。\"]},\"176\":{\"h\":\"3. Kafka 的副本机制优势\",\"t\":[\"Kafka 是支持多副本的，发生了一定的异常也可以保证系统正常运作，Kafka 的多副本机制大致有如下优势：\",\"高可用性： 如果 Leader 副本所在的 Broker 宕机，Kafka 会自动从其它副本中选取一个新的 Leader，确保服务的持续性，具体选择规则我们后面会介绍。\",\"容灾： 即使部分副本数据丢失，只要有一个副本是完整的，数据就不会丢失，简单来说就是多备份情况下数据丢失风险变小。\",\"读性能提升： 默认情况下，虽然数据的多个副本可以分布在不同的 broker 上，但是Kafka都是Leader提供读写，如果特定业务需要，也可以让消费者从Follower上读数据，增加读的并发度。\"]},\"177\":{\"h\":\"4. 为用户的消息创建多副本\",\"t\":[\"注意\",\"分区的副本数量必须小于等于Broker的数量，比如只有1个Broker，却想为分区创建2个副本，会报错。\",\"使用kafka-topics.sh脚本，并指定Topic名称、副本个数和分区数：\",\"./kafka-topics.sh --create -bootstrap-server locahost:9092 --topic niugetest4 --partitions 2 --replication-factor 2\",\"如下图：\",\"对于 TopicA 的 partition0 来说\",\"Broker10 是 Leader 节点，Broker10 的 TopicA-Partition0 是 Leader 副本\",\"Broker11 是 Follower 节点，Broker11 的 TopicA-Partition0 是 Follower 副本\",\"数据持久化过程：不光写入Broker10上的Topic-A Partition0，还会最终同步到Broker11上的Topic-A Partition0\",\"副本创建示意图\"]},\"178\":{\"h\":\"5. 为Kafka内部的Topic配置多副本\",\"t\":[\"提示\",\"待补充内容\"]},\"179\":{\"h\":\"二、多副本的写入机制\"},\"180\":{\"h\":\"1. 写入机制\",\"t\":[\"总结\",\"数据是直接往Leader写入，写入之后Leader和Folower之间会进行同步，是否要等待同步完成取决于选择哪种写入策略（acks）。\",\"Kafka 会在诸多分区中选举一个分区作为主节点（Leader），它的副本作为Leader副本，负责接收生产者的消息并处理读写请求。\",\"其他的副本是从副本，从Leader副本复制数据，保持只读。当主节点掉线后，有机会被选举成为新的主节点，去负责读写请求。Follower副本存储在其他节点上。\",\"对于生产者来说，主节点是可见的，副节点是透明的。\"]},\"181\":{\"h\":\"2. 副本管理机制\",\"t\":[\"一个分区会有多个副本，为了对这些副本更好的管理，Kafka 会对所有副本进行划分，对应不同的集合。\",\"AR 集合\",\"AR 是指分区的所有副本，包括 Leader 副本和 Follower 副本，也就是整体的集合。\",\"ISR 集合\",\"ISR 是指与 Leader 副本保持同步的副本集合，或者说是跟得上节奏的副本集合。\",\"ISR 中的副本与 Leader 副本保持同步，即它们已经复制了 Leader 副本中的所有数据，并且与 Leader 副本之间的数据差异不超过一定的阈值（Follower 副本能够落后 Leader 副本的最长时间间隔）。\",\"ISR 副本集合是动态变化的，不是一成不变的。除非开启了 Unclean 选举，否则只有处于 ISR 中的副本才有可能被选举为新的 Leader 副本，以保证分区的正常运行。\",\"OSR 集合\",\"OSR 是指与 Leader 副本不同步的副本集合，也就是跟不上节奏的副本\",\"OSR 中的副本与 Leader 副本之间的数据差异超过了一定的阈值，或者它们还没有复制 Leader 副本中的所有数据。除非开启了 Unclean 选举，否则 OSR 中的副本不能被选举为新的 Leader 副本。\",\"简单来说：\",\"副本集合关系图\"]},\"182\":{\"h\":\"3. ISR 的动态调整\",\"t\":[\"每个Partition都会由Leader 动态维护一个与自己基本保持同步的ISR列表。\",\"所谓动态维护，就是说如果一个Follower比一个Leader落后超过了给定阈值，默认是10s，则Leader将其从ISR中移除。\",\"如果OSR列表内的Follower副本与Leader副本保持了同步，那么就将其添加到ISR列表当中。\"]},\"183\":{\"h\":\"4. ISR 为空，新 Leader 如何选举\",\"t\":[\"可以通过配置参数 unclean.leader.election来决定是否从OSR中选举出leader：\",\"true： 允许 OSR 成为 Leader，但是 OSR 的消息较为滞后，可能会出现消息丢失的问题\",\"false： 坚决不能让那些OSR竞选Leader。这样做的后果是这个分区就不可用\"]},\"184\":{\"h\":\"三、副本间的同步机制\",\"t\":[\"提示\",\"待补充内容\"]},\"185\":{\"h\":\"四、副本间的同步机制 - 优化\",\"t\":[\"提示\",\"待补充内容\"]},\"186\":{\"c\":[\"消息队列\"]},\"187\":{\"c\":[\"Kafka\",\"高可用\",\"分布式系统\"]},\"188\":{\"h\":\"Kafka\",\"t\":[\"本系列包含Kafka相关的技术文档和学习笔记。\"]},\"189\":{\"h\":\"Linux\",\"t\":[\"本系列包含Linux相关的技术文档和学习笔记。\"]},\"190\":{\"h\":\"Linux Shell用户和组管理详解\",\"t\":[\"Shell、用户和组\",\"Shell\",\"shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。有时，人们也称之为命令解释器。\",\"对 UNIX 系统而言，shell 只是一个用户进程。\",\"纵观 UNIX 历史，出现过以下几种重要的 shell。\",\"Bourne shell（sh）\",\"由 Steve Bourne 编写的 shell 历史最为悠久，且应用广泛，曾是第七版 UNIX 的标配 shell。Bourne shell 包含了在其他 shell 中常见的许多特性，I/O 重定向、管道、文件名生成（通配符）、变量、环境变量处理、命令替换、后台命令执行以及函数。\",\"Bourne again shell（bash）\",\"这款 shell 是 GNU 项目对 Bourne shell 的重新实现。Bash 提供了与 C shell 和 Korn shel 所类似的交互式特性。Brian Fox 和 Chet Ramey 是 bash的主要作者。bash 或许是 Linux 上应用最为广泛的 shell 了。在 Linux 上，Bourne shell （sh）其实正是由 bash 仿真提供的。\",\"C shell（csh）\",\"Korn shell（ksh）\",\"用户和组\",\"系统会对每个用户的身份做唯一标识，用户可隶属于多个组。\",\"用户\",\"系统的每个用户都拥有唯一的登录名（用户名）和与之相对应的整数型用户ID（UID）。\",\"存储在系统密码文件：/etc/passwd\",\"一个典型的 /etc/passwd 文件中的一行示例：\",\"username:x:1001:1001:User Name,,,:/home/username:/bin/bash\",\"每一行代表一个用户账户，字段之间用冒号（:）分隔。典型的字段包括：\",\"用户名\",\"密码占位符（通常是一个 \\\"x\\\" 或 \\\"*\\\"，实际密码存储在 /etc/shadow 文件中）\",\"用户ID（UID）\",\"组ID（GID）\",\"用户的描述信息（例如全名）\",\"用户的主目录路径\",\"用户的默认shell\",\"...\",\"组\",\"一个用户可以同时属于多个组。\",\"/etc/group 文件用于存储系统上所有用户组的信息。每一行代表一个用户组，字段之间用冒号（:）分隔。典型的字段包括：\",\"组名\",\"密码占位符（通常是一个 \\\"x\\\" 或 \\\"*\\\"，实际密码如果有的话存储在 /etc/gshadow 文件中）\",\"组ID（GID）\",\"组成员列表（以逗号分隔的用户名）\",\"以下是一个典型的 /etc/group 文件中的一行示例：\",\"groupname:x:1001:user1,user2,user3\",\"groupname 是组名。\",\"x 是密码占位符。\",\"1001 是组ID（GID）。\",\"user1,user2,user3 是属于该组的用户列表。\",\"...\",\"超级用户 root\",\"超级用户在系统中享有特权。超级用户账号的用户 ID 为 0，通常登录名为 root。\",\"超级用户都可以访问系统中的任何文件，也能发送信号干预系统运行的所有用户进程。\",\"系统管理员可以使用超级用户账号来执行各种系统管理任务。\"]},\"191\":{\"c\":[\"Linux\",\"系统管理\"]},\"192\":{\"c\":[\"Linux\",\"Shell\",\"用户管理\",\"权限管理\"]},\"193\":{\"h\":\"Linux常用命令详解\",\"t\":[\"本文详细介绍了Linux系统中常用的命令及其用法，帮助您高效地进行系统管理和日常操作。\"]},\"194\":{\"h\":\"1. 系统监控命令\"},\"195\":{\"h\":\"1.1 查看CPU占用率和进程PID\",\"t\":[\"top - 动态显示系统进程\",\"ps - 显示当前进程状态\"]},\"196\":{\"h\":\"1.2 查看进程的线程\",\"t\":[\"先找到进程的PID，然后：\",\"ps -T -p <pid>\"]},\"197\":{\"h\":\"1.3 查看端口被哪个进程占用\",\"t\":[\"netstat -napt | grep <端口号>\",\"lsof -i:<端口号>\"]},\"198\":{\"h\":\"1.4 查看进程占用的端口\",\"t\":[\"netstat -tulnp | grep <PID>\"]},\"199\":{\"h\":\"1.5 查看TCP状态\",\"t\":[\"netstat -napt | grep <端口号>\",\"ss -t\"]},\"200\":{\"h\":\"2. 目录和文件操作命令\"},\"201\":{\"h\":\"2.1 目录操作\",\"t\":[\"ls（list files）: 列出目录及文件名 \",\"-a：显示全部文件，包括隐藏文件（开头为.的文件）\",\"-d：仅列出目录本身，不列出目录内的文件数据\",\"-l：长格式列出，包含文件的属性与权限等数据\",\"cd（change directory）：切换目录\",\"pwd（print work directory）：显示当前目录\",\"mkdir（make directory）：创建一个新的目录\",\"rmdir（remove directory）：删除一个空的目录\"]},\"202\":{\"h\":\"2.2 文件操作\",\"t\":[\"cp（copy file）: 复制文件或目录\",\"rm（remove）: 删除文件或目录 \",\"-f：强制删除，忽略不存在的文件，不提示警告\",\"-i：互动模式，删除前会询问用户是否确认\",\"-r：递归删除，用于删除目录及其内容（危险选项！）\",\"mv（move file）: 移动文件与目录，或修改文件与目录的名称\"]},\"203\":{\"h\":\"3. 系统管理命令\"},\"204\":{\"h\":\"3.1 关机重启命令\",\"t\":[\"关闭和重启系统前应先运行sync命令，将内存数据同步到磁盘（现代系统中shutdown/reboot/halt等命令会自动执行sync）\",\"sync - 将内存数据同步到磁盘\",\"shutdown -h now - 立即关机\",\"shutdown -h 1 - 一分钟后关机\",\"shutdown -r now - 立即重启\",\"halt - 关机\",\"reboot - 立即重启计算机\"]},\"205\":{\"h\":\"3.2 用户登录、注销和切换\",\"t\":[\"su - 用户名 - 切换账号（高权限到低权限无需密码）\",\"logout - 注销当前登录用户\"]},\"206\":{\"h\":\"4. 用户和用户组管理\"},\"207\":{\"h\":\"4.1 用户管理\",\"t\":[\"添加用户后会自动创建和用户同名的home目录（/home/用户名）\",\"useradd 用户名 - 添加用户\",\"useradd -d 指定目录 新的用户名 - 添加用户并指定home目录\",\"passwd 用户名 - 更改用户密码（不指定用户名则更改当前账户）\",\"userdel 用户名 - 删除用户但保留家目录\",\"userdel -r 用户名 - 删除用户和家目录\",\"whoami - 查看当前用户\"]},\"208\":{\"h\":\"4.2 用户组管理\",\"t\":[\"groupadd 组名 - 新增组\",\"groupdel 组名 - 删除组\",\"useradd -g 用户组 用户名 - 新增用户同时加入指定组\",\"usermod -g 用户组 用户名 - 修改用户的组\"]},\"209\":{\"h\":\"5. 文件目录操作指令\",\"t\":[\"touch 文件名+后缀 - 创建一个空文件\",\"cp 文件名 目标路径 - 复制文件\",\"/cp 文件名 目标路径 - 强制覆盖复制\",\"rm [选项] 要删除的文件或目录\",\"-r：递归删除整个文件夹\",\"-f：强制删除不提醒\",\"mv 旧文件名 新文件名 - 重命名文件\",\"mv 旧路径 新路径 - 移动文件\",\"more和less - 查看文件内容（less是按需加载，对大文件效率更高）\",\"echo [选项] 输出内容 - 输出内容到控制台（如：echo $PATH）\",\"echo 内容 > 目标文档 - 输出内容到文档\",\"cat 文件名 - 查看文件内容\",\"ln -s [原文件或目录] [软链接目录+文件名] - 创建软链接（如：ln -s /root /home/myroot）\"]},\"210\":{\"h\":\"6. 时间日期命令\",\"t\":[\"date - 显示当前时间\",\"date +%Y - 显示年份\",\"date +%m - 显示月份\",\"date -s \\\"2022-11-03 20:02:11\\\" - 设置系统时间\"]},\"211\":{\"h\":\"7. 搜索查找命令\",\"t\":[\"find [路径] [选项] - 查找文件 \",\"-name - 按名字查找\",\"-user - 按用户名查找\",\"-size - 按文件大小查找\",\"示例：find /aaa/ -name 1.cpp\",\"which 指令名字 - 查找指令所在的目录（如：which ls）\",\"grep - 与管道符 | 一起使用进行文本搜索 \",\"示例：cat /home/hello.txt | grep \\\"搜索的字符串\\\"\"]},\"212\":{\"c\":[\"Linux\",\"系统管理\"]},\"213\":{\"c\":[\"Linux\",\"命令行\",\"系统管理\",\"Shell\"]},\"214\":{\"h\":\"Vim编辑器命令详解\",\"t\":[\"vim 命令\",\"2yy 复制2行\",\"2dd 删除2行\",\"G 跳到文末\",\"gg跳到文首\",\"20shift+g 跳到第20行\",\"：q！ 不保存退出\",\"：wq 写入后退出\",\"u 撤销操作\",\"/关键字 查找关键字\"]},\"215\":{\"c\":[\"Linux\",\"工具\"]},\"216\":{\"c\":[\"Vim\",\"Linux\",\"编辑器\",\"命令行\"]},\"217\":{\"h\":\"Linux内存管理详解\",\"t\":[\"内存管理\",\"一、虚拟内存\",\"1.1 为什么需要虚拟内存\",\"前提：单片机的 CPU 是直接操作内存的 物理地址。\",\"问题：想在单片机的内存中同时运行两个程序是做不到的。\",\"原因：单片机没有操作系统，每次写完代码都要借助工具把程序烧录进去，直接使用绝对物理地址。\",\"虚拟内存有什么作用？\",\"第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。\",\"第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。\",\"第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。\",\"1.2 虚拟内存的实现方式\",\"1.2.1 内存分段管理\",\"分段机制下的虚拟地址：\",\"段选择因子 ➕ 段内偏移量。\",\"虚拟地址和物理地址如何映射：\",\"段选择因子：保存在段寄存器里面。\",\"段选择因子里面最重要的是段号，用作段表的索引。\",\"段表里面保存的是这个段的基地址、段的界限和特权等级等。\",\"段内偏移量：虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。\",\"...\",\"不足之处：\",\"内存碎片的问题。（外部碎片）\",\"内存交换的效率低的问题。\",\"对于多进程的系统来说，用分段的方式，外部内存碎片是很容易产生的，产生了外部内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。\",\"如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。\",\"1.2.2 内存分页管理\",\"分段管理的不足：\",\"分段的好处就是能产生连续的内存空间，但是会出现外部内存碎片和内存交换的空间太大的问题。\",\"1.2.2.1 单页表的实现方式\",\"分页机制：\",\"分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。\",\"在 Linux 下，每一页的大小为 4KB。\",\"分页机制下内存如何映射\",\"虚拟地址分为两部分，页号 ➕ 页内偏移。\",\"页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。\",\"页表是存储在内存里的，内存管理单元（MMU）完成映射的工作。\",\"当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。\",\"...\",\"不足之处：\",\"出现内部碎片：分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费。\",\"多进程的系统中页表可能会占用大量内存：\",\"在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB，需要 4MB 的内存来存页表。\",\"每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了。\",\"1.2.2.2 多级页表的实现方式（知道）\",\"解决单页表的内存占用问题。\",\"二级分页\",\"将一级页表分为 1024 个二级页表\",\"每个表二级页表中包含 1024 个页表项\",\"...\",\"1.2.2.3 TLB - Translation Lookaside Buffer\",\"程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。\",\"多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。\",\"那把最常访问的几个页表项存储到访问速度更快的硬件，在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache。\",\"这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。\",\"...\",\"1.2.3 段页式内存管理\",\"段页式内存管理实现的方式：\",\"先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；\",\"接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；\",\"这样，地址结构就由段号、段内页号、页内位移三部分组成。\",\"段页式地址变换中要得到物理地址须经过三次内存访问：\",\"第一次访问段表，得到页表起始地址；\",\"第二次访问页表，得到物理页号；\",\"第三次将物理页号与页内位移组合，得到物理地址。\",\"...\",\"二、Linux 内存管理\",\"2.1 Linux 的虚拟地址空间是如何分布的\",\"2.1.1 虚拟地址空间如何划分\",\"地址空间通常分为两部分：\",\"**内核空间：**用于操作系统内核和内核模块。内核空间是全局共享的，所有进程都可以访问相同的内核地址空间，但通常只有内核态代码才能访问内核空间。\",\"**用户空间：**用于运行用户态的应用程序。用户空间中的每个进程都有其独立的虚拟地址空间，不同进程间的用户空间是相互隔离的。\",\"...\",\"2.1.2 用户空间如何划分\",\"在Linux操作系统中，每个进程都有自己独立的虚拟地址空间。这意味着每个进程都有一份独立的用户空间划分，包括代码段、数据段、堆、栈等。\",\"...\",\"以 32 位系统为例，每个进程的用户空间划分的情况（高地址 -- > 低地址）：\",\"**内核空间：**所有进程共享内核的代码和数据，独享与进程相关的数据结构\",\"**栈段：**包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；从高地址往低地址增长\",\"**文件映射段：**包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 (opens new window)）；\",\"**堆段：**包括动态分配的内存，从低地址开始向上增长；\",\"**BSS 段：**包括未初始化的静态变量和全局变量；\",\"**数据段：**包括已初始化的静态常量和全局变量；\",\"**代码段：**包括二进制可执行代码；\",\"堆和文件映射段的内存是动态分配的。\",\"比如说，使用 C 标准库的 malloc() 或者 mmap()，就可以分别在堆和文件映射段动态分配内存。\",\"...\",\"2.2 Linux 如何分配虚拟内存\",\"2.2.1 malloc() 如何分配虚拟内存\",\"2.2.1.1 malloc 涉及的两种系统调用\",\"malloc申请内存的时候，会有两种方式向操作系统申请堆内存。\",\"**方式一：**通过 brk() 系统调用从堆分配内存\",\"free内存后堆内存还存在，放在malloc的内存池里。\",\"将堆顶指针向高地址移动，获得新的内存空间。\",\"...\",\"**方式二：**通过 mmap() 系统调用在文件映射区域分配内存；不连续的哦！！！！\",\"free释放内存后就会归还给操作系统\",\"在文件映射区分配一块内存，也就是从文件映射区\\\"偷\\\"了一块内存。\",\"...\",\"2.2.1.2 两种系统调用的阈值\",\"malloc() 源码里默认定义了一个阈值：\",\"如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；\",\"如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；\",\"不同的 glibc 版本定义的阈值也是不同的。\",\"2.2.1.3 两种系统调用的异同\",\"不同：\",\"申请的内存位置不同\",\"brk()在堆上\",\"mmap()在文件映射区域\",\"free()释放内存的处理不同\",\"brk()申请的内存不会归给操作系统，先放在malloc的缓冲区，下次再有申请的时候可以直接使用。\",\"mmap()申请的内存会马上归还给操作系统\",\"共同：\",\"malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节\",\"多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。\",\"当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存\",\"...\",\"2.2.1.4 两种系统调用的设计目的\",\"问题：malloc()函数会在＞某个阈值的时候，通过系统调用mmap()来申请内存而不是brk()，而mmap()又会申请文件映射区域的虚拟内存返回，为什么要这么设计？\",\"2.3 Linux 的 swap 机制\",\"2.3.1 swap 机制工作原理\",\"内存页的分类:\",\"活跃页（Active Pages）: 最近被访问过的内存页，系统认为它们可能会被再次访问。\",\"非活跃页（Inactive Pages）: 最近未被访问的内存页，系统认为它们不太可能被立刻访问。\",\"交换空间（Swap Space）:\",\"交换空间通常是一个专用的磁盘分区或文件，用于存储被交换出去的内存页。\",\"页交换（Paging）:\",\"当系统的物理内存不足时，内核会选择一些非活跃页，将它们从物理内存中移出，写入到交换空间。\",\"当这些页再次被访问时，内核会将它们从交换空间读回物理内存。如果物理内存仍然不足，内核可能会继续交换出其他非活跃页。\",\"三、数组的物理空间连续？\",\"数组的虚拟地址是连续的，对于程序而言，只知道虚拟地址空间，物理地址对程序不可见。\",\"虚拟地址到物理地址的映射是操作系统负责的。\",\"四、用户空间的栈和堆区有什么区别\",\"增长方向不同\",\"内存回收策略不同，栈自动分配和回收，堆是手动申请和释放（c语言malloc()会有两种堆内存申请策略，对应两个系统调用brk和mmap，所以堆的释放也是有区别的）\",\"大小不同：栈一般是8MB（linux下），堆则受虚拟内存大小影响\",\"五、栈上操作比堆要快，为什么\",\"栈有寄存器直接对栈进行访问（esp、ebp），所以快。\",\"堆的数据需要通过指针访问（操作系统管理堆内存是有一个链表的，记录指针），将指针放在寄存器，再去取出这个地址的值，涉及到间接寻址。\",\"六、64 位和 32 位的操作系统，物理内存为4GB，申请 8G 的内存有什么区别\",\"32 位的操作系统，最大可用虚拟内存只有 4GB， 申请8GB的话会在申请阶段就失败\",\"64 位的操作系统，最大可用虚拟内存有 128TB， 申请8GB的话要考虑是否开启swap分区：\",\"未开启swap：由于物理内存不够，进程会被操作系统杀掉（kill），原因是：OOM（内存溢出）。\",\"开启了swap：可以正常使用8GB内存，进程可以正常运行。\",\"七、swap 区是动态调整的吗\",\"Macos 是会动态增长，每次1GB。\",\"Linux 不会自动增长，需要手动管理。\",\"八、fork 的写时复制\",\"Fork 创建子进程的时候，只会复制虚拟内存，不会复制物理内存。因此会先共享这份物理内存。\",\"当父/子进程进行写操作的时候，才会复制物理内存。\",\"...\",\"未发生写操作\",\"...\",\"发生了写操作\"]},\"218\":{\"c\":[\"Linux\",\"操作系统\"]},\"219\":{\"c\":[\"Linux\",\"内存管理\",\"虚拟内存\",\"系统优化\"]},\"220\":{\"h\":\"Linux内核态与用户态\",\"t\":[\"内核态与用户态\",\"操作系统：完整的软件包，这包括用来管理计算机资源的核心层软件，以及附带的所有标准软件工具，诸如命令行解释器、图形用户界面、文件操作工具和文本编辑器等。\",\"内核：管理和分配计算机资源（即CPU、RAM 和设备）的核心层软件\",\"Linux 内核：可执行文件采用/boot/vmlinuz 或与之类似的路径名。\",\"内核的重要职责：\",\"进程调度\",\"内存管理\",\"文件系统\",\"内核态和用户态\",\"现代处理器架构一般允许 CPU 至少在两种不同状态下运行，即：用户态和核心态（有 时也称之为监管态 supervisor mode）。执行硬件指令可使 CPU 在两种状态间来回切换。\",\"在用户态下运 行时，CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常。\",\"核心态时，CPU 既能访问用户空间内存，也能访问内核空间内存\"]},\"221\":{\"c\":[\"Linux\",\"操作系统\"]},\"222\":{\"c\":[\"Linux\",\"内核态\",\"用户态\",\"系统调用\"]},\"223\":{\"h\":\"Linux文件系统详解\",\"t\":[\"文件系统\",\"...\",\"😁 /bin 、😁 /sbin\",\"bin是 Binary的缩写，存放着可执行文件或可执行文件的链接（类似快捷方式\",\"Linux不按后缀识别文件类型，/bin目录中的文件都是可执行的二进制文件，而不是文本文件。\",\"...\",\"sbin是 System Binary的缩写，这里存放的命令可以对系统配置进行操作。\",\"...\",\"😁/run、😁/sys\",\"用来存储某些程序的运行时信息和系统需要的一些信息。比如说这个文件： 里面存储着一个数字，是你的显卡亮度，你修改这个数字就可以修改屏幕亮度。 需要注意的是，这两个位置的数据都存储在内存中，所以一旦重启，/run 和 /sys 目录的信息就会丢失，所以不要试图在这里存放任何文件。\",\"sudo vim /sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-eDP-1/intel\\\\_backlight/brightness\",\"😁 /boot\",\"这里是系统启动需要的文件，你可以看到 grub 文件夹，它是常见的开机引导程序。我们不应该乱动这里的文件。\",\"...\",\"😁 /dev\",\"dev 是 device 的缩写，这里存放所有的设备文件。\",\"Linux 中，所有东西都是以文件的形式存在的，包括硬件设备。\",\"鼠标、键盘等等设备也都可以在这里找到。\",\"比如说，sda, sdb 就是我电脑上的两块硬盘，后面的数字是硬盘分区：\",\"...\",\"😁/etc\",\"如果你要修改一些系统程序的配置，十有八九要到 etc 目录下寻找。\",\"这个目录经常使用，存放很多程序的配置信息，比如包管理工具 apt：\",\"...\",\"在 /etc/apt 中就存放着对应的配置，比如说镜像列表\",\"...\",\"😁/lib\",\"lib是 Library 的缩写，类似于 Windows 系统中存放 dll 文件的库，包含 bin 和 sbin 中可执行文件的依赖。\",\"也可能出现 lib32 或 lib64 这样的目录，和 lib 差不多，只是操作系统位数不同而已\",\"😁/media\",\"这里会有一个以你用户名命名的文件夹，里面是自动挂载的设备，比如 U 盘，移动硬盘，网络设备等。\",\"比如说我在电脑上插入一个 U 盘，系统会把 U 盘自动给我挂载到 /media/fdl 这个文件夹里（我的用户名是 fdl），如果我要访问 U 盘的内容，就可以在那里找到\",\"😁/mnt\",\"这也是和设备挂载相关的一个文件夹，一般是空文件夹。\",\"media 文件夹是系统自动挂载设备的地方，这里是你手动挂载设备的地方。\",\"比如说，刚才我们在 dev 中看到了一大堆设备，你想打开某些设备看看里面的内容，就可以通过命令把设备挂载到 mnt 目录进行操作。\",\"不过一般来说，现在的操作系统已经很聪明了，像挂载设备的操作几乎都不用你手动做，都被自动挂载到 media 目录了。\",\"😁 /opt\",\"opt 是 Option 的缩写，这个文件夹的使用比较随意，一般来说我们自己在浏览器上下载的软件，安装在这里比较好。\",\"当然，包管理工具下载的软件也可能被存放在这里。\",\"...\",\"😁/proc\",\"proc是 process 的缩写，这里存放的是全部正在运行程序的状态信息。\",\"...\",\"你会发现 /proc 里面有一大堆数字命名的文件夹，这个数字其实是 Process ID（PID），文件夹里又有很多文件。\",\"前面说过，Linux 中一切都以文件形式储存，类似 /dev，这里的文件也不是真正的文件，而是程序和内核交流的一些信息。比如说我们可以查看当前操作系统的版本，或者查看 CPU 的状态：\",\"...\",\"如果你需要调试应用程序，proc 目录中的信息也许会帮上忙。\",\"😁/root\",\"root 用户的家目录，普通用户需要授权才能访问\",\"😁/srv\",\"srv 是 service 的缩写，主要用来存放服务数据。\",\"对于桌面版 Linux 系统，这个文件夹一般是空的，但是对于 Linux 服务器，Web 服务或者 FTP 文件服务的资源可以存放在这里\",\"😁/tmp\",\"tmp 是 temporary 的缩写，存储一些程序的临时文件。\",\"...\",\"临时文件可能起到很重要的作用。比如经常听说某同学的 Word 文档崩溃了，好不容易写的东西全没了，Linux 的很多文本编辑器都会在 /tmp 放一份当前文本的 copy 作为临时文件，如果你的编辑器意外崩溃，还有机会在 /tmp 找一找临时文件抢救一下。\",\"比如上图的 VSCode Crashes应该就是 VScode 编辑器存放临时文件的地方。\",\"当然，tmp 文件夹在系统重启之后会自动被清空，如果没有被清空，说明系统删除某些文件失败，也许需要你手动删除一下。\",\"😁/usr\",\"usr 是 Universal System Resource 的缩写，这里存放的是一些非系统必须的资源，比如用户安装的应用程序。\",\"...\",\"/usr 和 /usr/local 目录中又含有 bin 和 sbin 目录，也是存放可执行文件（命令），但和根目录的 bin 和 sbin 不同的是，这里大都是用户使用的工具，而非系统必须使用的。\",\"比如说 /usr/bin 中含有我通过包管理工具安装的应用程序 Chrome 浏览器和 goldendict 字典的可执行文件：\",\"...\",\"值得一提的是，如果使用 Linux 桌面版，有时候在桌面找不到应用程序的快捷方式，就需要在 /usr/share/applications 中手动配置桌面图标文件：\",\"...\",\"😁/var\",\"var 是 variable 的缩写，这个名字是历史遗留的，现在该目录最主要的作用是存储日志（log）信息，比如说程序崩溃，系统异常等等信息都会记录在这里。\",\"这是我的 /var/log 目录：\",\"...\",\"日志文件不会自动删除，也就是说随着系统使用时间的增长，你的 var 目录占用的磁盘空间会越来越大，也许需要适时清理一下。\",\"😁/home\",\"home 目录，这是普通用户的家目录。\",\"在桌面版的 Linux 系统中，用户的家目录会有下载、视频、音乐、桌面等文件夹，这些没啥可说的，我们说一些隐藏的比较重要的文件夹（Linux 中名称以 . 开头就是隐藏文件）\",\"这是我的家目录的部分文件：\",\"...\",\"其中 .cache 文件夹存储应用缓存数据，.config 文件夹存储了一部分应用程序的配置，比如说我的 Chrome 浏览器配置就是那里面。\",\"但是还有一部分应用程序并不把配置储存在 .config 文件夹，而是自己创建一个隐藏文件夹，存放自己的配置文件等等信息，比如你可以看到 Intellij 的配置文件就不在.config 中。\",\"最后说 .local 文件夹，有点像 /usr/local，里面也有 bin 文件夹，也是存放可执行文件的。\",\"比如说我的 python pip 以及 pip 安装的一些工具，都存放在 ～/.local/bin 目录中。但是，存在这里的文件，只有该用户才能使用。\",\"这就是为什么，有时候普通用户可以使用的命令，用 sudo 或者超级用户却被告知找不到该命令。 因为有的命令是特定用户家目录里的，被添加到了该用户的 PATH环境变量里，他可以直接用。你超级用户想用当然可以，但是得写全绝对路径才行。\",\"😁😁summary😁😁\",\"如果修改系统配置，就去 /etc 找，如果修改用户的应用程序配置，就在用户家目录的隐藏文件里找。\",\"在命令行里可以直接输入使用的命令，其可执行文件一般就在以下几个位置：\",\"/bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin /home/USER/.local/bin /home/USER/.local/sbin\",\"如果你写了一个脚本/程序，想在任何时候都能直接调用，可以把这个脚本/程序添加到上述目录中。\",\"如果某个程序崩溃了，可以到 /var/log 中尝试寻找出错信息，到 /tmp 中寻找残留的临时文件。\",\"设备文件在 /dev 目录，但是一般来说系统会自动帮你挂载诸如 U 盘之类的设备，可以到 /media 文件夹访问设备内容。\"]},\"224\":{\"c\":[\"Linux\",\"操作系统\"]},\"225\":{\"c\":[\"Linux\",\"文件系统\",\"存储管理\",\"系统编程\"]},\"226\":{\"h\":\"Linux网络编程详解\",\"t\":[\"网络编程\",\"一、Socket 编程\",\"Socket 编程大致的工作流程\",\"\\\\1. 创建一个TCP服务端的流程\",\"建立一个 socket\",\"*//参数：IPV4 数据流类型 TCP类型* SOCKET \\\\_mysocket = socket(AF\\\\_INET,SOCK\\\\_STREAM,IPPROTO\\\\_TCP);\",\"绑定网络端口和IP地址\",\"//绑定网络端口和IP地址 sockaddr\\\\_in \\\\_myaddr = {};//建立sockaddr结构体 sockaddr\\\\_in结构体方便填写 但是下面要进行类型转换 \\\\_myaddr.sin\\\\_family = AF\\\\_INET;//IPV4 \\\\_myaddr.sin\\\\_port = htons(8888);//端口 host to net unsigned short \\\\_myaddr.sin\\\\_addr.S\\\\_un.S\\\\_addr = inet\\\\_addr(\\\"127.0.0.1\\\");//网络地址 INADDR\\\\_ANY监听所有网卡的端口 //参数：socket，(强制转换)sockaddr结构体，结构体大小 if(SOCKET\\\\_ERROR == bind(\\\\_mysocket,(sockaddr\\\\*)&\\\\_myaddr,sizeof(sockaddr\\\\_in))){}\",\"监听网络端口\",\"*//监听网络端口* *//参数：套接字 最大多少人连接* if(SOCKET\\\\_ERROR == listen(\\\\_mysocket,5)){}\",\"等待客户端链接、接受客户端消息，响应客户端消息\",\"//等待接收客户端连接 sockaddr\\\\_in \\\\_clientAddr = {};//新建sockadd结构体接收客户端数据 int \\\\_addr\\\\_len = sizeof(sockaddr\\\\_in);//获取sockadd结构体长度 SOCKET \\\\_temp\\\\_socket = INVALID\\\\_SOCKET;//声明客户端套接字 char \\\\_buf[256] = {};//接收客户端发送的消息 while(true) { *//参数：自身套接字 客户端结构体 结构体大小* \\\\_temp\\\\_socket = accept(\\\\_mysocket,(sockaddr\\\\*)&\\\\_clientAddr,&\\\\_addr\\\\_len); if(INVALID\\\\_SOCKET == \\\\_temp\\\\_socket)//接收失败 { cout<<\\\"接收到无效客户端Socket\\\"<<endl; } else { cout<<\\\"新客户端加入\\\"<<endl; printf(\\\"IP地址为：%s \\\\n\\\", inet\\\\_ntoa(\\\\_clientAddr.sin\\\\_addr)); } //接收客户端发送的数据 char \\\\_buf[256] = {}; int \\\\_buf\\\\_len = recv(\\\\_temp\\\\_socket,\\\\_buf,256,0); if(\\\\_buf\\\\_len>0) { printf(\\\"%s\\\\n\\\",\\\\_buf); } //向客户端发送数据 char \\\\_msg[] = \\\"HelloWorld\\\"; send(\\\\_temp\\\\_socket,\\\\_msg,strlen(\\\\_msg)+1,0);//客户端套接字 数据 数据长短 flag //关闭客户端socket closesocket(\\\\_temp\\\\_socket); }\",\"\\\\2. 创建一个TCP客户端的流程\",\"建立一个套接字 （socket）\",\"SOCKET _mysocket = socket(AF_INET,SOCK_STREAM,0);\",\"连接服务器 connect\",\"//连接服务器 sockaddr\\\\_in \\\\_sin = {};//sockaddr结构体 \\\\_sin.sin\\\\_family = AF\\\\_INET;//IPV4 \\\\_sin.sin\\\\_port = htons(8888);//想要连接的端口号 \\\\_sin.sin\\\\_addr.S\\\\_un.S\\\\_addr = inet\\\\_addr(\\\"127.0.0.1\\\");//想要连接的IP if(SOCKET\\\\_ERROR == connect(\\\\_mysocket,(sockaddr\\\\*)&\\\\_sin,sizeof(sockaddr\\\\_in))) { cout<<\\\"连接失败\\\"<<endl; closesocket(\\\\_mysocket); }\",\"向客户端发送数据 （send）\",\"char \\\\_msg[] = \\\"HelloServer\\\"; // 参数：*客户端套接字 数据 数据长短 flag* send(\\\\_mysocket,\\\\_msg,strlen(\\\\_msg)+1,0);\",\"接收客户端发送的数据 （recv）\",\"*//接收服务器信息* char \\\\_buf[256] = {}; int \\\\_buf\\\\_len = recv(\\\\_mysocket,\\\\_buf,256,0); if(\\\\_buf\\\\_len>0) { printf(\\\"%s\\\\n\\\",\\\\_buf); }\",\"关闭套接字 （closesocket）\",\"*//关闭socket* closesocket(\\\\_mysocket);\",\"\\\\3. TCP握手过程、半连接和全连接队列\",\"...\",\"\\\\4. TCP挥手过程\",\"...\",\"\\\\5. 都发起 close 会怎么处理\",\"\\\\6. 服务端怎么感知客户端关闭tcp连接？\",\"客户端正常发起关闭，发送FIN报文到服务端后，服务端的内核会在FIN报文插入一个结束符EOF并放在内核的接收缓冲区中，后续在服务端应用程序调用read()读取内核缓冲区的数据，感知到客户端的FIN报文后，read()会返回0，这样就代表这一条TCP连接断开。\",\"客户端宕机，服务端一段时间后会触发TCP保活机制，探测客户端的心跳，如果最后判断客户端无心跳，服务端会自动释放链接。\",\"二、I/O模型\",\"\\\\1. linux的五种IO模型\",\"同步IO模型\",\"1. 阻塞IO\",\"2. 非阻塞IO\",\"3. IO多路复用（事件驱动IO）\",\"4. 信号驱动\",\"同步异步的区别\",\"将就绪的数据从内核拷贝到用户空间时，用户进程会阻塞就是同步IO，不会就是异步IO。\",\"异步IO模型\",\"1. 异步IO\",\"**阻塞I/0：**这是最常见的I/0模型。在此模式中，当应用程序执行I/0操作时，如果数据还没有准备好，应用程序就会被阻塞(挂起)，直到数据准备好为止。这期间，应用程序不能做其他事情。\",\"**非阻塞I/0：**在此模式中，如果I/0操作的数据还没有准备好，操作会立即返回一个错误，而不是阻塞应用程序。应用程序可以继续执行其他操作，也可以反复尝试该I/0操作。\",\"**I/0多路复用：**也常称为事件驱动I/0。在此模式中，应用程序可以同时监控多个I/0描述符(比如，socket)，当任何一个I/0描述符准备好数据时，应用程序就可以对其进行处理。这可以在一个单独的进程或线程中同时处理多个I/0操作，并且不需要阻塞或轮询。select、poll、epoll都是这种模型的实现。\",\"**信号驱动：**在此模型中，应用程序可以向操作系统注册一个信号处理函数当数据准备好时，操作系统会发送一个信号，应用程序可以在接收到信号时读取数据。这种模式避免了阻塞和轮询，但是编程复杂性较高。\",\"**异步I/0：**在此模型中，应用程序发起I/0操作后，可以立即开始做其他事情，当数据准备好时，操作系统会将数据复制到应用程序的缓冲区，并通知应用程序。这种模型的优点是应用程序不需要等待I/0操作的完成，缺点是编程复杂性较高。\",\"\\\\2. 阻塞和非阻塞IO应用场景\",\"计算密集型的场景适合阻塞IO，不会一直轮询占用cpu资源。\",\"IO密集型的时候用非阻塞IO，比如视频传输，瓶颈不是cpu，所以用非阻塞IO模型可以避免阻塞在传输函数上，提高程序并发性和响应时间。\",\"\\\\3. 理解I/O多路复用\",\"不使用多路复用时：\",\"如果不使用 I/0 多路复用，服务端要并发处理多个客户端的 I/0 事件的话，需要通过创建子进程或者线程的方式来实现，也就是针对每一个连接的I/0 事件要需要一个子进程或者线程来处理，但是随着客户端越来越多，意味着服务端需要创建更多的子进程或者线程，这样对系统的开销太大了。\",\"使用了多路复用：\",\"那么有了 I/0 多路复用就可以解决这个问题，I/0 多路复用可以实现是多个I/0复用一个进程，也就是只需要一个进程就能并发处理多个客户端的 I/0 事件，进程可以通过select、poll、epoll这类 I/0 多路复用系统调用接口从内核中获取有事件发生的 socket 集合，然后应用程序就可以遍历这个集合，对每一个 socket 事件进行处理。\",\"Redis 单线程也能做到高性能的原因，也跟 I/0 多路复用有关系\",\"\\\\4. IO多路复用的 3 个实现\",\"\\\\1. select\",\"select 实现多路复用的方式：\",\"将已连接的 Socket 都放到一个文件描述符集合（用户态），然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生。\",\"检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。\",\"...\",\"select调用过程\",\"缺点\",\"select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符。\",\"每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；\",\"对 socket 扫描时是线性扫描，采用轮询的方法，效率较低\",\"select 使用示例\",\"**int** **main**() { */\\\\** \\\\* 这里进行一些初始化的设置， \\\\* 包括socket建立，地址的设置等, \\\\*/ fd\\\\_set read\\\\_fs, write\\\\_fs; **struct** **timeval** timeout; **int** max = 0; *// 用于记录最大的fd，在轮询中时刻更新即可* *// 初始化比特位* FD\\\\_ZERO(&read\\\\_fs); FD\\\\_ZERO(&write\\\\_fs); **int** nfds = 0; *// 记录就绪的事件，可以减少遍历的次数* **while** (1) { *// 阻塞获取* *// 每次需要把fd从用户态拷贝到内核态* nfds = select(max + 1, &read\\\\_fd, &write\\\\_fd, NULL, &timeout); *// 每次需要遍历所有fd，判断有无读写事件发生* **for** (**int** i = 0; i <= max && nfds; ++i) { **if** (i == listenfd) { --nfds; *// 这里处理accept事件* FD\\\\_SET(i, &read\\\\_fd);*//将客户端socket加入到集合中* } **if** (FD\\\\_ISSET(i, &read\\\\_fd)) { --nfds; *// 这里处理read事件* } **if** (FD\\\\_ISSET(i, &write\\\\_fd)) { --nfds; *// 这里处理write事件* } } }\",\"\\\\2. poll\",\"实现方式\",\"用动态数组存储关注的fd，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。\",\"poll和 select并没有太大的本质区别，都是使用线性结构存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合。\",\"缺点\",\"每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；\",\"对 socket 扫描时是线性扫描，采用轮询的方法，效率较低\",\"poll使用示例\",\"*// 先宏定义长度* **#define MAX\\\\_POLLFD\\\\_LEN 4096** **int** **main**() { */\\\\** \\\\* 在这里进行一些初始化的操作， \\\\* 比如初始化数据和socket等。 \\\\*/ **int** nfds = 0; pollfd fds[MAX\\\\_POLLFD\\\\_LEN]; memset(fds, 0, sizeof(fds)); fds[0].fd = listenfd; fds[0].events = POLLRDNORM; **int** max = 0; *// 队列的实际长度，是一个随时更新的，也可以自定义其他的* **int** timeout = 0; **int** current\\\\_size = max; **while** (1) { *// 阻塞获取* *// 每次需要把fd从用户态拷贝到内核态* nfds = poll(fds, max+1, timeout); **if** (fds[0].revents & POLLRDNORM) { *// 这里处理accept事件* connfd = accept(listenfd); *//将新的描述符添加到读描述符集合中* } *// 每次需要遍历所有fd，判断有无读写事件发生* **for** (**int** i = 1; i < max; ++i) { **if** (fds[i].revents & POLLRDNORM) { sockfd = fds[i].fd **if** ((n = read(sockfd, buf, MAXLINE)) <= 0) { *// 这里处理read事件* **if** (n == 0) { close(sockfd); fds[i].fd = -1; } } **else** { *// 这里处理write事件* } **if** (--nfds <= 0) { **break**; } } } }\",\"\\\\3. epoll\",\"\\\\1. 学习一下 epoll 的用法\",\"先用epoll_create 创建一个 epoll对象 epfd,\",\"再通过 epoll_ctl 将需要监视的 socket 添加到epfd中,\",\"最后调用 epoll_wait 等待数据。\",\"/// 创建socket服务端... // 使用epoll获取网络事件 int epfd = epoll\\\\_create(...); epoll\\\\_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中 while(1) { *// 阻塞获取* int n = epoll\\\\_wait(...); for(接收到数据的socket){ //处理 } } **int** **main**(**int** argc, **char**\\\\* argv[]) { */\\\\** \\\\* 在这里进行一些初始化的操作， \\\\* 比如初始化数据和socket等。 \\\\*/ int s = socket(AF\\\\_INET, SOCK\\\\_STREAM, 0); bind(s, ...); listen(s, ...) *// 内核中创建ep对象* epfd = epoll\\\\_create(256); *// 需要监听的socket放到ep中* epoll\\\\_ctl(epfd,EPOLL\\\\_CTL\\\\_ADD,listenfd,&ev); **while**(1) { *// 阻塞获取* nfds = epoll\\\\_wait(epfd,events,20,0); **for**(i=0;i<nfds;++i) { **if**(events[i].data.fd==listenfd) { *// 这里处理accept事件* connfd = accept(listenfd); *// 接收新连接写到内核对象中* epoll\\\\_ctl(epfd,EPOLL\\\\_CTL\\\\_ADD,connfd,&ev); } **else** **if** (events[i].events&EPOLLIN) { *// 这里处理read事件* read(sockfd, BUF, MAXLINE); *//读完后准备写* epoll\\\\_ctl(epfd,EPOLL\\\\_CTL\\\\_MOD,sockfd,&ev); } **else** **if**(events[i].events&EPOLLOUT) { *// 这里处理write事件* write(sockfd, BUF, n); *//写完后准备读* epoll\\\\_ctl(epfd,EPOLL\\\\_CTL\\\\_MOD,sockfd,&ev); } } } **return** 0; }\",\"\\\\2. 实现方式\",\"epoll 通过下面2个数据结构，高效解决了select和poll的缺点\",\"红黑树\",\"epoll 在内核里使用红黑树来跟踪进程所有待检测的fd，把需要监控的 socket 通过epoll_ctl() 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)。\",\"而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。\",\"链表维护就绪事件\",\"内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。\",\"注意：epoll_wait会调用put_user函数，将数据从内核拷贝到用户空间\",\"...\",\"\\\\3. 关注 eventpoll 结构体\",\"*// 数据结构* *// 每一个epoll对象都有一个独立的eventpoll结构体* *// 用于存放通过epoll\\\\_ctl方法向epoll对象中添加进来的事件* *// epoll\\\\_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可* **struct** **eventpoll** { */\\\\*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件\\\\*/* **struct** **rb\\\\_root** rbr; */\\\\*双链表中则存放着将要通过epoll\\\\_wait返回给用户的满足条件的事件\\\\*/* **struct** **list\\\\_head** rdlist; }; *// API* *// 内核中间加一个 **eventpoll** 对象，把所有需要监听的 socket 都放到 **eventpoll** 对象中* **int** **epoll\\\\_create**(**int** size); *// epoll\\\\_ctl 负责把 socket 增加、删除到内核红黑树* **int** **epoll\\\\_ctl**(**int** epfd, **int** op, **int** fd, **struct** epoll\\\\_event \\\\*event); *// epoll\\\\_wait 负责检测可读队列，没有可读 socket 则阻塞进程* **int** **epoll\\\\_wait**(**int** epfd, **struct** epoll\\\\_event \\\\* events, **int** maxevents, **int** timeout);\",\"\\\\4. 优缺点\",\"epoll的优点\",\"没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；\",\"效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你\\\"活跃\\\"的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll；\",\"内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。\",\"epoll缺点\",\"epoll只能工作在 linux\",\"\\\\5. 边缘触发和水平触发\",\"水平触发：用户程序每次调用epoll_wait时，只要文件描述符处于就绪状态（例如有数据可读），epoll_wait都会返回这个事件。\",\"边缘触发：用户程序只有在文件描述符的状态发生变化时（例如从不可读变为可读）调用epoll_wait时才会返回这个事件。即使文件描述符仍然处于就绪状态，如果用户程序没有处理完这个事件，epoll_wait也不会再次返回这个事件，直到状态再次变化。\"]},\"227\":{\"c\":[\"Linux\",\"网络编程\"]},\"228\":{\"c\":[\"Linux\",\"Socket\",\"网络编程\",\"TCP/IP\"]},\"229\":{\"h\":\"Protocol Buffers详解\",\"t\":[\"Protobuf\",\"protocol buffers使用指南 - 李文周的博客\",\"Go是如何实现protobuf的编解码的(1)：原理\",\"Protobuf 对比 Json\",\"假设要描述一个人，他拥有name、age和sex三个属性，可以怎么表示呢？\",\"Json可以很清晰的描述\",\"{\\\"name\\\":\\\"Taylor\\\",\\\"age\\\":18,\\\"sex\\\":\\\"female\\\"}\",\"ProtoBuf\",\"但是像\\\"name\\\"、\\\"age和\\\"sex\\\"这样的key占用了将近一半的内存，这是无法忍受的。\",\"能不能通过定义一种消息格式，例如用1表示name，2表示age，3表示sex呢?\",\"这当然是可以的，ProtoBuf通过定义 .proto 文件，提供一种与语言、平台无关的机制来实现对数据的序列化，并且比Json更快，占用的内存更小。\",\"数据被序列化为一种紧凑、向前和向后兼容、但不可自我描述的二进制线性格式（binary wire format）\",\".proto 文件\",\"ProtoBuf将协议保存在.proto文件中，编译器在运行的时候会调用该文件，生成各种编程语言的代码。\",\"对于上面例子中的person，用protoBuf描述如下：\",\"第一行，指定了ProtoBuf的版本，也就是proto3，如果没有指定，则默认是proto2。\",\"接下来定义了一个message类型的Person（可以理解为C#中的类），里面包含几个字段，在使用编译器编译后，message会变成对应语言的对象，比如C#中的Class。\",\"这些字段都是以 type fieldName = fieldNumber 格式定义的，\",\"syntax = \\\"proto3\\\" //定义proto版本，不显示表明，默认是 proto2 message Person{ string name = 1; int32 age = 2; enum Sex { male = 0; female = 1; } Sex sex = 3; }\",\"支持的数据类型\",\"repeated表示一个字段可以包含零个或多个值，类似于数组或列表的概念\",\"1. 标量值类型 - Scalar value type\",\"默认值不能设置为null\",\"...\",\"点击图片可查看完整电子表格\",\"2. 枚举 - Enum\",\"message Student { string name = 1; enum Gender { FEMALE = 0; MALE = 1; } Gender gender = 2; repeated int32 scores = 3; }\",\"枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。\",\"别名（Alias），允许为不同的枚举值赋予相同的标识符，称之为别名，需要打开allow_alias选项。\",\"message EnumAllowAlias { enum Status { option allow\\\\_alias = true; UNKOWN = 0; STARTED = 1; RUNNING = 1; } }\",\"3. 任意类型 - Any\",\"Any 可以表示不在 .proto 中定义任意的内置类型。\",\"import \\\"google/protobuf/any.proto\\\"; message ErrorStatus { string message = 1; repeated google.protobuf.Any details = 2; }\",\"4. oneof\",\"message SampleMessage { oneof test\\\\_oneof { string name = 4; SubMessage sub\\\\_message = 9; } }\",\"5. map\",\"message MapRequest { map<string, int32> points = 1; }\",\"6. 其他消息类型\",\"Result是另一个消息类型，在 SearchReponse 作为一个消息字段类型使用。\",\"message SearchResponse { repeated Result results = 1; } message Result { string url = 1; string title = 2; repeated string snippets = 3; }\",\"可以嵌套使用\",\"message SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; }\",\"Protobuf 语法\",\"packages\",\"对于Go，包可以被用做Go包名称，除非你显式的提供一个option go_package在你的.proto文件中。\",\"可以向 .proto 文件添加一个可选package说明符，以防止协议消息类型之间的名称冲突。\",\"package foo.bar; message Open { ... }\",\"然后，你可以在定义消息类型的字段时使用package说明符:\",\"message Foo { ... foo.bar.Open open = 1; ... }\",\"定义服务\",\"如果消息类型是用来远程通信的(Remote Procedure Call, RPC)，可以在 .proto 文件中定义 RPC 服务接口。\",\"例如我们定义了一个名为 SearchService 的 RPC 服务，提供了 Search 接口，入参是 SearchRequest 类型，返回类型是 SearchResponse\",\"service SearchService { rpc Search (SearchRequest) returns (SearchResponse); }\",\"官方仓库也提供了一个插件列表，帮助开发基于 Protocol Buffer 的 RPC 服务。\",\"生产 go 代码\",\"编译器调用\",\"protocol buffer 编译器需要借助一个插件来根据提供的 proto 文件生成 Go 代码\",\"Go1.16+请使用下面的命令安装插件。\",\"go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\",\"这个命令将在 $GOBIN 中安装一个 protocol-gen-go 的二进制文件。\",\"我们需要确保 $GOBIN 在你的环境变量中，protocol buffer编译器才能找到它（可以通过go env命令查看$GOPATH）。\",\"当使用go_out标志调用 protoc 时，protocol buffer编译器将生成 Go 代码。\",\"protocol buffer编译器会将生成的Go代码输出到命令行参数go_out指定的位置。\",\"go_out标志的参数是你希望编译器编写 Go 输出的目录。\",\"编译器为每个.proto 文件输入创建一个源文件。\",\"输出文件的名称是通过将.proto 扩展名替换为.pb.go而创建的。\",\"生成的.pb.go文件放置的目录取决于编译器标志。\",\"有以下几种输出模式:\",\"paths=import：输出文件放在以 Go 包的导入路径命名的目录中。\",\"例如：protos/buzz.proto文件中带有example.com/project/protos/fizz的导入路径，则输出的生成文件会保存在example.com/project/protos/fizz/buzz.pb.go。\",\"如果未指定路径标志，这就是默认输出模式。\",\"module=$PREFIX：输出文件放在以 Go 包的导入路径命名的目录中，但是从输出文件名中删除了指定的目录前缀。\",\"例如，输入文件 pros/buzz.proto，其导入路径为 example.com/project/protos/fizz 并指定example.com/project为module前缀，结果会产生一个名为 pros/fizz/buzz.pb.go 的输出文件。\",\"在module路径之外生成任何 Go 包都会导致错误。此模式对于将生成的文件直接输出到 Go 模块非常有用。\",\"paths=source_relative：输出文件与输入文件放在相同的相对目录中。\",\"例如，一个protos/buzz.proto输入文件会产生一个位于protos/buzz.pb.go的输出文件。\",\"go_opt标志位参数\",\"在调用protoc时，通过传递 go_opt标志来提供特定于 protocol-gen-go 的标志位参数。可以传递多个go_opt标志位参数。\",\"例如，当执行下面的命令时：\",\"protoc --proto\\\\_path=src --go\\\\_out=out --go\\\\_opt=paths=source\\\\_relative foo.proto bar/baz.proto\",\"编译器将从 src 目录中读取输入文件 foo.proto 和 bar/baz.proto，并将输出文件 foo.pb.go 和 bar/baz.pb.go 写入 out 目录。如果需要，编译器会自动创建嵌套的输出子目录，但不会创建输出目录本身。\",\"package\",\"为了生成 Go 代码，必须为每个.proto 文件（包括那些被生成的 .proto 文件传递依赖的文件）提供 Go 包的导入路径。\",\"有两种方法可以指定 Go 导入路径：\",\"通过在 .proto 文件中声明它。\",\"通过在调用 protoc 时在命令行上声明它。\",\"建议在 .proto 文件中声明它，以便 .proto 文件的 Go 包可以与 .proto 文件本身集中标识，并简化调用 protoc 时传递的标志集。\",\"如果给定 .proto 文件的 Go 导入路径由 .proto 文件本身和命令行提供，则后者优先于前者。\",\"Go 导入路径是在 .proto 文件中指定的，通过声明带有 Go 包的完整导入路径的 go_package 选项来创建 proto 文件。用法示例：\",\"option go\\\\_package = \\\"example.com/project/protos/fizz\\\";\",\"调用编译器时，可以在命令行上指定 Go 导入路径，方法是传递一个或多个 M${PROTO_FILE}=${GO_IMPORT_PATH} 标志位。\",\"用法示例：\",\"protoc --proto\\\\_path=src \\\\ --go\\\\_opt=Mprotos/buzz.proto=example.com/project/protos/fizz \\\\ --go\\\\_opt=Mprotos/bar.proto=example.com/project/protos/foo \\\\ protos/buzz.proto protos/bar.proto\",\"由于所有 .proto 文件到其 Go 导入路径的映射可能非常大，这种指定 Go 导入路径的模式通常由控制整个依赖树的某些构建工具（例如 Bazel）执行。 如果给定的 .proto 文件有重复条目，则指定的最后一个条目优先。\",\"导入路径用于确定一个 .proto 文件导入另一个 .proto 文件时必须生成哪些导入语句。\",\"例如，如果 a.proto 导入 b.proto，则生成的 a.pb.go 文件需要导入包含生成的 b.pb.go 文件的 Go 包（除非两个文件在同一个包中）。 导入路径也用于构造输出文件名。\",\"Go 导入路径和 .proto 文件中的package说明符之间没有关联。\",\"后者仅与 protobuf 命名空间相关，而前者仅与 Go 命名空间相关。 此外，Go 导入路径和 .proto 导入路径之间没有关联。\"]},\"230\":{\"c\":[\"微服务\",\"协议\"]},\"231\":{\"c\":[\"Protobuf\",\"微服务\",\"序列化\",\"RPC\"]},\"232\":{\"h\":\"微服务\",\"t\":[\"本系列包含微服务相关的技术文档和学习笔记。\"]},\"233\":{\"c\":[\"微服务\",\"系统架构\"]},\"234\":{\"c\":[\"微服务\",\"分布式系统\",\"系统设计\",\"架构设计\"]},\"235\":{\"h\":\"MySQL\",\"t\":[\"本系列包含MySQL相关的技术文档和学习笔记。\"]},\"236\":{\"h\":\"计算机网络\",\"t\":[\"本系列包含计算机网络相关的技术文档和学习笔记。\"]},\"237\":{\"h\":\"计算机网络传输层详解\",\"t\":[\"传输层\",\"一、TCP 三次握手（以SOCKET的角度）\",\"二、TCP 四次挥手\",\"...\",\"TIME_WAIT 状态的产生\",\"该状态出现在主动断开方，在主动断开方完成第四次挥手，也就是发送完最后一个ACK报文后，进入 TIME_WAIT 状态，该状态会持续 2MSL 的时长，以确保对方已收到了最后一个ACK报文。\",\"**MSL：**最大报文存活时长，单位是时间，Linux默认 30s。\",\"**TTL：**IP报文在网络中允许经过的最大路由数，单位是经过路由数，Linux默认64。\",\"TIME_WAIT 为什么要等待 2MSL\",\"2 MSL的时长，相当于：允许报文在网络中丢失一次。\",\"比如：第四挥手ACK报文没有被被动方接收到，1个MSL后该ACK报文在网路中消亡，被动方由于没有收到ACK响应，会启动FIN报文重传，另一方接收到FIN报文，就可以重发ACK报文。这样的一来一回正是 2MSL时长内。\",\"TIME_WAIT 过多的危害\",\"在Linux中，某种东西过多一般会意味着：占用系统资源。文件描述符、内存资源、CPU资源等等。\",\"TIME_WAIT 过多的时候，由于与网络有关，所以会有以下两个基本的影响：\",\"占用系统资源，一切皆文件，会占用较多的文件描述符、内存资源。\",\"占用系统端口，端口资源是有限的，linux一般可以开启的端口为 3w-6w。\",\"在以上基本影响外，客户端和服务端的 TIME_WAIT 过多的影响也有不同：\",\"客户端：TCP四元组确定一条连接，所以不能对 目的IP+目的port 相同的服务端发起连接请求，端口耗尽。\",\"服务端：由于TCP四元组确定一条连接，所以服务端可以处理的TCP连接理论上可以非常多，但是TCP连接在服务端会受限于系统资源，文件描述符和内存资源\",\"TIME_WAIT 过多如何解决\",\"**客户端：**可以考虑开启 tcp_tw_reuse 参数，设置为1为开启。当发起新连接的时候，就会复用处于 time_wait的连接。\",\"启用后，处于 TIME-WAIT 状态的连接可能被重用。这种重用可能导致新的连接混淆，因为内核会重用一个旧连接的五元组（源 IP、源端口、目的 IP、目的端口和协议），这可能导致数据包被误导。\",\"**服务端：**说明服务端主动关闭了连接，服务端应该尽量避免主动断开连接，由客户端来进行，可以在应用层设计一个逻辑，当服务端要断开的时候，发送一个消息给客户端，让客户端收到信息后发起断开TCP连接。\",\"TIME_WAIT 在服务端大量出现的原因？\",\"相当于： 服务端为什么会主动关闭连接？\",\"**没有开启HTTP长连接：**服务端发完HTTP响应后，会主动关闭连接。\",\"**HTTP长连接的请求数量设置过小：**web服务端通常会有个参数来定义 HTTP 长连接能处理的最大请求数量，比如 nginx的 keepalive_requests默认是100。QPS高的时候，就会频繁关闭连接，导致time_wait过多。\",\"TIME_WAIT 状态设计的目的\",\"设计 TIME_WAIT 状态，主要有两个原因：\",\"防止历史连接中的数据，被后面相同四元组的连接错误的接收（序列号是32位，可能会有序列号绕回导致数据完整性破坏）；\",\"保证「被动关闭连接」的一方，能被正确的关闭（确保有没有收到最后一次挥手）；\",\"假设 TCP 的发送窗口是 1 GB，并且使用了时间戳选项，发送方会为每个 TCP 报文分配时间戳数值，我们假设每个报文时间加 1，然后使用这个连接传输一个 6GB 大小的数据流。\",\"...\",\"32 位的序列号（2^32 = 4 GB）在时刻 D 和 E 之间回绕。假设在时刻B有一个报文丢失并被重传，又假设这个报文段在网络上绕了远路并在时刻 F 重新出现。如果 TCP 无法识别这个绕回的报文，那么数据完整性就会遭到破坏。\",\"TCP_TW_REUSE 为什么默认关闭\",\"开启 tcp_tw_reuse 的同时，也需要开启tcp_timestamps。\",\"开启了 tcp_timestamps参数，TCP 头部就会使用时间戳选项，它有两个好处，一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）。\",\"默认关闭的原因：\",\"启用后，处于 TIME-WAIT 状态的连接可能被重用。这种重用可能导致新的连接混淆，因为内核会重用一个旧连接的五元组（源 IP、源端口、目的 IP、目的端口和协议），这可能导致数据包被误导。\",\"三、TCP长连接、HTTP长连接 的保活机制\",\"**TCP长连接保活：**通过探测报文来检测连接状态。这是传输层的机制，独立于应用层的具体协议。\",\"**HTTP长连接保活：**通过Connection: keep-alive和Keep-Alive头部字段来管理连接的持久性和空闲超时。\",\"Connection: keep-alive Keep-Alive: timeout=5, max=100\",\"HTTP长连接的保活实际上是由两部分组成的：应用层的HTTP保活机制和传输层的TCP保活机制。\",\"HTTP保活负责管理HTTP请求/响应的连接复用和空闲超时\",\"TCP保活负责确保底层连接的持续有效性。如果TCP连接因任何原因断开，HTTP长连接也会失效。\",\"三、socket 五元组\",\"源IP地址\",\"目的IP地址\",\"源端口号\",\"目的端口号\",\"传输协议（通常是TCP或UDP）\",\"常说的TCP四元组，是指默认 传输协议固定为TCP的情况下讨论的。\",\"也可以得出，tcp/udp可以使用同一个端口。因为传输协议不同，不会认为是相同的连接。\",\"四、传输层的报文\",\"端口\",\"tcp和udp都有端口字段，用于区分同一主机的不同应用程序的数据包。\"]},\"238\":{\"c\":[\"计算机网络\",\"网络协议\"]},\"239\":{\"c\":[\"TCP\",\"UDP\",\"传输层\",\"网络协议\"]},\"240\":{\"h\":\"计算机网络应用层详解\",\"t\":[\"应用层\",\"一、HTTP\",\"状态码\",\"200类 表示：服务端正常处理客户端的请求\",\"200：成功，通常body会有数据\",\"204：也是成功，但是没有body数据\",\"206：文件断点续传\",\"300类 表示：客户端请求的资源发生了变动，需要用新的url重新发送请求获取资源。\",\"301：永久重定向。浏览器会记录新的url，下次会自动跳转。\",\"302：临时重定向。要到新的url请求资源，但这不是永久的，还会更改。\",\"304：表示资源请求成功，在本地浏览器缓存就有这个资源。\",\"400类 表示：客户端请求报文有误，服务端无法处理。\",\"400：请求报文有错误，是一个笼统的错误。\",\"403：请求的资源权限不够。\",\"404：请求的资源不存在。\",\"500类 表示：客户端请求报文正确，但是服务端内部处理发生错误。\",\"500：服务器程序错误\",\"501：服务端不具备完成请求的功能，可能是无法识别这个请求方法\",\"502：服务器作为网关层（nginx）返回的错误码，表示网关服务器正常，但是访问后端服务器错误。\",\"503：服务器很忙，无法响应。也就是网络正忙\",\"504：服务器作为网关，但是没有及时收到上游服务器的请求\",\"版本差异\",\"http 1.0\",\"1. 明文传输\",\"2. 默认短链接\",\"http 1.1\",\"1. 明文传输\",\"2. 默认长连接\",\"3. 无法并发传输\",\"http 2.0\",\"1. 基于https，基于tls1.2（rsa算法，2RTT） 握手。\",\"2. 引入stream，复用tcp连接能并发传输。\",\"3. 头部压缩，hpack算法压缩http报文的头部\",\"4. 明文传输改为二进制格式，提高传输效率\",\"5. 支持服务器主动推送资源。\",\"http 3.0\",\"1. 基于udp协议，并在应用层实现可靠机制。用tls1.3（rcdhe算法，1RTT）握手\",\"2. udp协议解决tcp的对头阻塞问题\",\"3. 只要3次握手就可以完成3tcp+4tls的过程。\",\"4. 网络切换不需要重新建立连接，在应用层通过连接id来维护，而不是tcp4元组\",\"二、HTTPS\",\"TLS握手 - RSA算法\",\"...\",\"...\",\"CA 签发证书的过程，如上图左边部分：\",\"首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；\",\"然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；\",\"最后将 Certificate Signature 添加在文件证书上，形成数字证书；\",\"客户端校验服务端的数字证书的过程，如上图右边部分：\",\"首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；\",\"通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；\",\"最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。\",\"三、HTTP 状态维护\",\"JWT\",\"[该类型的内容暂不支持下载]\",\"四、ngnix\",\"正向代理、反向代理\",\"**正向代理：**代理客户端，相当于客户端是第三方身份，服务器不知道真实的客户端。\",\"**反向代理：**代理服务端，相当于服务器是第三方身份，客户端不知道真实的服务器。\",\"...\",\"负载均衡算法\"]},\"241\":{\"c\":[\"计算机网络\",\"网络协议\"]},\"242\":{\"c\":[\"HTTP\",\"HTTPS\",\"DNS\",\"应用层\"]},\"243\":{\"h\":\"计算机网络安全详解\",\"t\":[\"网络安全\",\"一、网络攻击\",\"DNS 劫持\",\"**定义：**DNS劫持是指拦截或篡改用户的DNS查询，使其访问特定的IP地址，不管用户请求的是什么域名。\",\"**发生的环节：**查询目标网站域名的的IP时，需要DNS解析，在解析过程可能会发生劫持。\",\"**攻击手段：**攻击者劫持 DNS 服务器，取得控制权篡改DNS解析结果，将域名解析到攻击者控制的恶意服务器，访问域名就会被重定向到恶意网站的服务器上。\",\"解决办法： 手动更换公共的DNS服务器。\",\"...\",\"DNS 污染\",\"又叫：DNS 缓存投毒（多是恶意的）\",\"**定义：**DNS污染是指向DNS解析系统注入虚假的DNS数据，使用户访问错误的IP地址。\",\"**发生的环节：**DNS解析过程通常是基于UDP协议，查询者只接受最先返回的响应，后来的查询结果会被丢弃。\",\"攻击手段：攻击者对UDP的 53 端口进行入侵检测，监听DNS查询，一经发现与关键词相匹配的请求则立即伪装成目标域名的服务器，返回给查询者。\",\"**解决办法：**手动更换公共的DNS服务器。\",\"DDOS 攻击\",\"\\\"群殴\\\"、分布式拒绝服务、量大\",\"**定义：**用大量的僵尸计算机（被污染的个人计算机等），对攻击的服务器发起大量的请求，让服务器带宽、cpu、内存 耗尽。无法处理正常的用户请求，丧失对外服务的能力。\",\"DDOS 分类：\",\"应用层攻击、网络层攻击：\",\"流量型攻击、连接型攻击、协议缺陷攻击\",\"防御方式：\",\"ip黑名单\",\"用户验证\",\"花钱买可靠的DDOS防护服务\",\"3.1 流量型 - UDP 洪水攻击\",\"在短时间内 模拟随机的源端口地址向随机的目的端口发送大量的udp包，造成目标主机不能处理其他udp的请求。\",\"3.2 流量型 - ICMP 洪水攻击\",\"icmp flood 也就是 ping flood。\",\"此攻击在短时间内向目的主机发送大量的ping的echo报文，主机不断响应，造成网络堵塞、主机资源耗尽。\",\"3.3 连接型 - SYN 洪水攻击\",\"依据 tcp建立连接的三次握手。\",\"此攻击以多个随机的源主机地址向目的主机发送syn包，而在收到目的主机的syn＋ack包后并不回应，目的主机就为这些源主机建立大量的连接队列，由于没有收到ack一直维护这些连接队列，造成资源的大量消耗而不能向正常的请求提供服务。\",\"CC 攻击\",\"利用 代理服务器 向 受害者 发起大量HTTP Get 请求；\",\"主要请求动态页面，涉及到数据库访问操作；数据库负载以及数据库连接池负载极高，无法响应正常请求\",\"放大攻击\",\"放大：将一个请求通过手段放大几十倍。\",\"比如有：\",\"基于 DNS 的放大\",\"基于 SNMP 协议的放大\",\"。。。\",\"...\",\"反射攻击\",\"伪造 源IP地址（攻击目标），对网络中的服务器发起请求，这些网络服务器会对 源IP响应，导致大量的网络数据发送给 攻击目标。\",\"意义：\",\"攻击的实际来源被隐藏，很难追踪;\",\"如果使用了许多互联网服务器，攻击可能包括来自世界各地的大量数据包。\",\"二、接口安全\",\"接口安全设计\",\"Tutorial/system/architecture/如何设计一个对外安全的接口.md at master · zhonghuasheng/Tutorial\",\"三、信息安全\",\"Sql 注入防御\",\"**Sql 注入攻击：**通过在输入字段插入恶意SQL代码来操控数据库查询的攻击手段，导致未授权访问或数据泄露。\",\"1.1 参数化查询\",\"在使用参数化查询的情况下，数据库服务器不会将参数的内容视为SQL指令的一部份来处理，而是在数据库完成SQL指令的编译后，才套用参数运行，因此就算参数中含有指令，也不会被数据库运行。\"]},\"244\":{\"c\":[\"计算机网络\",\"网络安全\"]},\"245\":{\"c\":[\"网络安全\",\"加密\",\"攻击防护\",\"安全协议\"]},\"246\":{\"h\":\"虚拟机网络模式详解\",\"t\":[\"虚拟机网络模式\",\"【虚拟机网络模式】NAT | NAT网络 | 桥接Bridged | 内部网络Internal | 仅主机(Host-Only)_哔哩哔哩_bilibili\",\"虚拟机网络模式\",\"NAT（Network Address Translation）\",\"定义：\",\"NAT模式是一种虚拟机网络连接模式，虚拟机通过虚拟网络地址转换（NAT）与外部网络通信。在这种模式下，虚拟机通过宿主机的IP地址和网络连接来访问外部网络。\",\"特点：\",\"IP地址分配： 虚拟机使用一个虚拟的私有IP地址，这个地址在宿主机的私有网络范围内。\",\"网络隔离： 虚拟机与外部网络之间有一定的隔离，虚拟机无法直接被外部网络访问，增加了一层安全性。\",\"访问外网： 虚拟机可以通过宿主机访问外部网络，这种方式非常适合需要访问互联网但不需要外部设备访问虚拟机的场景。\",\"配置简单： 配置简单，无需对物理网络进行复杂设置，只需在虚拟机软件中选择NAT模式即可。\",\"主机不能ping通虚拟机，虚拟机IP是虚有的，不占用主机的IP\",\"NAT网络\",\"定义：\",\"NAT网络模式类似于NAT模式，但它允许多个虚拟机共享一个虚拟的私有网络，并通过宿主机的网络连接访问外部网络。\",\"特点：\",\"虚拟局域网： 创建一个虚拟的局域网，所有在同一NAT网络中的虚拟机可以相互通信。\",\"共享外网访问： 通过宿主机的网络连接，NAT网络中的虚拟机可以访问外部网络。\",\"网络隔离： NAT网络中的虚拟机与外部网络有一定的隔离，外部网络无法直接访问这些虚拟机。\",\"适用场景： 适用于需要多个虚拟机进行内部通信并共同访问外部网络的场景，如测试环境、开发环境等。\",\"桥接（Bridged）\",\"定义：\",\"桥接模式是一种虚拟机网络连接模式，虚拟机直接连接到物理网络，就像物理机一样。虚拟机将获得一个与物理网络相同的IP地址，并且可以直接与物理网络中的其他设备通信。\",\"特点：\",\"直接连接： 虚拟机直接连接到物理网络，获得一个与物理网络相同的IP地址。\",\"双向通信： 虚拟机可以与物理网络中的其他设备进行双向通信，外部设备可以直接访问虚拟机。\",\"独立性： 虚拟机的网络行为与物理机无异，适用于需要虚拟机作为独立网络节点的场景。\",\"网络配置： 需要在物理网络中配置相应的网络设置，如IP地址分配、子网掩码等。\"]},\"247\":{\"c\":[\"计算机网络\",\"虚拟化\"]},\"248\":{\"c\":[\"虚拟机\",\"网络配置\",\"VMware\",\"网络模式\"]},\"249\":{\"h\":\"计算机网络基础知识汇总\",\"t\":[\"计算机网络 8古 语雀导入\",\"1. 导图\",\"...\",\"2. 网络体系结构\",\"OSI 模型是理论是理论网络模型\",\"TCP/IP 模型是 Linux 实际使用的\",\"2.1. 为什么要设计分层网络模型\",\"模块化：它将网络通信划分为不同的层次，每层负责一组特定的功能，这样可以简化网络的设计和管理。\",\"互操作性：分层模型促进了不同厂商和设备之间的标准化，使得它们能够无缝协作。\",\"维护和扩展性：由于每一层都是独立的，网络可以逐步发展和扩展，而不需要全面重构。\",\"故障隔离：当出现问题时，我们可以快速定位到问题发生在哪一层，这样有助于提高故障排除的效率。\",\"安全性：分层允许我们在不同层级上实施安全控制，提高整个网络的安全性。\",\"2.2. OSI 模型\",\"2.2.1. 参考模型\",\"...\",\"2.2.2. 各层作用\",\"...\",\"2.2.3. 7 层通信\",\"会话层只对何时建立连接、何时发送数据等问题进行管理，并不具有实际传输数据的功能\",\"真正负责在网络上传输具体数据的是会话层以下的 4 层\",\"...\",\"2.3. TCP/IP 模型\",\"2.3.1. TCP/IP 的具体含义\",\"TCP/IP 并不是指 TCP 与 IP 两种协议\",\"很多情况下，TCP/IP只是利用 IP 进行通信时所必须用到的协议群的统称，也称 TCP/IP 为网际协议族\",\"...\",\"2.3.2. 参考模型\",\"最下面两层可以一起叫：链路层\",\"tcp/ip 分为 4 层\",\"...\",\"2.3.3. 4 各层作用\",\"**应用层：**应用层是最接近用户的层，它为应用程序提供网络服务。\",\"这一层包括所有高级协议，如HTTP（用于网页访问）、SMTP（用于电子邮件传输）、FTP（用于文件传输）等。\",\"应用层协议定义了应用程序如何通过网络进行通信和数据交换。\",\"**传输层：**传输层负责提供端到端的通信服务。\",\"它确保数据可以在系统之间可靠地、按顺序地以及错误检测和修正的方式传输。\",\"**网络层：**网络层处理数据包在网络中的路由。\",\"它决定数据如何从源头到达目的地，通常涉及跨越多个网络和路由器。\",\"IP协议就位于这一层，它定义了IP地址和数据包如何封装和处理。\",\"**链路层：**链路层负责在网络的物理媒介上发送和接收数据。\",\"这包括处理与物理网络硬件（例如以太网、Wi-Fi、光纤等）的直接交互，以及与地址解析协议（ARP）相关的任务，用于将IP地址解析为物理MAC地址。\",\"2.3.4. 4 层通信\",\"...\",\"2.4. OSI 和 TCP/IP 模型联系和区别\",\"2.4.1. 联系\",\"基本概念相似：两者都采用了分层的概念，将复杂的网络通信任务分解为更小、更易管理的部分。\",\"共同目标：两者的目标都是实现网络设备之间的互操作性和通信。\",\"部分层次对应：OSI模型的传输层、应用层在TCP/IP模型中有直接对应的层次，而网络层在OSI模型中也有对应，只是在TCP/IP模型中称为互联网层。\",\"2.4.2. 区别\",\"层数不同：OSI模型有7层，而TCP/IP模型通常有4层。\",\"实用性：TCP/IP模型是为了在实际网络中应用而设计的，而OSI模型是理论上的指导框架。\",\"标准化时间：TCP/IP模型比OSI模型更早被广泛采用，因为它是随着互联网的发展而发展起来的。\",\"中间层的差异：OSI模型设有会话层和表示层，而TCP/IP模型通常不区分这些层次\",\"灵活性：TCP/IP模型在实践中被证明更为灵活和可靠，因为它是基于现实世界的需求而设计的。\",\"协议举例：\",\"在OSI模型中，网络层对应的协议包括IPX和IP，而在TCP/IP模型中，互联网层主要使用的协议是IP。\",\"在传输层，OSI模型和TCP/IP模型都使用TCP和UDP协议。\",\"3. 应用层\",\"3.1. HTTP\",\"3.1.1. 报文格式\",\"请求报文、响应报文组成\",\"两者结构相似，三大部分组成：\",\"起始行：描述请求或响应的基本信息\",\"头部字段集合：使用 key-value 形式更详细地说明报文；\",\"消息正文：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据\",\"...\",\"请求报文、响应报文结构\",\"HTTP 协议规定报文必须有 header，但可以没有 body，\",\"header 之后必须要有一个\\\"空行\\\"，也就是\\\"CRLF\\\"，十六进制的\\\"0D0A\\\"\",\"...\",\"...\",\"头部字段 header\",\"头部字段是 key-value 的形式\",\"可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头\",\"注意：\",\"字段名不区分大小写，例如\\\"Host\\\"也可以写成\\\"host\\\"，但首字母大写的可读性更好\",\"字段名里不允许出现空格，可以使用连字符\\\"-\\\"，但不能使用下划线\\\"_\\\"\",\"字段名后面必须紧接着\\\":\\\"，不能有空格，而\\\":\\\"后的字段值前可以有多个空格\",\"字段的顺序是没有意义的，可以任意排列不影响语义\",\"字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie\",\"一个 GET 请求实例\",\"...\",\"一个 POST 请求示例\",\"...\",\"3.1.2. 请求方法\",\"...\",\"目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式：\",\"GET：获取资源，可以理解为读取或者下载数据；\",\"HEAD：获取资源的元信息；\",\"POST：向资源提交数据，相当于写入或上传数据；\",\"PUT：类似 POST；\",\"DELETE：删除资源；\",\"CONNECT：建立特殊的连接隧道；\",\"OPTIONS：列出可对资源实行的方法；\",\"TRACE：追踪请求 - 响应的传输路径。\",\"GET、HEAD\",\"含义：请求从服务器获取资源\",\"HEAD 可以看作是 GET 的简化版，可以在并不真正需要资源的场合，避免传输 body 数据的浪费。（比如检查某个文件是否存在）\",\"POST、PUT\",\"含义：向 URI 指定的资源提交数据，数据就放在报文的 body 里（向服务器发送数据）\",\"通常 POST 表示的是\\\"新建\\\"\\\"create\\\"的含义，而 PUT 则是\\\"修改\\\"\\\"update\\\"的含义。（PUT 用到的比较少，有些服务器选择直接禁用 PUT 方法）\",\"扩展方法\",\"HTTP 协议有良好的扩展性：可以任意添加请求动作，只要请求方和响应方都能理解就行。\",\"可以根据实际需求，自己发明新的方法，比如\\\"PULL\\\"拉取某些资源到本地，\\\"PURGE\\\"清理某个目录下的所有缓存数据。\",\"安全、幂等\",\"**安全：**是指请求方法不会\\\"破坏\\\"服务器上的资源，即不会对服务器上的资源造成实质的修改。\",\"**幂等：**实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次\\\"\\\"幂\\\"后结果\\\"相等\\\"。\",\"GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是\\\"资源不存在\\\"，所以也是幂等的。\",\"POST 和 PUT 的幂等性质就略费解一点。\",\"POST 是\\\"新增或提交数据\\\"，多次提交数据会创建多个资源，即使数据相同。所以不是幂等的\",\"PUT 是\\\"替换或更新数据\\\"，多次更新一个资源，只要数据是相同的，资源还是第一次更新的状态，所以是幂等的。\",\"3.1.3. URI 和 URL\",\"URI：统一资源标识符（Uniform Resource Identifier）\",\"URL：统一资源定位符（Uniform Resource Locator）\",\"URN：统一资源名称（Uniform Resource Name）\",\"URI 是一个包含URL和URN的超集，它可以是一个位置（URL），也可以是一个名字（URN）\",\"URI 通常可以叫 URL\",\"URI 的格式\",\"...\",\"URI 基本组成\",\"**scheme：**协议名，表示资源应该使用哪种协议来访问。\",\"**😕/ ：**把 scheme 和后面的部分分离开。\",\"**host：**表示资源所在的主机名，通常的形式是\\\"host:port\\\"主机名可以是 IP 地址或者域名的形式\",\"**path：**标记资源所在位置\",\"**?query：**在 path 之后，用一个\\\"?\\\"开始，但不包含\\\"?\\\"，表示对资源附加的额外要求\",\"参数 query 的格式，：多个\\\"key=value\\\"的字符串，这些 KV 值用字符\\\"&\\\"连接。\",\"http://www.chrono.com:8080/11-1?uid=1234&name=mario&referer=xxx\",\"**#fragment：**片段标识符，是 URI 所定位的资源内部的一个\\\"锚点\\\"或者说是\\\"标签\\\"，浏览器可以在获取资源后直接跳转到它指示的位置。\",\"补充\",\"可以直接把文件或目录从资源管理器\\\" 拖入浏览器窗口，地址栏就会显示出对应的 URI。\",\"查询参数 query 也可以不使用\\\"key=value\\\"的形式，只是单纯的\\\"key\\\"，这样\\\"value\\\"就是空字符串。\",\"如果查询参数 query 太长，也可以使用 POST方法，放在 body 里发送给服务器。\",\"URL还有\\\"绝对URL\\\"和\\\"相对URL\\\"之分多用在HTML页面里标记引用的其他资源，而在HTTP 请求行里则不会出现。\",\"需要注意URI编码转义与 HTML里的编码转义是完全不同的，URI 转义使用的是\\\"%\\\"，而HTML 转义使用的是\\\"&#\\\"，不要混淆\",\"3.1.4. 状态码\",\"RFC规定 HTTP 的状态码为三位数，被分为五类：\",\"1xx ：表示目前是协议处理的中间状态，还需要后续操作\",\"2xx ：表示成功状态\",\"3xx ：重定向状态，资源位置发生变动，需要重新请求\",\"4xx ：请求报文有误\",\"5xx ：服务端发生错误\",\"3.1.4.1. 1xx Informational 信息化\",\"表示临时响应并需要请求者继续执行操作的状态代码。\",\"...\",\"点击图片可查看完整电子表格\",\"3.1.4.2. 2xx Success 成功\",\"表示成功处理了请求的状态代码。\",\"...\",\"点击图片可查看完整电子表格\",\"3.1.4.3. 3xx Redirection 重定向\",\"表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\",\"...\",\"点击图片可查看完整电子表格\",\"3.1.4.4. 4xx Client Error 客户端错误\",\"这些状态代码表示请求可能出错，妨碍了服务器的处理。\",\"...\",\"点击图片可查看完整电子表格\",\"3.1.4.5. 5xx Server Error 服务端错误\",\"这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\",\"...\",\"点击图片可查看完整电子表格\",\"3.1.5. 连接\",\"3.1.5.1. 短链接\",\"短链接\",\"HTTP 协议最初是个非常简单的协议，通信过程也采用了简单的“请求 - 应答”方式。\",\"它底层的数据传输基于 TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。\",\"因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“短连接”（short-lived connections）。早期的 HTTP 协议也被称为是“无连接”的协议。\",\"短链接缺点\",\"短连接的缺点相当严重，因为在 TCP 协议里，建立连接和关闭连接都是非常“昂贵”的操作。\",\"TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；\",\"关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。\",\"...\",\"3.1.5.2. 长连接\",\"长连接也叫“持久连接”\",\"把时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上。\",\"...\",\"3.1.5.3. 连接相关的头字段\",\"HTTP/1.1 中的连接都会默认启用长连接\",\"也可以在请求头里明确地要求使用长连接机制，使用的字段是Connection，值是 keep-alive\",\"...\",\"3.1.5.4. 队头阻塞\",\"队头阻塞与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。\",\"因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。 队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。\",\"如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。\",\"...\",\"3.1.6. 连接状态\",\"3.1.6.1. http 无状态\",\"HTTP无状态协议，是指协议对于事务处理没有记忆能力，之前做了啥完全记不住，每次请求都是完全独立互不影响的，没有任何上下文信息。\",\"缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，来实现上下文和状态的交互。\",\"原生无状态的http协议，我们每换一个页面可能就得重新登录一次\",\"3.1.6.2. Cookie\",\"Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。\",\"内存Cookie：由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。\",\"硬盘Cookie：保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。\",\"所以，按存在时间，可分为非持久Cookie和持久Cookie。\",\"工作过程\",\"响应头字段Set-Cookie\",\"请求头字段Cookie\",\"...\",\"服务端创建 Cookie\",\"当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie 选项。\",\"浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。\",\"另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。\",\"...\",\"Cookie 存在问题\",\"...\",\"3.1.6.3. Session\",\"Session代表服务器与浏览器的一次会话过程，并且完全有服务端掌控，实现分配ID、会话信息存储、会话检索等功能。\",\"Session机制将用户的所有活动信息、上下文信息、登录信息等都存储在服务端，只是生成一个唯一标识ID发送给客户端，后续的交互将没有重复的用户信息传输，取而代之的是唯一标识ID，暂且称之为Session-ID\",\"与 Cookie 对比\",\"如果说Cookie是客户端行为，那么Session就是服务端行为。\",\"...\",\"Session 实现方式\",\"首先明确一点：Session和Cookie没有直接的关系，可以认为Cookie只是实现Session机制的一种方法途径而已，没有Cookie还可以用别的方法。\",\"session的实现主要两种方式：cookie与url重写，而cookie是首选方式\",\"因为各种现代浏览器都默认开通cookie功能，但是每种浏览器也都有允许cookie失效的设置，因此对于Session机制来说还需要一个备胎。\",\"...\",\"Session 利用 Cookie 实现，简单交互过程\",\"当客户端第一次请求session对象时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象。\",\"当浏览器下次请求别的资源的时候，浏览器会将sessionID放置到请求头中，服务器接收到请求后解析得到sessionID，服务器找到该id的session来确定请求方的身份和一些上下文信息。\",\"Session 机制的弊端\",\"Session信息是存储在服务端的，因此如果用户量很大的场景，Session信息占用的空间就不容忽视。\",\"集群&分布式更是\",\"...\",\"3.1.6.4. Token\",\"Token是令牌的意思，由服务端生成并发放给客户端，具有时效性的一种验证身份的手段\",\"简单交互流程\",\"...\",\"以 JWT 为例\",\"以JSON Web Token（JWT）为例，Token主要由3部分组成：\",\"Header头部信息：记录了使用的加密算法信息\",\"Payload 净荷信息：记录了用户信息和过期时间等\",\"Signature 签名信息：Token 根据header中的加密算法和payload中的用户信息以及密钥key来生成\",\"header和payload的信息不做加密，只做一般的base64编码，服务端收到token后剥离出header和payload获取算法、用户、过期时间等信息\",\"然后根据自己的加密密钥来生成signature，并与客户端的sign进行一致性验证。\",\"...\",\"3.1.7. http 缓存技术\",\"3.1.7.1. 强制缓存\",\"强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：\",\"Cache-Control， 是一个相对时间；\",\"Expires，是一个绝对时间；\",\"Cache-Control 的优先级高于 Expires\",\"3.1.7.2. 协商缓存\",\"协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存\",\"...\",\"3.1.8. http 版本\",\"3.1.8.1. HTTP/0.9 单行协议\",\"最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。\",\"HTTP/0.9 极其简单：请求由单行指令构成，以唯一可用方法 GET开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。\",\"响应也极其简单的：只包含响应文档本身。\",\"<html> 这是一个非常简单的 HTML 页面 </html>\",\"跟后来的版本不同，HTTP/0.9 的响应内容并不包含 HTTP 头。\",\"这意味着只有 HTML 文件可以传送，无法传输其他类型的文件。\",\"也没有状态码或错误代码。一旦出现问题，一个特殊的包含问题描述信息的 HTML 文件将被发回，供人们查看。\",\"3.1.8.2. HTTP/1.0 构建可扩展性\",\"由于 HTTP/0.9 协议的应用十分有限，浏览器和服务器迅速扩展内容使其用途更广：\",\"协议版本信息现在会随着每个请求发送（ HTTP/1.0 被追加到了 GET 行）。\",\"状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，并相应调整行为（如更新或使用本地缓存）。\",\"引入了 HTTP 标头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性。\",\"在新 HTTP 标头的帮助下，具备了传输除纯文本 HTML 文件以外其他类型文档的能力（凭借 Content-Type标头）。\",\"一个典型的请求看起来就像这样：\",\"GET /mypage.html HTTP/1.0 User-Agent: NCSA\\\\_Mosaic/2.0 (Windows 3.1) 200 OK Date: Tue, 15 Nov 1994 08:12:31 GMT Server: CERN/3.0 libwww/2.17 Content-Type: text/html <HTML> 一个包含图片的页面 <IMG SRC=\\\"/myimage.gif\\\"></HTML>\",\"接下来是第二个连接，请求获取图片（并具有相同的响应）：\",\"GET /myimage.gif HTTP/1.0 User-Agent: NCSA\\\\_Mosaic/2.0 (Windows 3.1) 200 OK Date: Tue, 15 Nov 1994 08:12:32 GMT Server: CERN/3.0 libwww/2.17 Content-Type: text/gif (这里是图片内容)\",\"3.1.8.3. HTTP/1.1 标准化的协议\",\"HTTP/1.0 多种不同的实现方式在实际运用中显得有些混乱\",\"HTTP/1.1 消除了大量歧义内容并引入了多项改进：\",\"连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间。\",\"增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。\",\"支持响应分块。\",\"引入额外的缓存控制机制。\",\"引入内容协商机制，包括语言、编码、类型等。并允许客户端和服务器之间约定以最合适的内容进行交换。\",\"凭借 Host标头，能够使不同域名配置在同一个 IP 地址的服务器上。\",\"一个典型的请求流程，所有请求都通过一个连接实现，看起来就像这样：\",\"GET /zh-CN/docs/Glossary/Simple\\\\_header HTTP/1.1 Host: developer.mozilla.org User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9, \\\\*/\\\\* ;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://developer.mozilla.org/zh-CN/docs/Glossary/Simple\\\\_header 200 OK Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html; charset=utf-8 Date: Wed, 20 Jul 2016 10:55:30 GMT Etag: \\\"547fa7e369ef56031dd3bff2ace9fc0832eb251a\\\" Keep-Alive: timeout=5, max=1000 Last-Modified: Tue, 19 Jul 2016 00:59:33 GMT Server: Apache Transfer-Encoding: chunked Vary: Cookie, Accept-Encoding (content) GET /static/img/header-background.png HTTP/1.1 Host: developer.mozilla.org User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: https://developer.mozilla.org/zh-CN/docs/Glossary/Simple\\\\_header 200 OK Age: 9578461 Cache-Control: public, max-age=315360000 Connection: keep-alive Content-Length: 3077 Content-Type: image/png Date: Thu, 31 Mar 2016 13:34:46 GMT Last-Modified: Wed, 21 Oct 2015 18:27:50 GMT Server: Apache (image content of 3077 bytes)\",\"3.1.8.4. HTTP/2 为了更优异的表现\",\"HTTP/2 在 HTTP/1.1 有几处基本的不同：\",\"HTTP/2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。\",\"这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。\",\"压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。\",\"其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。\",\"HTTP2 不需要站点和应用做出改变：使用 HTTP/1.1 和 HTTP/2 对他们来说是透明的。\",\"拥有一个最新的服务器和新点的浏览器进行交互就足够了。\",\"3.1.8.5. 后 HTTP/2 进化\",\"随着 HTTP/2.的发布，就像先前的 HTTP/1.x 一样，HTTP 没有停止进化，HTTP 的扩展性依然被用来添加新的功能\",\"3.1.8.6. HTTP/3 基于 QUIC 的 HTTP\",\"HTTP 的下一个主要版本，HTTP/3 有着与 HTTP 早期版本的相同语义，但在传输层部分使用 QUIC (en-US)而不是 TCP。\",\"QUIC 旨在为 HTTP 连接设计更低的延迟。类似于 HTTP/2，它是一个多路复用协议，但是 HTTP/2 通过单个 TCP 连接运行，所以在 TCP 层处理的数据包丢失检测和重传可以阻止所有流。\",\"QUIC 通过 UDP运行多个流，并为每个流独立实现数据包丢失检测和重传，因此如果发生错误，只有该数据包中包含数据的流才会被阻止。\",\"3.2. HTTPS\",\"3.2.1. http 和 https 的区别\",\"HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。 HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。\",\"HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。 而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。\",\"HTTP 的端口号是 80，HTTPS 的端口号是 443。\",\"HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。\",\"HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。\",\"...\",\"3.2.2. https 混合加密\",\"在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。\",\"在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。\",\"3.2.3. 非对称加密\",\"3.2.3.1. 生成密钥\",\"生成一对匹配的 私钥 和 公钥 (ps：公钥其实是根据私钥生成的)\",\"将公钥公布给外界\",\"...\",\"RSA 算法\",\"为什么公钥自己加密的数据自己还解不出来？\",\"RSA算法\",\"RSA算法计算流程如下：\",\"随机选取两个质数p和q\",\"计算 n = pq\",\"计算 φ(n) = (p-1)(q-1)\",\"找一个与φ(n)互质的小奇数e，互质是指两个数的公约数只有1\",\"对模φ(n)，计算e的乘法逆元d，即找到一个d，使下列等式成立：(e*d) mod φ(n) = 1\",\"得到公钥：(e, n)，私钥： (d, n)\",\"加密过程：c = (m^e) mod n, （c为加密后的密文，m为原文）\",\"解密过程：m = (c^d) mod n\",\"第七步说明下，m的e次方，m就是我们发送的原文，可以是文本，json，图片，虽然形式多样，但是在计算机里面都是二进制01，所以可以转换成数字求次方。下面我们找两个数来试一下这个算法：\",\"随便选两个质数23和61\",\"计算 n = 23 * 61 = 1403\",\"计算 φ(n) = (23-1) * (61-1) = 22 * 60 = 1320\",\"找一个与φ(n)互质的小奇数e，我们选7\",\"计算乘法逆元d，我这里算好的是 d =943。对乘法逆元感兴趣的朋友可以网上搜搜怎么算，因为不是本文主题，我就不展开了。\",\"得到公钥(7, 1403)，私钥(943, 1403)\",\"我们用公钥随便加密一个5试试，加密 c = (m^e) mod n = (5^7) % 1403 = 78125 % 1403 = 960\",\"私钥解密: m = (c^d) mod n = (960^943) % 1403 = 5，(960^943)这个数字超级大，一般计算器算不出来,JS计算更不行\",\"再试试私钥加密：c = (m^d) mod n = (5^943) % 1403 = 283\",\"公钥解密: m = (c^e) mod n = (283 ^ 7) % 1403 = 5\",\"注意看加密算法(m^e) mod n这是个模运算啊，模运算是不能反解的。\",\"比如5对4取模，5%4=1，但是反过来，知道x%4=1，求x。这个x可以有无限个，5，9，13，17。。。\",\"所以即使你有公钥(e,n),和密文c，你也不知道(m^e)到底取哪个值，是反解不出来的，这就是非对称加密的核心机密，私钥加密同理，自己加密的自己也反解不出来\",\"3.2.3.2. 公钥加密\",\"场景： 用来针对互联网上加密数据传递\",\"Linda 用 James的公钥 对数据进行加密，然后发给 James，James用自己的私钥解密\",\"...\",\"因为一个公钥加密的数据 只有 对应的 私钥才能解密，所以密文很安全\",\"补充：如果要在网络上相互发送密文，可以让对方也发对方的公钥过来，用对方的公钥来加密\",\"3.2.3.3. 私钥签名\",\"场景： 目的是为了将明文公布给别人，同时证明是自己发的；可以防止明文被篡改。\",\"第一步： James 用 James的私钥 对明文的hash值进行加密，把密文(签名)和明文一起发给 Linda\",\"...\",\"第二步： Linda 用 James 的公钥 进行解密，解密后的明文hash值 和 接收到的明文的hash值进行对比，如果一样则是 James 发的\",\"...\",\"3.2.4. 数字证书、CA 机构\",\"数字签名是什么？ - 阮一峰的网络日志\",\"3.2.4.1. 一个数字证书\",\"一个数字证书通常包含：\",\"公钥；\",\"持有者信息；\",\"证书认证机构（CA）的信息；\",\"CA 对这份文件的数字签名及使用的算法；\",\"证书有效期；\",\"还有一些其他额外信息；\",\"为了让服务端的公钥被大家信任，服务端的证书都是由 CA （证书认证机构）签名\",\"CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。\",\"3.2.4.2. 数字证书签发、验证流程\",\"...\",\"CA 签发证书的过程，如上图左边部分：\",\"首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；\",\"然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；\",\"最后将 Certificate Signature 添加在文件证书上，形成数字证书；\",\"客户端校验服务端的数字证书的过程，如上图右边部分：\",\"首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；\",\"通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；\",\"最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信\",\"3.2.4.3. 证书链\",\"向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的\",\"比如百度的证书，从下图你可以看到，证书的层级有三级：\",\"...\",\"3.2.5. TLS 之 RSA 握手\",\"3.2.5.1. 握手过程流程图\",\"通常经过 4 个消息即可完成 TLS 握手。2 个 RTT\",\"...\",\"3.2.5.2. 抓包握手过程\",\"...\",\"...\",\"3.2.5.3. 第一次握手：客户端打招呼\",\"客户端发送 Client Hello 信息\",\"包括客户端使用的 TLS 版本号\",\"支持的密码套件列表\",\"生成的客户端随机数 Client Random\",\"...\",\"3.2.5.4. 第二次握手：服务端回应招呼\",\"服务端收到 Client Hello 后\",\"确认 TLS 版本号是否支持\",\"从密码套件列表中选择一个密码套件\",\"生成服务端随机数\",\"服务端返回 Server Hello\",\"消息里面有：\",\"服务器确认的 TLS 版本号\",\"出了服务端随机数 Server Random\",\"从客户端的密码套件列表选择了一个合适的密码套件。\",\"...\",\"密码套件是： Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256\",\"基本的形式是「密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法」\",\"由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；\",\"握手后的通信使用 AES 对称算法，密钥长度 128 位\",\"分组模式是 GCM\",\"摘要算法 SHA256 用于消息认证和产生随机数\",\"服务端发送 Server Certificate\",\"消息里含有数字证书\",\"...\",\"服务端发送 Server Hello Done\",\"目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。\",\"...\",\"3.2.5.5. 第三次握手：客户端确认回应\",\"客户端收到证书后\",\"客户端验证完证书后，认为可信则继续往下走\",\"客户端回应 Client Key Exchange\",\"生成一个新的随机数 (pre-master)\",\"用服务器的 RSA 公钥加密该随机数通过「Client Key Exchange」消息传给服务端\",\"...\",\"服务端收到后解密\",\"服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。\",\"至此，客户端和服务端都共享了三个随机数\",\"Client Random\",\"Server Random\",\"pre-master\",\"客户端发送 Change Cipher Spec\",\"双方根据已经得到的三个随机数，生成**会话密钥（Master Secret）**它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。\",\"Change Cipher Spec 之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。\",\"...\",\"客户端再发送 Encrypted Handshake Message（Finishd）\",\"把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下\",\"让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。\",\"...\",\"3.2.5.6. 第四次握手\",\"服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。\",\"最后，就用「会话密钥」加解密 HTTP 请求和响应了\",\"3.3. DNS\",\"DNS 查询原理详解 - 阮一峰的网络日志\",\"3.4. RPC\",\"3.5. CDN\",\"4. 传输层\",\"4.1. TCP\",\"4.1.1. 三次握手、四次挥手\",\"4.1.2. 可靠性\",\"4.1.3. 粘包、拆包\",\"4.1.4. 半连接、全连接\",\"4.1.5. tcp 异常\",\"4.2. UDP\",\"4.2.1. udp 实现可靠传输\",\"5. 网络层\",\"5.1. IP\",\"5.2. ICMP\",\"5.3. DHCP\",\"5.4. NAT\",\"6. 数据链路层\",\"6.1. ARP 协议\",\"7. 网络传输场景\",\"7.1. 网页异常排查\",\"8. 网络代理\",\"8.1. 正向代理、反向代理\",\"8.2. 负载均衡\"]},\"250\":{\"c\":[\"计算机网络\",\"网络基础\"]},\"251\":{\"c\":[\"网络协议\",\"TCP/IP\",\"OSI模型\",\"网络架构\"]},\"252\":{\"h\":\"Redis\",\"t\":[\"本系列包含Redis相关的技术文档和学习笔记。\"]},\"253\":{\"h\":\"Go语言Channel详解\",\"t\":[\"本文详细介绍Go语言Channel的底层实现原理和使用方法。\"]},\"254\":{\"h\":\"1. Channel简介\",\"t\":[\"Channel是Go语言并发编程的核心概念之一：\",\"Go语言遵循CSP并发编程模式（Communicating Sequential Process 通信顺序进程），提倡通过通信来实现内存共享，而不提倡通过共享内存来实现通信\",\"Channel的存在，使Go的并发变得简单快捷\",\"Channel和select的搭配使用以及调度器对goroutine的调度，可以高效实现协程的阻塞和唤醒及多路复用\"]},\"255\":{\"h\":\"2. Channel的分类\",\"t\":[\"Channel根据缓冲区大小可以分为两类：\"]},\"256\":{\"h\":\"2.1 有缓冲Channel\",\"t\":[\"读写时是阻塞的，向channel写入一条数据，如果这条数据还没被消费掉，再写入新的数据就会阻塞\",\"读取也是，当channel没有可读的数据，再读取就会阻塞\"]},\"257\":{\"h\":\"2.2 无缓冲Channel\",\"t\":[\"读写是非阻塞的，但是要满足一定条件——队列没满\",\"如果channel队列满了，就会退化成无缓冲channel一样\",\"...\"]},\"258\":{\"h\":\"3. Channel的数据结构\",\"t\":[\"Channel用make创建初始化会在堆上分配一个runtime.hchan类型的数据结构，并返回指针指向堆上这块hchan内存区域，所以channel是一个引用类型。\",\"为什么在堆上创建而不是栈上？因为channel是用来实现goroutine间通信的，其生命周期和作用域很可能不局限于某个具体的函数。\",\"...\"]},\"259\":{\"h\":\"3.1 sendq和recvq字段\",\"t\":[\"存储当前channel由于缓冲区（buf）不足而阻塞的：要读取或者要写入当前的channel的goroutine列表。\",\"这些等待队列使用双向链表waitq表示，waitq是一个对sudog链表进行封装之后的一个结构。\",\"字段为sudog队列的首尾指针，链表中所有元素都是sudog结构。\"]},\"260\":{\"h\":\"waitq结构\",\"t\":[\"...\"]},\"261\":{\"h\":\"3.2 sudog结构\",\"t\":[\"sudog和goroutine之间存在绑定关系，goroutine是绑定在sudog中这个结构上的：\",\"recvq可以理解为：读操作阻塞在channel的goroutine列表\",\"sendq是写操作阻塞在channel的goroutine列表\",\"...\",\"...\"]},\"262\":{\"h\":\"4. Channel操作\"},\"263\":{\"h\":\"4.1 Channel初始化\",\"t\":[\"用make函数初始化一个channel，而在运行时其实是调用makechan函数来完成初始化工作。\",\"源码分析：\",\"...\",\"makechan有两个参数，第一个代表创建的channel的类型，即是通道可以传递的消息类型，第二个参数代表通道中的元素大小\",\"创建的主要逻辑位于switch中，有三种情况： \",\"没有缓冲区buf，即创建无缓冲区的channel，只分配hchan本身结构体大小的内存\",\"有缓冲区buf，但元素类型不含指针，一次为当前的hchan结构和buf数组分配一块连续的内存空间\",\"有缓冲区，且元素包含指针类型，分两次分配内存，先为hchan结构和分配内存，再为buf数组元素分配内存\",\"不同状态的channel，写入时结果如下：\",\"...\"]},\"264\":{\"h\":\"4.2 Channel写入\",\"t\":[\"运行时调用了runtime.chansend函数，源码如下：\",\"...\",\"...\",\"...\",\"向channel发送数据分为三种方式：直接发送、缓冲发送、阻塞发送\",\"直接发送 \",\"当前channel有正在阻塞等待接受数据的goroutine，那么直接发送数据，直接从一个goroutine操作另一个goroutine的栈，将待发送数据直接copy到此处\",\"缓冲发送 \",\"会判定缓冲区的剩余空间，如果有剩余空间，将数据拷贝到channel中，sendx索引自增1（若sendx等于dataqsiz，则将sendx置0，原因是buf是一个环形数组）自增完成后，队列总数自增1\",\"阻塞发送 \",\"当前channel没有正在阻塞等待接受数据的goroutine，并且channel的缓冲区满了之后，发送goroutine就会阻塞，首先获取sudog，将发送的goroutine绑定到sudog上，加入到当前channel的发送阻塞队列，调用gopark方法挂起当前goroutine，等待被唤醒\",\"...\",\"流程图：\",\"...\",\"...\",\"...\",\"...\"]},\"265\":{\"h\":\"4.3 Channel读取\",\"t\":[\"读取都是调用chanrecv函数做数据接收，下面是chanrecv源码：\",\"func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // 特殊场景：非阻塞模式，并且没有元素的场景直接就可以返回了，这个分支是快速分支，下面的代码都是在锁内的； if !block && (c.dataqsiz == 0 && c.sendq.first == nil || c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) && atomic.Load(&c.closed) == 0 { return } // 以下所有的逻辑都在锁内； lock(&c.lock) if c.closed != 0 && c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(&c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } // 场景：如果发现有个人（sender）正在等着别人接收，那么刚刚好，直接把它的元素给到我们这里就好了； if sg := c.sendq.dequeue(); sg != nil { recv(c, sg, ep, func() { unlock(&c.lock) }, 3) return true, true } // 场景：ringbuffer 还有空间存元素，那么下面就可以把元素放到 ringbuffer 放好，递增索引，就可以返回了； if c.qcount > 0 { // 存元素 qp := chanbuf(c, c.recvx) if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) // 递增索引 c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(&c.lock) return true, true } // 代码到这说明 ringbuffer 空间是不够的，后面要做两个事情，是否需要阻塞？ // 如果 block 为 false ，那么直接就退出了，返回对应的返回值； if !block { unlock(&c.lock) return false, false } // 到这就说明要阻塞等待了，下面唯一要做的就是给阻塞做准备（准备好唤醒的条件） gp := getg() mysg := acquireSudog() mysg.releasetime = 0 mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil // goroutine 作为一个 waiter 入队列，等待条件满足之后，从这个队列里取出来唤醒； c.recvq.enqueue(mysg) // goroutine 切走，交出 cpu 执行权限 goparkunlock(&c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3) // 这里是被唤醒的开始的地方； if mysg != gp.waiting { throw(\\\"G waiting list is corrupted\\\") } // 下面做一些资源的清理 gp.waiting = nil closed := gp.param == nil gp.param = nil mysg.c = nil }\"]},\"266\":{\"h\":\"5. 参考资料\",\"t\":[\"Golang Channel 最详细的源码剖析\"]},\"267\":{\"c\":[\"Go\",\"数据结构\",\"并发编程\"]},\"268\":{\"c\":[\"Go\",\"Channel\",\"并发\",\"通信\"]},\"269\":{\"h\":\"Go语言Context详解\",\"t\":[\"本文详细介绍Go语言Context的底层实现原理和使用方法。\"]},\"270\":{\"h\":\"1. Context简介\",\"t\":[\"Context是Go语言中用于控制goroutine的一种机制，常用于处理请求的超时、取消以及传递请求相关的值。\",\"...\"]},\"271\":{\"h\":\"2. Context的底层实现\",\"t\":[\"Context在底层用到了2个接口，对这个接口有4种实现，以及提供了6个方法。\"]},\"272\":{\"h\":\"2.1 接口定义\",\"t\":[\"Context的核心接口定义：\",\"...\"]},\"273\":{\"h\":\"2.2 实现类型\",\"t\":[\"Context有四种基本实现类型：\",\"...\"]},\"274\":{\"h\":\"2.3 提供的方法\",\"t\":[\"Context包提供了以下几个方法用于创建和操作Context：\",\"...\"]},\"275\":{\"h\":\"3. 接口详解\"},\"276\":{\"h\":\"3.1 Context接口\",\"t\":[\"Context接口定义了四个必须实现的方法：\",\"...\"]},\"277\":{\"h\":\"3.2 canceler接口\",\"t\":[\"canceler接口用于实现上下文取消功能：\",\"...\"]},\"278\":{\"h\":\"4. Context实现类型\"},\"279\":{\"h\":\"4.1 emptyCtx\",\"t\":[\"emptyCtx是一个最基本的Context实现，它实际上只是一个int值：\",\"...\",\"...\",\"...\"]},\"280\":{\"h\":\"4.2 cancelCtx\",\"t\":[\"cancelCtx实现了可取消的Context：\",\"...\",\"...\",\"...\",\"...\",\"...\",\"...\",\"...\"]},\"281\":{\"h\":\"4.3 timerCtx\",\"t\":[\"timerCtx在cancelCtx的基础上增加了超时功能：\",\"...\",\"...\",\"...\"]},\"282\":{\"h\":\"4.4 valueCtx\",\"t\":[\"valueCtx用于在Context中存储和传递键值对：\",\"...\",\"...\",\"...\"]},\"283\":{\"h\":\"5. 参考资料\",\"t\":[\"Go语言标准库context.go源码解读\",\"Context进阶\"]},\"284\":{\"c\":[\"Go\",\"并发编程\"]},\"285\":{\"c\":[\"Go\",\"Context\",\"并发控制\",\"超时控制\"]},\"286\":{\"h\":\"Go语言defer机制详解\",\"t\":[\"本文详细介绍Go语言defer机制的底层实现原理和执行过程。\"]},\"287\":{\"h\":\"1. defer底层数据结构\",\"t\":[\"defer在Go语言运行时由特定的数据结构支持：\",\"...\",\"...\"]},\"288\":{\"h\":\"2. defer执行过程\",\"t\":[\"defer语句执行过程涉及注册和实际调用两个阶段：\",\"...\",\"...\"]},\"289\":{\"h\":\"3. defer内存分配方式\"},\"290\":{\"h\":\"3.1 _defer结构体的分配\",\"t\":[\"_defer结构体在不同场景下有不同的分配策略：\",\"...\"]},\"291\":{\"h\":\"3.2 堆上分配\",\"t\":[\"当defer无法在栈上分配时，会在堆上分配内存：\",\"...\",\"...\"]},\"292\":{\"h\":\"3.3 栈上分配\",\"t\":[\"在特定条件下，defer可以直接在栈上分配，避免堆分配的开销：\",\"...\"]},\"293\":{\"h\":\"4. defer的优化 - 开放编码\",\"t\":[\"开放编码是Go语言对defer实现的一种重要优化方式：\",\"...\",\"...\",\"...\",\"...\"]},\"294\":{\"h\":\"5. defer函数的执行机制\",\"t\":[\"defer函数的实际调用发生在包含它的函数返回前：\",\"...\",\"...\"]},\"295\":{\"c\":[\"Go\",\"语言特性\"]},\"296\":{\"c\":[\"Go\",\"defer\",\"延迟调用\",\"资源管理\"]},\"297\":{\"h\":\"Go语言接口详解\",\"t\":[\"本文详细介绍Go语言接口的底层实现原理和使用方法。\"]},\"298\":{\"h\":\"1. 接口基础概念\",\"t\":[\"Go语言中的接口是一种特殊的类型，定义了一组方法的集合，但没有具体实现。\"]},\"299\":{\"h\":\"2. 空接口 interface{}\"},\"300\":{\"h\":\"2.1 概念与用途\",\"t\":[\"没有任何方法的接口为空接口\",\"空接口可以接受任意数据类型：可以将任意类型的数据赋值给一个空接口\"]},\"301\":{\"h\":\"2.2 空接口的结构\",\"t\":[\"空接口在运行时由以下结构表示：\",\"...\"]},\"302\":{\"h\":\"2.3 _type字段解析\",\"t\":[\"_type 是什么：\",\"_type 是 Go 里面所有类型的一个抽象，包含了：类型大小，哈希，对齐，以及k类型编号等，决定了data字段如何解析和操作\",\"Go 中几乎所有的数据结构都可以抽象成_type\",\"...\"]},\"303\":{\"h\":\"2.4 动态类型和动态值\",\"t\":[\"空接口的动态类型和动态值示例：\",\"...\",\"...\"]},\"304\":{\"h\":\"3. 非空接口\"},\"305\":{\"h\":\"3.1 概念\",\"t\":[\"包含方法列表的接口就是非空接口\",\"...\"]},\"306\":{\"h\":\"3.2 非空接口结构\",\"t\":[\"非空接口在运行时由以下结构表示：\",\"...\"]},\"307\":{\"h\":\"3.3 itab结构详解\",\"t\":[\"itab结构是非空接口实现的核心：\",\"...\",\"...\",\"itab字段含义：\",\"**inter：**指向 interfacetype 结构的指针，interfacetype 结构记录了这个接口的方法列表。\",\"**_type：**实际类型的指针，指向 _type 结构，_type 结构保存了接口的动态类型信息，与空接口的_type 一样，即赋值给这个接口的具体类型信息的元数据\",\"**hash：**该类型的hash值，itab 中的 hash 和 itab.type 中的 hash 相等，其实是从 itab._type 中拷贝出来的，目的是用于快速判断类型是否相等。\",\"**fun：**fun 是一个指针数组，里面保存了实现了该接口的实际类型的方法地址（只包含该接口方法）。 \",\"这些方法地址实际上是从interfacetype结构中的mhdr 拷贝出来的，用的时候快速定位到方法。\",\"如果该接口对应的动态类型没有实现接口的所有方法，那么itab.fun[0] == 0,表示断言失败，该类型不能赋值给该接口\"]},\"308\":{\"h\":\"3.4 interfacetype结构\",\"t\":[\"接口类型在运行时由interfacetype结构表示：\",\"...\"]},\"309\":{\"h\":\"4. 接口赋值过程\"},\"310\":{\"h\":\"4.1 接口赋值示例\",\"t\":[\"下面是一个非空接口赋值的例子：\",\"...\"]},\"311\":{\"h\":\"4.2 赋值前后的结构变化\",\"t\":[\"在程序第28行，赋值之前，ifc的结构如下：\",\"...\",\"在第29行，给ifc赋值一个包含方法的结构体a之后，ifc的结构如下图：\",\"...\",\"...\"]},\"312\":{\"h\":\"5. itab缓存机制\"},\"313\":{\"h\":\"5.1 itab复用\",\"t\":[\"为了提高性能，Go运行时会复用itab结构体：\",\"...\"]},\"314\":{\"h\":\"5.2 itabTable实现\",\"t\":[\"itabTable是Go运行时管理itab的数据结构：\",\"...\",\"...\",\"...\",\"...\"]},\"315\":{\"h\":\"6. 参考资料\",\"t\":[\"类型断言究竟咋\\\"断言\\\"？_哔哩哔哩_bilibili\"]},\"316\":{\"c\":[\"Go\",\"数据结构\"]},\"317\":{\"c\":[\"Go\",\"interface\",\"接口\",\"多态\"]},\"318\":{\"h\":\"Go语言Map详解\",\"t\":[\"本文详细介绍Go语言map的底层实现原理和使用方法。\"]},\"319\":{\"h\":\"1. Map概念基础\",\"t\":[\"Go语言中的map是一种哈希表实现，用于存储键值对数据。Go中map底层采用哈希表，用变种拉链法来解决哈希冲突问题。\"]},\"320\":{\"h\":\"1.1 哈希冲突\",\"t\":[\"哈希冲突是指不同的键计算出相同的哈希值：\",\"...\"]},\"321\":{\"h\":\"1.2 解决哈希冲突的方法\"},\"322\":{\"h\":\"拉链法\",\"t\":[\"拉链法通过链表结构来解决哈希冲突：\",\"...\"]},\"323\":{\"h\":\"开放地址法\",\"t\":[\"开放地址法通过探测空闲位置来解决哈希冲突：\",\"...\"]},\"324\":{\"h\":\"2. Map底层数据结构\"},\"325\":{\"h\":\"2.1 整体结构\",\"t\":[\"map是一个指向hmap的指针，该指针占用8个字节\",\"hmap是一个结构体，包含多个bucket数组（但并不是只有bucket）\",\"bucket数组的元素为bmap结构体，通过链表结构把bmap结构体连接起来\",\"一个bmap结构体能存放8个键值对，而不是一个\",\"...\"]},\"326\":{\"h\":\"2.2 hmap结构体\",\"t\":[\"hmap是map的主要数据结构：\",\"...\",\"字段含义：\",\"...\"]},\"327\":{\"h\":\"2.3 mapextra结构体\",\"t\":[\"mapextra包含了一些额外的字段：\",\"...\",\"字段含义：\",\"...\"]},\"328\":{\"h\":\"2.4 bmap结构体\",\"t\":[\"hmap真正存储数据的是buckets指向的bmap（桶）数组：\",\"...\",\"字段含义：\",\"...\"]},\"329\":{\"h\":\"3. Map工作原理\"},\"330\":{\"h\":\"3.1 tophash机制\",\"t\":[\"map会根据每一个key算出一个hash值\",\"hash值是一分为二使用的，分成：高位、低位\",\"...\",\"tophash就存放高8位。\",\"在上面的map底层结构图可以看到，bmap显示存储了8个tophash值，然后存储了8个键值对。\",\"注意：\",\"这8个键值对不是按照key + value这样key和value一起存储的。而是先存完连续的8个key，再存连续的8个value\",\"当键值对不够8个时，对应位置留空，这样子存储的好处是可以消除字节对齐带来的空间浪费\"]},\"331\":{\"h\":\"3.2 Map访问原理\",\"t\":[\"Map提供两种访问方式：\",\"...\",\"访问步骤：\",\"...\"]},\"332\":{\"h\":\"3.3 Map赋值原理\",\"t\":[\"Map赋值操作：\",\"...\",\"赋值流程：\",\"...\",\"...\"]},\"333\":{\"h\":\"4. 参考资料\",\"t\":[\"Go Map底层实现原理\",\"为什么 Go map 和 slice 是非线程安全的？\"]},\"334\":{\"c\":[\"Go\",\"数据结构\"]},\"335\":{\"c\":[\"Go\",\"Map\",\"哈希表\",\"键值对\"]},\"336\":{\"h\":\"Go语言切片详解\",\"t\":[\"本文详细介绍Go语言切片(slice)的实现原理和使用方法。\"]},\"337\":{\"h\":\"1. 切片基本概念\",\"t\":[\"切片(slice)可以理解为动态数组，追加元素时，如果切片容量不足，会自动扩容。\",\"...\"]},\"338\":{\"h\":\"2. 切片的数据结构\",\"t\":[\"切片在Go语言中由三部分组成：指向底层数组的指针、长度(len)和容量(cap)。\",\"...\"]},\"339\":{\"h\":\"3. 切片操作\"},\"340\":{\"h\":\"3.1 切片初始化\",\"t\":[\"切片可以通过多种方式进行初始化，包括从数组切片、通过make函数等。\",\"...\"]},\"341\":{\"h\":\"3.2 切片截取\",\"t\":[\"切片截取遵循左闭右开原则，即包含开始索引但不包含结束索引。\",\"...\"]},\"342\":{\"h\":\"3.3 切片复制\",\"t\":[\"当我们对切片进行赋值操作时，只复制切片结构，不复制底层数组。\",\"...\",\"...\"]},\"343\":{\"h\":\"4. 切片扩容机制\"},\"344\":{\"h\":\"4.1 扩容示例\",\"t\":[\"下面是一个有趣的切片扩容示例：\",\"...\",\"解析：\",\"arr1 slice struct{ array ->//// len = 1 cap = 4 } [ ] -> [1] arr2 slice struct{ array ->//// len = 2 cap = 4 } [1] -> [1,2] -> [1,3] arr3 slice struct{ array ->//// len = 2 cap = 4 } [1,2] -> [1,3]\",\"...\"]},\"345\":{\"h\":\"4.2 扩容规则\",\"t\":[\"Go语言中切片的扩容规则如下：\",\"...\"]},\"346\":{\"h\":\"5. 切片完全复制\",\"t\":[\"要完全复制一个切片，不仅复制slice结构体，还要复制底层数组，应使用copy函数。\",\"注意：copy函数复制的数据数量取决于两个切片的len的最小值。\",\"...\"]},\"347\":{\"c\":[\"Go\",\"数据结构\"]},\"348\":{\"c\":[\"Go\",\"Slice\",\"切片\",\"数组\"]},\"349\":{\"h\":\"Go语言字符串详解\",\"t\":[\"本文详细介绍Go语言字符串的实现原理和使用方法。\"]},\"350\":{\"h\":\"1. 字符串基本概念\"},\"351\":{\"h\":\"1.1 源代码定义\",\"t\":[\"在sec/builtin/builtin.go中，Go对字符串的定义如下：\",\"...\",\"翻译：\",\"字符串是所有8bit字节的集合，但不一定是UTF-8编码的文本\",\"字符串可以是empty但不能是nil，空字符串就是\\\"\\\"没有任何字符\",\"字符串不可以被修改，所有字符串类型的值都是不可变的\"]},\"352\":{\"h\":\"1.2 字符串本质\",\"t\":[\"字符串本质是一串字符数组，每个字符在存储时都对应一个整数，也有可能对应多个整数，具体要看字符串的编码方式。\",\"...\"]},\"353\":{\"h\":\"2. 字符串数据结构\",\"t\":[\"字符串在Go语言中由两部分组成：指向底层字节数组的指针和长度。\",\"...\",\"本例中，len = 5，表示word这个字符串所占的字节数。\",\"len字段存储的是实际的字节数，而不是字符数，对于非单字节编码的字符，可能len>字符个数\"]},\"354\":{\"h\":\"2.1 stringStruct的使用\",\"t\":[\"既然runtime里stirng的定义有stringStruct结构，但是平常并没有用到这个结构体，它在哪里被使用了？\",\"...\"]},\"355\":{\"h\":\"3. 字符串操作\"},\"356\":{\"h\":\"3.1 string和[]byte的相互转换\",\"t\":[\"string可以被重新赋值，但是不能被修改：\",\"...\",\"为什么不能以下标的形式修改字符串？\",\"...\",\"可以把字符串转化为字节数组，通过下标修改字节数组，再转化回字符串（实际原来字符串没有变化，而是发生了拷贝）：\",\"...\"]},\"357\":{\"h\":\"3.2 转换原理\",\"t\":[\"string与[]byte转化会发生一次内存拷贝，或申请一块新的切片内存空间。\"]},\"358\":{\"h\":\"byte切片转化为string\",\"t\":[\"...\"]},\"359\":{\"h\":\"string转化为byte切片\",\"t\":[\"...\"]},\"360\":{\"h\":\"转化是否一定发生内存拷贝\",\"t\":[\"很多场景会用到这个转化，但不是每一次转化都发生上面的内存拷贝。转化为字符串被用于临时场景：\",\"...\"]},\"361\":{\"h\":\"4. 字符串表示方式\",\"t\":[\"Go语言中使用字面量来表示字符串有两种方式，双引号和反引号：\",\"...\"]},\"362\":{\"h\":\"5. 字符串拼接\",\"t\":[\"Go语言提供了多种字符串拼接方式，包括+运算符和fmt.Sprintf等：\",\"...\"]},\"363\":{\"h\":\"5.1 性能分析\",\"t\":[\"不同的字符串拼接方式在性能上有所差异：\",\"...\"]},\"364\":{\"c\":[\"Go\",\"数据结构\"]},\"365\":{\"c\":[\"Go\",\"String\",\"字符串\",\"Unicode\"]},\"366\":{\"h\":\"GMP模型：demo演示\"},\"367\":{\"h\":\"一、Demo 代码\",\"t\":[\"提示\",\"根据 Demo，思考以下问题：\",\"输出结果是什么？\",\"为什么先打印它，一次调度流程是怎么样的？\",\"如果 n 设置为 257、258，输出有什么不同？\",\"package main import ( \\\"fmt\\\" \\\"runtime\\\" \\\"sync\\\" ) func main() { // 设置只有一个 P 工作 runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} n := 10 // 启动 n 个 goroutine 打印 wg.Add(n) for i := 1; i <= n; i++ { go func(i int) { defer wg.Done() fmt.Println(\\\"我是协程：\\\", i) }(i) } wg.Wait() }\"]},\"368\":{\"h\":\"二、输出结果\",\"t\":[\"比较长...........\"]},\"369\":{\"h\":\"N = 10\",\"t\":[\"我是协程： 10 我是协程： 1 我是协程： 2 我是协程： 3 我是协程： 4 我是协程： 5 我是协程： 6 我是协程： 7 我是协程： 8 我是协程： 9\"]},\"370\":{\"h\":\"N = 257\",\"t\":[\"我是协程： 256 我是协程： 1 我是协程： 2 我是协程： 3 我是协程： 4 我是协程： 5 我是协程： 6 我是协程： 7 我是协程： 8 我是协程： 9 我是协程： 10 我是协程： 11 我是协程： 12 我是协程： 13 我是协程： 14 我是协程： 15 我是协程： 16 我是协程： 17 我是协程： 18 我是协程： 19 我是协程： 20 我是协程： 21 我是协程： 22 我是协程： 23 我是协程： 24 我是协程： 25 我是协程： 26 我是协程： 27 我是协程： 28 我是协程： 29 我是协程： 30 我是协程： 31 我是协程： 32 我是协程： 33 我是协程： 34 我是协程： 35 我是协程： 36 我是协程： 37 我是协程： 38 我是协程： 39 我是协程： 40 我是协程： 41 我是协程： 42 我是协程： 43 我是协程： 44 我是协程： 45 我是协程： 46 我是协程： 47 我是协程： 48 我是协程： 49 我是协程： 50 我是协程： 51 我是协程： 52 我是协程： 53 我是协程： 54 我是协程： 55 我是协程： 56 我是协程： 57 我是协程： 58 我是协程： 59 我是协程： 60 我是协程： 61 我是协程： 62 我是协程： 63 我是协程： 64 我是协程： 65 我是协程： 66 我是协程： 67 我是协程： 68 我是协程： 69 我是协程： 70 我是协程： 71 我是协程： 72 我是协程： 73 我是协程： 74 我是协程： 75 我是协程： 76 我是协程： 77 我是协程： 78 我是协程： 79 我是协程： 80 我是协程： 81 我是协程： 82 我是协程： 83 我是协程： 84 我是协程： 85 我是协程： 86 我是协程： 87 我是协程： 88 我是协程： 89 我是协程： 90 我是协程： 91 我是协程： 92 我是协程： 93 我是协程： 94 我是协程： 95 我是协程： 96 我是协程： 97 我是协程： 98 我是协程： 99 我是协程： 100 我是协程： 101 我是协程： 102 我是协程： 103 我是协程： 104 我是协程： 105 我是协程： 106 我是协程： 107 我是协程： 108 我是协程： 109 我是协程： 110 我是协程： 111 我是协程： 112 我是协程： 113 我是协程： 114 我是协程： 115 我是协程： 116 我是协程： 117 我是协程： 118 我是协程： 119 我是协程： 120 我是协程： 121 我是协程： 122 我是协程： 123 我是协程： 124 我是协程： 125 我是协程： 126 我是协程： 127 我是协程： 128 我是协程： 129 我是协程： 130 我是协程： 131 我是协程： 132 我是协程： 133 我是协程： 134 我是协程： 135 我是协程： 136 我是协程： 137 我是协程： 138 我是协程： 139 我是协程： 140 我是协程： 141 我是协程： 142 我是协程： 143 我是协程： 144 我是协程： 145 我是协程： 146 我是协程： 147 我是协程： 148 我是协程： 149 我是协程： 150 我是协程： 151 我是协程： 152 我是协程： 153 我是协程： 154 我是协程： 155 我是协程： 156 我是协程： 157 我是协程： 158 我是协程： 159 我是协程： 160 我是协程： 161 我是协程： 162 我是协程： 163 我是协程： 164 我是协程： 165 我是协程： 166 我是协程： 167 我是协程： 168 我是协程： 169 我是协程： 170 我是协程： 171 我是协程： 172 我是协程： 173 我是协程： 174 我是协程： 175 我是协程： 176 我是协程： 177 我是协程： 178 我是协程： 179 我是协程： 180 我是协程： 181 我是协程： 182 我是协程： 183 我是协程： 184 我是协程： 185 我是协程： 186 我是协程： 187 我是协程： 188 我是协程： 189 我是协程： 190 我是协程： 191 我是协程： 192 我是协程： 193 我是协程： 194 我是协程： 195 我是协程： 196 我是协程： 197 我是协程： 198 我是协程： 199 我是协程： 200 我是协程： 201 我是协程： 202 我是协程： 203 我是协程： 204 我是协程： 205 我是协程： 206 我是协程： 207 我是协程： 208 我是协程： 209 我是协程： 210 我是协程： 211 我是协程： 212 我是协程： 213 我是协程： 214 我是协程： 215 我是协程： 216 我是协程： 217 我是协程： 218 我是协程： 219 我是协程： 220 我是协程： 221 我是协程： 222 我是协程： 223 我是协程： 224 我是协程： 225 我是协程： 226 我是协程： 227 我是协程： 228 我是协程： 229 我是协程： 230 我是协程： 231 我是协程： 232 我是协程： 233 我是协程： 234 我是协程： 235 我是协程： 236 我是协程： 237 我是协程： 238 我是协程： 239 我是协程： 240 我是协程： 241 我是协程： 242 我是协程： 243 我是协程： 244 我是协程： 245 我是协程： 246 我是协程： 247 我是协程： 248 我是协程： 249 我是协程： 250 我是协程： 251 我是协程： 252 我是协程： 253 我是协程： 254 我是协程： 255\"]},\"371\":{\"h\":\"N = 258\",\"t\":[\"我是协程： 258 我是协程： 129 我是协程： 130 我是协程： 131 我是协程： 132 我是协程： 133 我是协程： 134 我是协程： 135 我是协程： 136 我是协程： 137 我是协程： 138 我是协程： 139 我是协程： 140 我是协程： 141 我是协程： 142 我是协程： 143 我是协程： 144 我是协程： 145 我是协程： 146 我是协程： 147 我是协程： 148 我是协程： 149 我是协程： 150 我是协程： 151 我是协程： 152 我是协程： 153 我是协程： 154 我是协程： 155 我是协程： 156 我是协程： 157 我是协程： 158 我是协程： 159 我是协程： 160 我是协程： 161 我是协程： 162 我是协程： 163 我是协程： 164 我是协程： 165 我是协程： 166 我是协程： 167 我是协程： 168 我是协程： 169 我是协程： 170 我是协程： 171 我是协程： 172 我是协程： 173 我是协程： 174 我是协程： 175 我是协程： 176 我是协程： 177 我是协程： 178 我是协程： 179 我是协程： 180 我是协程： 181 我是协程： 182 我是协程： 183 我是协程： 184 我是协程： 185 我是协程： 186 我是协程： 187 我是协程： 188 我是协程： 1 我是协程： 189 我是协程： 190 我是协程： 191 我是协程： 192 我是协程： 193 我是协程： 194 我是协程： 195 我是协程： 196 我是协程： 197 我是协程： 198 我是协程： 199 我是协程： 200 我是协程： 201 我是协程： 202 我是协程： 203 我是协程： 204 我是协程： 205 我是协程： 206 我是协程： 207 我是协程： 208 我是协程： 209 我是协程： 210 我是协程： 211 我是协程： 212 我是协程： 213 我是协程： 214 我是协程： 215 我是协程： 216 我是协程： 217 我是协程： 218 我是协程： 219 我是协程： 220 我是协程： 221 我是协程： 222 我是协程： 223 我是协程： 224 我是协程： 225 我是协程： 226 我是协程： 227 我是协程： 228 我是协程： 229 我是协程： 230 我是协程： 231 我是协程： 232 我是协程： 233 我是协程： 234 我是协程： 235 我是协程： 236 我是协程： 237 我是协程： 238 我是协程： 239 我是协程： 240 我是协程： 241 我是协程： 242 我是协程： 243 我是协程： 244 我是协程： 245 我是协程： 246 我是协程： 247 我是协程： 248 我是协程： 2 我是协程： 249 我是协程： 250 我是协程： 251 我是协程： 252 我是协程： 253 我是协程： 254 我是协程： 255 我是协程： 256 我是协程： 3 我是协程： 4 我是协程： 5 我是协程： 6 我是协程： 7 我是协程： 8 我是协程： 9 我是协程： 10 我是协程： 11 我是协程： 12 我是协程： 13 我是协程： 14 我是协程： 15 我是协程： 16 我是协程： 17 我是协程： 18 我是协程： 19 我是协程： 20 我是协程： 21 我是协程： 22 我是协程： 23 我是协程： 24 我是协程： 25 我是协程： 26 我是协程： 27 我是协程： 28 我是协程： 29 我是协程： 30 我是协程： 31 我是协程： 32 我是协程： 33 我是协程： 34 我是协程： 35 我是协程： 36 我是协程： 37 我是协程： 38 我是协程： 39 我是协程： 40 我是协程： 41 我是协程： 42 我是协程： 43 我是协程： 44 我是协程： 45 我是协程： 46 我是协程： 47 我是协程： 48 我是协程： 49 我是协程： 50 我是协程： 51 我是协程： 52 我是协程： 53 我是协程： 54 我是协程： 55 我是协程： 56 我是协程： 57 我是协程： 58 我是协程： 59 我是协程： 60 我是协程： 61 我是协程： 62 我是协程： 63 我是协程： 64 我是协程： 65 我是协程： 66 我是协程： 67 我是协程： 68 我是协程： 69 我是协程： 70 我是协程： 71 我是协程： 72 我是协程： 73 我是协程： 74 我是协程： 75 我是协程： 76 我是协程： 77 我是协程： 78 我是协程： 79 我是协程： 80 我是协程： 81 我是协程： 82 我是协程： 83 我是协程： 84 我是协程： 85 我是协程： 86 我是协程： 87 我是协程： 88 我是协程： 89 我是协程： 90 我是协程： 91 我是协程： 92 我是协程： 93 我是协程： 94 我是协程： 95 我是协程： 96 我是协程： 97 我是协程： 98 我是协程： 99 我是协程： 100 我是协程： 101 我是协程： 102 我是协程： 103 我是协程： 104 我是协程： 105 我是协程： 106 我是协程： 107 我是协程： 108 我是协程： 109 我是协程： 110 我是协程： 111 我是协程： 112 我是协程： 113 我是协程： 114 我是协程： 115 我是协程： 116 我是协程： 117 我是协程： 118 我是协程： 119 我是协程： 120 我是协程： 121 我是协程： 122 我是协程： 123 我是协程： 124 我是协程： 125 我是协程： 126 我是协程： 127 我是协程： 128 我是协程： 257\"]},\"372\":{\"h\":\"三、问题解答\"},\"373\":{\"h\":\"为什么先打印它，一次调度流程是怎么样的？\",\"t\":[\"提示\",\"该问题以 n = 10 的结果展开讨论。\",\"打印是有序的，先创建的 g 先被调度执行。\",\"最后创建的 10 却是最先被调度。\",\"这段 demo 中设置了 runtime.GOMAXPROCS(1)，也就是只有一个 P 能够工作，不设置就是默认等于 cpu 的核心数。\",\"因为只有一个 P，所以创建的协程 G 会被依次放入到 P 的本地队列中，然后被调度执行。\",\"那么为什么最先调度的是 g10？？\",\"因为 GMP 在运行时，有一个 runnext 指针，会指向最新切换进来的协程 g，把原本指向的 g 放入到 P 的本地队列中。\",\"模拟一下：\",\"g1 创建：Runnext --> g1 、P --> nil\",\"g2 加入调度：runnext ---> g2、P --> g1\",\"g3 加入调度：runnext ---> g3、P --> g1、g2\",\"........\",\"g10 加入调度：runnext ---> g10、P --> g1、... 、g9\"]},\"374\":{\"h\":\"如果 设置为 257、258，打印输出的规律是什么？\",\"t\":[\"提示\",\"先解释一下为什么选 257 和 258 两个数值：\",\"**257：**P 本地队列的长度是 256，runnext 又可以指向一个 g，加起来就是 257。\",\"258：258 个 g > 最大的本地队列长度256 + 1，就会把部分 g 放进全局队列，多了全局队列的参与，调度又会发生很多不同。\",\"根据上面 问题 1 的模拟过程，我们可以知道：\",\"g257 加入调度： runnext ---> g257、P --> g1、... 、g256、Global：--> nil\",\"g258 加入调度，把 g257 切换出来，由于 P 已经满了，会把 P 的一半 1-128 放到全局队列，再把 257 也放到全局队列： runnext ---> g258、P --> g129 、... 、g256、Global：--> g1、...、g128、g257\",\"所以当 n = 257 的时候：\",\"会先调度 g257，然后再在 P 中从 g1 到 g256 依次调度。\",\"输出结果也是如此。\",\"但是 当 n = 258 的时候：\",\"先调度 g258，\",\"后面先调度本地队列 P 的待执行的 g。\",\"(思考) 但是发现到 g188 的时候，突然又调度了一下 g1，在接着调度 g189。到 g248 之后又到了 g2。\",\"接下来把 p 本地队列中的最后一个 g256 调度后，就开始从 g3 开始调度堆积在全局队列的 g。\",\"最后 s 把全局队列的 g 全部调度完了。\",\"回想八股：GMP 模型下，内核线程 M 每调度 61 次本地队列 p 中的协程后，都会去全局队列中获取一个 g 来执行。\",\"But： 188 - 128 = 60，也就是完整调度了 60 次就去全局队列中偷一个协程 g 了，岂不是八股错了？\",\"哦哦哦： GMP 调度过程不仅仅只处理用户定义的协程，还有一些 runtime 本来就有的协程要调度，也会算到这 61 次里面。只是其中的 60 次调度了用户定义的 g。\",\"再回想八股：当 P 为空时，会去全局队列中拿一批 g 回来调度\",\"一批是多少：\",\"// 简化版： n = min( len(global) / GOMAXPROCS + 1, len(global/2) )\",\"因为设置了 GOMAXPROCS = 1，所以 n = min ( 129 / 1 + 1 , 129 / 2) = 全拿\",\"详细如下：\",\"// Try get a batch of G's from the global runnable queue. // sched.lock must be held. func globrunqget(pp *p, max int32) *g { assertLockHeld(&sched.lock) if sched.runqsize == 0 { return nil } n := sched.runqsize/gomaxprocs + 1 if n > sched.runqsize { n = sched.runqsize } if max > 0 && n > max { n = max } if n > int32(len(pp.runq))/2 { n = int32(len(pp.runq)) / 2 } sched.runqsize -= n gp := sched.runq.pop() n-- for ; n > 0; n-- { gp1 := sched.runq.pop() runqput(pp, gp1, false) } return gp }\"]},\"375\":{\"c\":[\"Go\"]},\"376\":{\"c\":[\"Go\",\"GMP\"]},\"377\":{\"h\":\"GMP模型\",\"t\":[\"本文详细介绍GMP模型的基本概念及其在Go语言运行时中的作用。\"]},\"378\":{\"h\":\"1. Go 的协程 - goroutine\",\"t\":[\"Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。\",\"虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。\",\"goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。\",\"最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。\"]},\"379\":{\"h\":\"2. 旧：GM模型\"},\"380\":{\"h\":\"2.1 GM符号概念\",\"t\":[\"20240131144616\"]},\"381\":{\"h\":\"2.2 废弃的调度器模型 GM 是如何实现的\",\"t\":[\" M 想要执行、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。\",\"老调度器有几个缺点\",\"创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。\",\"M 转移 G 会造成延迟和额外的系统负载。 比如当 G 中包含创建新协程的时候，M 创建了 G'，为了继续执行 G，需要把 G'交给 M'执行，也造成了很差的局部性，因为 G'和 G 是相关的，最好放在 M 上执行，而不是其他 M'。\",\"系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。\"]},\"382\":{\"h\":\"3. 新：GMP模型\"},\"383\":{\"h\":\"3.1 GMP符号定义\",\"t\":[\"20240131144909\"]},\"384\":{\"h\":\"3.2 GMP 模型\",\"t\":[\"在 Go 中，线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上 \"]},\"385\":{\"c\":[\"Go\",\"并发\"]},\"386\":{\"c\":[\"GMP\",\"Go\",\"并发模型\"]},\"387\":{\"h\":\"Go编译器原理\",\"t\":[\"本文详细介绍Go语言编译器的工作原理和编译过程。\"]},\"388\":{\"h\":\"1. 编译器基础知识\",\"t\":[\"编译器将高级语言代码转换为机器可执行的指令，是程序运行的基础。\"]},\"389\":{\"h\":\"1.1 编译器工作流程\",\"t\":[\"编译过程主要包括词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成几个阶段。\"]},\"390\":{\"h\":\"2. Go 编译命令解析\",\"t\":[\"Go语言提供了丰富的编译命令行工具，帮助开发者了解编译过程：\"]},\"391\":{\"h\":\"2.1 常用命令\",\"t\":[\"# 查看环境变量信息 $ go env # 查看Go帮助 $ go help # 编译go源码 *.go 为可执行文件 $ go build [-o 输出名] [-i] [编译标记] [包名] # 只编译选定的源码而不构建可执行文件 $ go tool compile [编译标记] gofile... # 编译并执行go源码 $ go run *.go # 测试指定包 $ go test # 查看go tool compile帮助 $ go tool compile -h\"]},\"392\":{\"h\":\"2.2 编译标记说明\",\"t\":[\"Go编译器提供了多种编译标记，用于控制编译过程和输出：\",\"-D 设置编译阶段允许访问的包，常用于 cgoimport -I 添加导入搜索路径 -L 展示完整的文件路径 -N 禁用优化 -S 输出汇编代码 -S -S 输出具体的代码计划\"]},\"393\":{\"h\":\"3. Go 编译器架构\"},\"394\":{\"h\":\"3.1 大致架构\",\"t\":[\"Go编译器的架构如下：\",\"扫描器(scanner) -> 解析器(parser) -> 类型检查(type check) -> SSA -> 生成机器码(genssa)\"]},\"395\":{\"h\":\"3.2 具体编译过程\",\"t\":[\"首先经过扫描器，扫描器会对源码进行词法分析，生成token流\",\"解析器将token流解析为抽象语法树(AST)\",\"类型检查阶段将进行语义分析，确保代码符合语言规范\",\"SSA(Static Single Assignment)阶段进行中间代码生成和优化\",\"最后生成目标机器码\"]},\"396\":{\"h\":\"3.3 编译器命令行流程\",\"t\":[\"当我们输入go build命令时，实际执行了以下步骤：\",\"检查GOOS+GOARCH路径，使用对应编译器\",\"解析编译参数\",\"确定编译的包列表\",\"编译依赖包，同时递归处理导入的包\",\"链接生成可执行文件\"]},\"397\":{\"h\":\"4. 优化选项\",\"t\":[\"Go编译器提供了多种优化选项，可以控制编译过程中的优化行为：\"]},\"398\":{\"h\":\"4.1 gcflags参数\",\"t\":[\"通过-gcflags参数可以控制Go编译器的行为：\",\"# 禁用函数内联和优化 go build -gcflags=\\\"-N -l\\\" main.go # 打印优化决策 go build -gcflags=\\\"-m\\\" main.go # 显示详细的优化决策 go build -gcflags=\\\"-m -m\\\" main.go\"]},\"399\":{\"h\":\"4.2 逃逸分析\",\"t\":[\"Go编译器会进行逃逸分析，确定变量是分配在栈上还是堆上：\",\"# 查看逃逸分析结果 go build -gcflags=\\\"-m\\\" main.go\"]},\"400\":{\"h\":\"5. 总结\",\"t\":[\"Go编译器是一个高效的多阶段编译系统，通过词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成，将Go源代码转换为可执行文件。了解编译器的工作原理有助于编写高效的Go代码。\"]},\"401\":{\"c\":[\"Go\",\"编译原理\"]},\"402\":{\"c\":[\"Go\",\"编译器\",\"编译原理\"]},\"403\":{\"h\":\"Go内存逃逸\",\"t\":[\"本文详细介绍Go语言中内存逃逸的场景及优化方法。\",\"Go语言内存逃逸的场景\"]},\"404\":{\"h\":\"1. 逃逸是什么\",\"t\":[\"编译器用于决定变量分配到堆上还是栈上的一种行为\"]},\"405\":{\"h\":\"1.1 发生逃逸的时机\",\"t\":[\"**首先：**函数运行在栈上，在栈里声明临时变量分配内存， 函数运行完毕后回收内存。每个函数的栈空间都是独立的，其他函数不能进行访问。\",\"**发生内存逃逸：**在某些情况下，栈上的数据需要在函数结束之后还能被访问，这时会发生内存逃逸：\",\"如果变量从栈上逃逸，会跑到堆上：\",\"栈上面的变量在函数结束的时候会自动回收，回收代价比较小。而且栈内存的分配和释放，只需要两个CPU指令PUSH和RELEASE。\",\"堆分配内存，需要先找到一块大小合适的内存，之后通过GC回收才能释放，如果频繁进行，占用比较大的系统开销\",\"**所以：**尽量在栈上分配内存，可以减少gc压力，提高程序运行速度\"]},\"406\":{\"h\":\"2. 逃逸过程\",\"t\":[\"如果函数外部没有引用，则优先放到栈中；\",\"如果函数外部存在引用，则必定放到堆中；\"]},\"407\":{\"h\":\"2.1 基本逃逸分析原则\",\"t\":[\"如果一个函数返回了一个变量的引用，那它系一定发生逃逸，逃到堆上。\",\"编译器会分析代码的特征和生命周期，Go的变量如果能在编译器编译过程中证明确认在函数返回后不会再被引用，才会分配到栈上。其他情况都是分配到堆上。\",\"Go中没有一个关键字或者函数可以让变量被编译器分配到堆上，只能是编译器来分析代码确定 \"]},\"408\":{\"h\":\"3. 逃逸情景\",\"t\":[\"**指针逃逸：**在函数内部返回一个局部变量指针\",\"**分配大对象：**导致栈空间不足，不得不分配到堆上\",\"**调用接口类型的方法：**接口类型的方法调用是动态调度（实际使用的具体实现只能在运行时确定）。\",\"尽管在能符合分配到栈的场景，但是它的大小不能在编译时确定的情况，也会分配到堆上\"]},\"409\":{\"h\":\"3.1 指针逃逸\",\"t\":[\"传递指针可以减少底层值拷贝，提高效率。\",\"但是如果拷贝的数据量小，由于指针传递会逃逸（发生了函数外引用），可能会使用到堆，这样子会增加GC的负担，所以传递指针不一定是高效的\",\"使用命令：go build -gcflags '-m' xxx.go\"]},\"410\":{\"h\":\"示例代码\",\"t\":[\"package main import \\\"fmt\\\" type Student struct { Name string Age int } func StudentRegister(name string, age int) *Student { // s 原本是局部指针变量，被返回了引用，逃逸到了堆 s := new(Student) s.Age = age s.Name = name return s } func main() { ss := StudentRegister(\\\"kryiea\\\", 20) fmt.Println(ss) }\"]},\"411\":{\"h\":\"3.2 栈空间不足逃逸\"},\"412\":{\"h\":\"栈空间足够时，没有逃逸\",\"t\":[\"package main func MakeSlice() { s := make([]int, 100, 100) for index, _ := range s { s[index] = index } } func main() { MakeSlice() }\"]},\"413\":{\"h\":\"容量增大后，发生逃逸\",\"t\":[\"package main func MakeSlice() { s := make([]int, 10000, 10000) for index, _ := range s { s[index] = index } } func main() { MakeSlice() }\",\"20240115164413\"]},\"414\":{\"h\":\"3.3 动态类型逃逸\",\"t\":[\"函数参数为interface，在编译期间很难确定参数具体类型，也能产生逃逸：\",\"20240115164427\"]},\"415\":{\"h\":\"3.4 变量大小不确定\",\"t\":[\"在创建切片的时候，初始化切片容量的时候，传入一个变量来指定其大小，由于变量的值不能在编译器确定，所以就不能确定其内存大小，会将对象分配在堆上\",\" package main func MakeSlice() { length := 1 a := make([]int, length, length) for i := 0; i < length; i++ { a[i] = i } } func main() { MakeSlice() }\"]},\"416\":{\"h\":\"4. 避免逃逸\",\"t\":[\"对于性能要求高且访问频次高的函数调用，应该尽量避免使用接口类型。因为go中接口类型的方法调用都是动态，不能再编译阶段确定\",\"避免变量大小不能确定的时候\"]},\"417\":{\"h\":\"5. 总结\",\"t\":[\"不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。\",\"但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。\"]},\"418\":{\"c\":[\"Go\"]},\"419\":{\"h\":\"Go多返回值原理\",\"t\":[\"本文详细介绍Go语言多返回值的实现原理及其使用场景。\"]},\"420\":{\"h\":\"1. 多返回值简介\",\"t\":[\"Go支持多返回值，这是区别于C语言等传统语言的一个重要特性。\"]},\"421\":{\"h\":\"2. 多返回值的实现\"},\"422\":{\"h\":\"2.1 基本实现原理\",\"t\":[\"在Go语言中，多返回值实际上是通过一个匿名结构体实现的，编译器会将所有返回值封装为一个结构体返回。\"]},\"423\":{\"h\":\"2.2 汇编实现分析\",\"t\":[\"让我们通过汇编代码分析多返回值的实现机制：\",\"package main func A() (int, int) { return 1, 2 } func main() { a, b := A() println(a, b) }\",\"使用以下命令查看汇编代码：\",\"go tool compile -S main.go > main.s\",\"从汇编代码可以看出，返回值被分配在栈上。对于上面这段代码，返回值的内存布局如下：\",\"高地址 | v +------+ | 栈 | +------+ | b | +------+ | a | +------+ ^ | 低地址\"]},\"424\":{\"h\":\"3. 多返回值应用场景\"},\"425\":{\"h\":\"3.1 错误处理\",\"t\":[\"Go语言常用多返回值进行错误处理，第一个返回值为正常返回值，最后一个返回值为错误信息：\",\"func openFile(filename string) (*File, error) { if filename == \\\"\\\" { return nil, errors.New(\\\"filename cannot be empty\\\") } // Open the file and return it return file, nil } // 调用 file, err := openFile(\\\"test.txt\\\") if err != nil { // 处理错误 return } // 使用file\"]},\"426\":{\"h\":\"3.2 多值返回\",\"t\":[\"在需要同时返回多个值的场景下非常有用：\",\"func minMax(arr []int) (min int, max int) { min = arr[0] max = arr[0] for _, v := range arr { if v < min { min = v } if v > max { max = v } } return }\"]},\"427\":{\"h\":\"3.3 命名返回值\",\"t\":[\"Go支持命名返回值，可以使代码更清晰：\",\"func divide(a, b int) (result int, err error) { if b == 0 { err = errors.New(\\\"division by zero\\\") return // 隐式返回命名的返回值 } result = a / b return // 隐式返回命名的返回值 }\"]},\"428\":{\"h\":\"4. 多返回值的性能考量\",\"t\":[\"在大多数情况下，多返回值不会带来明显的性能开销。对于小型结构体，编译器可以有效地优化。但对于包含大量数据的返回值，可能会导致不必要的内存复制。\"]},\"429\":{\"h\":\"4.1 避免返回大型结构体\",\"t\":[\"如果需要返回大型数据结构，考虑使用指针返回：\",\"// 不推荐 func getBigData() (BigStruct, error) { // ... } // 推荐 func getBigData() (*BigStruct, error) { // ... }\"]},\"430\":{\"h\":\"5. 总结\",\"t\":[\"Go语言的多返回值特性通过栈上分配的匿名结构体实现，为错误处理和多值返回提供了便利。在使用多返回值时，应注意返回值的数量和类型，以及对大型结构体返回的性能考量。\"]},\"431\":{\"c\":[\"Go\",\"语言特性\"]},\"432\":{\"h\":\"Go基础语法\",\"t\":[\"本文详细介绍Go语言的基础语法和使用方法。\",\"好文章\",\"【一文Go起来】快速上手篇\",\"语法的特性符合 Go 1.22 以前版本\"]},\"433\":{\"h\":\"1.1 标识符大小写\",\"t\":[\"标识符：常量、变量、类型、函数名、结构字段...\",\"以大写字母开头：这种形式的标识符对象可以被外部包的代码所使用\",\"以小写字母开头：对包外不可见，但在整个本包内是可见而且是可用的（类似protected）\"]},\"434\":{\"h\":\"1.2 文件结构\",\"t\":[\"文件名与包名： 没有直接关系，不一定要将文件名与包名定成一个名称\",\"文件夹名与包名： 没有直接关系，也不一定要一致\",\"同一个文件夹下的文件只能有一个包名\"]},\"435\":{\"h\":\"2.1 基本规范\",\"t\":[\"变量命名：首个字符不能是数字\",\"声明变量格式：var Name type\"]},\"436\":{\"h\":\"2.2 单变量声明\",\"t\":[\"声明变量，没有显示初始化，变量默认为零值，不同类型零值不一样： \",\"bool类型：false\",\"数值类型：0\",\"字符串类型：\\\"\\\" 空字符串\",\"指针、chan、切片 类型：nil\",\"根据值自行判断变量类型 \",\"var v_name = value\",\":=\"]},\"437\":{\"h\":\"2.3 多变量声明\",\"t\":[\"声明格式：var v_name1 v_name2 v_name3 type\",\"var()： 一般用于声明全局变量\",\"var( v_name1 int v_name2 string )\"]},\"438\":{\"h\":\"2.4 注意\",\"t\":[\":= 只能在函数体内使用，不可以用于全局变量的声明和赋值\",\" // g,h := 123, \\\"hello\\\" 不行 func main(){ //这里可行 g,h := 123, \\\"hello\\\" }\"]},\"439\":{\"h\":\"2.5 变量的生命周期\",\"t\":[\"全局变量： 生命周期是程序存活时间\",\"局部变量： 在不发生内存逃逸的情况下，局部变量周期是函数存活时间\"]},\"440\":{\"h\":\"2.6 常量\",\"t\":[\"不可被修改\",\"常量数据类型只能是：布尔型、数字型（整数型、浮点型、复数型）、字符串型\",\"定义方式：const identifier [type] = value\",\"[type] 可以省略，编译器可以根据变量的值来推断类型\",\"const b string = \\\"abc\\\" 👇等价👇 const b = \\\"abc\\\" // := 错误 const a := 111\"]},\"441\":{\"h\":\"2.7 常量用作枚举\",\"t\":[\"go没有专门的枚举类型，枚举一般用常量表示\",\"package main import \\\"unsafe\\\" const( a = \\\"abc\\\" b = len(a) // 必须是内置函数 c = unsafe.Sizeof(a) ) func main(){ println(a,b,c) } // result：abc 3 16\",\"注意：字符串的 unsafe.Sizeof() 的返回值一直都是16！\",\"解释：\",\"字符串类型对应一个16字节大小的结构体，该结构体有两个域：\",\"type StringHeader srtuct{ Data uintptr // 8字节 Len int // 8字节 }\",\"sizeof(stringType) 只是获取string顶层结构体的大小，并不会深入到实际数据\",\"结论：\",\"sizeof(stringType) 的返回值始终是 16\"]},\"442\":{\"h\":\"2.8 iota\",\"t\":[\"iota 是一个特殊的常量，可认为是一个计数器\",\"iota 在 const 关键字出现时将被重置为 0 （const 内部的第一行之前），const中每新增加一行常量声明将使iota计数一次\",\"const( a = iota // 第一次声明 iota为 0 b = iota // 第二次声明 iota为 1 c = iota // 第三次声明 iota为 2 ) const( a = iota // 第一次声明 iota为 0 b // 1 c // 2 )\",\" func main(){ const( a = iota // 0 b // 1 c // 2 d = \\\"ha\\\" // d是字符串\\\"ha\\\"，但是iota = 3 e // e是字符串\\\"ha\\\"，但是iota = 4 f = 100 // iota = 5 g // 6 h = iota // 7 并且恢复默认记数 i // 8 ) }\",\"go语言跟其他语言一样，运算符大体上也分为以下几种：\",\"算术运算符\",\"关系运算符\",\"逻辑运算符\",\"位运算符\",\"赋值运算符\",\"其他运算符\"]},\"443\":{\"h\":\"3.1 逻辑运算符\",\"t\":[\"20240424155614\"]},\"444\":{\"h\":\"3.2 位运算符\",\"t\":[\"位运算符是对内存中的二进制数进行按位运算，包括 & ，| ，^ ，<<，>>\",\"20240424155622\"]},\"445\":{\"h\":\"3.3 运算符优先级\",\"t\":[\"有些运算符拥有较高的优先级，二元运算待的运算方向均是从左至右。 由上至下代表优先级由高到低： \"]},\"446\":{\"h\":\"3.3 特殊运算符\",\"t\":[\"&^：位清除，先 & 再 ^ 就全变成 0 了 a &^ b：清零a中，ab都为1的位\"]},\"447\":{\"h\":\"4.1 键值对初始化\",\"t\":[\"在初始化时以属性：值的方式完成，如果有的属性不写，则为默认值\",\"type student struct{ ID int Name string Age int Score int } func main(){ st := student{ ID :100, Name : \\\"kryiea\\\", } }\"]},\"448\":{\"h\":\"4.2 值列表初始化\",\"t\":[\"直接按照 属性顺序 来初始化 ⚠️值列表的个数必须 = 结构体属性个数，且按顺序，允许后空缺，不允许中间跳开\",\"st := student{ 101, \\\"ddd\\\" 2, 33, }\"]},\"449\":{\"h\":\"5.1 if\",\"t\":[\"处理map的时候可以用多重赋值写法，表达性强\",\"if num, ok := dic[\\\"apple\\\"]; ok{ ... }\"]},\"450\":{\"h\":\"5.2 switch - case\",\"t\":[\"case 默认有break 跳出条件选择。 若希望从某个case开始按顺序往下执行，可以使用fallthrough。\",\"只有 for 一种循环方式\"]},\"451\":{\"h\":\"6.1 理解 for 的结构\",\"t\":[\"init: 一般为赋值表达式，给控制变量赋初值，执行一次；\",\"condition: 关系表达式或逻辑表达式，循环控制条件；\",\"post: 一般为赋值表达式，给控制变量增量或减量。\",\"// 1 for init; condition; post{ } // 2 for condition{ } // 3 for{ }\"]},\"452\":{\"h\":\"6.2 for range\",\"t\":[\"go version 1.22.2 之后 每次迭代都是一个新变量。\",\"go version 1.22.2 之前\",\"for range 格式可以对 slice、map、数组、字符串继续迭代读取\",\"但是属于副本读，每次迭代都共享一个底层变量 temp，覆盖写入 temp 返回给 value！\",\"详细分析看 6.3 部分。\",\"示例代码：\",\"// range 返回值 for key/index, value := range Map{ } // 或者 for key :=range Map{ } //或者 for _,value :=range Map{ }\"]},\"453\":{\"h\":\"6.3 for range 陷阱\",\"t\":[\"以下分析适合 go version 1.22.2 之前，之后的版本已经更改。\",\"坑 1： for range 取不到所有元素的地址\",\"func main(){ arr := [2]int{1,2} res := []*int{} for _, v := range arr{ res = append(res, &v) } fmt.println(*res[0], *res[1]) } // except: 1, 2 // result: 2, 2\",\"分析：\",\"res 中最终所有的元素都是一个地址，这一个地址最终指向的是 v 最后遍历得到的值，也就是 2。\",\"说明遍历 arr 元素的时候，只是将元素赋值一个临时变量 temp，整个循环都是用这一个 temp变量。\",\"希望得到 1 和 2 怎么实现：\",\"方式 1：用局部变量 v1 拷贝 v\",\"for _, v := range arr{ v1 := v res = append(res, &v1) }\",\"方式 2：直接使用索引获取原来的元素\",\"for k, _ := range arr{ res = append(res, &arr[k])\",\"坑 2：循环终止问题\",\"在 for-range 中向切片追加元素时，循环会在完成遍历原本切片长度后停止。因为 for-range 循环在开始前就已经确定了切片的长度。\",\"循环迭代的是切片在迭代开始时的状态，后续追加的元素不会影响当前的迭代过程。\",\"v := []int{1, 2, 3} for i := range v { fmt.Println(i) // 这里打印的是切片v的索引 v = append(v, i) } // result: 1, 2, 3\"]},\"454\":{\"h\":\"7.1 参数传递\",\"t\":[\"go中参数传递都是值传递，不存在引用传递（区别于c++）\",\"值传递时，可以改变形参的值，但不会改变实参值\",\"传递地址也是值传递，会拷贝原地址，指向同一块区域\"]},\"455\":{\"h\":\"7.2 基本类型\",\"t\":[\"int、float、bool、string ...\",\"对于基础数据类型，值传递意味着每次函数调用时都会 创建变量的一个新副本。 这些副本是独立的，对副本的任何修改都不会影响原始变量。\"]},\"456\":{\"h\":\"7.3 引用类型和指针\",\"t\":[\"引用类型如：切片、映射、通道\",\"对于引用类型和指针，虽然参数传递仍然是按值传递，但传递的是一个 引用的副本或指针的副本\",\"例子： 内存位置 0xfff0 叫 v1，传到到函教参数 v2，v2 的内存位置可能是 0xffe8，里面再保存 0xfff0。\"]},\"457\":{\"h\":\"7.4 结构体和数组\",\"t\":[\"结构体和数组也是按值传递的。 当你传递一个结构体或数组给函数时，会 创建这个结构体或数组的一个完整副本。 函数内部对副本的修改不会影响原始的结构体或数组。\"]},\"458\":{\"h\":\"7.5 可变参数\",\"t\":[\"在 Go 语言中，可变参数（variadic parameter）允许函数接受数量可变的参数。\",\"可变参数使用省略号（...）表示。\",\"简单的示例\",\"package main import \\\"fmt\\\" func sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } func main() { fmt.Println(sum(1, 2)) // 输出: 3 fmt.Println(sum(1, 2, 3, 4, 5)) // 输出: 15 }\",\"在上面的示例中，sum 函数使用了可变参数语法，其中 nums ...int 表示 sum 函数接受任意数量的 int 类型参数。 在 main 函数中，我们可以调用 sum 函数并传入任意数量的 int 参数，而不需要提前指定参数的个数。\",\"可变参数原理\",\"在函数内部，可变参数会被当作一个切片（slice）来处理\",\"nums ...int 会被当做 nums []int\"]},\"459\":{\"h\":\"8.1 Go 普通指针特性\",\"t\":[\"类型安全：Go 语言的指针是类型安全的。这意味着，如果你有一个指向 int 的指针，你只能将它指向 int 类型的变量。类型安全可以防止许多常见的编程错误。\",\"限制：Go 不允许指针算术。这是一个故意的设计选择，用来简化内存管理并减少与指针相关的错误。\",\"用途：普通指针常用于引用变量，以便在函数之间共享和修改数据，或者在结构体中嵌入指向其他结构体的指针。\",\"零值：未初始化的指针的零值是 nil。\"]},\"460\":{\"h\":\"8.2 unsafe 包中的 uintptr 和 Pointer\",\"t\":[\"类型不安全：unsafe 包允许你绕过 Go 的类型系统，进行任意类型的转换。这带来了更高的灵活性，但也带来了更高的风险，因为错误的类型转换可能会导致程序崩溃。\",\"uintptr指针算术：使用 unsafe 包中的 uintptr 类型，你可以对指针进行算术运算。uintptr是一个可变长的整数类型，它用于表示一个无类型的指针或将一个 unsafe.Pointer 转换成一个可以比较的整数。在32位系统上是32位的。在64位系统上是64位的。\",\"unsafe.Pointer：这是 unsafe 包中定义的一个特殊类型，可以被用来转换任何类型的指针。它提供了一种方式来暂时存储指针值，然后可能将其转换回原来的类型或不同的类型。\",\"方法是绑定在某种类型的变量上的函数\",\"某种类型不限于结构体，基本数据类型也可以\",\"变量类型不仅仅局限于结构体类型，可以是任意类型。\",\"比如：不可以直接对 int 自定义方法，但可以通过起别名来实现绑定\",\"package main import \\\"fmt\\\" // MyInt 是 int 的一个类型别名 type MyInt int // Double 是 MyInt 类型的一个方法，它返回值的两倍 func (m MyInt) Double() MyInt { return m * 2 } func main() { var a MyInt = 10 fmt.Println(a.Double()) // 输出: 20 }\"]},\"461\":{\"h\":\"9.1 自定义方法的位置\",\"t\":[\"⚠️ 必须在同一个包下：类型的定义和绑定在它上面的方法的定义可以不放置在同一个文件中，可以存在不同的源文件\",\"在 Go 中，并没有传统面向对象语言中的继承概念，但可以通过组合和接口来达到类似的效果。\",\"因为 Go 没有类这个概念，没有c++和java一样的显式继承关系，自然就不存在父类子类一说\"]},\"462\":{\"h\":\"10.1 组合实现继承\",\"t\":[\"嵌入 \\\\ 组合 差不多意思\",\"通过在一个结构体中嵌入另一个匿名结构体，可以实现类似继承的效果。\",\"内部结构体的字段和方法会被提升到外部结构体中，使得外部结构体可以直接访问这些字段和方法\",\"// Person type Person struct { Name string } func (p Person) SayHello() { fmt.Println(\\\"Hello, my name is\\\", p.Name) } // Employee type Employee struct { Title string Person // 嵌入 Person 结构体,相当于： /* type Person struct { Name string } */ } func main() { emp := Employee{ Person: Person{Name: \\\"John\\\"}, Title: \\\"Developer\\\", } emp.SayHello() // 可以直接调用内部结构体 Person 的方法 }\",\"这个\\\"提升 \\\"Go 怎么实现\",\"编译器在生成代码时会进行以下操作：\",\"对于内部结构体的字段，编译器会在外部结构体中创建相同名字的字段，并且这些字段会被初始化为内部结构体的实例。\",\"对于内部结构体的方法，编译器会在外部结构体中创建同名的方法，并且将内部结构体实例作为方法的接收者。\",\"这样，外部结构体就可以直接访问内部结构体的字段和方法，而不需要通过内部结构体的实例来访问。\"]},\"463\":{\"h\":\"10.2 接口\",\"t\":[\"通过定义接口和实现接口的方式，可以实现多态的效果。 一个结构体只要实现了某个接口定义的所有方法，就被视为实现了该接口。\",\"type Shape interface { Area() float64 } type Circle struct { Radius float64 } func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius }\"]},\"464\":{\"h\":\"10.3 方法重写\",\"t\":[\"在 Go 中，匿名字段的方法可以被外部结构体重写，从而实现类似于继承中方法的覆盖。\",\"type Animal struct { Name string } func (a Animal) Speak() { fmt.Println(\\\"Animal speaks\\\") } type Dog struct { Animal } // 重写Animal的Speal() func (d Dog) Speak() { fmt.Println(\\\"Dog speaks\\\") }\",\"接口用来抽象一系列行为，不推荐把字段定义在接口中\",\"当某一种类型实现了所有这些声明的方法，那么就称这种类型为该接口的一种实现\"]},\"465\":{\"h\":\"11.1 接口定义\",\"t\":[\"type interfaceName interface{ methodName1([parameter_list])[return_type_list] methodName2([parameter_list])[return_type_list] methodName3([parameter_list])[return_type_list] ..... }\",\"例子： \"]},\"466\":{\"h\":\"11.2 实现多个接口\",\"t\":[\"在 Go 中，一个类型可以实现多个接口。\",\"这种灵活性允许一个类型定义多种行为，并且可以根据需要实现不同的接口。\",\"一个简单的例子\",\"package main import \\\"fmt\\\" // 定义接口A type A interface { MethodA() } // 定义接口B type B interface { MethodB() } // 定义一个结构体，实现接口A和接口B type MyStruct struct { } // 实现接口A的方法 func (m MyStruct) MethodA() { fmt.Println(\\\"MethodA called\\\") } // 实现接口B的方法 func (m MyStruct) MethodB() { fmt.Println(\\\"MethodB called\\\") } func main() { var s MyStruct var a A var b B a = s b = s a.MethodA() // 输出: MethodA called b.MethodB() // 输出: MethodB called }\"]},\"467\":{\"h\":\"11.3 空接口\",\"t\":[\"没有任何方法声明的接口称之为空接口\",\"所有类型都实现了空接口，所以空接口可以存储任意类型的数值\",\"Goland很多库的源代码都会以空接口作为参数，表示接受任何类型的参数，fmt包下的Print系列\",\"func Println(a ...interface{})(n int, err error)\"]},\"468\":{\"h\":\"11.4 断言陷阱\",\"t\":[\"例子：不能把interface{}类型的变量i赋值给整形变量b\",\"func main(){ var a int = 1 var i interface{} = a var b int = i } // result: // cannot use i (variable of type interface{}) as int value // in variable declaration: need type assertion\"]},\"469\":{\"h\":\"11.5 断言原理\",\"t\":[\"要实现 11.4 的操作，就要用断言。（更深的理解：接口的数据结构有关。 先不展开。）\",\"类型断言接口操作：用来检查接口变量的值是否实现了某个接口，或者是否是某个具体的类型。 格式：value, ok := x.(T)， x 为接口类型，ok 为 bool 类型\",\"package main import \\\"fmt\\\" func main(){ var x interface{} x = 8 val, ok := x.(int) fmt.Printf(\\\"val is %d, ok is %t \\\\n\\\", val, ok) } //result: val is 8, ok is true\",\"⚠️注意\",\"无论 T是什么类型，如果x是nil接口值，类型断言都会失败\",\"如果ok这个返回值不接受，没问题就没问题，有问题就报panic\"]},\"470\":{\"h\":\"11.6 接口作为函数参数\",\"t\":[\"package main import \\\"fmt\\\" // 定义一个接口 type Shape interface { Area() float64 } // 定义一个函数，接受实现了 Shape 接口的类型作为参数 func PrintArea(s Shape) { fmt.Println(\\\"Area:\\\", s.Area()) } // 定义一个结构体，实现了 Shape 接口 type Circle struct { Radius float64 } // 实现 Shape 接口的方法 func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius } // 定义一个结构体，实现了 Shape 接口 type Rectangle struct { Width float64 Height float64 } // 实现 Shape 接口的方法 func (r Rectangle) Area() float64 { return r.Width * r.Height } func main() { c := Circle{Radius: 3} r := Rectangle{Width: 4, Height: 5} PrintArea(c) // 输出: Area: 28.26 PrintArea(r) // 输出: Area: 20 }\"]},\"471\":{\"h\":\"11.7 接口嵌套\",\"t\":[\"一个接口中包含了其他接口，要实现外部接口，就需要实现内部嵌套的接口对应的所有方法。\",\"package main import \\\"fmt\\\" // 定义两个简单的接口 type Reader interface { Read() } type Writer interface { Write() } // 嵌套接口 type ReadWriter interface { Reader Writer } // 实现接口 type MyStruct struct { } func (m MyStruct) Read() { fmt.Println(\\\"Reading data...\\\") } func (m MyStruct) Write() { fmt.Println(\\\"Writing data...\\\") } func main() { var rw ReadWriter rw = MyStruct{} rw.Read() // 输出: Reading data... rw.Write() // 输出: Writing data... }\"]},\"472\":{\"h\":\"12.1 error 接口类型\",\"t\":[\"error是 go 的一个普通的接口，并且不携带任何堆栈信息。\",\"type error interfce{ Error() string }\",\"生成一个 error 对象\",\"常用errors.New()或者 fmt.Errorf() 来返回一个error对象\",\"这两种方式返回的 error 是不可以直接进行比较的，以为errors.New()返回的其实是一个地址，不用用来做等值判断.\"]},\"473\":{\"h\":\"13.1 需要思考的 3 个问题\",\"t\":[\"defer 调用栈\",\"执行到 defer 关键字时会发生什么\",\"defer 的栈什么时机会执行，与 return 的关系\"]},\"474\":{\"h\":\"13.2 使用场景 1: 资源的释放\",\"t\":[\"延迟调用，优雅解决资源回收问题，避免遗漏资源回收。 如：网络连接、数据库连接、文件句柄的资源释放。\"]},\"475\":{\"h\":\"13.3 使用场景 2：配合 recover 处理 panic\",\"t\":[\"用panic抛出异常，用 defer + recover捕获异常\"]},\"476\":{\"h\":\"13.4 defer 的快照读\",\"t\":[\"func derferRun() { var num = 1 derfer fmt.Printf(\\\"num is %d\\\",num) num = 2 return } func main(){ derfer() } // result： num is 1\",\"为什么是 1 不是 2 ：\",\" 就算 defer 中参数是地址，也会相当于快照一样保存那个地址，但是如果地址所指向的内容被修改了，也会跟着一起变化。\"]},\"477\":{\"h\":\"14.1 return 的非原子性\",\"t\":[\"return并非一个原子操作，可被分解成以下3步：\",\"设置返回值\",\"执行defer 栈\",\"将返回值结果返回\",\"思考下面 3 个例子\",\"例子1\",\"package main import \\\"fmt\\\" func main(){ res := deferRun() fmt.Println(res) } func deferRun()(res int){ num := 1 defer func(){ res++ }() return num } // result: 2\",\"例子2\",\"package main import \\\"fmt\\\" func main(){ res := deferRun() fmt.Println(res) } func deferRun() int { num := 1 defer func(){ num++ }() return num } // result: 1\",\"例子3\",\"package main import \\\"fmt\\\" func main(){ res := deferRun() fmt.Println(res) } func deferRun() int { var num int defer func(){ num++ }() return 1 } // result: 1\"]},\"478\":{\"h\":\"15.1 painc 捕获方式\",\"t\":[\"异常：程序运行过程发生的 panic，注意 fatal 这种致命错误是会导致程序直接崩溃，无法捕获。\",\"捕获：不让程序core，在程序中加入recover机制，捕获异常，打印\",\"例子\",\"20240424173111\",\"注意\",\"有了recover之后，程序不会在panic出中断，在执行完panic之后，接下来会执行defer函数，但是当前函数panic后面的代码不会被执行，但是调用该函数的代码可以接着执行(理解panic的传递)。\"]},\"479\":{\"h\":\"15.2 panic的传递\",\"t\":[\"当一个函数发生panic后当前函数体的剩余代码不再执行\",\"若在当前的函数体没有recover，该panic会一直向外层传递，往外传递 panic 过程中也不会执行上层的剩余代码，直到某层被recover后，该层剩下的代码才会恢复执行。\",\"如果一直到主函数，迟迟没有recover，main就会终止。\",\"如果在过程中遇到了最近的recover，就会被捕获，捕获后当前函数体的剩余代码不再执行，但是再上一层的还可以可以继续执行\",\"例子\",\"解析\",\"func 调用链：main --> testpanic1 --> testpanic2 --> testpanic3panic 传递链：testpanic3 --> testpanic2 --> revocer() --> painc 传递结束。\",\"在 testpanic3 中发现了一个 panic，由于 testpanic3 没有 recover，panic 向上传递。\",\"在 testpanic2 中找到了 recover，panic 被捕获了，程序接着运行。\",\"由于 testpanic3 发生了 panic，所以不再继续运行，函数跳出返回到 testpanic2。\",\"testpanic2 也不会再继续执行，跳出函数 testpanic2。\",\"到了 testpanic1 接着运行。\",\"所以 recover 和 panic 可以总结为以下 2 点：\",\"recover 只能恢复当前函数级或以当前函数为首的调用链中的函数中的 panic，恢复后调用当数结束，但是调用此函数的函数继续执行。\",\"函数发生了 panic 之后会 一直向上传递，如果直至 main 函数都没有 recover，程序将终止，如果是碰见了 recover，将被 recover 捕获。\"]},\"480\":{\"c\":[\"vscode\"]},\"481\":{\"c\":[\"插件\",\"vscode 配置\"]},\"482\":{\"h\":\"Json包的使用\",\"t\":[\"json包的用法\"]},\"483\":{\"h\":\"json.Marshal（序列化）与json.Unmarshal（反序列化）的基本用法。\",\"t\":[\"type Person struct { Name string Age int64 Weight float64 } func main() { p1 := Person{ Name: \\\"小明\\\", Age: 18, Weight: 71.5, } // struct -> json string b, err := json.Marshal(p1) if err != nil { fmt.Printf(\\\"json.Marshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) // json string -> struct var p2 Person err = json.Unmarshal(b, &p2) if err != nil { fmt.Printf(\\\"json.Unmarshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"p2:%#v\\\\n\\\", p2) }\",\"输出：\",\"str:{\\\"Name\\\":\\\"小明\\\",\\\"Age\\\":18,\\\"Weight\\\":71.5} p2:main.Person{Name:\\\"小明\\\", Age:18, Weight:71.5}\"]},\"484\":{\"h\":\"结构体tag介绍\",\"t\":[\"Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：\",\"`key1:\\\"value1\\\" key2:\\\"value2\\\"`\",\"总结：\",\"结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。\",\"同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。\"]},\"485\":{\"h\":\"使用json tag指定字段名\",\"t\":[\"序列化与反序列化默认情况下使用结构体的字段名，我们可以通过给结构体字段添加tag来指定json序列化生成的字段名。\",\"// 使用json tag指定序列化与反序列化时的行为 type Person struct { Name string `json:\\\"name\\\"` // 指定json序列化/反序列化时使用小写name Age int64 Weight float64 }\"]},\"486\":{\"h\":\"忽略某个字段\",\"t\":[\"如果你想在json序列化/反序列化的时候忽略掉结构体中的某个字段，可以按如下方式在tag中添加-。\",\"// 使用json tag指定json序列化与反序列化时的行为 type Person struct { Name string `json:\\\"name\\\"` // 指定json序列化/反序列化时使用小写name Age int64 Weight float64 `json:\\\"-\\\"` // 指定json序列化/反序列化时忽略此字段 }\"]},\"487\":{\"h\":\"忽略空值字段\",\"t\":[\"当 struct 中的字段没有值时， json.Marshal() 序列化的时候不会忽略这些字段，而是默认输出字段的类型零值（例如int和float类型零值是 0，string类型零值是\\\"\\\"，对象类型零值是 nil）。 如果想要在序列化时忽略这些没有值的字段时，可以在对应字段添加omitempty tag。 举个例子：\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email\\\"` Hobby []string `json:\\\"hobby\\\"` } func omitemptyDemo() { u1 := User{ Name: \\\"小明\\\", } // struct -> json string b, err := json.Marshal(u1) if err != nil { fmt.Printf(\\\"json.Marshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) }\",\"输出结果：\",\"str:{\\\"name\\\":\\\"小明\\\",\\\"email\\\":\\\"\\\",\\\"hobby\\\":null}\"]},\"488\":{\"h\":\"如果想要在最终的序列化结果中去掉空值字段，可以像下面这样定义结构体：使用omitempty\",\"t\":[\"// 在tag中添加omitempty忽略空值 // 注意这里 hobby,omitempty 合起来是json tag值，中间用英文逗号分隔 type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` }\",\"此时，再执行上述的omitemptyDemo，输出结果如下：\",\"str:{\\\"name\\\":\\\"小明\\\"} // 序列化结果中没有email和hobby字段\",\"说句题外话，我们使用gorm操作数据库的话，经常会遇到想忽略指定字段修改的问题，比如结构体中的关联实体，只想json展示，form提交时忽略实体，这个问题请关注我的Go语言学习专栏吧。\"]},\"489\":{\"h\":\"忽略嵌套结构体空值字段\",\"t\":[\"首先来看几种结构体嵌套的示例：\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` Profile } type Profile struct { Website string `json:\\\"site\\\"` Slogan string `json:\\\"slogan\\\"` } func nestedStructDemo() { u1 := User{ Name: \\\"小明\\\", Hobby: []string{\\\"足球\\\", \\\"篮球\\\"}, } b, err := json.Marshal(u1) if err != nil { fmt.Printf(\\\"json.Marshal failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) }\",\"匿名嵌套Profile时序列化后的json串为单层的：\",\"str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"蓝球\\\"],\\\"site\\\":\\\"\\\",\\\"slogan\\\":\\\"\\\"}\",\"想要变成嵌套的json串，需要改为具名嵌套或定义字段tag：\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` Profile `json:\\\"profile\\\"` } // str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"篮球\\\"],\\\"profile\\\":{\\\"site\\\":\\\"\\\",\\\"slogan\\\":\\\"\\\"}}\",\"想要在嵌套的结构体为空值时，忽略该字段，仅添加omitempty是不够的\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` Profile `json:\\\"profile,omitempty\\\"` } // str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"篮球\\\"],\\\"profile\\\":{\\\"site\\\":\\\"\\\",\\\"slogan\\\":\\\"\\\"}}\",\"还需要使用嵌套的结构体指针\",\"type User struct { Name string `json:\\\"name\\\"` Email string `json:\\\"email,omitempty\\\"` Hobby []string `json:\\\"hobby,omitempty\\\"` *Profile `json:\\\"profile,omitempty\\\"` //这里是重点 } // str:{\\\"name\\\":\\\"小明\\\",\\\"hobby\\\":[\\\"足球\\\",\\\"篮球\\\"]}\"]},\"490\":{\"h\":\"不修改原结构体忽略空值字段\",\"t\":[\"我们需要json序列化User，但是不想把密码也序列化，又不想修改User结构体，这个时候我们就可以使用创建另外一个结构体PublicUser匿名嵌套原User，同时指定Password字段为匿名结构体指针类型，并添加omitemptytag，示例代码如下：\",\"type User struct { Name string `json:\\\"name\\\"` Password string `json:\\\"password\\\"` } type PublicUser struct { *User // 匿名嵌套 Password *struct{} `json:\\\"password,omitempty\\\"` } func omitPasswordDemo() { u1 := User{ Name: \\\"小明\\\", Password: \\\"123456\\\", } b, err := json.Marshal(PublicUser{User: &u1}) if err != nil { fmt.Printf(\\\"json.Marshal u1 failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"str:%s\\\\n\\\", b) // str:{\\\"name\\\":\\\"小明\\\"} }\"]},\"491\":{\"h\":\"优雅处理字符串格式的数字\",\"t\":[\"有时候，前端在传递来的json数据中可能会使用字符串类型的数字，这个时候可以在结构体tag中添加string来告诉json包从字符串中解析相应字段的数据：\",\"type Card struct { ID int64 `json:\\\"id,string\\\"` // 添加string tag Score float64 `json:\\\"score,string\\\"` // 添加string tag } func intAndStringDemo() { jsonStr1 := `{\\\"id\\\": \\\"1234567\\\",\\\"score\\\": \\\"88.50\\\"}` var c1 Card if err := json.Unmarshal([]byte(jsonStr1), &c1); err != nil { fmt.Printf(\\\"json.Unmarsha jsonStr1 failed, err:%v\\\\n\\\", err) return } fmt.Printf(\\\"c1:%#v\\\\n\\\", c1) // c1:main.Card{ID:1234567, Score:88.5} }\"]},\"492\":{\"c\":[\"Go\"]},\"493\":{\"c\":[\"Go库\"]},\"494\":{\"h\":\"Go语言字符串处理\",\"t\":[\"Go语言的strings包提供了丰富而强大的字符串处理功能。本文将深入介绍这些常用函数，并结合实际场景分析其性能特点和最佳实践。\"]},\"495\":{\"h\":\"1. 基础字符串操作\"},\"496\":{\"h\":\"1.1 字符串比较\",\"t\":[\"// 按字典顺序比较两个字符串 strings.Compare(a, b string) int // 忽略大小写比较两个字符串 strings.EqualFold(s1, s2 string) bool // 示例 fmt.Println(strings.Compare(\\\"abc\\\", \\\"abd\\\")) // 输出: -1 fmt.Println(strings.EqualFold(\\\"Go\\\", \\\"go\\\")) // 输出: true\",\"性能提示\",\"对于简单的相等性比较，直接使用==运算符比Compare函数更高效。EqualFold适用于不区分大小写的场景，如HTTP头部字段比较。\"]},\"497\":{\"h\":\"1.2 字符串查找\",\"t\":[\"// 检查字符串是否包含子串 strings.Contains(s, substr string) bool // 检查字符串是否包含字符集合中的任何字符 strings.ContainsAny(s, chars string) bool // 统计子串出现次数 strings.Count(s, substr string) int // 示例 text := \\\"Hello, Go World!\\\" fmt.Println(strings.Contains(text, \\\"Go\\\")) // true fmt.Println(strings.ContainsAny(text, \\\"aeiou\\\")) // true fmt.Println(strings.Count(text, \\\"o\\\")) // 2\",\"注意事项\",\"Contains函数使用了Boyer-Moore算法的变体，对于长字符串搜索效率较高。但对于短字符串（长度<50），简单的遍历可能更快。\"]},\"498\":{\"h\":\"2. 字符串转换与修改\"},\"499\":{\"h\":\"2.1 大小写转换\",\"t\":[\"// 转换为小写 strings.ToLower(s string) string // 转换为大写 strings.ToUpper(s string) string // 示例 fmt.Println(strings.ToLower(\\\"Hello, World!\\\")) // hello, world! fmt.Println(strings.ToUpper(\\\"Hello, World!\\\")) // HELLO, WORLD!\"]},\"500\":{\"h\":\"2.2 字符串修剪\",\"t\":[\"// 去除两端指定字符集 strings.Trim(s, cutset string) string // 去除空白字符 strings.TrimSpace(s string) string // 去除前缀/后缀 strings.TrimPrefix(s, prefix string) string strings.TrimSuffix(s, suffix string) string // 示例 text := \\\" Hello, World! \\\" fmt.Println(strings.TrimSpace(text)) // \\\"Hello, World!\\\" fmt.Println(strings.Trim(\\\"!!!Hello!!!\\\", \\\"!\\\")) // \\\"Hello\\\"\"]},\"501\":{\"h\":\"3. 字符串分割与连接\"},\"502\":{\"h\":\"3.1 字符串分割\",\"t\":[\"// 按空白字符分割 strings.Fields(s string) []string // 按分隔符分割 strings.Split(s, sep string) []string // 限制分割次数 strings.SplitN(s, sep string, n int) []string // 示例 text := \\\"apple,banana,orange\\\" fmt.Println(strings.Split(text, \\\",\\\")) // [apple banana orange] fmt.Println(strings.SplitN(text, \\\",\\\", 2)) // [apple banana,orange]\",\"性能优化\",\"当需要处理大量字符串分割操作时，考虑使用bytes.Split，可以避免创建临时字符串。\"]},\"503\":{\"h\":\"3.2 字符串连接\",\"t\":[\"// 使用分隔符连接字符串切片 strings.Join(elems []string, sep string) string // 重复字符串 strings.Repeat(s string, count int) string // 示例 fruits := []string{\\\"apple\\\", \\\"banana\\\", \\\"orange\\\"} fmt.Println(strings.Join(fruits, \\\", \\\")) // apple, banana, orange fmt.Println(strings.Repeat(\\\"Go!\\\", 3)) // Go!Go!Go!\"]},\"504\":{\"h\":\"4. 高效的字符串构建\"},\"505\":{\"h\":\"4.1 strings.Builder 的使用\",\"t\":[\"var builder strings.Builder // 预分配内存 builder.Grow(100) // 写入字符串 builder.WriteString(\\\"Hello\\\") builder.WriteString(\\\", \\\") builder.WriteString(\\\"World!\\\") // 获取结果 result := builder.String()\",\"最佳实践\",\"在循环中构建大字符串时，使用strings.Builder而不是+运算符\",\"如果可以预估最终字符串长度，使用Grow方法预分配内存\",\"Builder是非线程安全的，在并发环境中需要额外同步\",\"性能对比：\",\"// 不推荐：使用+运算符 result := \\\"\\\" for i := 0; i < 1000; i++ { result += \\\"x\\\" } // 推荐：使用strings.Builder var builder strings.Builder builder.Grow(1000) for i := 0; i < 1000; i++ { builder.WriteByte('x') } result := builder.String()\"]},\"506\":{\"c\":[\"Go\"]},\"507\":{\"c\":[\"Go\",\"字符串处理\",\"strings包\"]},\"508\":{\"h\":\"SyncMap包的源码学习\",\"t\":[\"syncmap 源码学习\"]},\"509\":{\"h\":\"一、map 与 sync.Map\",\"t\":[\"map 不支持并发的读写操作，否则会出现 fatal error 导致程序直接被终止。无法用 defer + recover 捕获。\",\"Go 官方提供了一个并发安全的 sync.Map。\"]},\"510\":{\"h\":\"1. 模拟 map 的并发读写 fatal\",\"t\":[\"报错：fatal\",\"package main func main() { // 初始化一个 map m := make(map[int]int) // 并发写操作 go func() { for i := 0; i < 1000000; i++ { m[i] = i } }() // 并发读操作 go func() { for i := 0; i < 1000000; i++ { _ = m[i] } }() // 阻塞主线程 select {} } result：fatal error: concurrent map read and map write\"]},\"511\":{\"h\":\"2. 盲点：加上打印却可以避免 fatal\",\"t\":[\"给每个协程加上一行打印语句，fatal 就不会发生：\",\"package main import \\\"fmt\\\" func main() { // 初始化一个 map m := make(map[int]int) // 并发写操作 go func() { for i := 0; i < 1000000; i++ { m[i] = i fmt.Println(\\\"写:\\\", m[i]) } }() // 并发读操作 go func() { for i := 0; i < 1000000; i++ { _ = m[i] fmt.Println(\\\"读:\\\", m[i]) } }() // 阻塞主线程 select {} }\",\"原因：fmt.Println 内部使用了锁\",\"每次调用 fmt.Println 时，它会获取一个锁，以确保多个 goroutine 并发调用 fmt.Println 时，输出不会混乱。\",\"这种锁机制会导致其他 goroutine 在等待锁释放时被阻塞，从而改变 goroutine 的执行顺序。从而在某些情况下掩盖数据竞争的问题。\"]},\"512\":{\"h\":\"二、sync.Map 简介\",\"t\":[\"sync.Map 是 Go 官方提供的一个并发安全的一个 Map\",\"它本质是采用空间换时间的思想，使用两个 map(read map 和 dirty map)，这两个 map 互相配合来提供一个拥有并发读写能力，并且会权衡整体操作性能的并发安全 map。\",\"readmap 通过无锁的 cas 操作揽下大部分操作，减少 dirtymap 锁的使用。\",\"请求流程：\",\"当请求访问 sync.map，会让请求在 readmap 上解决，如果无法解决再交给 dirtymap 来兜底完成。\",\"dirtymap 会拥有全量的数据，因为它有兜底完成 readmap 无法处理的请求的责任。\",\"写指的是新增数据，更新指的是更新已有数据。\",\"对于 读、删、更新 会尽量在 readmap 中处理，实在处理不了再去拿锁，找 dirtymap 处理。\",\"对于 写 会通过锁找到 dirtymap 处理。\",\"readmap 是通过无锁的 cas 去完成对变量的操作，而 dirtymap 是通过加锁来做了限流保护的。\",\"关于 entry：\",\"最下面的 entry 被 read 和 dirty 同时指向，代表的是：两个 map 中相同的 key 对应同一块 value 内存，而 value 就是 sync.map 的 entry。这里会涉及到数据的双向流转机制，后面会解读。\"]},\"513\":{\"h\":\"三、sync.map 的使用\"},\"514\":{\"h\":\"1. 基本的 crud\",\"t\":[\"// 添加元素 m.Store(\\\"key1\\\", \\\"value1\\\") m.Store(\\\"key2\\\", \\\"value2\\\") // 更新元素 m.Store(\\\"key1\\\", \\\"newValue1\\\") // 查询元素 if value, ok := m.Load(\\\"key1\\\"); ok { fmt.Println(\\\"key1:\\\", value) } else { fmt.Println(\\\"key1 not found\\\") } // 删除元素 m.Delete(\\\"key2\\\") // 遍历所有元素 m.Range(func(key, value interface{}) bool { fmt.Printf(\\\"%s: %s\\\\n\\\", key, value) return true })\"]},\"515\":{\"h\":\"2. 验证并发安全\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"sync\\\" \\\"time\\\" ) func main() { var m sync.Map var wg sync.WaitGroup // 启动多个并发写操作 for i := 0; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() for j := 0; j < 1000; j++ { key := fmt.Sprintf(\\\"key-%d-%d\\\", i, j) m.Store(key, j) } }(i) } // 启动多个并发读操作 for i := 0; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() for j := 0; j < 1000; j++ { key := fmt.Sprintf(\\\"key-%d-%d\\\", i, j) if value, ok := m.Load(key); ok { fmt.Printf(\\\"Read key: %s, value: %d\\\\n\\\", key, value) } } }(i) } // 启动多个并发删除操作 for i := 0; i < 10; i++ { wg.Add(1) go func(i int) { defer wg.Done() for j := 0; j < 1000; j++ { key := fmt.Sprintf(\\\"key-%d-%d\\\", i, j) m.Delete(key) } }(i) } // 启动一个 goroutine 遍历所有元素 wg.Add(1) go func() { defer wg.Done() time.Sleep(1 * time.Second) // 等待部分写操作完成 m.Range(func(key, value interface{}) bool { fmt.Printf(\\\"Range key: %s, value: %d\\\\n\\\", key, value) return true }) }() // 等待所有 goroutine 完成 wg.Wait() fmt.Println(\\\"All operations completed.\\\") }\"]},\"516\":{\"h\":\"四、sync.map 的结构\",\"t\":[\"关注这三个结构体：\",\"Map： sync.map 的顶层封装\",\"readOnly： readmap 的封装，里面有一个 amended 字段，true 就是标记 有数据在 read 没有，而 dirty 有。\",\"Entry： 就是 value 的封装\",\"//******************************************************************************** type Map struct { // 互斥锁，保护对映射数据的并发访问 mu Mutex // read map： 用cas操作，无锁 read atomic.Pointer[readOnly] // dirty map：需要配合互斥锁使用 dirty map[any]*entry // misses 记录有多少次请求打到了 dirty 去处理 // 当 misses 的次数足够多时，dirty map将被提升为 read map misses int } //******************************************************************************** type readOnly struct { // read map 存放 k-v的实体，底层还是使用的 map m map[any]*entry // 标记 是否数据缺失 // 即 dirtymap 有，readmap没有的 key，此时 amended 为 true amended bool } //******************************************************************************** type entry struct { // p 字段是一个原子指针，使用 atomic.Pointer[any] 类型，用于存储条目的值。 // 这个指针可以安全地在不同的 goroutine 之间共享和访问，并且支持原子性的读写操作。 p atomic.Pointer[any] }\"]},\"517\":{\"h\":\"五、两个 map 的数据双向流转机制\"},\"518\":{\"h\":\"1. Dirty map --> Read map\",\"t\":[\"read 可以为 dirty 尽量的挡住 读、删、更新的操作流量，但是如果 read 很多次没有挡住请求，让这些请求到了 dirty 中，就意味着：\",\"这个流转的可以理解为：将 readmap 指针指向 dirtymap，然后 dirtymap 置为 nil。\"]},\"519\":{\"h\":\"2. Read map --> Dirty map\",\"t\":[\"从上面可以知道 Dirty map --> Read map 后，dirty 是 nil。\",\"如果这时候来了一个写（新增）请求，写请求是要通过加锁到 dirty 中操作的，dirty 需要保证自己的数据是全量的，就会从 readmap 中复制一份逻辑上存在（能通过 key 查询到的）的数据过来。\"]},\"520\":{\"h\":\"3. 为什么要双向流转\",\"t\":[\"为什么要把数据集当成皮球一样踢来踢去呢？\",\"dirty 把数据全给 read ，为什么自己要置为 nil?\",\"数据隔离： 如果 dirty 不重置为 nil，就会出现 dirty 和 read 使用同一个底层 map。这样就无法做到数据隔离的。go 语言希望 read map 和 dirty map 依赖的是不同的 map，但 entry 是可以共享的。\",\"dirty 能不能 copy 一份全量数据给 read，不把自己置 nil?\",\"并发冲突：在复制的过程中，整个 sync.Map 将会处于一种不稳定的状态。如果在这个过程中有并发访问，可能会导致数据不一致或崩溃。\",\"性能问题：复制大数据量的 dirty 到 read 是一个耗时的操作，会降低性能。直接切换引用可以避免这些性能问题。\"]},\"521\":{\"h\":\"六、Enrty 的状态解读\",\"t\":[\"首先 Entry 是 value 的实体。\"]},\"522\":{\"h\":\"1. entry 的结构\",\"t\":[\"type entry struct { // p 字段是一个原子指针，使用 atomic.Pointer[any] 类型，用于存储条目的值。 // 这个指针可以安全地在不同的 goroutine 之间共享和访问，并且支持原子性的读写操作。 p atomic.Pointer[any] }\"]},\"523\":{\"h\":\"2. entry 的三个状态\",\"t\":[\"**正常值：**正常的 k-v 实体，数据存在。\",\"nil 状态：表示软删除状态，代表 k-v 数据在逻辑上不存在（不能通过 k 获取到 v），但是在内存仍然存在这个 key。\",\"**expunged 状态：**表示硬删除状态，代表逻辑和内存里都不存在这个 k 和 v\",\"画个图理解一下：\"]},\"524\":{\"h\":\"3. Nil 状态\",\"t\":[\"先说结论：\",\"nil 状态是为了优化 “对用一个 key 先删后写的场景优化”，让这个 key 能直接在 readmap 中无锁完成写，不需要加锁到 dirty 中操作。\",\"可以说是让原本的 去 dirty 中加锁写 --> cas 无锁更新\",\"同时 read 是可以挡住删除的流量的，通过 cas 操作在 readmap 中将 key 的值变成 nil，表示当前 key 在逻辑上已经删除了。\",\"现在来模拟一下读、写两个操作：\",\"读：读到 key 的值为 nil，直接返回 nil，读不到，用户可以认为改 key 被删除了。\",\"写：当 key 存在，但是值为 nil，代表 key 在 read 和 dirty 都存着，可以再次通过 cas 操作，将 nil 改为对于的 value 值，完成了更新操作，避免了加锁访问 dirty。\"]},\"525\":{\"h\":\"4. Expunged 状态\",\"t\":[\"在 Read map --> Dirty map 过程中，read 只会将逻辑上存在的数据 copy 给 dirty。\",\"那么问题是：\",\"read 中 nil 的数据，不会 copy 给 dirty，也就是会导致两个 map 的数据不一致。在下一次更新/写操作到来，在 read 层就读到了该 key 为 nil 值，但是 dirty 中是没有这个 key 的。\",\"这个时候就需要在 copy 完之后，将原本为 nil 的 key 设置为 expunged。表示硬删除\",\"简而言之： expunged 状态是由 nil 状态 流转来的，在发生 Read map --> Dirty map 过程后，需要把 readmap 的 nil 状态 修改为 expunged\"]},\"526\":{\"h\":\"七、回顾 sync.Map 的底层原理\",\"t\":[\"空间换时间： read map 尽量用 cas 操作无锁完成 读、删、更新 的操作，dirty map 加锁完成写操作。\",\"数据的双向流转： read <-----> dirty\",\"Entry 的nil 和 expunged状态设计： 优化的先删后写场景和无锁完成删操作。\"]},\"527\":{\"h\":\"八、sync.Map 的不足\",\"t\":[\"不适合多写的场景，当写多的时候 sync.Map 就相当于 map + Mutex 性能没那么好。\",\"sync.Map 存在 read ----> dirty 的数据流转过程，这是一个线性时间复杂度 O(n)的过程，当 k-v 数量较多的时候，容易导致程序性能抖动。比如需要访问 sync.Map 拿锁去操作的协程需要一直等待这个线性时间复杂度的过程完成。\"]},\"528\":{\"h\":\"九、sync.Map 源码走读\"},\"529\":{\"h\":\"1. Load() - 读\",\"t\":[\"// Load 方法根据 key 加载相应的 value，如果 key 存在且value有效，返回存储的值和一个布尔值，表示查找成功。 func (m *Map) Load(key any) (value any, ok bool) { // 首先读取 readOnly 结构体，加载 read map read := m.loadReadOnly() // 尝试从 read 中获取 k-v e, ok := read.m[key] // 若 read 中没有，并且 read 的数据不全，加锁访问 dirty 获取 if !ok && read.amended { // 加锁以操作 dirty m.mu.Lock() // double_check：检查自上次加载 read 以来，dirty 字段是否已经被提升为 read。 // 目的是避免有其他 goroutine 更新了 read。 dirtymap -----> readmap read = m.loadReadOnly() // 再次尝试从 read中获取 k-v e, ok = read.m[key] // 若 read 中没有，并且 read 的数据不全，到 dirty 获取 if !ok && read.amended { // 若在 dirty 字段中找到条目 e, ok = m.dirty[key] // 记录一次 miss，这将加速提升 dirty 到 read 的过程，相当于dirty的压力++ m.missLocked() } // 操作结束，解锁 m.mu.Unlock() } // 若连 dirty 中都没有 if !ok { // 返回 nil 和 false return nil, false } // 若找到 k-v，调用其 load 方法得到 v return e.load() }\"]},\"530\":{\"h\":\"2. missLocked() - missssss\",\"t\":[\"包含：自增 miss，判断是否将 dirty 晋升\",\"// missLocked 处理 read 未命中的情况 func (m *Map) missLocked() { // 每次未命中时增加 misses 计数 m.misses++ // 如果 misses 计数小于脏数据的数量，则不需要采取进一步的操作 if m.misses < len(m.dirty) { return } // 发生数据流转： dirty -----> read // 创建一个新的只读缓存，并将 misses 计数重置为 0 m.read.Store(&readOnly{m: m.dirty}) m.dirty = nil m.misses = 0 }\"]},\"531\":{\"h\":\"3. Store() - 写\",\"t\":[\"// Store 整合了写和更新操作，底层调用 Swap() func (m *Map) Store(key, value any) { _, _ = m.Swap(key, value) } func (m *Map) Swap(key, value any) (previous any, loaded bool) { // 加载 read read := m.loadReadOnly() // 如果 key 已经存在于 read 中，尝试在 read 中更新 key if e, ok := read.m[key]; ok { // 尝试用 cas在 read 更新 key，避免加锁访问 dirty if v, ok := e.trySwap(&value); ok { if v == nil { // 返回 nil 和 false，表示没有加载任何值 return nil, false } // 返回旧值和 true，表示已经加载 return *v, true } } // 加锁操作 dirty m.mu.Lock() // double_check read = m.loadReadOnly() // 如果key存在于read中 if e, ok := read.m[key]; ok { // 将 key 修改为非 expunged 状态 ----> nil if e.unexpungeLocked() { //entry是共享的，expunged状态下的entry，只有read有它的指针，这一步就是让dirty也能有这个key和entry。 //同时unexpungeLocked() 就是通过cas将expunged态的entry变成nil态，这就代表read和dirty都有个nil的entry。 //上面的两个过程一起完成这个enrty“复活”，以便后面完成真正的更新操作 m.dirty[key] = e } // cas交换值 if v := e.swapLocked(&value); v!= nil { // 设置加载标志为 true，表示加载了新值 loaded = true previous = *v } // 如果 k 不存在于 read 中，但存在于 dirty 中 } else if e, ok := m.dirty[key]; ok { // cas交换值 if v := e.swapLocked(&value); v!= nil { // 设置加载标志为 true，表示加载了新值 loaded = true previous = *v // 如果 k 既不存在于 raed 中，也不存在于 dirty 中 } else { // 如果 dirty 未被修改 if!read.amended { // 为 dirty 分配空间并标记 read 为不完整 m.dirtyLocked() m.read.Store(&readOnly{m: read.m, amended: true}) } // 将新的 kv 对添加到 dirty 中 m.dirty[key] = newEntry(value) } // 释放互斥锁 m.mu.Unlock() // 返回 return previous, loaded } func (e *entry) trySwap(i *any) (*any, bool) { // 无限循环，直到交换成功或者entry被移除。 for { // 加载当前 entry 指针。 p := e.p.Load() // 如果entry被移除（指针为 expunged，代表硬删除），则返回 nil 和 false。 if p == expunged { return nil, false } // 尝试使用原子操作 CompareAndSwap 将新值交换到 entry。 if e.p.CompareAndSwap(p, i) { // 如果操作成功，返回 p 和 true。 return p, true } } }\"]},\"532\":{\"h\":\"4. Range() - 读\",\"t\":[\"注意：\",\"Range 方法不保证遍历期间 map 内容的一致性。Range 方法不会阻塞其他方法的执行。\",\"遍历期间，键不会被重复访问，但键的值可能会因为并发操作而发生变化。\",\"func (m *Map) Range(f func(key, value any) bool) { read := m.loadReadOnly() if read.amended { m.mu.Lock() read = m.loadReadOnly() if read.amended { read = readOnly{m: m.dirty} m.read.Store(&read) m.dirty = nil m.misses = 0 } m.mu.Unlock() } for k, e := range read.m { v, ok := e.load() if !ok { continue } if !f(k, v) { break } } }\"]},\"533\":{\"c\":[\"Go\"]},\"534\":{\"c\":[\"syncMap\"]},\"535\":{\"h\":\"Java异常机制\",\"t\":[\"本文详细介绍Java异常机制的基本概念、原理、使用方法以及实践。\"]},\"536\":{\"h\":\"1. 异常基础\",\"t\":[\"异常是程序运行过程中出现的非正常情况，Java的异常处理机制提供了一种结构化和受控的方式来处理程序中的错误。\"]},\"537\":{\"h\":\"1.1 异常的概念\",\"t\":[\"在Java中，异常是一个事件，它发生在程序运行期间，干扰了程序的正常指令流。当方法中发生错误时，方法会创建一个异常对象并交给运行时系统处理。\"]},\"538\":{\"h\":\"1.2 异常的分类\",\"t\":[\"Java中的异常主要分为三类：\",\"检查型异常（Checked Exception）：必须在代码中显式处理的异常\",\"非检查型异常（Unchecked Exception）：运行时异常，不强制处理\",\"错误（Error）：表示严重问题，通常不应该被捕获\",\"// Java异常层次结构 Throwable ├── Error // 严重错误，不应捕获 │ ├── OutOfMemoryError │ ├── StackOverflowError │ └── ... └── Exception // 异常基类 ├── IOException // 检查型异常 ├── SQLException // 检查型异常 └── RuntimeException // 非检查型异常 ├── NullPointerException ├── ArrayIndexOutOfBoundsException └── ...\"]},\"539\":{\"h\":\"2. 异常处理机制\"},\"540\":{\"h\":\"2.1 try-catch-finally\",\"t\":[\"最基本的异常处理结构：\",\"public class ExceptionHandlingDemo { public static void main(String[] args) { try { // 可能抛出异常的代码 int result = divide(10, 0); System.out.println(\\\"结果: \\\" + result); } catch (ArithmeticException e) { // 处理特定类型的异常 System.out.println(\\\"算术异常: \\\" + e.getMessage()); } catch (Exception e) { // 处理其他类型的异常 System.out.println(\\\"其他异常: \\\" + e.getMessage()); } finally { // 无论是否发生异常都会执行的代码 System.out.println(\\\"finally块总是执行\\\"); } } public static int divide(int a, int b) { return a / b; // 当b为0时抛出ArithmeticException } }\"]},\"541\":{\"h\":\"2.2 try-with-resources\",\"t\":[\"Java 7引入的自动资源管理：\",\"public class ResourceManagementDemo { public static void readFile(String path) { // 自动关闭资源 try (BufferedReader reader = new BufferedReader(new FileReader(path))) { String line; while ((line = reader.readLine()) != null) { System.out.println(line); } } catch (IOException e) { System.out.println(\\\"读取文件异常: \\\" + e.getMessage()); } // 不需要finally块来关闭资源 } }\"]},\"542\":{\"h\":\"2.3 throws声明\",\"t\":[\"方法声明可能抛出的检查型异常：\",\"public class ThrowsDemo { // 声明方法可能抛出IOException public static void readFile(String path) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(path)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } reader.close(); } public static void main(String[] args) { try { readFile(\\\"example.txt\\\"); } catch (IOException e) { System.out.println(\\\"IO异常: \\\" + e.getMessage()); } } }\"]},\"543\":{\"h\":\"2.4 throw关键字\",\"t\":[\"手动抛出异常：\",\"public class ThrowDemo { public static void validateAge(int age) { if (age < 0) { throw new IllegalArgumentException(\\\"年龄不能为负数\\\"); } if (age > 150) { throw new IllegalArgumentException(\\\"年龄不合理\\\"); } System.out.println(\\\"年龄有效: \\\" + age); } public static void main(String[] args) { try { validateAge(-5); } catch (IllegalArgumentException e) { System.out.println(\\\"参数异常: \\\" + e.getMessage()); } } }\"]},\"544\":{\"h\":\"3. 自定义异常\"},\"545\":{\"h\":\"3.1 创建自定义异常\",\"t\":[\"// 自定义检查型异常 public class InvalidUserException extends Exception { public InvalidUserException() { super(); } public InvalidUserException(String message) { super(message); } public InvalidUserException(String message, Throwable cause) { super(message, cause); } } // 自定义运行时异常 public class BusinessException extends RuntimeException { public BusinessException() { super(); } public BusinessException(String message) { super(message); } public BusinessException(String message, Throwable cause) { super(message, cause); } }\"]},\"546\":{\"h\":\"3.2 使用自定义异常\",\"t\":[\"public class UserService { public User findUser(String username) throws InvalidUserException { if (username == null || username.isEmpty()) { throw new InvalidUserException(\\\"用户名不能为空\\\"); } // 模拟数据库查询 if (\\\"admin\\\".equals(username)) { return new User(\\\"admin\\\", \\\"Admin User\\\"); } else { throw new InvalidUserException(\\\"用户不存在: \\\" + username); } } public void processBusinessLogic(String data) { if (data == null) { throw new BusinessException(\\\"数据不能为空\\\"); } // 处理业务逻辑 } }\"]},\"547\":{\"c\":[\"Java\"]},\"548\":{\"c\":[\"异常处理\",\"高级特性\"]},\"549\":{\"h\":\"Java反射机制\",\"t\":[\"本文详细介绍Java反射机制的基本概念、原理、使用方法以及实践.\"]},\"550\":{\"h\":\"1. 反射基础\",\"t\":[\"反射（Reflection）是Java的一个强大特性，它允许程序在运行时检查和操作类、接口、字段和方法等程序元素，而不需要在编译时知道这些元素的名称。\"]},\"551\":{\"h\":\"1.1 反射的概念\",\"t\":[\"反射提供了一种在运行时检查和修改程序行为的方式，使得程序可以：\",\"获取任何类的信息\",\"在运行时创建对象实例\",\"调用任意方法\",\"获取和设置对象字段的值\"]},\"552\":{\"h\":\"1.2 反射的优缺点\",\"t\":[\"优点：\",\"提高了程序的灵活性和扩展性\",\"支持动态加载类和使用类\",\"是很多框架实现的基础（如Spring、Hibernate等）\",\"缺点：\",\"性能开销较大\",\"可能破坏封装性\",\"代码可读性降低\",\"安全限制问题\"]},\"553\":{\"h\":\"2. 获取Class对象\",\"t\":[\"在Java中，Class对象是反射的入口点，有三种主要方式获取Class对象：\",\"// 方式1：通过对象的getClass()方法 String str = \\\"Hello\\\"; Class<?> class1 = str.getClass(); // 方式2：通过类的class属性 Class<?> class2 = String.class; // 方式3：通过Class.forName()方法 try { Class<?> class3 = Class.forName(\\\"java.lang.String\\\"); } catch (ClassNotFoundException e) { e.printStackTrace(); }\"]},\"554\":{\"h\":\"3. 反射的主要API\"},\"555\":{\"h\":\"3.1 检查类信息\",\"t\":[\"public class ReflectionDemo { public static void examineClass(Class<?> clazz) { System.out.println(\\\"类名: \\\" + clazz.getName()); System.out.println(\\\"简单类名: \\\" + clazz.getSimpleName()); System.out.println(\\\"包名: \\\" + clazz.getPackage().getName()); System.out.println(\\\"是否为接口: \\\" + clazz.isInterface()); System.out.println(\\\"是否为枚举: \\\" + clazz.isEnum()); System.out.println(\\\"是否为数组: \\\" + clazz.isArray()); System.out.println(\\\"父类: \\\" + clazz.getSuperclass().getName()); // 获取实现的接口 Class<?>[] interfaces = clazz.getInterfaces(); System.out.println(\\\"实现的接口:\\\"); for (Class<?> i : interfaces) { System.out.println(\\\" \\\" + i.getName()); } } }\"]},\"556\":{\"h\":\"3.2 构造函数操作\",\"t\":[\"public class ConstructorReflection { public static void main(String[] args) { try { // 获取Class对象 Class<?> personClass = Class.forName(\\\"com.example.Person\\\"); // 获取所有公共构造函数 Constructor<?>[] constructors = personClass.getConstructors(); System.out.println(\\\"公共构造函数数量: \\\" + constructors.length); // 获取特定构造函数 Constructor<?> constructor = personClass.getConstructor(String.class, int.class); // 使用构造函数创建对象 Object personObj = constructor.newInstance(\\\"John\\\", 30); System.out.println(personObj); } catch (Exception e) { e.printStackTrace(); } } }\"]},\"557\":{\"h\":\"3.3 字段操作\",\"t\":[\"public class FieldReflection { public static void main(String[] args) { try { // 获取Class对象 Class<?> personClass = Class.forName(\\\"com.example.Person\\\"); Object person = personClass.newInstance(); // 创建实例 // 获取公共字段 Field[] fields = personClass.getFields(); // 获取所有字段（包括私有字段） Field[] allFields = personClass.getDeclaredFields(); // 获取特定字段 Field nameField = personClass.getDeclaredField(\\\"name\\\"); // 设置私有字段可访问 nameField.setAccessible(true); // 设置字段值 nameField.set(person, \\\"Alice\\\"); // 获取字段值 String name = (String) nameField.get(person); System.out.println(\\\"Name: \\\" + name); } catch (Exception e) { e.printStackTrace(); } } }\"]},\"558\":{\"h\":\"3.4 方法操作\",\"t\":[\"public class MethodReflection { public static void main(String[] args) { try { // 获取Class对象 Class<?> personClass = Class.forName(\\\"com.example.Person\\\"); Object person = personClass.newInstance(); // 创建实例 // 获取所有公共方法 Method[] methods = personClass.getMethods(); // 获取所有方法（包括私有方法） Method[] allMethods = personClass.getDeclaredMethods(); // 获取特定方法 Method setNameMethod = personClass.getDeclaredMethod(\\\"setName\\\", String.class); Method getNameMethod = personClass.getDeclaredMethod(\\\"getName\\\"); // 调用方法 setNameMethod.invoke(person, \\\"Bob\\\"); String name = (String) getNameMethod.invoke(person); System.out.println(\\\"Name: \\\" + name); // 获取方法的修饰符 int modifiers = getNameMethod.getModifiers(); System.out.println(\\\"Is public: \\\" + Modifier.isPublic(modifiers)); System.out.println(\\\"Is static: \\\" + Modifier.isStatic(modifiers)); } catch (Exception e) { e.printStackTrace(); } } }\"]},\"559\":{\"h\":\"4. 动态代理\",\"t\":[\"反射的一个重要应用是动态代理，它允许在运行时创建一个实现了指定接口的代理类。\",\"import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // 接口 interface UserService { void addUser(String name); String getUser(int id); } // 实现类 class UserServiceImpl implements UserService { @Override public void addUser(String name) { System.out.println(\\\"Adding user: \\\" + name); } @Override public String getUser(int id) { return \\\"User \\\" + id; } } // 调用处理器 class LoggingHandler implements InvocationHandler { private Object target; public LoggingHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"Before method: \\\" + method.getName()); Object result = method.invoke(target, args); System.out.println(\\\"After method: \\\" + method.getName()); return result; } } // 使用动态代理 public class DynamicProxyDemo { public static void main(String[] args) { UserService userService = new UserServiceImpl(); // 创建代理 UserService proxy = (UserService) Proxy.newProxyInstance( userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), new LoggingHandler(userService) ); // 调用代理方法 proxy.addUser(\\\"John\\\"); String user = proxy.getUser(1); System.out.println(\\\"Result: \\\" + user); } }\"]},\"560\":{\"c\":[\"Java\"]},\"561\":{\"c\":[\"反射\",\"高级特性\"]},\"562\":{\"h\":\"Java基础\"},\"563\":{\"h\":\"一、Java语言特性\"},\"564\":{\"h\":\"1.1 Java的特点\",\"t\":[\"面向对象：具备封装、继承、多态、抽象、反射、泛型等特性\",\"跨平台：一次编译，到处运行，依靠JVM实现\",\"稳健性：强类型语言，异常处理\"]},\"565\":{\"h\":\"1.2 JVM、JDK、JRE\",\"t\":[\"JDK = JRE + Java工具 + 编译器 + 调试器\",\"JRE = JVM + Java核心类库\"]},\"566\":{\"h\":\"1.3 字节码\",\"t\":[\"在Java中，JVM可以理解的代码就叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。\",\"java程序从代码到运行的过程\"]},\"567\":{\"h\":\"二、基本语法\"},\"568\":{\"h\":\"2.1 关键字\",\"t\":[\"分类\",\"关键字\",\"访问控制\",\"private\",\"protected\",\"public\",\"类、方法和变量修饰符\",\"abstract\",\"class\",\"extends\",\"final\",\"new\",\"static\",\"strictfp\",\"synchronized\",\"程序控制\",\"break\",\"continue\",\"return\",\"do\",\"for\",\"instanceof\",\"switch\",\"case\",\"错误处理\",\"try\",\"catch\",\"throw\",\"throws\",\"包相关\",\"import\",\"package\",\"基本类型\",\"boolean\",\"byte\",\"char\",\"double\",\"short\",\"变量引用\",\"super\",\"this\",\"void\",\"保留字\",\"goto\",\"const\"]},\"569\":{\"h\":\"2.2 位移运算符\",\"t\":[\">><< ：带符号右移和左移\",\">>> ：无符号右移，忽略符号位，空位都以0补齐\"]},\"570\":{\"h\":\"2.3 final关键字的作用\",\"t\":[\"final修饰的类不能被继承\",\"final修饰的方法不能被重写\",\"final修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改\"]},\"571\":{\"h\":\"2.4 成员变量与局部变量\",\"t\":[\"语法形式 成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数。成员变量可以被public、private、static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰。\",\"存储方式 从变量在内存中的存储方式来看，如果成员变量是使用static修饰的，那么这个成员变量是属于类的。如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。\",\"生存时间 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。\",\"默认值 从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外：被final修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\"]},\"572\":{\"h\":\"三、方法\"},\"573\":{\"h\":\"3.1 静态方法不能调用非静态成员\",\"t\":[\"静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。\",\"在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。\"]},\"574\":{\"c\":[\"Java\"]},\"575\":{\"c\":[\"基础语法\",\"语言特性\"]},\"576\":{\"h\":\"Filter学习笔记\",\"t\":[\"本文详细介绍了Java Filter过滤器的核心概念、工作原理、生命周期以及常见应用场景，快速掌握Java Web开发中的过滤器技术。\",\"提示\",\"Filter是Java Web开发中的重要组件，它可以对请求和响应进行预处理和后处理，是实现诸如权限验证、日志记录、编码转换等功能的理想选择。\"]},\"577\":{\"h\":\"1. Filter概述\"},\"578\":{\"h\":\"1.1 什么是Filter\",\"t\":[\"Filter（过滤器）是Java Servlet规范中定义的组件，它可以拦截和处理对Web资源（如Servlet、JSP页面或HTML文件）的请求和响应。Filter不是一个标准的Servlet，它不能直接处理用户请求生成响应，但它可以修改请求和响应，或者根据特定条件阻止请求的继续处理。\",\"与Servlet相比，Filter具有以下特点：\",\"拦截能力：可以拦截进入Web应用的请求和离开Web应用的响应\",\"链式处理：多个Filter可以组成一个过滤器链（Filter Chain）\",\"非终端处理：通常不直接生成响应，而是修改或增强请求/响应\",\"可配置性：可以通过注解或XML配置应用于特定的URL模式\"]},\"579\":{\"h\":\"1.2 Filter的作用\",\"t\":[\"Filter在Web应用中主要用于以下场景：\",\"身份验证和授权：验证用户身份，控制资源访问权限\",\"日志记录：记录请求信息，如IP地址、访问时间、请求参数等\",\"数据转换：如请求参数的编码转换、响应内容的压缩等\",\"响应内容修改：添加或修改HTTP头信息，修改响应内容\",\"性能监控：记录请求处理时间，监控应用性能\",\"缓存控制：实现简单的页面缓存机制\",\"会话管理：处理会话相关的操作，如会话验证、会话劫持防护等\"]},\"580\":{\"h\":\"2. Filter快速入门\"},\"581\":{\"h\":\"2.1 环境准备\",\"t\":[\"开发Filter应用需要以下组件：\",\"JDK 8或更高版本\",\"Servlet容器（如Tomcat、Jetty或Undertow）\",\"IDE（如IntelliJ IDEA、Eclipse）\",\"Maven或Gradle（用于依赖管理）\"]},\"582\":{\"h\":\"2.2 创建第一个Filter\"},\"583\":{\"h\":\"2.2.1 添加依赖\",\"t\":[\"在Maven项目的pom.xml中添加Servlet API依赖：\",\"<dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>4.0.1</version> <scope>provided</scope> </dependency>\",\"提示\",\"对于Jakarta EE 9+项目，应使用jakarta.servlet-api依赖。\"]},\"584\":{\"h\":\"2.2.2 创建Filter类\",\"t\":[\"package com.example.filter; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import java.io.IOException; @WebFilter(\\\"/api/*\\\") public class LoggingFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 过滤器初始化时调用 System.out.println(\\\"LoggingFilter 初始化中...\\\"); } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 转换为HTTP请求以获取更多信息 HttpServletRequest httpRequest = (HttpServletRequest) request; // 记录请求信息 String requestURI = httpRequest.getRequestURI(); String method = httpRequest.getMethod(); String remoteAddr = request.getRemoteAddr(); System.out.println(\\\"收到请求: \\\" + method + \\\" \\\" + requestURI + \\\" 来自 \\\" + remoteAddr); // 记录请求处理时间 long startTime = System.currentTimeMillis(); // 继续处理请求（传递给下一个过滤器或目标资源） chain.doFilter(request, response); // 请求处理完成后的操作 long endTime = System.currentTimeMillis(); System.out.println(\\\"请求处理完成，耗时: \\\" + (endTime - startTime) + \\\"ms\\\"); } @Override public void destroy() { // 过滤器销毁时调用 System.out.println(\\\"LoggingFilter 销毁中...\\\"); } }\"]},\"585\":{\"h\":\"2.2.3 urlPattern配置详解\",\"t\":[\"与Servlet类似，Filter也使用urlPattern来定义哪些请求会被过滤。可以通过@WebFilter注解或web.xml配置。\"]},\"586\":{\"h\":\"2.2.3.1 使用@WebFilter注解配置\",\"t\":[\"// 单个URL模式 @WebFilter(\\\"/api/*\\\") // 多个URL模式 @WebFilter(urlPatterns = {\\\"/api/*\\\", \\\"/services/*\\\"}) // 完整配置 @WebFilter( filterName = \\\"loggingFilter\\\", urlPatterns = {\\\"/api/*\\\", \\\"/services/*\\\"}, initParams = { @WebInitParam(name = \\\"logLevel\\\", value = \\\"INFO\\\") } )\"]},\"587\":{\"h\":\"2.2.3.2 URL模式匹配规则\",\"t\":[\"Filter的URL模式匹配规则与Servlet相同，支持以下几种模式：\",\"精确匹配：完全匹配请求路径\",\"@WebFilter(\\\"/login\\\") // 只匹配 /login\",\"路径匹配：以/开头，以/*结尾\",\"@WebFilter(\\\"/admin/*\\\") // 匹配 /admin/开头的所有路径\",\"扩展名匹配：以*.开头\",\"@WebFilter(\\\"*.jsp\\\") // 匹配所有以.jsp结尾的请求\",\"全局过滤器：使用/*\",\"@WebFilter(\\\"/*\\\") // 匹配所有请求\"]},\"588\":{\"h\":\"2.2.4 配置web.xml（可选）\",\"t\":[\"如果使用@WebFilter注解，则不需要在web.xml中配置。但如果需要使用XML配置，可以在WEB-INF/web.xml中添加：\",\"<filter> <filter-name>loggingFilter</filter-name> <filter-class>com.example.filter.LoggingFilter</filter-class> <init-param> <param-name>logLevel</param-name> <param-value>INFO</param-value> </init-param> </filter> <filter-mapping> <filter-name>loggingFilter</filter-name> <url-pattern>/api/*</url-pattern> </filter-mapping>\"]},\"589\":{\"h\":\"3. Filter生命周期\",\"t\":[\"Filter的生命周期由Servlet容器管理，包含三个主要阶段：\"]},\"590\":{\"h\":\"3.1 初始化阶段\",\"t\":[\"当Web应用启动时，Servlet容器会为每个Filter创建一个实例，并调用其init()方法进行初始化。初始化过程中，Filter可以通过FilterConfig获取配置参数。\",\"@Override public void init(FilterConfig filterConfig) throws ServletException { // 获取初始化参数 String logLevel = filterConfig.getInitParameter(\\\"logLevel\\\"); System.out.println(\\\"LoggingFilter 初始化中，日志级别: \\\" + logLevel); // 获取Servlet上下文 ServletContext context = filterConfig.getServletContext(); // 可以在这里进行其他初始化操作 }\"]},\"591\":{\"h\":\"3.2 过滤阶段\",\"t\":[\"当请求到达Web应用并匹配Filter的URL模式时，Servlet容器会调用Filter的doFilter()方法。在这个方法中，Filter可以：\",\"检查请求参数和头信息\",\"修改请求对象（如添加属性）\",\"修改响应对象（如添加头信息）\",\"拦截请求（不调用chain.doFilter()）\",\"在请求处理前后执行操作\",\"@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 请求处理前的操作 System.out.println(\\\"请求处理前...\\\"); // 继续处理请求 chain.doFilter(request, response); // 请求处理后的操作 System.out.println(\\\"请求处理后...\\\"); }\",\"注意\",\"如果不调用chain.doFilter()方法，请求将被拦截，不会传递给下一个Filter或目标资源。这在实现身份验证等功能时非常有用。\"]},\"592\":{\"h\":\"3.3 销毁阶段\",\"t\":[\"当Web应用关闭或重新加载时，Servlet容器会调用Filter的destroy()方法进行清理操作。\",\"@Override public void destroy() { System.out.println(\\\"LoggingFilter 销毁中...\\\"); // 释放资源，关闭连接等 }\"]},\"593\":{\"h\":\"4. Filter链\"},\"594\":{\"h\":\"4.1 Filter链的概念\",\"t\":[\"Filter链是指多个Filter按照特定顺序依次处理请求和响应的机制。当一个请求到达Web应用时，它会依次经过Filter链中的每个Filter，然后到达目标资源（如Servlet）；响应则按照相反的顺序经过这些Filter返回客户端。\",\"Filter链工作原理\"]},\"595\":{\"h\":\"4.2 Filter链的执行顺序\",\"t\":[\"Filter链的执行顺序由以下因素决定：\",\"使用web.xml配置时：按照<filter-mapping>元素在web.xml中的出现顺序\",\"使用@WebFilter注解时： \",\"如果指定了filterName属性，则按照filterName的字母顺序\",\"如果没有指定filterName属性，则按照Filter类名的字母顺序\",\"提示\",\"如果需要精确控制Filter的执行顺序，建议使用web.xml配置而不是注解。\"]},\"596\":{\"h\":\"4.3 Filter链示例\",\"t\":[\"// 第一个Filter @WebFilter(filterName = \\\"authenticationFilter\\\", urlPatterns = \\\"/*\\\") public class AuthenticationFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\\\"AuthenticationFilter: 验证用户身份\\\"); // 验证逻辑... chain.doFilter(request, response); System.out.println(\\\"AuthenticationFilter: 请求处理完成\\\"); } // 其他方法省略... } // 第二个Filter @WebFilter(filterName = \\\"loggingFilter\\\", urlPatterns = \\\"/*\\\") public class LoggingFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\\\"LoggingFilter: 记录请求信息\\\"); chain.doFilter(request, response); System.out.println(\\\"LoggingFilter: 记录响应信息\\\"); } // 其他方法省略... }\",\"执行顺序（按字母顺序）：\",\"AuthenticationFilter（请求阶段）\",\"LoggingFilter（请求阶段）\",\"目标资源（如Servlet）\",\"LoggingFilter（响应阶段）\",\"AuthenticationFilter（响应阶段）\"]},\"597\":{\"h\":\"5. 常见应用场景\"},\"598\":{\"h\":\"5.1 身份验证Filter\",\"t\":[\"@WebFilter(\\\"/*\\\") public class AuthenticationFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse httpResponse = (HttpServletResponse) response; // 获取当前会话 HttpSession session = httpRequest.getSession(false); // 检查用户是否已登录 boolean isLoggedIn = (session != null && session.getAttribute(\\\"user\\\") != null); // 获取请求的URI String requestURI = httpRequest.getRequestURI(); // 允许访问登录页面和静态资源 boolean isLoginPage = requestURI.endsWith(\\\"login.jsp\\\") || requestURI.endsWith(\\\"/login\\\"); boolean isStaticResource = requestURI.endsWith(\\\".css\\\") || requestURI.endsWith(\\\".js\\\") || requestURI.endsWith(\\\".png\\\") || requestURI.endsWith(\\\".jpg\\\"); if (isLoggedIn || isLoginPage || isStaticResource) { // 用户已登录或访问登录页面或静态资源，继续处理 chain.doFilter(request, response); } else { // 用户未登录，重定向到登录页面 httpResponse.sendRedirect(httpRequest.getContextPath() + \\\"/login.jsp\\\"); } } // 其他方法省略... }\"]},\"599\":{\"h\":\"5.2 字符编码Filter\",\"t\":[\"@WebFilter(\\\"/*\\\") public class CharacterEncodingFilter implements Filter { private String encoding = \\\"UTF-8\\\"; @Override public void init(FilterConfig filterConfig) throws ServletException { String encodingParam = filterConfig.getInitParameter(\\\"encoding\\\"); if (encodingParam != null && !encodingParam.isEmpty()) { encoding = encodingParam; } } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 设置请求编码 request.setCharacterEncoding(encoding); // 设置响应编码 response.setCharacterEncoding(encoding); response.setContentType(\\\"text/html;charset=\\\" + encoding); // 继续处理 chain.doFilter(request, response); } // 其他方法省略... }\"]},\"600\":{\"h\":\"5.3 性能监控Filter\",\"t\":[\"@WebFilter(\\\"/*\\\") public class PerformanceMonitorFilter implements Filter { private static final Logger logger = Logger.getLogger(PerformanceMonitorFilter.class.getName()); @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; // 记录开始时间 long startTime = System.currentTimeMillis(); // 记录请求信息 String requestURI = httpRequest.getRequestURI(); String method = httpRequest.getMethod(); try { // 继续处理请求 chain.doFilter(request, response); } finally { // 计算处理时间 long endTime = System.currentTimeMillis(); long processingTime = endTime - startTime; // 记录性能信息 logger.info(String.format(\\\"%s %s - 处理时间: %d ms\\\", method, requestURI, processingTime)); // 如果处理时间超过阈值，记录警告 if (processingTime > 1000) { logger.warning(String.format(\\\"性能警告: %s %s 处理时间超过1秒 (%d ms)\\\", method, requestURI, processingTime)); } } } // 其他方法省略... }\"]},\"601\":{\"h\":\"5.4 CORS Filter\",\"t\":[\"@WebFilter(\\\"/*\\\") public class CORSFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletResponse httpResponse = (HttpServletResponse) response; // 设置CORS头信息 httpResponse.setHeader(\\\"Access-Control-Allow-Origin\\\", \\\"*\\\"); httpResponse.setHeader(\\\"Access-Control-Allow-Methods\\\", \\\"GET, POST, PUT, DELETE, OPTIONS\\\"); httpResponse.setHeader(\\\"Access-Control-Allow-Headers\\\", \\\"Content-Type, Authorization\\\"); httpResponse.setHeader(\\\"Access-Control-Max-Age\\\", \\\"3600\\\"); // 继续处理 chain.doFilter(request, response); } // 其他方法省略... }\"]},\"602\":{\"h\":\"6. 最佳实践\"},\"603\":{\"h\":\"6.1 性能考虑\",\"t\":[\"避免重复操作：如果多个Filter需要执行相同的操作，考虑合并或使用共享组件\",\"减少阻塞操作：在Filter中避免长时间运行的操作，如复杂的数据库查询\",\"使用缓存：对于频繁访问的资源，考虑实现缓存机制\"]},\"604\":{\"h\":\"6.2 安全考虑\",\"t\":[\"输入验证：验证所有用户输入，防止注入攻击\",\"输出编码：对输出内容进行适当编码，防止XSS攻击\",\"敏感信息处理：不要在日志中记录敏感信息，如密码、信用卡号等\"]},\"605\":{\"h\":\"6.3 可维护性考虑\",\"t\":[\"单一职责原则：每个Filter只负责一种功能，避免创建\\\"超级Filter\\\"\",\"配置外部化：使用初始化参数或外部配置文件，避免硬编码\",\"适当的日志记录：记录关键操作和异常情况，便于问题排查\"]},\"606\":{\"h\":\"7. 常见问题与解决方案\"},\"607\":{\"h\":\"7.1 Filter不生效\",\"t\":[\"可能的原因：\",\"URL模式配置错误\",\"Filter类路径错误\",\"web.xml配置错误\",\"解决方案：\",\"检查URL模式是否正确匹配目标请求\",\"确保Filter类在正确的包中\",\"验证web.xml中的配置是否正确\"]},\"608\":{\"h\":\"7.2 Filter执行顺序问题\",\"t\":[\"可能的原因：\",\"多个Filter的执行顺序不符合预期\",\"解决方案：\",\"使用web.xml配置而不是注解，按照所需顺序定义<filter-mapping>\",\"使用注解时，通过命名约定控制顺序（如使用数字前缀：01AuthFilter、02LogFilter）\"]},\"609\":{\"h\":\"7.3 请求参数读取问题\",\"t\":[\"可能的原因：\",\"请求参数被多次读取导致流关闭\",\"解决方案：\",\"使用包装器类（Wrapper）包装请求对象，允许多次读取\",\"在Filter中读取参数后，将其作为请求属性传递给后续组件\"]},\"610\":{\"c\":[\"Java\"]},\"611\":{\"c\":[\"Web开发\",\"Filter\",\"JavaEE\"]},\"612\":{\"h\":\"Listener学习笔记\",\"t\":[\"本文详细介绍了Java Listener监听器的核心概念、工作原理、生命周期以及常见应用场景，快速掌握Java Web开发中的监听器技术。\",\"提示\",\"Listener是Java Web开发中的重要组件，它可以监听Web应用中的各种事件，如应用启动/关闭、会话创建/销毁、属性变更等，是实现诸如资源初始化、统计分析、日志记录等功能的理想选择。\"]},\"613\":{\"h\":\"1. Listener概述\"},\"614\":{\"h\":\"1.1 什么是Listener\",\"t\":[\"Listener（监听器）是Java Servlet规范中定义的组件，它用于监听Web应用中的各种事件，如ServletContext、HttpSession和ServletRequest的创建、销毁和属性变更等。当这些事件发生时，容器会调用相应的Listener进行处理。\",\"与Servlet和Filter相比，Listener具有以下特点：\",\"被动触发：不直接处理请求，而是对特定事件做出响应\",\"观察者模式：基于观察者设计模式实现\",\"生命周期管理：可以监听Web组件的创建和销毁\",\"属性变更监控：可以监听属性的添加、移除和替换\"]},\"615\":{\"h\":\"1.2 Listener的作用\",\"t\":[\"Listener在Web应用中主要用于以下场景：\",\"应用初始化：在应用启动时初始化资源，如数据库连接池、配置信息等\",\"应用清理：在应用关闭时释放资源，如关闭数据库连接、清理临时文件等\",\"会话管理：跟踪在线用户数量，实现单点登录，防止会话固定攻击等\",\"统计分析：收集用户访问数据，分析用户行为模式\",\"事件处理：响应特定事件，如用户登录/注销、购物车更新等\",\"属性监控：监控重要属性的变化，如用户权限变更、系统状态更新等\"]},\"616\":{\"h\":\"2. Listener快速入门\"},\"617\":{\"h\":\"2.1 环境准备\",\"t\":[\"开发Listener应用需要以下组件：\",\"JDK 8或更高版本\",\"Servlet容器（如Tomcat、Jetty或Undertow）\",\"IDE（如IntelliJ IDEA、Eclipse）\",\"Maven或Gradle（用于依赖管理）\"]},\"618\":{\"h\":\"2.2 Listener的分类\",\"t\":[\"Java Servlet规范定义了多种类型的Listener，按照监听对象和事件类型可以分为以下几类：\"]},\"619\":{\"h\":\"2.2.1 ServletContext相关监听器\",\"t\":[\"ServletContextListener：监听ServletContext的创建和销毁\",\"ServletContextAttributeListener：监听ServletContext属性的添加、移除和替换\"]},\"620\":{\"h\":\"2.2.2 HttpSession相关监听器\",\"t\":[\"HttpSessionListener：监听HttpSession的创建和销毁\",\"HttpSessionAttributeListener：监听HttpSession属性的添加、移除和替换\",\"HttpSessionBindingListener：监听对象绑定到HttpSession或从HttpSession解除绑定\",\"HttpSessionActivationListener：监听HttpSession的钝化和活化\"]},\"621\":{\"h\":\"2.2.3 ServletRequest相关监听器\",\"t\":[\"ServletRequestListener：监听ServletRequest的创建和销毁\",\"ServletRequestAttributeListener：监听ServletRequest属性的添加、移除和替换\"]},\"622\":{\"h\":\"2.3 创建第一个Listener\"},\"623\":{\"h\":\"2.3.1 添加依赖\",\"t\":[\"在Maven项目的pom.xml中添加Servlet API依赖：\",\"<dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>4.0.1</version> <scope>provided</scope> </dependency>\",\"提示\",\"对于Jakarta EE 9+项目，应使用jakarta.servlet-api依赖。\"]},\"624\":{\"h\":\"2.3.2 创建ServletContextListener\",\"t\":[\"package com.example.listener; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; @WebListener public class AppInitListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { // 获取ServletContext对象 ServletContext context = sce.getServletContext(); // 应用启动时执行的初始化操作 System.out.println(\\\"Web应用启动中...\\\"); // 初始化应用级别的资源 String dbUrl = context.getInitParameter(\\\"dbUrl\\\"); String dbUser = context.getInitParameter(\\\"dbUser\\\"); // 创建数据库连接池或其他资源 // DatabaseConnectionPool pool = new DatabaseConnectionPool(dbUrl, dbUser); // 将资源存储在ServletContext中，供全局使用 // context.setAttribute(\\\"connectionPool\\\", pool); System.out.println(\\\"应用初始化完成\\\"); } @Override public void contextDestroyed(ServletContextEvent sce) { // 获取ServletContext对象 ServletContext context = sce.getServletContext(); // 应用关闭时执行的清理操作 System.out.println(\\\"Web应用关闭中...\\\"); // 释放资源 // DatabaseConnectionPool pool = (DatabaseConnectionPool) context.getAttribute(\\\"connectionPool\\\"); // if (pool != null) { // pool.close(); // } System.out.println(\\\"应用资源已释放\\\"); } }\"]},\"625\":{\"h\":\"2.3.3 创建HttpSessionListener\",\"t\":[\"package com.example.listener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSession; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; import java.util.concurrent.atomic.AtomicInteger; @WebListener public class SessionCountListener implements HttpSessionListener { // 使用AtomicInteger保证线程安全 private static final AtomicInteger activeSessions = new AtomicInteger(0); @Override public void sessionCreated(HttpSessionEvent se) { // 会话创建时，活跃会话数加1 int currentActiveSessions = activeSessions.incrementAndGet(); // 获取当前会话 HttpSession session = se.getSession(); System.out.println(\\\"会话创建: \\\" + session.getId()); System.out.println(\\\"当前活跃会话数: \\\" + currentActiveSessions); // 可以在这里设置会话属性，如创建时间 session.setAttribute(\\\"creationTime\\\", System.currentTimeMillis()); } @Override public void sessionDestroyed(HttpSessionEvent se) { // 会话销毁时，活跃会话数减1 int currentActiveSessions = activeSessions.decrementAndGet(); // 获取当前会话 HttpSession session = se.getSession(); System.out.println(\\\"会话销毁: \\\" + session.getId()); System.out.println(\\\"当前活跃会话数: \\\" + currentActiveSessions); } // 提供一个静态方法，用于获取当前活跃会话数 public static int getActiveSessionCount() { return activeSessions.get(); } }\"]},\"626\":{\"h\":\"2.3.4 创建ServletRequestListener\",\"t\":[\"package com.example.listener; import javax.servlet.ServletRequest; import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpServletRequest; @WebListener public class RequestLogListener implements ServletRequestListener { @Override public void requestInitialized(ServletRequestEvent sre) { // 获取请求对象 ServletRequest request = sre.getServletRequest(); // 如果是HTTP请求，可以获取更多信息 if (request instanceof HttpServletRequest) { HttpServletRequest httpRequest = (HttpServletRequest) request; // 记录请求信息 String requestURI = httpRequest.getRequestURI(); String method = httpRequest.getMethod(); String remoteAddr = request.getRemoteAddr(); System.out.println(\\\"请求开始: \\\" + method + \\\" \\\" + requestURI + \\\" 来自 \\\" + remoteAddr); // 记录请求开始时间，用于计算请求处理时间 request.setAttribute(\\\"requestStartTime\\\", System.currentTimeMillis()); } } @Override public void requestDestroyed(ServletRequestEvent sre) { // 获取请求对象 ServletRequest request = sre.getServletRequest(); // 如果是HTTP请求，可以获取更多信息 if (request instanceof HttpServletRequest) { HttpServletRequest httpRequest = (HttpServletRequest) request; // 获取请求开始时间 Long startTime = (Long) request.getAttribute(\\\"requestStartTime\\\"); if (startTime != null) { // 计算请求处理时间 long endTime = System.currentTimeMillis(); long processingTime = endTime - startTime; String requestURI = httpRequest.getRequestURI(); System.out.println(\\\"请求结束: \\\" + requestURI + \\\" 处理时间: \\\" + processingTime + \\\"ms\\\"); } } } }\"]},\"627\":{\"h\":\"2.3.5 配置web.xml（可选）\",\"t\":[\"如果使用@WebListener注解，则不需要在web.xml中配置。但如果需要使用XML配置，可以在WEB-INF/web.xml中添加：\",\"<listener> <listener-class>com.example.listener.AppInitListener</listener-class> </listener> <listener> <listener-class>com.example.listener.SessionCountListener</listener-class> </listener> <listener> <listener-class>com.example.listener.RequestLogListener</listener-class> </listener>\"]},\"628\":{\"h\":\"3. Listener生命周期\"},\"629\":{\"h\":\"3.1 ServletContextListener生命周期\",\"t\":[\"ServletContextListener的生命周期与Web应用的生命周期紧密相关：\",\"初始化阶段：当Web应用启动时，Servlet容器会创建ServletContext，然后调用所有ServletContextListener的contextInitialized()方法。这个阶段通常用于初始化应用级别的资源。\",\"销毁阶段：当Web应用关闭时，Servlet容器会调用所有ServletContextListener的contextDestroyed()方法，然后销毁ServletContext。这个阶段通常用于释放应用级别的资源。\"]},\"630\":{\"h\":\"3.2 HttpSessionListener生命周期\",\"t\":[\"HttpSessionListener的生命周期与HttpSession的生命周期相关：\",\"创建阶段：当用户首次访问Web应用并且需要创建会话时，Servlet容器会创建HttpSession，然后调用所有HttpSessionListener的sessionCreated()方法。\",\"销毁阶段：当会话超时或被显式销毁时，Servlet容器会调用所有HttpSessionListener的sessionDestroyed()方法，然后销毁HttpSession。\"]},\"631\":{\"h\":\"3.3 ServletRequestListener生命周期\",\"t\":[\"ServletRequestListener的生命周期与ServletRequest的生命周期相关：\",\"初始化阶段：当请求到达Web应用时，Servlet容器会创建ServletRequest，然后调用所有ServletRequestListener的requestInitialized()方法。\",\"销毁阶段：当请求处理完成时，Servlet容器会调用所有ServletRequestListener的requestDestroyed()方法，然后销毁ServletRequest。\"]},\"632\":{\"h\":\"4. 属性监听器\"},\"633\":{\"h\":\"4.1 ServletContextAttributeListener\",\"t\":[\"package com.example.listener; import javax.servlet.ServletContextAttributeEvent; import javax.servlet.ServletContextAttributeListener; import javax.servlet.annotation.WebListener; @WebListener public class ContextAttributeListener implements ServletContextAttributeListener { @Override public void attributeAdded(ServletContextAttributeEvent event) { String name = event.getName(); Object value = event.getValue(); System.out.println(\\\"ServletContext属性添加: \\\" + name + \\\" = \\\" + value); } @Override public void attributeRemoved(ServletContextAttributeEvent event) { String name = event.getName(); Object value = event.getValue(); System.out.println(\\\"ServletContext属性移除: \\\" + name + \\\" = \\\" + value); } @Override public void attributeReplaced(ServletContextAttributeEvent event) { String name = event.getName(); Object value = event.getValue(); // 获取的是旧值 Object newValue = event.getServletContext().getAttribute(name); // 获取新值 System.out.println(\\\"ServletContext属性替换: \\\" + name + \\\" 旧值 = \\\" + value + \\\", 新值 = \\\" + newValue); } }\"]},\"634\":{\"h\":\"4.2 HttpSessionAttributeListener\",\"t\":[\"package com.example.listener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionBindingEvent; @WebListener public class SessionAttributeListener implements HttpSessionAttributeListener { @Override public void attributeAdded(HttpSessionBindingEvent event) { String name = event.getName(); Object value = event.getValue(); String sessionId = event.getSession().getId(); System.out.println(\\\"会话[\\\" + sessionId + \\\"]属性添加: \\\" + name + \\\" = \\\" + value); } @Override public void attributeRemoved(HttpSessionBindingEvent event) { String name = event.getName(); Object value = event.getValue(); String sessionId = event.getSession().getId(); System.out.println(\\\"会话[\\\" + sessionId + \\\"]属性移除: \\\" + name + \\\" = \\\" + value); } @Override public void attributeReplaced(HttpSessionBindingEvent event) { String name = event.getName(); Object value = event.getValue(); // 获取的是旧值 Object newValue = event.getSession().getAttribute(name); // 获取新值 String sessionId = event.getSession().getId(); System.out.println(\\\"会话[\\\" + sessionId + \\\"]属性替换: \\\" + name + \\\" 旧值 = \\\" + value + \\\", 新值 = \\\" + newValue); } }\"]},\"635\":{\"h\":\"4.3 ServletRequestAttributeListener\",\"t\":[\"package com.example.listener; import javax.servlet.ServletRequestAttributeEvent; import javax.servlet.ServletRequestAttributeListener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpServletRequest; @WebListener public class RequestAttributeListener implements ServletRequestAttributeListener { @Override public void attributeAdded(ServletRequestAttributeEvent event) { String name = event.getName(); Object value = event.getValue(); // 如果是HTTP请求，可以获取更多信息 if (event.getServletRequest() instanceof HttpServletRequest) { HttpServletRequest request = (HttpServletRequest) event.getServletRequest(); String requestURI = request.getRequestURI(); System.out.println(\\\"请求[\\\" + requestURI + \\\"]属性添加: \\\" + name + \\\" = \\\" + value); } else { System.out.println(\\\"请求属性添加: \\\" + name + \\\" = \\\" + value); } } @Override public void attributeRemoved(ServletRequestAttributeEvent event) { String name = event.getName(); Object value = event.getValue(); // 如果是HTTP请求，可以获取更多信息 if (event.getServletRequest() instanceof HttpServletRequest) { HttpServletRequest request = (HttpServletRequest) event.getServletRequest(); String requestURI = request.getRequestURI(); System.out.println(\\\"请求[\\\" + requestURI + \\\"]属性移除: \\\" + name + \\\" = \\\" + value); } else { System.out.println(\\\"请求属性移除: \\\" + name + \\\" = \\\" + value); } } @Override public void attributeReplaced(ServletRequestAttributeEvent event) { String name = event.getName(); Object value = event.getValue(); // 获取的是旧值 Object newValue = event.getServletRequest().getAttribute(name); // 获取新值 // 如果是HTTP请求，可以获取更多信息 if (event.getServletRequest() instanceof HttpServletRequest) { HttpServletRequest request = (HttpServletRequest) event.getServletRequest(); String requestURI = request.getRequestURI(); System.out.println(\\\"请求[\\\" + requestURI + \\\"]属性替换: \\\" + name + \\\" 旧值 = \\\" + value + \\\", 新值 = \\\" + newValue); } else { System.out.println(\\\"请求属性替换: \\\" + name + \\\" 旧值 = \\\" + value + \\\", 新值 = \\\" + newValue); } } }\"]},\"636\":{\"h\":\"5. 特殊监听器\"},\"637\":{\"h\":\"5.1 HttpSessionBindingListener\",\"t\":[\"HttpSessionBindingListener不需要在web.xml中配置，也不需要使用@WebListener注解。它是由实现该接口的对象自身负责监听其绑定到会话或从会话解除绑定的事件。\",\"package com.example.listener; import javax.servlet.http.HttpSessionBindingEvent; import javax.servlet.http.HttpSessionBindingListener; import java.io.Serializable; public class User implements HttpSessionBindingListener, Serializable { private static final long serialVersionUID = 1L; private String username; private String email; public User(String username, String email) { this.username = username; this.email = email; } // Getters and setters... @Override public void valueBound(HttpSessionBindingEvent event) { String attributeName = event.getName(); String sessionId = event.getSession().getId(); System.out.println(\\\"用户[\\\" + username + \\\"]对象被绑定到会话[\\\" + sessionId + \\\"]的属性[\\\" + attributeName + \\\"]\\\"); } @Override public void valueUnbound(HttpSessionBindingEvent event) { String attributeName = event.getName(); String sessionId = event.getSession().getId(); System.out.println(\\\"用户[\\\" + username + \\\"]对象从会话[\\\" + sessionId + \\\"]的属性[\\\" + attributeName + \\\"]解除绑定\\\"); } }\",\"使用示例：\",\"// 在Servlet中 User user = new User(\\\"john\\\", \\\"john@example.com\\\"); session.setAttribute(\\\"currentUser\\\", user); // 触发valueBound方法 // 稍后 session.removeAttribute(\\\"currentUser\\\"); // 触发valueUnbound方法 // 或者会话超时/失效时也会触发valueUnbound方法\"]},\"638\":{\"h\":\"5.2 HttpSessionActivationListener\",\"t\":[\"HttpSessionActivationListener用于监听会话的钝化（序列化到磁盘）和活化（从磁盘反序列化）事件。在分布式环境或内存不足时，容器可能会将不活跃的会话序列化到磁盘以释放内存。\",\"package com.example.listener; import javax.servlet.http.HttpSessionActivationListener; import javax.servlet.http.HttpSessionEvent; import java.io.Serializable; public class ShoppingCart implements HttpSessionActivationListener, Serializable { private static final long serialVersionUID = 1L; private List<Product> items = new ArrayList<>(); private double total = 0.0; // 添加商品、计算总价等方法... @Override public void sessionWillPassivate(HttpSessionEvent se) { String sessionId = se.getSession().getId(); System.out.println(\\\"购物车对象即将随会话[\\\" + sessionId + \\\"]钝化到磁盘\\\"); // 可以在这里进行一些清理工作，如关闭资源等 } @Override public void sessionDidActivate(HttpSessionEvent se) { String sessionId = se.getSession().getId(); System.out.println(\\\"购物车对象随会话[\\\" + sessionId + \\\"]从磁盘活化\\\"); // 可以在这里进行一些初始化工作，如重新建立连接等 } }\",\"使用示例：\",\"// 在Servlet中 ShoppingCart cart = new ShoppingCart(); cart.addItem(new Product(\\\"手机\\\", 3999.0)); session.setAttribute(\\\"cart\\\", cart); // 当会话钝化时，sessionWillPassivate方法会被调用 // 当会话活化时，sessionDidActivate方法会被调用\"]},\"639\":{\"h\":\"6. 常见应用场景\"},\"640\":{\"h\":\"6.1 应用初始化和资源管理\",\"t\":[\"@WebListener public class ApplicationResourceManager implements ServletContextListener { private DataSource dataSource; @Override public void contextInitialized(ServletContextEvent sce) { ServletContext context = sce.getServletContext(); // 读取配置参数 String dbUrl = context.getInitParameter(\\\"dbUrl\\\"); String dbUser = context.getInitParameter(\\\"dbUser\\\"); String dbPassword = context.getInitParameter(\\\"dbPassword\\\"); try { // 初始化数据库连接池 ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(\\\"com.mysql.cj.jdbc.Driver\\\"); cpds.setJdbcUrl(dbUrl); cpds.setUser(dbUser); cpds.setPassword(dbPassword); // 配置连接池参数 cpds.setMinPoolSize(5); cpds.setMaxPoolSize(50); dataSource = cpds; // 将数据源存储在ServletContext中 context.setAttribute(\\\"dataSource\\\", dataSource); System.out.println(\\\"数据库连接池初始化成功\\\"); // 加载其他应用资源... } catch (Exception e) { System.err.println(\\\"初始化数据库连接池失败: \\\" + e.getMessage()); e.printStackTrace(); } } @Override public void contextDestroyed(ServletContextEvent sce) { // 关闭数据库连接池 if (dataSource instanceof ComboPooledDataSource) { ComboPooledDataSource cpds = (ComboPooledDataSource) dataSource; cpds.close(); System.out.println(\\\"数据库连接池已关闭\\\"); } // 释放其他资源... } }\"]},\"641\":{\"h\":\"6.2 在线用户统计\",\"t\":[\"@WebListener public class OnlineUserManager implements HttpSessionListener, HttpSessionAttributeListener { private static final Set<String> onlineUsers = Collections.synchronizedSet(new HashSet<>()); @Override public void sessionCreated(HttpSessionEvent se) { // 会话创建时不做处理，等用户登录后再添加到在线用户列表 } @Override public void sessionDestroyed(HttpSessionEvent se) { HttpSession session = se.getSession(); String username = (String) session.getAttribute(\\\"username\\\"); // 如果用户已登录，从在线用户列表中移除 if (username != null) { onlineUsers.remove(username); System.out.println(\\\"用户[\\\" + username + \\\"]已离线，当前在线用户数: \\\" + onlineUsers.size()); } } @Override public void attributeAdded(HttpSessionBindingEvent event) { // 当用户登录成功时，会在会话中添加username属性 if (\\\"username\\\".equals(event.getName())) { String username = (String) event.getValue(); onlineUsers.add(username); System.out.println(\\\"用户[\\\" + username + \\\"]已上线，当前在线用户数: \\\" + onlineUsers.size()); } } @Override public void attributeRemoved(HttpSessionBindingEvent event) { // 当用户注销时，会从会话中移除username属性 if (\\\"username\\\".equals(event.getName())) { String username = (String) event.getValue(); onlineUsers.remove(username); System.out.println(\\\"用户[\\\" + username + \\\"]已离线，当前在线用户数: \\\" + onlineUsers.size()); } } @Override public void attributeReplaced(HttpSessionBindingEvent event) { // 处理用户切换账号的情况 if (\\\"username\\\".equals(event.getName())) { String oldUsername = (String) event.getValue(); String newUsername = (String) event.getSession().getAttribute(\\\"username\\\"); onlineUsers.remove(oldUsername); onlineUsers.add(newUsername); System.out.println(\\\"用户从[\\\" + oldUsername + \\\"]切换到[\\\" + newUsername + \\\"]，当前在线用户数: \\\" + onlineUsers.size()); } } // 提供一个静态方法，用于获取当前在线用户列表 public static Set<String> getOnlineUsers() { return Collections.unmodifiableSet(onlineUsers); } // 提供一个静态方法，用于获取当前在线用户数 public static int getOnlineUserCount() { return onlineUsers.size();\"]},\"642\":{\"c\":[\"Java\"]},\"643\":{\"c\":[\"Web开发\",\"Listener\",\"JavaEE\"]},\"644\":{\"h\":\"Servlet学习笔记\",\"t\":[\"本文详细介绍了Java Servlet技术的核心概念、开发流程、生命周期以及常见问题，快速掌握Java Web开发的基础。\",\"提示\",\"Servlet是Java Web开发的基础，掌握Servlet的核心概念和使用方法对于理解其他Java Web框架（如Spring MVC）非常重要。\",\"随着技术的发展，Java Web开发通常使用更高级的框架，但Servlet作为底层技术，仍然是这些框架的基础。\",\"理解Servlet有助于更深入地理解这些框架的工作原理。\"]},\"645\":{\"h\":\"1. Servlet概述\"},\"646\":{\"h\":\"1.1 什么是Servlet\",\"t\":[\"Servlet（Server Applet）是运行在Web服务器上的Java程序，它是Java Web应用的核心组件，主要用于处理客户端的HTTP请求并生成响应。Servlet充当Web浏览器或其他HTTP客户端与后端数据库或应用程序之间的中间层。\",\"与传统的CGI（Common Gateway Interface）相比，Servlet具有以下优势：\",\"性能更高：Servlet在Web服务器的地址空间内执行，无需创建新进程\",\"平台无关性：基于Java，可在任何支持Java的平台上运行\",\"安全性：继承了Java语言的安全特性\",\"可扩展性：可以访问Java API的完整功能集\"]},\"647\":{\"h\":\"1.2 Servlet的作用\",\"t\":[\"Servlet在Web应用中主要承担以下职责：\",\"接收和处理来自客户端的请求\",\"访问后端资源（如数据库）\",\"生成动态内容\",\"将响应发送回客户端\",\"维护会话和状态管理\"]},\"648\":{\"h\":\"2. Servlet快速入门\"},\"649\":{\"h\":\"2.1 环境准备\",\"t\":[\"开发Servlet应用需要以下组件：\",\"JDK 8或更高版本\",\"Servlet容器（如Tomcat、Jetty或Undertow）\",\"IDE（如IntelliJ IDEA、Eclipse）\",\"Maven或Gradle（用于依赖管理）\"]},\"650\":{\"h\":\"2.2 创建第一个Servlet\"},\"651\":{\"h\":\"2.2.1 添加依赖\",\"t\":[\"在Maven项目的pom.xml中添加Servlet API依赖：\",\"<dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>4.0.1</version> <scope>provided</scope> </dependency>\",\"提示\",\"对于Jakarta EE 9+项目，应使用jakarta.servlet-api依赖。\"]},\"652\":{\"h\":\"2.2.2 创建Servlet类\",\"t\":[\"package com.example.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(\\\"/hello\\\") public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 设置响应内容类型 response.setContentType(\\\"text/html;charset=UTF-8\\\"); // 获取输出流 PrintWriter out = response.getWriter(); // 输出HTML内容 out.println(\\\"<!DOCTYPE html>\\\"); out.println(\\\"<html>\\\"); out.println(\\\"<head>\\\"); out.println(\\\"<title>Hello Servlet</title>\\\"); out.println(\\\"</head>\\\"); out.println(\\\"<body>\\\"); out.println(\\\"<h1>Hello, Servlet World!</h1>\\\"); out.println(\\\"<p>当前时间: \\\" + new java.util.Date() + \\\"</p>\\\"); out.println(\\\"</body>\\\"); out.println(\\\"</html>\\\"); } }\"]},\"653\":{\"h\":\"2.2.3 urlPattern配置详解\",\"t\":[\"urlPattern是Servlet映射的核心配置，它定义了哪些URL请求会被特定的Servlet处理。无论是使用注解还是XML配置，都需要理解urlPattern的配置规则。\"]},\"654\":{\"h\":\"2.2.3.1 使用@WebServlet注解配置\",\"t\":[\"@WebServlet注解提供了多种配置urlPattern的方式：\",\"// 单个URL模式 @WebServlet(\\\"/hello\\\") // 多个URL模式 @WebServlet(urlPatterns = {\\\"/hello\\\", \\\"/greeting\\\"}) // 完整配置 @WebServlet( name = \\\"helloServlet\\\", urlPatterns = {\\\"/hello\\\", \\\"/greeting\\\"}, loadOnStartup = 1 )\"]},\"655\":{\"h\":\"2.2.3.2 URL模式匹配规则\",\"t\":[\"Servlet支持以下几种URL模式匹配规则：\",\"精确匹配：完全匹配请求路径\",\"@WebServlet(\\\"/hello\\\") // 只匹配 /hello\",\"路径匹配：以/开头，以/*结尾\",\"@WebServlet(\\\"/user/*\\\") // 匹配 /user/开头的所有路径，如 /user/list, /user/add\",\"扩展名匹配：以*.开头\",\"@WebServlet(\\\"*.do\\\") // 匹配所有以.do结尾的请求，如 /user.do, /product.do\",\"默认Servlet：仅使用/\",\"@WebServlet(\\\"/\\\") // 匹配所有未被其他Servlet匹配的请求\"]},\"656\":{\"h\":\"2.2.3.3 匹配优先级\",\"t\":[\"当一个请求可能匹配多个Servlet时，容器会按照以下优先级选择：\",\"精确匹配（如/hello）\",\"路径匹配（如/user/*）\",\"扩展名匹配（如*.do）\",\"默认Servlet（/）\",\"示例\",\"对于请求/user/profile.jsp：\",\"如果有/user/profile.jsp的精确匹配，则使用它\",\"否则，如果有/user/*的路径匹配，则使用它\",\"否则，如果有*.jsp的扩展名匹配，则使用它\",\"否则，使用默认Servlet（/）\"]},\"657\":{\"h\":\"2.2.3.4 注意事项\",\"t\":[\"URL模式必须以/或*.开头\",\"路径匹配中的/*只能出现在末尾\",\"不同的Servlet不应配置相同的URL模式\",\"在大型应用中，建议使用有意义的URL模式，便于维护\"]},\"658\":{\"h\":\"2.2.4 配置web.xml（可选）\",\"t\":[\"如果使用@WebServlet注解，则不需要在web.xml中配置。但如果需要使用XML配置，可以在WEB-INF/web.xml中添加：\",\"<web-app xmlns=\\\"http://xmlns.jcp.org/xml/ns/javaee\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\\\" version=\\\"4.0\\\"> <servlet> <servlet-name>helloServlet</servlet-name> <servlet-class>com.example.servlet.HelloServlet</servlet-class> </servlet> <servlet-mapping> <servlet-name>helloServlet</servlet-name> <url-pattern>/hello</url-pattern> </servlet-mapping> </web-app>\"]},\"659\":{\"h\":\"2.3 部署和访问\",\"t\":[\"将应用打包为WAR文件\",\"部署到Servlet容器（如Tomcat）\",\"启动容器\",\"访问URL：http://localhost:8080/your-app/hello\"]},\"660\":{\"h\":\"3. Servlet执行流程与生命周期\"},\"661\":{\"h\":\"3.1 执行流程\",\"t\":[\"Servlet的执行流程如下：\",\"客户端（浏览器）发送HTTP请求到Web服务器\",\"Web服务器接收请求并将其转发给Servlet容器\",\"Servlet容器根据URL找到对应的Servlet\",\"如果Servlet尚未加载，容器会： \",\"加载Servlet类\",\"创建Servlet实例\",\"调用init()方法初始化Servlet\",\"容器创建请求和响应对象\",\"容器调用Servlet的service()方法，根据请求类型调用doGet()、doPost()等方法\",\"Servlet处理请求并生成响应\",\"容器将响应发送回客户端\"]},\"662\":{\"h\":\"3.2 生命周期\",\"t\":[\"Servlet的生命周期包含以下阶段：\",\"加载和实例化：容器加载Servlet类并创建实例\",\"初始化：容器调用init()方法，只执行一次\",\"请求处理：容器调用service()方法处理客户端请求，可多次执行\",\"销毁：容器调用destroy()方法，只执行一次\",\"public class LifecycleServlet extends HttpServlet { @Override public void init(ServletConfig config) throws ServletException { super.init(config); System.out.println(\\\"Servlet初始化中...\\\"); // 执行初始化操作，如建立数据库连接 } @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\\\"Servlet处理请求中...\\\"); super.service(req, resp); // 调用doGet或doPost等方法 } @Override public void destroy() { System.out.println(\\\"Servlet销毁中...\\\"); // 执行清理操作，如关闭数据库连接 super.destroy(); } }\",\"注意\",\"Servlet实例在容器中通常是单例的，因此需要注意线程安全问题。避免在Servlet中使用实例变量存储请求特定的数据。\"]},\"663\":{\"h\":\"4. Servlet方法介绍与体系结构\"},\"664\":{\"h\":\"4.1 Servlet接口\",\"t\":[\"Servlet接口是所有Servlet必须直接或间接实现的接口，定义了以下核心方法：\",\"init(ServletConfig config)：初始化Servlet\",\"service(ServletRequest req, ServletResponse res)：处理客户端请求\",\"destroy()：销毁Servlet\",\"getServletConfig()：返回ServletConfig对象\",\"getServletInfo()：返回Servlet信息\"]},\"665\":{\"h\":\"4.2 GenericServlet抽象类\",\"t\":[\"GenericServlet是一个抽象类，实现了Servlet接口，提供了基本实现，但仍然是协议无关的。它简化了Servlet的开发，开发者只需要重写service()方法。\"]},\"666\":{\"h\":\"4.3 HttpServlet抽象类\",\"t\":[\"HttpServlet扩展了GenericServlet，专门用于处理HTTP请求。它重写了service()方法，根据HTTP请求类型调用以下方法：\",\"doGet()：处理GET请求\",\"doPost()：处理POST请求\",\"doPut()：处理PUT请求\",\"doDelete()：处理DELETE请求\",\"doHead()：处理HEAD请求\",\"doOptions()：处理OPTIONS请求\",\"doTrace()：处理TRACE请求\",\"在实际开发中，通常只需要继承HttpServlet并重写需要的方法。\"]},\"667\":{\"h\":\"4.4 Servlet体系结构\",\"t\":[\"Servlet接口 | +-- GenericServlet抽象类 | +-- HttpServlet抽象类 | +-- 自定义Servlet类\"]},\"668\":{\"h\":\"5. 请求和响应对象\"},\"669\":{\"h\":\"5.1 HttpServletRequest\",\"t\":[\"HttpServletRequest接口表示客户端的HTTP请求，提供了访问请求信息的方法：\"]},\"670\":{\"h\":\"5.1.1 获取请求参数\",\"t\":[\"// 获取单个参数值 String username = request.getParameter(\\\"username\\\"); // 获取同名参数的多个值（如复选框） String[] hobbies = request.getParameterValues(\\\"hobby\\\"); // 获取所有参数名 Enumeration<String> paramNames = request.getParameterNames(); // 获取参数Map Map<String, String[]> paramMap = request.getParameterMap();\"]},\"671\":{\"h\":\"5.1.2 获取请求头\",\"t\":[\"// 获取单个请求头 String userAgent = request.getHeader(\\\"User-Agent\\\"); // 获取所有请求头名称 Enumeration<String> headerNames = request.getHeaderNames();\"]},\"672\":{\"h\":\"5.1.3 获取请求路径\",\"t\":[\"// 获取请求URL StringBuffer url = request.getRequestURL(); // 获取请求URI（不包含域名） String uri = request.getRequestURI(); // 获取上下文路径 String contextPath = request.getContextPath(); // 获取Servlet路径 String servletPath = request.getServletPath();\"]},\"673\":{\"h\":\"5.1.4 获取会话和Cookie\",\"t\":[\"// 获取会话 HttpSession session = request.getSession(); // 获取所有Cookie Cookie[] cookies = request.getCookies();\"]},\"674\":{\"h\":\"5.2 HttpServletResponse\",\"t\":[\"HttpServletResponse接口表示服务器的HTTP响应，提供了设置响应信息的方法：\"]},\"675\":{\"h\":\"5.2.1 设置响应头\",\"t\":[\"// 设置内容类型 response.setContentType(\\\"text/html;charset=UTF-8\\\"); // 设置响应头 response.setHeader(\\\"Cache-Control\\\", \\\"no-cache\\\");\"]},\"676\":{\"h\":\"5.2.2 设置响应状态\",\"t\":[\"// 设置状态码 response.setStatus(HttpServletResponse.SC_OK); // 200 // 发送错误状态 response.sendError(HttpServletResponse.SC_NOT_FOUND, \\\"资源不存在\\\"); // 404\"]},\"677\":{\"h\":\"5.2.3 输出响应内容\",\"t\":[\"// 获取字符输出流 PrintWriter writer = response.getWriter(); writer.println(\\\"Hello, World!\\\"); // 获取二进制输出流（用于输出图片等二进制数据） ServletOutputStream outputStream = response.getOutputStream();\"]},\"678\":{\"h\":\"5.2.4 重定向\",\"t\":[\"// 重定向到另一个URL response.sendRedirect(\\\"/another-page\\\");\"]},\"679\":{\"h\":\"6. Servlet高级特性\"},\"680\":{\"h\":\"6.1 请求转发与重定向\"},\"681\":{\"h\":\"6.1.1 请求转发\",\"t\":[\"请求转发是服务器内部的跳转，客户端感知不到：\",\"// 获取RequestDispatcher RequestDispatcher dispatcher = request.getRequestDispatcher(\\\"/target-servlet\\\"); // 转发请求 dispatcher.forward(request, response); // 包含其他资源的输出 // dispatcher.include(request, response);\"]},\"682\":{\"h\":\"6.1.2 重定向\",\"t\":[\"重定向是客户端的跳转，会改变浏览器地址栏：\",\"response.sendRedirect(\\\"/target-servlet\\\");\",\"转发与重定向的区别：\",\"特性\",\"转发\",\"重定向\",\"URL变化\",\"不变\",\"变化\",\"请求次数\",\"1次\",\"2次\",\"数据共享\",\"可共享request域\",\"不可共享\",\"跳转限制\",\"只能在同一应用内\",\"可跳转到任意URL\"]},\"683\":{\"h\":\"6.2 过滤器（Filter）\",\"t\":[\"过滤器用于拦截请求和响应，可以在Servlet处理前后执行操作：\",\"@WebFilter(\\\"/*\\\") public class LogFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化操作 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 请求处理前的操作 System.out.println(\\\"请求处理前...\\\"); // 传递给下一个过滤器或Servlet chain.doFilter(request, response); // 响应处理后的操作 System.out.println(\\\"响应处理后...\\\"); } @Override public void destroy() { // 清理操作 } }\"]},\"684\":{\"h\":\"6.3 监听器（Listener）\",\"t\":[\"监听器用于监听Servlet上下文、会话和请求的事件：\",\"@WebListener public class AppContextListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\\\"应用启动...\\\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\\\"应用关闭...\\\"); } }\"]},\"685\":{\"h\":\"7. 常见问题与解决方案\"},\"686\":{\"h\":\"7.1 中文乱码问题\"},\"687\":{\"h\":\"7.1.1 请求乱码\",\"t\":[\"// GET请求参数乱码（Tomcat 8.0以下） String name = new String(request.getParameter(\\\"name\\\").getBytes(\\\"ISO-8859-1\\\"), \\\"UTF-8\\\"); // POST请求参数乱码 request.setCharacterEncoding(\\\"UTF-8\\\");\"]},\"688\":{\"h\":\"7.1.2 响应乱码\",\"t\":[\"// 设置响应编码 response.setCharacterEncoding(\\\"UTF-8\\\"); response.setContentType(\\\"text/html;charset=UTF-8\\\");\"]},\"689\":{\"h\":\"7.2 线程安全问题\",\"t\":[\"Servlet是单例多线程的，需要注意线程安全：\",\"注意\",\"避免在Servlet中使用实例变量存储请求特定的数据。如果必须使用，确保进行适当的同步处理。\",\"// 错误示例 public class UnsafeServlet extends HttpServlet { private String sharedState; // 实例变量，多线程共享 protected void doGet(HttpServletRequest request, HttpServletResponse response) { sharedState = request.getParameter(\\\"state\\\"); // 线程不安全 // 处理逻辑... } } // 正确示例 public class SafeServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) { String localState = request.getParameter(\\\"state\\\"); // 局部变量，线程安全 // 处理逻辑... } }\"]},\"690\":{\"h\":\"7.3 会话管理问题\"},\"691\":{\"h\":\"7.3.1 会话超时\",\"t\":[\"// 设置会话超时时间（秒） request.getSession().setMaxInactiveInterval(1800); // 30分钟 // 在web.xml中设置全局会话超时 <session-config> <session-timeout>30</session-timeout> <!-- 分钟 --> </session-config>\"]},\"692\":{\"h\":\"7.3.2 会话安全\",\"t\":[\"// 防止会话固定攻击 request.getSession().invalidate(); // 使当前会话失效 HttpSession newSession = request.getSession(true); // 创建新会话 // 设置Cookie为HttpOnly和Secure response.setHeader(\\\"Set-Cookie\\\", \\\"JSESSIONID=\\\" + request.getSession().getId() + \\\"; HttpOnly; Secure\\\");\"]},\"693\":{\"h\":\"7.4 文件上传问题\",\"t\":[\"使用Apache Commons FileUpload或Servlet 3.0+的文件上传功能：\",\"@WebServlet(\\\"/upload\\\") @MultipartConfig(fileSizeThreshold = 1024 * 1024, // 1 MB maxFileSize = 1024 * 1024 * 10, // 10 MB maxRequestSize = 1024 * 1024 * 50) // 50 MB public class FileUploadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 获取上传的文件部分 Part filePart = request.getPart(\\\"file\\\"); String fileName = getFileName(filePart); // 保存文件 filePart.write(\\\"C:/uploads/\\\" + fileName); response.getWriter().println(\\\"文件上传成功\\\"); } private String getFileName(Part part) { String contentDisp = part.getHeader(\\\"content-disposition\\\"); String[] items = contentDisp.split(\\\";\\\"); for (String item : items) { if (item.trim().startsWith(\\\"filename\\\")) { return item.substring(item.indexOf(\\\"=\\\") + 2, item.length() - 1); } } return \\\"\\\"; } }\"]},\"694\":{\"c\":[\"Java\"]},\"695\":{\"c\":[\"Web开发\",\"Servlet\",\"JavaEE\"]},\"696\":{\"h\":\"Spring框架\"},\"697\":{\"h\":\"简介\",\"t\":[\"Spring是Java平台的一个开源应用框架，提供了一个简易的开发方式，通过依赖注入和面向切面编程。\"]},\"698\":{\"h\":\"核心特性\",\"t\":[\"依赖注入（DI）\",\"面向切面编程（AOP）\",\"事务管理\",\"MVC框架\",\"安全框架\"]},\"699\":{\"h\":\"依赖注入示例\",\"t\":[\"// 定义接口 public interface MessageService { String getMessage(); } // 实现类 public class MessageServiceImpl implements MessageService { public String getMessage() { return \\\"Hello, Spring!\\\"; } } // 使用依赖注入 public class MessagePrinter { private MessageService service; // 构造函数注入 public MessagePrinter(MessageService service) { this.service = service; } public void printMessage() { System.out.println(service.getMessage()); } }\"]},\"700\":{\"h\":\"Spring Boot\",\"t\":[\"Spring Boot是Spring框架的扩展，简化了Spring应用的初始搭建和开发过程。它采用了特定的方式来进行配置，使开发人员不再需要定义样板化的配置。\",\"@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }\"]},\"701\":{\"c\":[\"Java\",\"框架\"]},\"702\":{\"c\":[\"Spring\",\"依赖注入\",\"AOP\"]},\"703\":{\"h\":\"Kafka 实践应用经验\",\"t\":[\"本文总结了Kafka在实际应用中的关键问题及解决方案，包括消息语义、消息可靠性、消息顺序性等重要主题。\"]},\"704\":{\"h\":\"一、消费消息的语义\"},\"705\":{\"h\":\"1. 常见的消费语义\",\"t\":[\"对于消息一般有如下几种消费模式：\",\"At most once 最多一次： 消息可能会丢失，但是绝对不会重复发送。适合对消息传递可靠性不高的场景，如日志记录。\",\"At least once 至少一次： 消息不会丢失，但是可能被重复发送处理，适合对消息传递可靠性有要求，但是能容忍消息重复的场景，如事件通知。\",\"Exactly once 精确一次： 消息不会丢失，也不会被重复发送，其适用于关键业务场景，需要严格保证消息处理一次且仅一次，如金融交易处理。\",\"对于不同的业务需求，选择的消费语义不同。\"]},\"706\":{\"h\":\"2. 实现 精确一次 的困难\",\"t\":[\"消息队列组件一般实现的都是至少一次语义，也就是至少能消费一次。\",\"只要消息进入了 Kafka，是很容易实现至少一次语义的，但是需要考虑消息重复发送的可能性。\",\"但在 kafka 中进一步实现精确一次消费是非常困难的，因为后端的任何一个环节都要考虑故障情况：\",\"网络问题：网络延迟、中断....可能导致消息重复发送\",\"并发处理：kafka支持并发消费，多个消费者可以同时消费一个topic，因此要有对应的同步机制和协调\",\"消费者处理：消费者在消费消息的时候出现异常或者错误，导致消息处理失败，但是没有正确的处理这些异常情况，没有提交偏移量或者是一次失败了就不做了，没有重试机制，也可能导致消息重复消费\"]},\"707\":{\"h\":\"二、如何保证消息不丢失\"},\"708\":{\"h\":\"1. 消息在什么环节可能发生丢失\",\"t\":[\"生产阶段\",\"存储阶段\",\"消费阶段\",\"保证消息不丢失，就要保证在这 3 个阶段的消息不丢失。\",\"![消息丢失环节示意图](../images/Kafka 20实践应用经验.001.jpeg)\"]},\"709\":{\"h\":\"2. 生产阶段\",\"t\":[\"结论\",\"Kafka本身是没有什么机制能保证生产一定成功的，需要有额外的确认机制才可以。\",\"原因：这个环节是在数据进入消息队列之前，甚至可能因为某些原因都没发送过数据，所以不该由消息队列来保证，所以这个结论也不影响消息队列的可靠性。\",\"在生产阶段要有重试和确认机制：\",\"确认机制： 由Kafka 存储阶段 配合 producer的 acks 参数 实现，确保消息的可靠接收。\",\"重试机制： 由Producer依据确认机制的反馈来实现，确保在发送失败时能够重新尝试发送消息。\"]},\"710\":{\"h\":\"3. 存储阶段\",\"t\":[\"存储数据不丢失，也就是进去消息队列之后的数据，是持久的，Kafka这种消息队列，是非常可靠的，只要写入了队列，就不会丢消息。\",\"这个依托于持久化存储：Kafka的消息确认机制依赖存储阶段\",\"一旦消息被写入并确认(根据所选的确认级别)，它就会被持久化存储到磁盘中。\",\"这意味着即使系统发生故障或重启，已经确认的消息也不会丢失。它就可以被消费者至少消费一次。\",\"存储阶段的ACK机制，有写入策略配置：\",\"Acks\",\"行为\",\"可靠性\",\"性能\",\"0\",\"producer发送消息给broker后，不等待broker的确认消息。producer也就无法重试和确认信息是否发送成功\",\"不可靠\",\"最高\",\"1（默认）\",\"producer发送消息给broker后，等待leader节点的确认，但是不会等待所有follow的确认\",\"相对可靠\",\"比较高\",\"All\",\"只有所有的副本都成功写入消息后，producer才会收到确认\",\"可靠\",\"相对低一些\",\"acks 参数的作用机制\",\"Producer发送消息：Producer将消息发送到Kafka集群中的目标分区的Leader节点。\",\"Leader节点处理消息：Leader节点接收到消息后，根据acks参数的配置，决定是否立即向Producer发送确认或者等待同步副本的确认。\",\"Follower节点同步数据：如果acks=all，Leader节点会等待所有同步副本（Follower节点）成功复制数据后，再向Producer发送确认。\",\"一些疑问（已解决）\",\"acks是producer端配置的，发送消息到leader节点后，leader会根据acks参数决定是否回发确认以及何时回发确认\",\"acks参数是否是每次producer发送消息都要携带\",\"要携带acks，那这个参数或者类似的参数等等....是携带在自定义的消息结构里面，也就是kafka 在应用层自定义的二进制协议\"]},\"711\":{\"h\":\"4. 消费阶段\",\"t\":[\"Kafka提供了偏移量管理功能：Kafka消费者通过提交每个分区的偏移量来跟踪已经消费的消息。\",\"即使消费者在处理消息时发生故障，重新启动后它仍然可以从最后一个提交的偏移量处继续消费，确保消息至少被处理一次。\",\"上面是自动提交，也可用手动提交，由 consumer 业务代码自己控制提交时机，主动调用提交函数。\",\"消费阶段示意图\"]},\"712\":{\"h\":\"三、如何保证消息不重复\",\"t\":[\"结论\",\"光靠消息队列是做不到不重复消费的，要消息队列配合业务逻辑配合完成。由于网络波动，基本上不可能让消息真的不重复，本质上不重复是手段，不重复产生影响才是目的。\"]},\"713\":{\"h\":\"1. 发生重复消费的场景\",\"t\":[\"生产阶段： 发送时就重复了，比如网络波动，生产者重试发送，2次其实都发到了Broker\",\"存储阶段： 在Kafka中存储的阶段，是不会重复的\",\"消费阶段： 业务收到消息之后因为各种原因没有及时提交偏移，后面又拉到了相同消息\"]},\"714\":{\"h\":\"2. 常见防重实现思路\",\"t\":[\"基于 redis：\",\"唯一标识符： 为每个消息分配一个全局唯一的标识符(如UUID)\",\"Redis set： 将已消费的消息ID存储在Redis的Set数据结构中。每次消费消息前，检查该消息ID是否已存在于Set中\",\"原子操作： 使用Redis的原子操作(如 SISMEMBER和 SADD)来检查和添加消息ID，确保操作的原子性\",\"基于 mysql：\",\"唯一约束： 在MySQL表中为消息ID创建一个唯一约束\",\"INSERT IGNORE： 使用 INSERT IGNORE或 ON DUPLICATE KEY UPDATE 语句来尝试插入消息记录。如果消息ID已存在，则忽略或更新该记录\",\"事务： 在需要的情况下，使用事务来确保多个操作的原子性\"]},\"715\":{\"h\":\"3. 流量优化\",\"t\":[\"如果业务用mysql做存储，可以参考上面的防重处理思路，基于此可以再做一些小优化：\",\"如果重复请求过多，mysql 会无辜的多承担这部分的压力，如果再加一层 redis 做缓存限流，会好很多。\",\"流量优化示意图\"]},\"716\":{\"h\":\"四、如何保证消息准确消费一次\"},\"717\":{\"h\":\"1. 简单实现\",\"t\":[\"消息不丢失 + 消息不重复 = 准确消费一次\",\"消息准确消费示意图\"]},\"718\":{\"h\":\"五、如何保证消息有序\"},\"719\":{\"h\":\"1. 什么场景需要有序\",\"t\":[\"电商订单处理： \",\"在电商系统中，用户的订单操作（下单、支付、取消等）需要按照时间顺序处理。比如，用户先下单再支付，如果消息顺序错乱，可能会导致支付消息先到而下单消息后到，从而引发逻辑错误。\",\"金融交易系统： \",\"在股票交易或银行转账等金融系统中，交易操作必须严格按照时间顺序执行。任何顺序错乱可能导致账户数据不一致，甚至引发严重的金融风险。\",\"消息有序场景示意图\",\"任务调度： \",\"在任务调度系统中，任务的执行顺序可能直接影响结果。例如，某些依赖性任务必须按特定顺序执行，顺序错乱可能导致依赖关系无法满足，任务失败。\"]},\"720\":{\"h\":\"2. 思路1：业务单分区\",\"t\":[\"这是最简单的做法，就是根据业务确定分区，即每类业务自己一个分区，这样就可以实现业务消息有序。\",\"具体而言，将业务所有消息都指定同一个分区Key，这样一来所有消息都会添加至同一个Partition，这样就达到了我们的目的。\",\"潜在的不足之处：\",\"在于这样做性能的扩展性就低了很多，当单个业务增长比较快，最后压力都给到了同一个Partition，无法发挥多Partition的优势，所以一般而言还会根据情况进一步地业务内分区。\"]},\"721\":{\"h\":\"3. 思路2：业务内多分区\",\"t\":[\"提示\",\"类似数据库分表\"]},\"722\":{\"h\":\"3.1 子业务分区\",\"t\":[\"大业务分区：\",\"同一个团队下，可能有不同的服务，比如：金融服务，消息服务等，假设他们都要传递消息给消息队列，显然可以金融服务一个分区，消息服务一个分区。\",\"大业务 ----> 子业务：\",\"金融服务分为：风控子业务一个分区，支付子业务一个分区\",\"消息服务分为：短信通知分区，微信通知分区\"]},\"723\":{\"h\":\"3.2 客户分区\",\"t\":[\"如果对于客户而言，数据是比较独立的，客户之间没什么交互，我们还可以按客户来分区。\",\"比如消息是记录某个客户的减肥记录，里面包含了日期和减了多少斤，消费之后希望按投递的顺序记录进某个文件或数据库。\",\"这种场景就是客户自己有序即可，客户不用关心别的客户减肥情况，也就是说客户之间不需要依赖。\",\"符合这种场景的业务，就可以按客户来进行分区，比如最简单的，按用户id%100来分，这样就可以划出来100个分区，比如用户1001就用分区Key:user-mod-1，用户2002就用分区Key:user-mod-2\",\"缺点：\",\"这种方式有一个缺点，增减节点会对原有的路由分布会造成冲击。\",\"比如原来9个分区，用户id是10，那算出来就是10 % 9 = 1 号分区。\",\"假设增加一个分区，该用户就路由到 10 % 10= 0 号分区，也就是说，当节点增加或减少，原来的路由基本上是全乱了。\",\"扩展思路：引入 hash 槽\",\"每个节点负责一部分槽，用户id算出来在哪个槽，就去负载该槽的节点进行交互。\",\"大致实现思路：\",\"确定哈希函数 ： \",\"选择一个合适的哈希函数来计算每个客户的哈希值。常用的哈希函数包括 MD5、SHA-1 或者 CRC32 等。\",\"定义哈希槽 ： \",\"确定哈希槽的数量（通常是一个固定的常量，比如 1024 或 2048）。这些哈希槽将用于将客户分配到不同的队列中。\",\"计算哈希值并映射到哈希槽 ： \",\"使用哈希函数计算客户 ID 的哈希值。\",\"将哈希值取模哈希槽的数量，得到一个哈希槽编号（hash_slot = hash(customer_id) % num_slots）。\",\"分配队列 ： \",\"将每个哈希槽映射到一个特定的消息队列。这样，相同客户 ID 的消息总是会映射到同一个哈希槽，从而保证消息的有序性。\",\"哈希槽示意图\"]},\"724\":{\"h\":\"3.3 大小客户分区\",\"t\":[\"提示\",\"待补充内容\"]},\"725\":{\"c\":[\"消息队列\"]},\"726\":{\"c\":[\"Kafka\",\"最佳实践\",\"消息队列\"]},\"727\":{\"h\":\"MySQL分库分表实践\",\"t\":[\"分库分表\",\"一、什么时候分库、什么时候分表\",\"分表：单张数据表太大，大于 500w 以上，影响了事务执行效率，就需要考虑分表。\",\"分库：单个数据库的性能扛不住高并发流量，就要考虑分库。\",\"二、分库分表原理\",\"具体可以分为两种方式：垂直切分和水平切分\",\"(一) 垂直切分\",\"垂直拆分一般是按照业务和功能的维度进行拆分，把数据分别放到不同的数据库中。\",\"...\",\"(二) 水平切分\",\"水平拆分是把相同的表结构分散到不同的数据库和不同的数据表中，避免访问集中的单个数据库或者单张数据表，具体的分库和分表规则，一般是通过业务主键，进行哈希取模操作。\",\"...\",\"三、分库分表引发的问题\",\"(一) 分布式事务问题，解决方式：\",\"分布式事务是指：一次大的操作由多个小操作组成，这些小的操作分布在不同的服务器上，分布式事务需要保证这些小操作要么全部成功，要么全部失败。\",\"2PC 两阶段、3PC 三阶段提交协议。（强一致性，性能差，用的少）\",\"TCC 分段提交\",\"基于本地消息表来实现分布式事务（最终一致性，性能较好，用的多）\",\"(二) 全局 ID 唯一性问题，解决方式：\",\"雪花算法生成 ID\",\"美团 leaf 算法\",\"(三) 跨库跨表关联查询问题，解决方式：\",\"(四) 跨库跨表 count 查询问题，解决方式\"]},\"728\":{\"c\":[\"数据库\",\"MySQL\"]},\"729\":{\"c\":[\"MySQL\",\"分库分表\",\"数据库架构\",\"高可用\"]},\"730\":{\"h\":\"MySQL读写分离与主从同步详解\",\"t\":[\"读写分离、主从同步\",\"一、读写分离概念\",\"主库：处理新增、修改、删除等事务性操作。\",\"从库：处理 SELECT 查询操作\",\"二、主从同步过程\",\"...\",\"写入 binlog： 主库修改数据后，写入 binlog 日志，提交事务，更新本地存储的数据。\",\"同步 binlog：从库连接到主库后，主库会创建一个 dump 线程，把 binlog 同步到所有从库，每个从库把 binlog 写到暂存日志中。\",\"回放 binlog：从库启动一个 sql 线程去回放 binlog，去读 relay log 中继日志然后回放 binlog 更新数据。\",\"三、同步模式\",\"mysql 默认的同步模式：异步模式\",\"同步模式：主库提交事务的线程要等待所有从库的同步成功，才返回客户端结果。性能最差了。\",\"异步模式：主库提交事务的线程不会等待 binlog 同步完成就返回客户端结果，性能最好，但是主库宕机，数据就会丢失。\",\"半同步模式：比如一主二从的集群，只要成功同步到一个从库，就立即返回数据给客户端。即使主库宕机，仍有一个从库有最新数据。\",\"四、主从复制的数据延迟怎么解决\",\"使用缓存：在写入数据主库的同时，把数据写到 redis 缓存里面。这样其它线程（比同步从库的 dump 线程，因为写入缓存速度快，所以可以从缓存拿数据同步从库，不用从主库拿数据。）获取数据的时候会优先查询缓存，但是可能带来缓存一致性问题。\",\"直接查询主库：杜宇数据延迟敏感的业务，可以强制读主库。但是前提是查询的数据量不大，不然会出现主库写请求锁行，影响读请求的执行，最终对主库造成较大的压力。\",\"五、主从架构中，读写分离怎么实现\",\"独立部署代理中间件 mycat 来实现。\",\"六、主库掉了怎么办\",\"由于 mysql 没有像 redis 集群的哨兵模式可以自动将从库升级为主库，所以 MySQL 主从复制没有实现发现主服务器宕机和处理故障迁移的功能，要实现真的主从故障转移的话，简单了解过，可以用开源的 MySQL 高可用套件 MHA。\",\"MHA 可以在主数据库发生宕机时，可以剔除原有主机，选出新的主机，然后对外提供服务，保证业务的连续性。\"]},\"731\":{\"c\":[\"数据库\",\"MySQL\"]},\"732\":{\"c\":[\"MySQL\",\"读写分离\",\"主从同步\",\"高可用\"]},\"733\":{\"h\":\"MySQL日志系统详解\",\"t\":[\"从理解 SQL 执行过程到理解MySQL 日志系统的工作过程。\"]},\"734\":{\"h\":\"1. 一条 select 语句的执行过程\",\"t\":[\"一条查询语句执行的过程，属于读一条记录的过程，大致可以分为以下几个步骤：\",\"建立客户端/服务器通信：\",\"客户端发起的连接请求，通过MySQL连接器处理后，客户端将SQL查询语句发送到服务器。\",\"查询解析：\",\"SQL解析器：SQL解析器首先会对查询语句进行语法和词法分析，生成一个解析树（Parse Tree）。\",\"预处理器：预处理器进一步检查解析树的合法性，包括表和列是否存在、名称是否正确等。\",\"查询优化：\",\"查询重写：优化器可能会对解析树进行重写，例如将子查询转换为连接（JOIN），或者进行某些常见的SQL重写优化。\",\"选择执行计划：优化器会生成多个执行计划，并选择其中的最优计划。这里会考虑索引的使用、表扫描的方式（全表扫描或索引扫描）等。\",\"成本估算：MySQL使用一种基于成本的优化算法，通过估算不同执行计划的代价，选择成本最低的计划。\",\"查询执行：\",\"存储引擎接口：MySQL的执行器根据优化器选择的执行计划，通过存储引擎接口调用具体的存储引擎（如InnoDB、MyISAM等）。\",\"存储引擎操作：存储引擎根据执行器的请求进行数据的读取、写入等操作。\",\"结果返回：\",\"结果集处理：执行器将存储引擎返回的数据进行处理，生成最终的结果集。\",\"结果发送：最终的结果集通过网络传输返回给客户端。\",\"缓存处理（可选）：\",\"查询缓存：如果查询缓存开启且命中缓存，MySQL会直接从缓存中返回结果，而不经过上述大部分步骤。需要注意的是，MySQL 8.0 版本已移除查询缓存这一特性。\",\"总结来说，MySQL一条查询语句的执行过程可以概括为：客户端发送SQL语句 -> 解析语句 -> 优化查询 -> 执行查询 -> 返回结果。每个步骤中都有许多细节和优化点，使得MySQL能够高效地处理各种查询请求。\",\"引用小林图解的一张图： \"]},\"735\":{\"h\":\"2. 一条 update 语句的执行过程\",\"t\":[\"比如这条待执行的 update 语句：UPDATE t_user SET name = 'kryiea' WHERE id = 10086;\",\"待执行的语句执行过程：\",\"select 语句的那一套流程，update 语句也是同样会走一遍\",\"查询到目标记录后，执行更新操作的同时会涉及对三种日志的改动，undolog、redolog、binlog。\"]},\"736\":{\"h\":\"3. 三种日志、MVCC、BufferPool 之间的相互配合\"},\"737\":{\"h\":\"3.1 三种日志的主要作用\",\"t\":[\"UndoLog 回滚日志： 是Innodb存储引擎层生成的日志，保证了事务中的原子性，主要用于事务回滚和MVCC。（撤销已经执行的修改，保证事务的原子性和一致性）\",\"RedoLog 重做日志： 是Innodb存储引擎层生成的日志，保证了事务中的持久性，主要用于掉电等故障恢复。（重做已经提交的修改，保证事务的持久性）\",\"BinLog 归档日志： 是 Server层 生成的日志，主要用于数据备份和主从复制。（记录和重放SQL语句，用于数据的复制和恢复）\",\"⬇️辅助理解： InnoDB 存储引擎的日志：\",\"UndoLog 记录了此次事务 开始前 的数据状态，记录的是 更新 之前 的值；\",\"RedoLog 记录了此次事务 完成后 的数据状态，记录的是 更新 之后 的值；\",\"Server 层的日志：\",\"BinLog 记录了完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写入 binlog文件。\"]},\"738\":{\"h\":\"3.2 UndoLog 回滚日志\"},\"739\":{\"h\":\"3.2.1 为什么需要 UndoLog\",\"t\":[\"先了解隐式事务： Innodb 引擎在执行一条增删改语句的时候，即使没有显式输入begin开启事务和commit提交事务，也会自动隐式开启事务。 而且执行一条 update 语句是否自动提交事务，是由 autocommit 参数决定，默认开启。\",\"试想以下场景： 在一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？\",\"如何解决： 如果每次在事务执行过程中，都记录下回滚时需要的信息到一个日志（undolog）里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。\"]},\"740\":{\"h\":\"3.2.2 认识 Undolog 机制\",\"t\":[\"在事务没提交之前，MySQL 会先记录更新前的数据到 undolog日志文件，当事务需要回滚时，可以利用 undolog 来进行回滚。\",\"过程如下图: \"]},\"741\":{\"h\":\"3.2.3 Undolog 如何记录和回滚\",\"t\":[\"每当 InnoDB 引擎对一条记录进行操作时，要把回滚时需要的信息都记录到 undolog 里，比如：\",\"在 插入 一条记录时，要把这条记录的主键值记下来，这样回滚时只需要把这个主键值对应的记录 delete 就好了；\",\"在 删除 一条记录时，要把这条记录中的内容都记下来，这样回滚时再把由这些内容组成的记录 insert 到表中就好了；\",\"在 更新 一条记录时，要把被更新的列的旧值记下来，这样回滚时再把这些列 update 为旧值就好了。\"]},\"742\":{\"h\":\"3.2.4 Undolog 日志的格式\",\"t\":[\"需要了解一条记录在innodb引擎中的存储格式。\",\"一条记录的每一次更新操作产生的 undolog 中，都有一个 roll_pointer 指针和一个 trx_id 事务id：\",\"通过 trx_id 可以知道该记录是被哪个事务修改的。\",\"通过 roll_pointer 指针可以将这些 undolog 串成一个链表，这个链表就被称为版本链。\",\"版本链如下图：\"]},\"743\":{\"h\":\"3.2.5 Undolog + ReadView 实现 MVCC\",\"t\":[\"MVCC - Multi-version concurrency control 多版本并发控制（MVCC）是一种数据库管理技术，通过维护数据的多个版本来实现并发访问，从而提高读写操作的性能和一致性。\",\"并发访问的多个版本通过快照控制： 对于读提交和可重复读隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 ReadView + undolog 来实现的。 读提交 和 可重复读 的 快照读 区别在于创建 ReadView 的时机不同：\",\"读提交隔离级别：每次执行 select 都会生成一个新的 ReadView，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\",\"可重复读隔离级别：在启动事务时生成一个 ReadView，然后整个事务期间都在用这个 ReadView，这样就保证了在事务期间读到的数据都是事务启动前的记录。\",\"如何知道版本的可见性，参考 3.2.6 ： 通过 事务的 ReadView 里的字段 和 记录中的两个隐藏列 trx_id 和 roll_pointer 的比对，如果不满足可见行，就会顺着 undolog 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）\"]},\"744\":{\"h\":\"3.2.6 ReadView 机制\",\"t\":[\"ReadView 的四个字段： ReadView 可以理解为记录当前事务id创建时，整个数据库还有哪些其他活着的事务，记录下来，以便于判断数据的可见性。\",\"creator_trx_id：代表创建当前这个 ReadView 的事务ID。\",\"m_ids：表示在生成当前 ReadView 时，系统内活跃且未提交的事务ID列表。\",\"min_trx_id：活跃的事务列表中最小的事务ID。\",\"max_trx_id：表示在生成当前 ReadView 时，系统中要给下一个事务分配的ID值\",\"如何判断可见性： 判定方法：事务 readview 里的字段 与 记录中的两个隐藏列 进行对比：\",\"如果事务ReadView 中的 min_trx_id 值>=记录的 trx_id 值，表示这个版本的记录是在创建 ReadView 前 已经提交的事务生成的，所以该版本的记录对当前事务 可见 。\",\"如果事务ReadView 中的 max_trx_id 值<=记录的 trx_id 值，表示这个版本的记录是在创建 ReadView 后 才启动的事务生成的，所以该版本的记录对当前事务 不可见 。\",\"如果 事务ReadView 中的 min_trx_id<记录的 trx_id 值<事务ReadView 中的 max_trx_id，需要判断 trx_id 是否在 m_ids 列表中： \",\"如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务 不可见 。\",\"如果记录的 trx_id 不在 m_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务 可见 。\"]},\"745\":{\"h\":\"3.2.7 UndoLog 如何刷盘的\",\"t\":[\"Undolog 和 数据页 的刷盘策略是一样的，都需要通过 Redolog 保证持久化。\",\"Buffer pool 中有 Undo 页，对 Undo 页的修改也都会记录到 Redolog。\",\"Redolog 会每秒刷盘，提交事务时也会刷盘，数据页和 Undo 页都是靠这个机制保证持久化的。\"]},\"746\":{\"h\":\"3.3 Buffer Pool 缓冲池\"},\"747\":{\"h\":\"3.3.1 Buffer Pool 的意义\",\"t\":[\"场景： MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。\",\"那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢： 这也是 Buffer Pool 的意义。 当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。\",\"有了Buffer Pool后：\",\"当读取数据时，如果数据存在于 BufferPool 中，客户端就会直接读取 BufferPool 中的数据，否则再去磁盘中读取。\",\"当修改数据时，如果数据存在于 Buffe Pool 中，那直接修改 BufferPool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。\",\"Buffer Pool 属于哪一层： 属于：Innodb引擎层。 区别：不是本文开头讨论 select 语句执行过程中提到的缓存，那个是在 server 层的。\"]},\"748\":{\"h\":\"3.3.2 Buffer Pool 缓存什么\",\"t\":[\"InnoDB中磁盘与内存的交互基本单位： InnoDB 会把存储的数据划分为若干个页，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，BufferPool 同样需要按页来划分，使用与存储引擎一样的基本单位。\",\"在 MySQL 启动的时候： InnoDB 会为 BufferPool 申请一片连续的内存空间，然后按照默认的 16KB 的大小划分出一个个的页， BufferPool 中的页就叫做缓存页。 此时这些缓存页都是空闲的，之后随着程序的运行，会有磁盘上的页被加载缓存到 BufferPool 中的缓存页。\",\"在 MySQL 启动完成的时候： 由于是先申请了一片连续的内存空间但没写入具体数据，所以可以观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小。 这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。\",\"BufferPool 可以缓存的数据类型：\",\"Undo 页是记录什么的 开启事务后，InnoDB 会在更新记录之前，先记录相应操作的 undolog 来保证事务的原子性。\",\"比如：如果是 update 操作，需要把被更新的列的旧值记下来，旧值作为一条 undolog，然后把这条 undolog 写入 BufferPool 中的 Undo页\",\"查询一条记录，只需要缓存一条记录吗？ 刚刚提到了 InnoDB 存储引擎以16KB大小的页作为磁盘与内存交互的基本单位，所以查询一条记录的时候，会将整个页加载进 BufferPool 中，再通过页的页目录去定位到某条具体的记录.\",\"上面提到的 页目录 是什么？ 简单来说：页目录类似于字典的目录，用于快速定位某条记录的大致位置。\",\"这个问题需要了解一个 页 内部是如何组织数据的。小林图解也有提到，这里附上一张更具体的图来辅助理解。\",\"一个页空间会被划分成许多部分，有：文件头、页头、最大最小记录、用户记录、空闲空间、文件尾等。\",\"主要关注用户记录：存储的一行行记录会被存放在这里，记录还会进一步被分成一个个组，每一个组内部都有一些数据记录。\",\"再看到左边的页目录：有一个个的槽位，其指向每一个分组内的最后一条记录。\",\"mysql-4.drawio\"]},\"749\":{\"h\":\"3.3.3 Buffer Pool 刷盘策略\",\"t\":[\"深入学习文章推荐：(十二)MySQL之内存篇：深入探寻数据库内存与Buffer Pool的奥妙！ - 竹子爱熊猫\"]},\"750\":{\"h\":\"3.4 RedoLog 重做日志\"},\"751\":{\"h\":\"3.4.1 为什么需要 Redolog\",\"t\":[\"试想以下场景： Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。\",\"解决方案： 采用 WAL (Write-Ahead Logging) 技术。\",\"MySQL 的写操作并不是立刻写到磁盘上，而是先写日志文件，然后在合适的时间再将新的记录写到磁盘上。\",\"在事务提交时，数据库系统只需确保 redolog 已经写入磁盘，而数据页可以稍后再写入。\",\"解决方案的场景： 当有一条记录需要更新的时候，InnoDB 引擎会先更新 Buffer Pool 中的数据页，同时将该页标记为脏页。然后，将本次对这个页修改后的数据状态以 redo log 的形式记录下来并写入 redo log 文件，这时更新操作就算完成了。\",\"到这里，只是完成了 redo log 文件的刷盘，但还未完成将最新的数据记录（脏的数据页）刷盘到存储表数据的文件 xxx.ibd 中。简而言之：日志文件是最新的，但数据库文件还不是最新的，还需要完成最后的 Buffer Pool --> 磁盘 操作，才能完成持久化存储。\",\"后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL 的核心思想。\",\"图示，第4步的细节参考 3.4.5：\"]},\"752\":{\"h\":\"3.4.2 认识 Redolog 机制\",\"t\":[\"redolog 是物理日志，记录了某个数据页做了什么修改\",\"如何记录这个 \\\"修改\\\"： 格式：AAA表空间 中的 BBB数据页 的 CCC偏移量 的地方做了 DDD的更新，每当执行一个事务就会产生这样的一条或者多条物理日志。\",\"WAL： 在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。\",\"如何保证事务的持久性： 当系统崩溃时，虽然脏页数据没有持久化，但是 redolog 已经持久化，MySQL 能在重启后根据 redolog 的日志内容，将所有数据恢复到最新的状态。\"]},\"753\":{\"h\":\"3.4.3 Redolog 与 Undolog 的配合\",\"t\":[\"配合场景： 开启事务后，InnoDB 在进行更新操作之前，首先会记录相应的 undolog。\",\"如果是更新操作，InnoDB 需要将被更新的列的旧值记下来，也就是生成一条 undolog。这个 undolog 会被写入 Buffer Pool 中的 Undo 页面。 然后在 BufferPool 中完成数据页的更新，标记该页为脏页，并且记录对于的 redolog。\",\"具体的配合过程：\",\"记录 undolog：\",\"当事务对数据库中的记录进行更新时，InnoDB 会先生成一条 undolog，记录被修改前的数据。这个操作是为了保证在事务回滚时能够恢复到原始状态。\",\"生成的 undolog 会被写入 BufferPool 中的 Undo 页面，并在内存中进行修改。\",\"记录 redolog：\",\"在内存中修改 Undo 页面后，InnoDB 还需要记录对应的 redo log。redo log 记录的是对数据页的物理修改操作，是用来在系统崩溃后进行数据恢复的。\",\"具体来说，redo log 会记录对数据页的修改操作细节，包括何时修改、修改了哪些数据等。这些信息会先写入 redolog buffer 中，并在适当的时机（例如事务提交时）刷写到磁盘上的 redo log 文件中。\",\"Redolog Buffer 与 Buffer Pool 不一样! Redolog Buffer 是 redolog 自己的缓存 具体细节往下看。\"]},\"754\":{\"h\":\"3.4.4 Redolog与数据分开写入磁盘的必要性\",\"t\":[\"能提高数据库的写性能：\",\"顺序写入：\",\"redo log 的写入是顺序写入，采用在文件尾部追加写入文件的方式，这样可以减少磁盘的寻道时间和旋转延迟，从而提高写入速度。\",\"顺序写入的性能通常比随机写入高\",\"随机写入：\",\"数据页的写入通常是随机写入。随机写入是指数据写入磁盘的不同位置，写入速度较慢。\",\"通过将数据页首先写入缓冲池（Buffer Pool），然后在适当时机批量写入磁盘，可以减少随机写入的频率和次数。\"]},\"755\":{\"h\":\"3.4.5 Redolog 的刷盘策略\",\"t\":[\"执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。 所以，redo log 也有自己的缓存 redo log buffer ，每当产生一条 redo log 时，会先写入到 redo log buffer，后续再持久化到磁盘.\",\"redo log buffer 默认大小 16 MB，可以通过 innodb_log_Buffer_size 参数动态的调整大小，增大它的大小可以让 MySQL 处理大事务时不必写入磁盘（提高了写入磁盘的阈值），进而提升写 IO 性能。\",\"redo log buffer 的持久化如下图： \"]},\"756\":{\"h\":\"3.4.6 redolog buffer 的刷盘时机：\",\"t\":[\"主要的几个刷盘时机：\",\"MySQL 正常关闭时。\",\"当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘。\",\"InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\",\"每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制）。\",\"了解一个主要参数 innodb_flush_log_at_trx_commit:\",\"innodb_flush_log_at_trx_commit = 0 每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。\",\"innodb_flush_log_at_trx_commit = 1 这是默认值。 每次事务提交时，都 将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘 ，这样可以保证 MySQL 异常重启之后数据不会丢失。\",\"innodb_flush_log_at_trx_commit = 2 每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意并不意味着写入到了磁盘 ，因为操作系统的文件系统中有个 Page Cache（Page Cache 是专门用来缓存文件数据的，所以写入 redo log文件意味着写入到了操作系统的文件缓存。\"]},\"757\":{\"h\":\"3.4.7 Redolog 日志重写\",\"t\":[\"问题背景： redolog 文件写满了/文件过大怎么办？\",\"解决方案 - 日志重写： 默认情况下，InnoDB 存储引擎有 1 个重做日志文件组 redo log Group，由 2 个 redolog 文件 组成，分别是：ib_logfile0 和 ib_logfile1。\",\"日志重写方式：循环写重做日志文件组是以 循环写 的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。 先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。\",\"图示： \"]},\"758\":{\"h\":\"3.5 BinLog 重做日志\"},\"759\":{\"h\":\"3.5.1 Binlog 的作用\",\"t\":[\"binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用，用于备份恢复、主从复制等；\",\"binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。\",\"binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。\",\"产生 binlog 的场景： MySQL 在完成一条更新操作后，Server 层会生成一条 binlog，将其写到 binlog cache（Server 层的 cache），等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写入 binlog 文件。\"]},\"760\":{\"h\":\"3.5.2 Binlog 刷盘策略\",\"t\":[\"MySQL 给每一个处理线程分配了一片内存用于缓冲 binlog，该内存叫 binlog cache。\",\"事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。\",\"关键点1： 一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。\",\"MySQL 设定一个处理线程只能同时有一个事务在执行，所以每当执行一个 begin/start transaction 的时候，就会默认提交上一个事务。\",\"关键点2： 场景：什么时候 binlog cache 会写到 binlog 文件？\",\"回答：在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空binlog cache。\",\"关键点3： 每一个线程都有自己的binlog cache，最终写入同一个Binlog文件\",\"关键点4： 场景：如关键点3所提到的 最终写入同一个Binlog文件，那这里的并发问题如何解决？\",\"回答：MySQL采用了多种机制来确保并发安全和一致性\",\"锁机制\",\"顺序写入\",\"组提交 Group Commit\",\"关键点5： 场景：写入binlog文件的过程还可以继续拆分。\",\"系统调用 write()后，会先写入内核的缓冲区 page cache，这里不涉及磁盘I/O\",\"内核再通过 fsync() 持久化到磁盘，这里涉及磁盘I/O。频繁的 fsync() 会导致磁盘的I/O 升高。\",\"20240603001559\",\"关键点6：fsync() 的频率由参数 sync_binlog 控制\",\"sync_binlog = 0 是默认值 表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘。\",\"sync_binlog = 1 表示每次提交事务都会 write，然后马上执行 fsync，最多丢失一个事务的 binlog。\",\"sync_binlog > 1 表示每次提交事务都 write，但累积 N 个事务后才 fsync。\"]},\"761\":{\"h\":\"3.5.3 Binlog - 主从同步模型\",\"t\":[\"主从同步过程：\",\"写入 binlog： 主库修改数据后，写入 binlog 日志，提交事务，更新本地存储的数据。\",\"同步 binlog： 从库连接到主库后，主库会创建一个 dump 线程，把 binlog 同步到所有从库，每个从库把 binlog 写到暂存日志中。\",\"回放 binlog： 从库启动一个 sql 线程去回放 binlog，去读 relay log 中继日志然后回放 binlog 更新数据。 \",\"三种主从同步模式： MySQL 默认的同步模式：异步模式\",\"同步模式： 主库提交事务的线程要等待所有从库的同步成功，才返回客户端结果。性能最差了。\",\"异步模式： 主库提交事务的线程不会等待 binlog 同步完成就返回客户端结果，性能最好，但是主库宕机，数据就会丢失。\",\"半同步模式： 比如一主二从的集群，只要成功同步到一个从库，就立即返回数据给客户端。即使主库宕机，仍有一个从库有最新数据。\"]},\"762\":{\"h\":\"3.6 两阶段提交\"},\"763\":{\"h\":\"3.6.1 两阶段提交的提出\",\"t\":[\"思考以下问题： 事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。\",\"问题的场景复现：\",\"原数据：表名 t_user，某行记录 id = 1；name = jay 执行SQL：UPDATE t_user SET name = 'kryiea' WHERE id = 1 事务提交后：进行持久化 redolog和 binlog。\",\"这两个日志的刷盘先后顺序可能会导致下面两种情况：\",\"如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入。 \",\"MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 kryiea。\",\"但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致。\",\"如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入 。 \",\"由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name 字段还是旧值 jay。\",\"而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 kryiea，与主库的值不一致。\",\"问题的解决方案： 两阶段提交\"]},\"764\":{\"h\":\"3.6.2 两阶段提交的概念\",\"t\":[\"两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。\",\"两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是准备（Prepare）阶段和提交（Commit）阶段 ，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。\",\"协调者与参与者之间的协作： 例子来自小林图解。\",\"举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？\",\"准备阶段 ： 裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。\",\"提交阶段 ： 如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。\"]},\"765\":{\"h\":\"3.6.3 两阶段提交的过程\",\"t\":[\"在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog与 redolog，为了保证这两个日志的一致性，MySQL 事务提交时使用 内部 XA 事务 来保证一致性。\",\"内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。\",\"（是的，也有外部 XA 事务）\",\"当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务， 分两阶段来完成 XA 事务的提交 。\",\"场景举例： 事务的提交过程有两个阶段：将 redolog 的写入拆成了两个步骤 prepare 和 commit，中间再穿插写入 binlog。\",\"具体如下：\",\"prepare 阶段 ：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）\",\"commit 阶段 ：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了。因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；\",\"20240603005031\"]},\"766\":{\"h\":\"3.6.4 两阶段提交有什么问题\",\"t\":[\"两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差。\",\"主要有两个方面的影响：\",\"磁盘 I/O 次数高 ： 对于\\\"双1\\\"配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。\",\"锁竞争激烈 ： 两阶段提交虽然能够保证单事务两个日志的内容一致，但在多事务的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。\"]},\"767\":{\"h\":\"3.6.5 对两阶段提交加强：加入组提交\",\"t\":[\"MySQL 引入了组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成1个，从而减少磁盘 I/O 的次数。\",\"引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为3个过程： ● flush 阶段 ： 多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）； ● sync 阶段 ： 对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）； ● commit 阶段 ： 各个事务按顺序做 InnoDB commit 操作；\",\"20240603010701\"]},\"768\":{\"c\":[\"数据库\",\"MySQL\"]},\"769\":{\"c\":[\"MySQL\",\"数据库日志\",\"binlog\",\"redo log\",\"undo log\"]},\"770\":{\"h\":\"InnoDB存储引擎详解\",\"t\":[\"InnoDB 存储引擎\",\"InnoDB 存储引擎是用 B+ 树来组织数据的\",\"一行记录是怎么存储的\",\"MySQL 一行记录是怎么存储的？\",\"MySQL 的数据存放在哪个文件\",\"以下均以默认存储引擎 InnoDB 为例。\",\"不同存储引擎保存的文件不一样\",\"数据库文件存放目录\",\"mysql> SHOW VARIABLES LIKE 'datadir'; +---------------+-----------------+ | Variable\\\\_name | Value | +---------------+-----------------+ | datadir | /var/lib/mysql/ | +---------------+-----------------+ 1 row in set (0.00 sec)\",\"我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。\",\"比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。\",\"...\",\"然后，我们进入 /var/lib/mysql/my_test 目录，看看里面有什么文件？\",\"[root@xiaolin ~]#ls /var/lib/mysql/my\\\\_test db.opt t\\\\_order.frm t\\\\_order.ibd\",\"可以看到，共有三个文件，这三个文件分别代表着：\",\"db.opt：用来存储当前数据库的默认字符集和字符校验规则。\",\"t_order.frm ：t_order 的表结构会保存在这个文件。\",\"在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。\",\"t_order.ibd：t_order 的表数据会保存在这个文件。\",\"表数据既可以存在共享表空间文件（文件名：ibdata1） 也可以存放在独占表空间文件（文件名：表名字.ibd）\",\"这个行为是由参数 innodb_file_per_table控制的 若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了， 因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。\",\"不同的存储引擎，数据库的文件结构不一样，和索引是否支持聚簇索引密切相关\",\"myISAM：因为表数据和索引数据分别放在两个文件，是不支持聚簇索引的\",\"InnoDB：因为 .ibd 中存储了表的行数据和索引数据，是支持聚簇索引的\",\"表空间文件的结构\",\"表空间：由段（segment）、区（extent）、页（page）、行（row）组成\",\"InnoDB存储引擎的逻辑存储结构大致如下图：\",\"...\",\"从下往上看\",\"行（row）\",\"数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。\",\"页（page）\",\"**读取并不以「行」为单位：**记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。\",\"**按「页」为单位来读写的：**因此，InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。\",\"**默认每个页的大小为 16KB：**也就是最多能保证 16KB 的连续存储空间。\",\"**页是 InnoDB 存储引擎磁盘管理的最小单元：**意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。\",\"**页的类型：**有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的，数据页的结构：换一个角度看 B+ 树(opens new window)\",\"总之知道表中的记录存储在「数据页」里面就行。\",\"区（extent）\",\"InnoDB 存储引擎是用 B+ 树来组织数据的。\",\"B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。\",\"解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。\",\"那具体怎么解决呢？\",\"在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。\",\"每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。\",\"段（segment）\",\"表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。\",\"段一般分为数据段、索引段和回滚段等。\",\"索引段：存放 B + 树的非叶子节点的区的集合；\",\"数据段：存放 B + 树的叶子节点的区的集合；\",\"回滚段：存放的是回滚数据的区的集合，MVCC 利用了回滚段实现了多版本查询数据。\",\"InnoDB 行格式有哪些？\",\"行格式（row_format），就是一条记录的存储结构。\",\"InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。\",\"Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。\",\"由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。\",\"Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。\",\"从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。\",\"重点理解 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。\",\"compact 行格式\",\"「记录的额外信息」+「记录的真实数据」\",\"...\",\"变长字段长度列表\",\"varchar(n) 和 char(n) 的区别是：char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。\",\"所以，在存储数据的时候，也要把数据占用的大小存起 来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。\",\"「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」：\",\"我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：\",\"CREATE TABLE t\\\\_user ( id int(11) NOT NULL, name VARCHAR(20) DEFAULT NULL, phone VARCHAR(20) DEFAULT NULL, age int(11) DEFAULT NULL, PRIMARY KEY ( id ) USING BTREE ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW\\\\_FORMAT = COMPACT;\",\"现在 t_user 表里有这三条记录：\",\"...\",\"第一条记录：\",\"name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；\",\"phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；\",\"age 列和 id 列不是变长字段，所以这里不用管。\",\"这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放，所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。\",\"...\",\"第二条记录：\",\"「变长字段长度列表」里的内容是「 04 02」，如下图：\",\"...\",\"第三条记录：\",\"phone 列的值是 NULL，NULL 是不会存放在行格式中记录的真实数据部分里的，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。\",\"...\",\"为什么 「变长字段长度列表」 要按 逆序存放？\",\"主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是：向左读就是记录头信息，向右读就是真实数据，比较方便。\",\"「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。\",\"同样的道理， NULL 值列表的信息也需要逆序存放\",\"每个数据库表的行格式都有「变长字段字节数列表」吗？\",\"其实变长字段字节数列表不是必须的。\",\"当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了，因为没必要，不如去掉以节省空间。\",\"所以「变长字段长度列表」只出现在数据表有变长字段的时候\",\"NULL 值列表\",\"表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。\",\"如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。\",\"二进制位的值为1时，代表该列的值为NULL。\",\"二进制位的值为0时，代表该列的值不为NULL。\",\"另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 0。\",\"还是以 t_user 表的这三条记录作为例子：\",\"...\",\"接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。\",\"第一条记录，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：\",\"...\",\"但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是的：\",\"...\",\"所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。\",\"第二条记录，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。\",\"...\",\"最后第三条记录，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。\",\"...\",\"我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：\",\"...\",\"每个数据库表的行格式都有「NULL 值列表」吗？\",\"NULL 值列表也不是必须的。\",\"当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。\",\"所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。\",\"「NULL 值列表」是固定 1 字节空间吗？\",\"如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？\",\"「NULL 值列表」的空间不是固定 1 字节的。\",\"当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。\",\"记录头信息\",\"记录头信息中包含的内容很多，个比较重要的：\",\"delete_mask ：标识此条数据是否被删除。 从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。\",\"next_record：下一条记录的位置。 从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。\",\"record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录\",\"记录的真实数据\",\"记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：\",\"row_id\",\"trx_id\",\"roll_pointer\",\"...\",\"row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。 如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。 row_id不是必需的，占用 6 个字节。\",\"trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。\",\"roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录 roll_pointer 是必需的，占用 7 个字节。\",\"varchar（n）中 n 最大取值多少\",\"一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。\",\"n 代表什么\",\"varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小\",\"计算最大 n\",\"要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集\",\"n = 当前行可用最大字节 / 当前字符集一个字符的字节大小\",\"当前行可用最大字节 = 65535 - 非真实数据部分所占字节 - 隐藏字段所占字节\",\"单字段的情况下\",\"我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。\",\"CREATE TABLE test ( name VARCHAR(65535) NULL ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW\\\\_FORMAT = COMPACT;\",\"看能不能成功创建一张表：\",\"...\",\"可以看到，创建失败了。\",\"从报错信息就可以知道一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead。\",\"问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。\",\"所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead 占用的字节数。\",\"这是因为我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：\",\"真实数据\",\"真实数据占用的字节数\",\"NULL 标识，如果不允许为NULL，这部分不需要\",\"本次案例中，「NULL 值列表」所占用的字节数是多少？\",\"前面我创建表的时候，字段是允许为 NULL 的，所以会用 1 字节来表示「NULL 值列表」。\",\"本次案例中，「变长字段长度列表」所占用的字节数是多少？\",\"「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。\",\"所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：\",\"条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；\",\"条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；\",\"我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。\",\"因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个\",\"变长字段长度」占用的字节数，也就是 2 字节。\",\"因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。\",\"在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下：varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532。\",\"我们先来测试看看 varchar(65533) 是否可行？\",\"...\",\"可以看到，还是不行，接下来看看 varchar(65532) 是否可行？\",\"...\",\"可以看到，创建成功了。\",\"说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。\",\"当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了：\",\"在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。\",\"多字段的情况下\",\"如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535。\",\"...\",\"行溢出后，MySQL 怎么处理\",\"Compact 行格式在发生行溢出后的处理\",\"MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是 16384字节，而一个 varchar(n) 类型的列最多可以存储 65532字节，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会发生行溢出，多的数据就会存到另外的「溢出页」中。\",\"如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。\",\"在一般情况下，InnoDB 的数据都是存放在 「数据页」中。\",\"但是当发生行溢出时，溢出的数据会存放到「溢出页」中。\",\"**当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，**然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。\",\"...\",\"Compressed 和 Dynamic\",\"Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。\",\"这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。\",\"而实际的数据都存储在溢出页中，看起来就像下面这样：\",\"...\",\"char 与 varchar 的区别\",\"主要从存储机制、性能差异理解\",\"测试环境\",\"MySQL：5.7.36 版本\",\"存储引擎： Innodb\",\"行格式(Row format)：DYNAMIC\",\"Innodb存储引擎支持多种行格式：REDUNDANT、COMPACT、DYNAMIC、COMPRESSED，不同行格式存储方式存在差异。\",\"默认行格式可以通过innodb_default_row_format变量查看:\",\"mysql> show variables like \\\"innodb\\\\_default\\\\_row\\\\_format\\\"; +---------------------------+---------+ | Variable\\\\_name | Value | +---------------------------+---------+ | innodb\\\\_default\\\\_row\\\\_format | dynamic | +---------------------------+---------+ 1 row in set (0.08 sec)\",\"varchar和char在MySQL层的区别\",\"根据MySQL的官方文档The CHAR and VARCHAR Types中的描述, varchar和char的区别主要有：\",\"最大长度：char是255，varchar是65535，单位是字符（而不是字节）。\",\"尾随空格：char会将尾随空格去掉，而varchar不会。 因为存储时，char会用空格填充至指定长度，所以取出时需要去除空格。 如果char字段有唯一索引，a和a 会提示唯一索引冲突。\",\"存储空间占用：varchar会占用额外的1~2字节来存储字符串长度。如果最大长度超过255，就需要2字节，否则1字节。\",\"注意：这是MySQL层的描述，具体怎么存储由存储引擎决定。\",\"varchar和char在存储引擎层的区别\",\"以下描述基于Innodb存储引擎、DYNAMIC行格式。\",\"varchar如何存储\",\"下面通过一个实验来看看，varchar在Innodb底层是如何存储的。\",\"创建一个带有varchar字段的表格，并插入2条记录：\",\"mysql> drop table test\\\\_string; Query OK, 0 rows affected (0.02 sec) mysql> create table test\\\\_string( -> id int(11) unsigned not null primary key auto\\\\_increment, -> code varchar(100) not null -> )charset=utf8mb4;; Query OK, 0 rows affected (0.03 sec) mysql> insert into test\\\\_string values(1, \\\"hello\\\"); Query OK, 1 row affected (0.01 sec) mysql> insert into test\\\\_string values(2, \\\"hhhhhhhhhh\\\"); Query OK, 1 row affected (0.01 sec)\",\"找到数据文件/var/lib/mysql/study/test_string.ibd，使用hexdump命令查看：\",\"hexdump -C test.ibd ...... // 省略一堆 0000c060 02 00 1b 69 6e 66 69 6d 75 6d 00 03 00 0b 00 00 |...infimum......| 0000c070 73 75 70 72 65 6d 75 6d 05 00 00 10 00 1c 00 00 |supremum........| 0000c080 00 01 00 00 00 00 08 28 c3 00 00 01 8d 01 10 68 |.......(.......h| 0000c090 65 6c 6c 6f 0a 00 00 18 ff d6 00 00 00 02 00 00 |ello............| 0000c0a0 00 00 08 2a c5 00 00 01 d1 01 10 68 68 68 68 68 |...\\\\*.......hhhhh| 0000c0b0 68 68 68 68 68 00 00 00 00 00 00 00 00 00 00 00 |hhhhh...........| 0000c0c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| ...... // 省略一堆\",\"其中，65 6c 6c 6f、 68 68 68 68 68 68 68 68 68 68为实际存储的数据：hello和hhhhhhhhhh\",\"05和0a分别对应字符串的长度5和10\",\"插入2条中文（多字节编码），分别是6个字和100个字：\",\"mysql> insert into test\\\\_string values(3, \\\"毛毛毛毛毛毛\\\"); Query OK, 1sq row affected (0.01 sec) mysql> insert into test\\\\_string values(4, \\\"毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛 毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛\\\"); Query OK, 1 row affected (0.01 sec)\",\"再次用hexdump命令查看：\",\"...... // 省略一堆 0000c0b0 68 68 68 68 68 12 00 00 20 00 2a 00 00 00 03 00 |hhhhh... .\\\\*.....| 0000c0c0 00 00 00 08 3f d3 00 00 01 d9 01 10 e6 af 9b e6 |...\\\\*.......aaaaaa| 0000c0d0 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b 2c 81 |..............,.| 0000c0e0 00 00 28 ff 8b 00 00 00 04 00 00 00 00 08 41 d5 |..(...........A.| 0000c0f0 00 00 01 9f 01 10 e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c100 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c110 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c120 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c130 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c140 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c150 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c160 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c170 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c180 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c190 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c1a0 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c1b0 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c1c0 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c1d0 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c1e0 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c1f0 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c200 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c210 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c220 af 9b 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| ...... // 省略一堆\",\"从输出中可以看到大量重复的e6 af 9b，这是使用utf8mb4编码的\\\"毛\\\"字。\",\"可以使用hex()函数来验证：\",\"mysql> select hex('毛'); +------------+ | hex('毛') |s +------------+ | E6AF9B | +------------+ 1 row in set (0.09 sec)\",\"1个“毛”字占用3个字节，插入的第1条中文“毛毛毛毛毛毛”占用18个字节， 对应上面标红的12（十六进制，转换为十进制是18）。\",\"类似的，第2条中文记录，100个汉字占用300个字节，对应上面的2c 81\",\"2c 81是逆序存储（行格式决定），转过来之后是81 2c。\",\"其中第1位二进制位表示字符长度大于127字节，除去第1位后，即01 2c对应十进制的300\",\"从上面的实验可以看出，varchar类型对于短字符串、长字符串、多字节编码，都是存储了实际的字符+字符长度。\",\"char如何存储\",\"接下来对比char类型的字符串，看看有什么区别。\",\"先创建一个表格：\",\"mysql> create table test\\\\_char( -> id int unsigned not null primary key auto\\\\_increment, -> code char(50) -> ) charset=utf8mb4; Query OK, 0 rows affected (0.03 sec)\",\"注意表格字段定义是char(50)，编码是 utf8mb4\",\"意味code字段着最多可以存储50*4=200个字节的数据。\",\"接下来插入几条测试数据（5个字母、50个字母、50个多字节文字）：\",\"mysql> insert into test\\\\_char values(1, \\\"hello\\\"), (2, 'aaaaasaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'), (3, \\\"毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛\\\"); Query OK, 3 rows affected (0.00 sec) Records: 3 Duplicates: 0 Warnings: 0\",\"再次使用hexdump命令查看文件中的数据：\",\"0000c060 02 00 1c 69 6e 66 69 6d 75 6d 00 04 00 0b 00 00 |...infimum......| 0000c070 73 75 70 72 65 6d 75 6d 32 00 00 00 10 00 4a 00 |supremum2.....J.| 0000c080 00 00 01 00 00 00 00 08 4a dc 00 00 01 dd 01 10 |........J.......| 0000c090 68 65 6c 6c 6f 20 20 20 20 20 20 20 20 20 20 20 |hello | 0000c0a0 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 | | 0000c0b0 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 | | 0000c0c0 20 20 32 00 00 00 18 00 4a 00 00 00 02 00 00 00 | 2.....J.......| 0000c0d0 00 08 4a dc 00 00 01 dd 01 1c 61 61 61 61 61 61 |..J.......aaaaaa| 0000c0e0 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 0000c0f0 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa| 0000c100 61 61 61 61 61 61 61 61 61 61 61 61 96 00 00 00 |aaaaaaaaaaaa....| 0000c110 20 ff 5d 00 00 00 03 00 00 00 00 08 4a dc 00 00 | .].........J...| 0000c120 01 dd 01 28 e6 af 9b e6 af 9b e6 af 9b e6 af 9b |...(............| 0000c130 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c140 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c150 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c160 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c170 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c180 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b |................| 0000c190 e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 |................| 0000c1a0 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af 9b e6 af |................| 0000c1b0 9b e6 af 9b e6 af 9b e6 af 9b 00 00 00 00 00 00 |................| 0000c1c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 0000c1d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|\",\"从上面内容可以看出，对于char类型的字段，innodb同样保存了字符长度。\",\"对于utf8mb4 char(50)来说，长度不够50字节的字符串，会使用空格（0x20）填充到50个字节（但不是最大长度200）。\",\"char和varchar存储对比\",\"char和varchar都会存储字符串长度\",\"对于CHAR(N)字段，如果实际存储数据小于N字节，会填充空格到N个字节。\",\"性能对比\",\"从char和varchar的存储结构对比，可以得出一个结论：\",\"char填充空格可能导致浪费存储空间，进而导致性能下降。\",\"因为char多存储一些空格，意味着需要从磁盘读写更多的数据、耗费更多内存、查找数据时删除空格可能也会耗费一些CPU性能。\",\"那与varchar相比，char字段是不是一无是处呢？\",\"大部分情况，是的，最好使用varchar。\",\"不过考虑一个极端的场景：某个字段的最大长度是100字节，但是会频繁修改。如果使用char(100)，则插入记录后就分配了100个字节，后续修改不会造成页分裂、页空隙等问题，而varchar(100)由于没有提前分配存储空间，后续修改时可能出现页分裂，进而导致性能下降。\",\"数据页\",\"。。。。。\"]},\"771\":{\"c\":[\"数据库\",\"MySQL\"]},\"772\":{\"c\":[\"MySQL\",\"InnoDB\",\"存储引擎\",\"数据库原理\"]},\"773\":{\"h\":\"MySQL事务机制详解\",\"t\":[\"MySQL事务是数据库操作的基本单位，能够保证数据的一致性和完整性。本文详细介绍事务的ACID特性、隔离级别以及实现原理。\"]},\"774\":{\"h\":\"1. 事务的ACID特性\",\"t\":[\"原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。\",\"一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。\",\"隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。\",\"持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\"]},\"775\":{\"h\":\"1.1 InnoDB 如何保证 ACID\",\"t\":[\"A：undo log（回滚日志）\",\"I：MVCC（多版本并发控制）\",\"D：redo log（重做日志）\",\"C：A+I+D\"]},\"776\":{\"h\":\"2. 并行事务引发的问题\",\"t\":[\"MySQL 支持多客户端连接，可能出现同时处理多个事务的情况。以下是并行事务可能引发的问题，按严重性排序：\",\"...\"]},\"777\":{\"h\":\"2.1 脏读 (Dirty Read)\",\"t\":[\"一个事务读到了另一个已修改的数据但是未提交事务，就会发生脏读。\",\"或者说，读到了过期数据。\"]},\"778\":{\"h\":\"2.2 不可重复读 (Non-repeatable Read)\",\"t\":[\"在一个事务内，多次读取同一个数据，出现了前后两次读到的数据不一样的情况，就发生了不可重复读。\"]},\"779\":{\"h\":\"2.3 幻读 (Phantom Read)\",\"t\":[\"在一个事务内，多次查询某个条件下的记录数量，如果出现了前后两次查询的记录数量不一样，就发生了幻读。\"]},\"780\":{\"h\":\"2.3.1 幻读的另一种解释\",\"t\":[\"假设此时平台要升级，用户表中的性别字段，原本是以「男、女」的形式保存数据，现在平台升级后要求改为「0、1」代替。\",\"事务A开始更改表中所有数据的性别字段，当负责执行事务A的线程正在更改最后一条表数据时\",\"**此时事务B来了，**正好向用户表中插入了一条「性别=男」的数据并提交了\",\"然后事务A改完原本的最后一条数据后，当再次去查询用户表时，结果会发现表中依旧还存在一条「性别=男」的数据，似乎又产生了幻觉一样\"]},\"781\":{\"h\":\"3. 事务隔离级别\"},\"782\":{\"h\":\"3.1 四种隔离级别\",\"t\":[\"RU：read uncommitted（读未提交）\",\"RC：read committed（读已提交）\",\"RR：repeatable read（可重复读）\",\"Serializable（串行化）\",\"...\"]},\"783\":{\"h\":\"3.2 MySQL 默认 RR 是否解决幻读\",\"t\":[\"回答：并不是完全解决了\",\"针对 快照读（普通 select 语句），是 通过 MVCC 方式解决了幻读\",\"因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。\",\"针对 当前读（select ... for update 等语句），是 通过 next-key lock（记录锁+间隙锁）方式解决了幻读\",\"因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题\"]},\"784\":{\"h\":\"3.3 四种隔离级别的实现方式\",\"t\":[\"**「读未提交」：**因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好\",\"**「串行化」：**通过加读写锁的方式来避免并行访问\",\"「读提交」和「可重复读」： 通过 Read View 来实现的，区别在于创建 Read View 的时机不同 \",\"「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View\",\"「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View\"]},\"785\":{\"h\":\"3.4 开启事务命令的区别\",\"t\":[\"两种事务开启命令：\",\"begin/start transaction\",\"start transaction with consistent snapshot\",\"开启时机：\",\"执行了 begin/start transaction 命令后，并不代表事务启动了。 只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；\",\"执行了 start transaction with consistent snapshot 命令，就会马上启动事务。\"]},\"786\":{\"h\":\"4. MVCC 机制\",\"t\":[\"通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）\"]},\"787\":{\"h\":\"4.1 Read View 的四个字段\",\"t\":[\"...\",\"creator_trx_id：代表创建当前这个ReadView的事务ID。\",\"m_ids：表示在生成当前ReadView时，系统内活跃且未提交的事务 ID列表。\",\"min_trx_id：活跃的事务列表中，最小的事务ID。\",\"max_trx_id：表示在生成当前ReadView时，系统中要给下一个事务分配的ID值\"]},\"788\":{\"h\":\"4.2 聚集索引记录中和事务有关的两个隐藏列\",\"t\":[\"隐藏列不止两个，以下是与事务相关的两个隐藏列：\",\"trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；\",\"roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。\",\"...\"]},\"789\":{\"h\":\"4.3 事务访问数据的可见性判断\",\"t\":[\"判定方法 --- 事务 read view 里的字段与记录中的两个隐藏列进行对比：\",\"如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前 已经提交的事务生成的，所以该版本的记录对当前事务 可见。\",\"如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后 才启动的事务生成的，所以该版本的记录对当前事务 不可见。\",\"如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中： \",\"如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务 不可见。\",\"如果记录的 trx_id 不在 m_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务 可见。\"]},\"790\":{\"h\":\"5. 可重复读与幻读问题\"},\"791\":{\"h\":\"5.1 可重复读的工作原理\",\"t\":[\"可重复读隔离级别是：启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View\"]},\"792\":{\"h\":\"5.2 可重复读是否完全解决幻读\",\"t\":[\"虽然是 MySQL 默认隔离级别，但是没有完全解决幻读\"]},\"793\":{\"h\":\"5.2.1 幻读场景1\",\"t\":[\"...\",\"事务 A 执行查询 id = 5 的记录，此时表中是没有该记录的，所以查询不出来。\",\"事务 B 插入一条 id = 5 的记录，并且提交了事务。\",\"事务 A 更新 id = 5 这条记录，对没错，事务 A 看不到 id = 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询 id = 5 的记录，事务 A 就能看到事务 B 插入的纪录了，幻读就是发生在这种违和的场景。\",\"解释：\",\"在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。\",\"接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。\",\"因为这种特殊现象的存在，所以我们认为 MySQL Innodb 中的 MVCC 并不能完全避免幻读现象\"]},\"794\":{\"h\":\"5.2.2 幻读场景2\",\"t\":[\"T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。\",\"T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；\",\"T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。\"]},\"795\":{\"h\":\"5.3 解决幻读的方法\",\"t\":[\"要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，会触发 Next-Key 锁\"]},\"796\":{\"h\":\"6. 读提交隔离级别的工作原理\",\"t\":[\"读提交隔离级别是：在每次读取数据时，都会生成一个新的 Read View\"]},\"797\":{\"c\":[\"数据库\",\"MySQL\"]},\"798\":{\"c\":[\"MySQL\",\"事务\",\"ACID\",\"隔离级别\"]},\"799\":{\"h\":\"MySQL原理分类\",\"t\":[\"本文对MySQL的核心原理进行分类介绍。\"]},\"800\":{\"h\":\"1. 基础架构\",\"t\":[\"MySQL采用客户端/服务器架构,主要包含:\",\"连接层 - 处理客户端连接\",\"服务层 - SQL解析优化执行\",\"存储引擎层 - 数据存储和读写\"]},\"801\":{\"h\":\"2. 事务机制\",\"t\":[\"事务是MySQL的重要特性,包括:\",\"ACID特性\",\"隔离级别\",\"MVCC多版本并发控制\",\"锁机制\"]},\"802\":{\"h\":\"3. 日志系统\",\"t\":[\"MySQL的主要日志包括:\",\"binlog - 二进制日志\",\"redo log - 重做日志\",\"undo log - 回滚日志\"]},\"803\":{\"h\":\"4. 索引体系\",\"t\":[\"索引是优化查询的关键:\",\"B+树索引\",\"哈希索引\",\"全文索引\",\"空间索引\"]},\"804\":{\"h\":\"5. 优化机制\",\"t\":[\"查询优化的核心机制:\",\"查询缓存\",\"执行计划优化\",\"统计信息收集\",\"成本估算\",\"原理分类\",\"...\"]},\"805\":{\"c\":[\"数据库\",\"MySQL\"]},\"806\":{\"c\":[\"MySQL\",\"原理\"]},\"807\":{\"h\":\"MySQL性能调优指南\",\"t\":[\"性能调优\",\"📎高性能mysql第三版.pdf\",\"explain 查看执行计划\",\"(十七)SQL优化篇：如何成为一位写优质SQL语句的绝顶高手！ - 掘金\",\"EXPLAIN是MySQL中一个非常有用的命令，用于分析SQL语句的执行计划。\",\"通过执行计划，我们可以了解SQL语句是如何被优化器执行的，包括是否使用了索引、表的扫描方式、数据的读取顺序等信息。\",\"以下是EXPLAIN命令输出中type、key、extra这三个字段的含义及如何通过它们来判断SQL语句是否使用了索引。\",\"type：这是一个重要的字段，表示MySQL决定如何查找表中的行的方法，或者说是join类型。\",\"type的值从最好到最差依次是：system > const > eq_ref > ref > range > index > ALL。\",\"system和const通常表示已经使用了索引，并且查询非常快；\",\"eq_ref和ref表示通过索引查找记录，但需要对多个记录进行比较；\",\"range表示使用了索引范围扫描；\",\"index表示全索引扫描；\",\"ALL表示全表扫描，通常是最慢的。\",\"key：这个字段显示了MySQL实际从表中使用的索引。\",\"如果key是NULL，表示没有使用索引。\",\"如果这个字段非空，说明查询使用了索引，字段的值就是被使用的索引的名称。\",\"extra：这个字段包含不适合在其他字段显示的额外信息。\",\"如果看到Using index，表示查询只使用了索引中的信息，没有读取实际的行数据，这通常意味着效率很高。\",\"如果看到Using where，表示MySQL服务器将存储引擎返回的行进行了额外的过滤，可能是因为索引返回的行比实际需要的行多。\",\"Using filesort和Using temporary通常表示查询效率不高，可能需要优化。\",\"通过查看这三个字段的值，你可以判断出SQL语句是否有效地使用了索引。\",\"如果type字段显示的是ALL或者index，并且key字段是NULL，或者extra字段出现了Using filesort或Using temporary，那么可能需要考虑添加或优化索引以提高查询效率。\",\"索引调优\",\"独立的列\",\"...\",\"换成：actor_id = 5 -1 ，就是独立的列\",\"前级索引和索引选择性\",\"用字段的前几个字符作为索引\",\"具体是几个字符，需要去测试：增加字符数量时，效率提升的幅度是否也大，是，则继续增大，一直到提升幅度很小，就不再增加\",\"前缀索引可以通过使用字段值的前几个字符来减少索引大小并提升查询效率。\",\"选择性是衡量索引效果的一个重要指标，选择性高的索引有助于更快地定位记录。\",\"联合索引\",\"通过将多个列组合成一个索引来优化特定查询。\",\"重要的是要根据查询模式和列的选择性来选择索引列的顺序。\",\"选择合适的索引列顺序\",\"在创建联合索引时，将最常用于查询条件且选择性最高的列放在前面。\",\"正确的列顺序可以最大化索引的效率。\",\"聚族索引\",\"也称为主键索引，是按照每个表的主键构建的，它决定了表中数据的物理排序，基于 B+树，所以主键是逻辑上相邻的（也是聚簇的意思）。\",\"聚簇索引可以加速主键查找，但是每个表只能有一个聚簇索引。\",\"覆盖索引\",\"当索引包含所有需要查询的字段时，查询可以直接使用索引而无需回表，这称为覆盖索引。\",\"覆盖索引可以显著减少数据访问次数，提高查询性能。\",\"使用索引扫描来做排序\",\"如果查询的ORDER BY子句与索引列对应，可以直接利用索引顺序进行排序，避免额外排序开销。\",\"压缩(前缀压缩)索引\",\"对于有共同前缀的字符串，可以使用前缀压缩来节省索引空间。\",\"压缩索引尤其在有大量重复前缀的情况下有效，可以提升索引扫描的效率。\",\"元余和重复索引\",\"定期审查索引，去除不必要的或重复的索引，这可以减少维护成本并提高写操作的性能。\",\"未使用的索引\",\"使用数据库的监控工具来识别和删除长时间未被查询使用的索引。\",\"这可以帮助释放存储空间，减少维护开销。\",\"索引和锁\",\"在事务型数据库中，索引可以影响锁的粒度和类型，从而影响并发性能。\",\"适当的索引策略可以减少锁冲突，提高事务处理速度。\",\"SQL 优化\",\"如何定位一条查询慢 SQL 语句\",\"是否请求了不需要的数据\",\"误区：mysql 只返回需要的数据\",\"MySQL 是先返回全部结果集再进行计算\",\"...\",\"挖坑：多表关联时返回全部列\",\"...\",\"挖坑：总是取出全部列\",\"别- -\",\"挖坑：重复查询相同数据\",\"...\",\"是否扫描了额外的记录\",\"三个衡量指标\",\"...\",\"响应时间\",\"没有一致的公式，事先估计一下查询需要哪些索引，执行计划是什么等等来估计一下上限\",\"扫描的行数和返回的行数\",\"...\",\"如何对慢查询 SQL 语进行优化\",\"(十七)SQL优化篇：如何成为一位写优质SQL语句的绝顶高手！ - 掘金\",\"SQL优化思路+经典案例分析 - 掘金\",\"查询时尽量不要使用*\",\"连表查询时尽量不要关联太多表\",\"多表查询时一定要以小驱大\",\"不要使用like左模糊和全模糊查询\",\"查询时尽量不要对字段做空值判断\",\"不要在条件查询=前对字段做任何运算\",\"!=、!<>、not in、not like、or...要慎用\",\"必要情况下可以强制指定索引\",\"避免频繁创建、销毁临时表\",\"尽量将大事务拆分为小事务执行\",\"从业务设计层面减少大量数据返回的情况\",\"尽量避免深分页的情况出现\",\"SQL务必要写完整，不要使用缩写法\",\"基于联合索引查询时请务必确保字段的顺序性\",\"客户端的一些操作可以批量化完成\",\"明确仅返回一条数据的语句可以使用limit 1\",\"利用慢查询日志\",\"一个复杂查询 or 多个简单查询\",\"...\",\"将外链接转成内连接\",\"使用等价变化规则\",\"优化 count()、min()、max()\",\"优化 where 子句\",\"使用合适的逻辑运算符，以避免在索引列上使用函数或计算\",\"限制使用 having 子句\",\"having 通常有关于过滤聚合函数的结果，在聚合函数之后进行过滤，可能非常慢\",\"尽量在 where 中过滤数据\",\"适当分页\",\"只查询用户当前需要查看的数据\",\"使用参数化查询\",\"防止 sql 注入攻击\",\"避免数据类型转换\",\"避免隐式转换：字符和整形之间\",\"分页场景如何优化\",\"MySQL 性能优化\",\"(十六)MySQL调优篇：单机数据库如何在高并发场景下健步如飞？ - 掘金\",\"在做性能优化时，你应该要清楚系统的性能瓶颈在哪儿\",\"到底是要调哪个位置？是线程模型？或是CPU调度？还是内存回收？亦是磁盘IO速率？\",\"针对不同层面有不同的优化方案\",\"MySQL 调优的五个维度\",\"客户端与连接层的优化：调整客户端DB连接池的参数和DB连接层的参数。\",\"MySQL结构的优化：合理的设计库表结构，表中字段根据业务选择合适的数据类型、索引。\",\"MySQL参数优化：调整参数的默认值，根据业务将各类参数调整到合适的大小。\",\"整体架构优化：引入中间件减轻数据库压力，优化MySQL架构提高可用性。\",\"编码层优化：根据库表结构、索引结构优化业务SQL语句，提高索引命中率。\",\"通常情况下，带来的性能收益排序为④ > ② > ⑤ > ③ > ①，不过带来的性能收益越大，也就意味着成本会更高\",\"连接层优化\",\"数据库连接数\",\"情景：单库\",\"数据库连接数过多\",\"一个用户请求最终会分配一条线程处理，一个 32 核心的 CPU，数据库连接数配置 300 个，最多只能有 32 个线程同时工作，以时间片调度的模式工作，不同核心在不同线程之间反复切换执行，由于线程数远超核心数，线程的上下文切换开销远远大于线程执行开销\",\"客户端连接池 and 服务端连接池\",\"对比而言，无需关心 mysql 连接池，重点是客户端连接池的连接数。\",\"在客户端做了连接限制，服务端自然也就被限制\",\"客户端连接池 和 服务端连接池 配置一样的最大连接数可以吗？\",\"不行，有时候通过终端工具远程连接 MySQL，如果一致，你不就连不上了\",\"应该配置为多少呢\",\"PostgreSQL提供的计算公式：最大连接数 = (CPU核心数 * 2) + 有效磁盘数\",\"有效磁盘数：SSD 固态硬盘\",\"偶发高峰类业务的连接数配置\",\"情景：单库\",\"最大连接数按公式\",\"常驻连接数可以配置成 CPU 核数 + 1\",\"分库分表情况下的连接数配置\",\"情景：分库分表、读写分离、双主双写\",\"结构优化\",\"表结构、字段结构、索引结构\",\"表结构\",\"字段数量不能太多，一张表最多最多 30 个字段\",\"设计表结构时，正常情况下，应该遵循数据库三范式\",\"实时性不高的，建立中间表，比如游戏战力排名，每日定时统计一次\",\"字段结构\",\"在保证足够使用的范围内，选择最小数据类型，因为它们会占用更少的磁盘、内存和CPU缓存，同时在处理速度也会更快。\",\"尽量避免索引字段值为NULL，定义字段时应尽可能使用NOT NULL关键字，因为字段空值过多会影响索引性能。\",\"在条件允许的情况下，尽量使用最简单的类型代替复杂的类型，如IP的存储可以使用int而并非varchar，因为简单的数据类型，操作时通常需要的CPU资源更少\",\"索引结构\",\"索引字段尽量选择多个，节省磁盘资源\",\"充分利用索引覆盖\",\"值较长的字段，尽量建立前缀索引，而不使用完整字段值\",\"经常做模糊查询的字段，建立全文索引来代替。基于普通索引做 like 查询会导致索引失效\",\"某些不会做范围查询的字段建立索引，选用 hash 结构代替 B+Tree\",\"参数优化\",\"提供给用户控制的参数都有几百个，所以想要真正的做好参数优化，必须要对MySQL真正的熟悉才行\",\"调整 Inno DB 缓冲区\",\"比例控制在机器内存的 70%~75%\",\"官方建议每个缓冲区空间必须大于 1GB\",\"调整工作线程的缓冲区\",\"调整临时表空间\",\"调整空闲线程的存活时间\",\"架构优化与 SQL 优化\",\"引入中间件解决读压力\",\"在应用程序和数据库之间架设一个 redis 缓存\",\"...\",\"引入消息中间件解决写压力\",\"MQ 消息中间件做削峰填谷\",\"...\",\"主从读写分离\",\"架设了 MQ、Redis 后，必须走 mysql 执行的请求依旧超出单机 MySQL 承载范围，依旧会频繁宕机\",\"架构优化方案，分别是指三种：主从架构、双主架构、分库分表架构\",\"典型主从架构\",\"主节点数据变更后，从节点会基于 binlog 日志去同步。\",\"问题：这种模式下会存在些许数据不一致\",\"...\",\"双主双写+热备份\",\"注意每张表的主键要设置好，如果主键是自增类型，要手动设置自增步长起始值。\",\"节点1：[1、3、5、7、9、11、13、15、17、19.....]\",\"节点2：[2、4、6、8、10、12、14、16、18、20.....]\",\"确保主键唯一性\",\"...\",\"分库分表\",\"根据业务属性的不同，会创建不同的数据库，然后由不同的业务连接不同的数据库，各自之间数据分开存储，节点之间数据不会同步，以这种方式来部署MySQL，即提高了数据库的整体吞吐量和并发能力，同时也不存在之前的存储容量的木桶问题。\",\"...\"]},\"808\":{\"c\":[\"数据库\",\"MySQL\"]},\"809\":{\"c\":[\"MySQL\",\"性能优化\",\"调优\",\"性能监控\"]},\"810\":{\"h\":\"MySQL日志系统原理详解\",\"t\":[\"日志\",\"执行一条查询语句的过程\",\"一条查询语句经历的过程，这属于「读」一条记录的过程，如下图：\",\"...\",\"执行一条更新语句的过程\",\"执行一条 update 语句，期间发生了什么？比如这一条 update 语句：\",\"UPDATE t\\\\_user SET name = 'xiaolin' WHERE id = 1;\",\"查询语句的那一套流程，更新语句也是同样会走一遍：\",\"客户端先通过连接器建立连接，连接器自会判断用户身份；\",\"因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；\",\"解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；\",\"预处理器会判断表和字段是否存在；\",\"优化器确定执行计划，因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；\",\"执行器负责具体执行，找到这一行，然后更新。\",\"三种日志系统\",\"更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：\",\"undo log（回滚日志） ：是 Innodb 存储引擎层生成的日志，实现了事务中的 原子性 ，主要 用于事务回滚和 MVCC。\",\"redo log（重做日志） ：是 Innodb 存储引擎层生成的日志，实现了事务中的 持久性 ，主要 用于掉电等故障恢复 ；\",\"binlog （归档日志） ：是 Server 层生成的日志，主要 用于数据备份和主从复制 ；\",\"Undo log：用于撤销已经执行的修改，保证事务的原子性和一致性；\",\"Redo log：用于重做已经提交的修改，保证事务的持久性；\",\"Binlog：用于记录和重放SQL语句，用于数据的复制和恢复。\",\"undo log\",\"为什么需要 undo log\",\"事务隐式开启\",\"隐式开启事务\",\"我们在执行执行一条\\\"增删改\\\"语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会 隐式开启事务 来执行\\\"增删改\\\"语句的，执行完就自动提交事务的，这样就保证了执行完\\\"增删改\\\"语句后，我们可以及时在数据库表看到\\\"增删改\\\"的结果了。\",\"执行一条语句是否自动提交事务\",\"执行一条语句是否自动提交事务，是由 autocommit 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的。\",\"崩溃如何回滚\",\"那一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？\",\"如果我们每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。\",\"undo log\",\"实现这一机制就是：undo log（回滚日志），它保证了事务的 ACID 特性 中的原子性（Atomicity） 。\",\"undo log 是一种用于撤销回退的日志。\",\"在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：\",\"...\",\"undo 如何记录\",\"每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：\",\"在 插入 一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录 删掉 就好了；\",\"在 删除 一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录 插入 到表中就好了；\",\"在 更新 一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列 更新为旧值 就好了。\",\"undo 如何回滚\",\"在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。\",\"比如当 delete 一条记录时，undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。\",\"不同的操作，需要记录的内容也是不同的，所以不同类型的操作（修改、删除、新增）产生的 undo log 的格式也是不同的，具体的每一个操作的 undo log 的格式我就不详细介绍了，感兴趣的可以自己去查查。\",\"undo log 格式\",\"一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：\",\"通过 trx_id 可以知道该记录是被哪个事务修改的；\",\"通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；\",\"版本链如下图：\",\"...\",\"undo+RView 实现 MVCC\",\"通过 ReadView + undo log 实现 MVCC（多版本并发控制）\",\"对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同：\",\"「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\",\"「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。\",\"这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）\",\"undo log 两大作用\",\"实现事务回滚，保障事务的原子性 。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。\",\"实现 MVCC（多版本并发控制）关键因素之一 。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。\",\"undo log 是如何刷盘的\",\"undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。\",\"buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。\",\"redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。\",\"Buffer Pool\",\"为什么需要 Buffer Pool\",\"MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。\",\"那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢？\",\"当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。\",\"为此，Innodb 存储引擎设计了一个 缓冲池（Buffer Pool） ，来提高数据库的读写性能。\",\"...\",\"有了 Buffer Pool 后：\",\"当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。\",\"当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。\",\"Buffer Pool 缓存什么\",\"InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。\",\"在 MySQL 启动的时候， InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的 16KB 的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页 。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。\",\"所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系。\",\"Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。\",\"...\",\"Undo 页是记录什么？\",\"开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\",\"查询一条记录，就只需要缓冲一条记录吗？\",\"不是的。\",\"当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。\",\"redo log\",\"为什么需要 redo log\",\"Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。\",\"为了防止断电导致数据丢失的问题\",\"当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来， 这个时候更新就算完成了 。\",\"后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术 。\",\"WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上 。\",\"过程如下图：\",\"...\",\"redo log\",\"redo log 是物理日志，记录了某个数据页做了什么修改\",\"比如 对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新 ，每当执行一个事务就会产生这样的一条或者多条物理日志。\",\"在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。\",\"当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。\",\"被修改 Undo 页面，需要记录对应 redo log 吗？\",\"需要的。\",\"开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。\",\"不过， 在内存修改该 Undo 页面后，需要记录对应的 redo log 。\",\"redo log 和 undo log 区别在哪？\",\"这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：\",\"redo log 记录了此次事务「 完成后 」的数据状态，记录的是更新 之后 的值；\",\"undo log 记录了此次事务「 开始前 」的数据状态，记录的是更新 之前 的值；\",\"事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：\",\"...\",\"所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 crash-safe （崩溃恢复）。可以看出来， redo log 保证了事务四大特性中的持久性 。\",\"redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？\",\"写入 redo log 的方式使用了追加操作， 所以磁盘操作是 顺序写\",\"写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是 随机写 。\",\"磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。\",\"针对「顺序写」为什么比「随机写」更快这个问题，可以比喻为你有一个本子，按照顺序一页一页写肯定比写一个字都要找到对应页写快得多。\",\"可以说这是 WAL 技术的另外一个优点： MySQL 的写操作从磁盘的「随机写」变成了「顺序写」 ，提升语句的执行性能。\",\"这是因为 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。\",\"至此， 针对为什么需要 redo log 这个问题我们有两个答案：\",\"实现事务的持久性，让 MySQL 有 crash-safe 的能力 ，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；\",\"将写操作从「随机写」变成了「顺序写」 ，提升 MySQL 写入磁盘的性能。\",\"产生的 redo log 是直接写入磁盘的吗？\",\"不是的。\",\"实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。\",\"所以，redo log 也有自己的缓存—— redo log buffer ，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：\",\"...\",\"redo log buffer 默认大小 16 MB，可以通过 innodb_log_Buffer_size 参数动态的调整大小，增大它的大小可以让 MySQL 处理「大事务」是不必写入磁盘，进而提升写 IO 性能。\",\"redo log 什么时候刷盘？\",\"缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？\",\"主要有下面几个时机：\",\"MySQL 正常关闭时；\",\"当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；\",\"InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。\",\"每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制）\",\"innodb_flush_log_at_trx_commit 参数控制的是什么？\",\"单独执行一个更新语句的时候，InnoDB 引擎会自己启动一个事务，在执行更新语句的过程中，生成的 redo log 先写入到 redo log buffer 中，然后等事务提交的时候，再将缓存在 redo log buffer 中的 redo log 按组的方式「顺序写」到磁盘。\",\"上面这种 redo log 刷盘时机是在事务提交的时候，这个默认的行为。\",\"除此之外，InnoDB 还提供了另外两种策略，由参数 innodb_flush_log_at_trx_commit 参数控制，可取的值有：0、1、2，默认值为 1，这三个值分别代表的策略如下：\",\"当设置该 参数为 0 时 ，表示每次事务提交时 ，还是 将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。\",\"当设置该 参数为 1 时 ，表示每次事务提交时，都 将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘 ，这样可以保证 MySQL 异常重启之后数据不会丢失。\",\"当设置该 参数为 2 时 ，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘 ，因为操作系统的文件系统中有个 Page Cache（Page Cache 是专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。\",\"画了一个图：\",\"...\",\"innodb_flush_log_at_trx_commit 为 0 和 2 的时候，什么时候才将 redo log 写入磁盘？\",\"InnoDB 的后台线程每隔 1 秒：\",\"针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 write() 写到操作系统的 Page Cache，然后调用 fsync() 持久化到磁盘。 所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失 ;\",\"针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。 所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失 。\",\"加入了后台现线程后，innodb_flush_log_at_trx_commit 的刷盘时机如下图：\",\"...\",\"这三个参数的应用场景是什么？\",\"这三个参数的数据安全性和写入性能的比较如下：\",\"数据安全性：参数 1 > 参数 2 > 参数 0\",\"写入性能：参数 0 > 参数 2> 参数 1\",\"所以，数据安全性和写入性能是熊掌不可得兼的， 要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性 。\",\"在一些对数据安全性要求比较高的场景中，显然 innodb_flush_log_at_trx_commit 参数需要设置为 1。\",\"在一些可以容忍数据库崩溃时丢失 1s 数据的场景中，我们可以将该值设置为 0，这样可以明显地减少日志同步到磁盘的 I/O 操作。\",\"安全性和性能折中的方案就是参数 2，虽然参数 2 没有参数 0 的性能高，但是数据安全性方面比参数 0 强，因为参数 2 只要操作系统不宕机，即使数据库崩溃了，也不会丢失数据，同时性能方便比参数 1 高。\",\"redo log 文件写满了怎么办？\",\"默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ： ib_logfile0 和 ib_logfile1 。\",\"...\",\"在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。\",\"重做日志文件组是以 循环写 的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。\",\"所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。\",\"...\",\"我们知道 redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，那么如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，这时候我们擦除这些旧记录，以腾出空间记录新的更新操作。\",\"redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置，如下图：\",\"...\",\"图中的：\",\"write pos 和 checkpoint 的移动都是顺时针方向；\",\"write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；\",\"check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；\",\"如果 write pos 追上了 checkpoint，就意味着 redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞 （ 因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要 ）\",\"此时 会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针） ，然后 MySQL 恢复正常运行，继续执行新的更新操作。\",\"所以，一次 checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记 redo log 哪些记录可以被覆盖的过程。\",\"binlog\",\"undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。\",\"MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。\",\"binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。\",\"为什么有了 binlog， 还要有 redo log？\",\"这个问题跟 MySQL 的时间线有关系。\",\"最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。\",\"而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。\",\"redo log 和 binlog 有什么区别？\",\"这两个日志有四个区别。\",\"1、适用对象不同：\",\"binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；\",\"redo log 是 Innodb 存储引擎实现的日志；\",\"2、文件格式不同：\",\"binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：\",\"STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；\",\"ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；\",\"MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；\",\"redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；\",\"3、写入方式不同：\",\"binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。\",\"redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。\",\"4、用途不同：\",\"binlog 用于备份恢复、主从复制；\",\"redo log 用于掉电等故障恢复。\",\"如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？\",\"不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。\",\"因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。\",\"binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。\",\"主从复制是怎么实现？\",\"MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。\",\"这个过程一般是 异步 的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。\",\"...\",\"MySQL 集群的主从复制过程梳理成 3 个阶段：\",\"写入 Binlog ：主库写 binlog 日志，提交事务，并更新本地存储数据。\",\"同步 Binlog ：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。\",\"回放 Binlog ：回放 binlog，并更新存储引擎中的数据。\",\"具体详细过程如下：\",\"MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端\\\"操作成功\\\"的响应。\",\"从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库\\\"复制成功\\\"的响应。\",\"从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。\",\"在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。\",\"...\",\"从库是不是越多越好？\",\"不是的。\",\"因为从库数量增加，从库连接上来的 I/O 线程也比较多， 主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽 。\",\"所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。\",\"MySQL 主从复制还有哪些模型？\",\"主要有三种：\",\"同步复制 ：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。\",\"异步复制 （默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。\",\"半同步复制 ：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种 半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险 。\",\"binlog 什么时候刷盘？\",\"事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。\",\"一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。\",\"这是因为有一个线程只能同时有一个事务在执行的设定，所以每当执行一个 begin/start transaction 的时候，就会默认提交上一个事务，这样如果一个事务的 binlog 被拆开的时候，在备库执行就会被当做多个事务分段自行，这样破坏了原子性，是有问题的。\",\"MySQL 给每个线程分配了一片内存用于缓冲 binlog ，该内存叫 binlog cache，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。\",\"什么时候 binlog cache 会写到 binlog 文件？\",\"在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：\",\"...\",\"虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：\",\"图中的 write，指的就是指把日志写入到 binlog 文件，但是并没有把数据持久化到磁盘，因为数据还缓存在文件系统的 page cache 里，write 的写入速度还是比较快的，因为不涉及磁盘 I/O。\",\"图中的 fsync，才是将数据持久化到磁盘的操作，这里就会涉及磁盘 I/O，所以频繁的 fsync 会导致磁盘的 I/O 升高。\",\"MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：\",\"sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；\",\"sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；\",\"sync_binlog =N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。\",\"在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。\",\"而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。\",\"如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。\",\"再看 update 语句的执行过程\",\"当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。\",\"具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 的流程如下:\",\"执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：\",\"如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；\",\"如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。\",\"执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：\",\"如果一样的话就不进行后续更新流程；\",\"如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；\",\"开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。\",\"InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。 为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术 ：MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。\",\"至此，一条记录更新完了。\",\"在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。\",\"事务提交，剩下的就是「两阶段提交」的事情了，接下来就讲这个。\",\"两阶段提交\",\"为什么要两阶段提交？\",\"问题：两份日志之间的逻辑不一致\",\"事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。\",\"举个例子，假设 id = 1 这行数据的字段 name 的值原本是 'jay'，然后执行 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：\",\"如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入 。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id = 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；\",\"如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入 。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id = 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；\",\"可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。\",\"解决：两阶段提交\",\"MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决 ，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。\",\"两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」 ，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。\",\"注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。\",\"举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？\",\"准备阶段 ：裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。\",\"提交阶段 ：如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。\",\"两阶段提交的过程是怎样的？\",\"在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了 内部 XA 事务 （是的，也有外部 XA 事务），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。\",\"当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务， 分两阶段来完成 XA 事务的提交 ，如下图：\",\"...\",\"从图中可看出，事务的提交过程有两个阶段，就是 将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog ，具体如下：\",\"prepare 阶段 ：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；\",\"commit 阶段 ：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；\",\"异常重启会出现什么现象？\",\"我在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？\",\"下图中有时刻 A 和时刻 B 都有可能发生崩溃：\",\"...\",\"不管是时刻 A（redo log 已经写入磁盘， binlog 还没写入磁盘），还是时刻 B （redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃， 此时的 redo log 都处于 prepare 状态 。\",\"XID\",\"XID是事务标识符（Transaction Identifier）的缩写。在数据库管理系统中，每个事务都会被分配一个唯一的标识符，即XID，来跟踪和管理事务的状态。这在处理分布式事务和两阶段提交（2PC）协议时尤为重要。\",\"在MySQL中，当使用XA事务（XA代表扩展架构）进行分布式事务处理时，XID用于标识全局事务。XA事务是一种遵循XA规范的事务，该规范定义了两个或更多的数据库资源管理器如何在全局事务中协同工作的标准。在XA事务中，XID确保即使事务跨越多个数据库系统，它们也可以被正确地协调和管理。\",\"在两阶段提交中，XID用于在准备（prepare）阶段和提交（commit）或回滚（rollback）阶段跟踪事务。它允许事务协调器（通常是数据库系统或应用程序中的一个组件）在崩溃恢复时检查事务的状态，并根据binlog中的信息确定是否提交或回滚事务。\",\"例如，如果数据库系统在事务的提交过程中崩溃，当系统重启并恢复时，它会检查redo log中标记为prepare状态的事务。使用XID，系统可以检查binlog中是否存在对应的事务记录。如果存在，表示事务已经成功写入所有必要的日志，应该提交；如果不存在，表示事务在写入binlog之前崩溃，应该回滚。通过这种方式，XID帮助数据库系统在崩溃后保持数据的一致性和完整性。\",\"在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：\",\"如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务 。对应时刻 A 崩溃恢复的情况。\",\"如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务 。对应时刻 B 崩溃恢复的情况。\",\"可以看到， 对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID ，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。\",\"所以说， 两阶段提交是以 binlog 写成功为事务提交成功的标识 ，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。\",\"处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?\",\"binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。\",\"所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。\",\"事务没提交的时候，redo log 会被持久化到磁盘吗？\",\"会的。\",\"事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。\",\"也就是说， 事务没提交的时候，redo log 也是可能被持久化到磁盘的 。\",\"如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？\",\"放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。\",\"所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。\",\"两阶段提交有什么问题？\",\"两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：\",\"磁盘 I/O 次数高 ：对于\\\"双1\\\"配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。\",\"锁竞争激烈 ：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。\",\"为什么两阶段提交的磁盘 I/O 次数会很高？\",\"binlog 和 redo log 在内存中都对应的缓存空间，binlog 会缓存在 binlog cache，redo log 会缓存在 redo log buffer，它们持久化到磁盘的时机分别由下面这两个参数控制。一般我们为了避免日志丢失的风险，会将这两个参数设置为 1：\",\"当 sync_binlog = 1 的时候，表示每次提交事务都会将 binlog cache 里的 binlog 直接持久到磁盘；\",\"当 innodb_flush_log_at_trx_commit = 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘；\",\"可以看到，如果 sync_binlog 和 当 innodb_flush_log_at_trx_commit 都设置为 1，那么在每个事务提交过程中， 都会 至少调用 2 次刷盘操作 ，一次是 redo log 刷盘，一次是 binlog 落盘，所以这会成为性能瓶颈。\",\"为什么锁竞争激烈？\",\"在早期的 MySQL 版本中，通过使用 prepare_commit_mutex 锁来保证事务提交的顺序，在一个事务获取到锁时才能进入 prepare 阶段，一直到 commit 阶段结束才能释放锁，下个事务才可以继续进行 prepare 操作。\",\"通过加锁虽然完美地解决了顺序一致性的问题，但在并发量较大的时候，就会导致对锁的争用，性能不佳。\",\"组提交\",\"MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数 ，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。\",\"引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：\",\"flush 阶段 ：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；\",\"sync 阶段 ：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；\",\"commit 阶段 ：各个事务按顺序做 InnoDB commit 操作；\",\"上面的 每个阶段都有一个队列 ，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。\",\"...\",\"对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来， 锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率 。\",\"有 binlog 组提交，那有 redo log 组提交吗？\",\"这个要看 MySQL 版本，MySQL 5.6 没有 redo log 组提交，MySQL 5.7 有 redo log 组提交。\",\"在 MySQL 5.6 的组提交逻辑中，每个事务各自执行 prepare 阶段，也就是各自将 redo log 刷盘，这样就没办法对 redo log 进行组提交。\",\"所以在 MySQL 5.7 版本中，做了个改进，在 prepare 阶段不再让事务各自执行 redo log 刷盘操作，而是推迟到组提交的 flush 阶段，也就是说 prepare 阶段融合在了 flush 阶段。\",\"这个优化是将 redo log 的刷盘延迟到了 flush 阶段之中，sync 阶段之前。通过延迟写 redo log 的方式，为 redolog 做了一次组写入，这样 binlog 和 redo log 都进行了优化。\",\"每个阶段的过程\",\"每个阶段的过程段的过程，注意下面的过程针对的是\\\"双 1\\\" 配置（sync_binlog 和 innodb_flush_log_at_trx_commit 都配置为 1）。\",\"flush 阶段：支撑 redo log 的组提交\",\"第一个事务会成为 flush 阶段的 Leader，此时后面到来的事务都是 Follower ：\",\"...\",\"接着，获取队列中的事务组，由绿色事务组的 Leader 对 redo log 做一次 write + fsync，即一次将同组事务的 redolog 刷盘：\",\"...\",\"完成了 prepare 阶段后，将绿色这一组事务执行过程中产生的 binlog 写入 binlog 文件（调用 write，不会调用 fsync，所以不会刷盘，binlog 缓存在操作系统的文件系统中）。\",\"...\",\"从上面这个过程，可以知道 flush 阶段队列的作用是 用于支撑 redo log 的组提交 。\",\"如果在这一步完成后数据库崩溃，由于 binlog 中没有该组事务的记录，所以 MySQL 会在重启后回滚该组事务。\",\"sync 阶段：用于支持 binlog 的组提交\",\"绿色这一组事务的 binlog 写入到 binlog 文件后，并不会马上执行刷盘的操作，而是 会等待一段时间 ，这个等待的时长由 Binlog_group_commit_sync_delay 参数控制， 目的是为了组合更多事务的 binlog，然后再一起刷盘 ，如下过程：\",\"...\",\"不过，在等待的过程中，如果事务的数量提前达到了 Binlog_group_commit_sync_no_delay_count 参数设置的值，就不用继续等待了，就马上将 binlog 刷盘，如下图：\",\"...\",\"从上面的过程，可以知道 sync 阶段队列的作用是 用于支持 binlog 的组提交 。\",\"如果想提升 binlog 组提交的效果，可以通过设置下面这两个参数来实现：\",\"binlog_group_commit_sync_delay= N ，表示在等待 N 微妙后，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘，也就是将「 binlog 文件」持久化到磁盘。\",\"binlog_group_commit_sync_no_delay_count = N ，表示如果队列中的事务数达到 N 个，就忽视binlog_group_commit_sync_delay 的设置，直接调用 fsync，将处于文件系统中 page cache 中的 binlog 刷盘。\",\"如果在这一步完成后数据库崩溃，由于 binlog 中已经有了事务记录，MySQL会在重启后通过 redo log 刷盘的数据继续进行事务的提交。\",\"commit 阶段：承接 sync 阶段的事务，完成最后的引擎提交\",\"最后进入 commit 阶段，调用引擎的提交事务接口，将 redo log 状态设置为 commit。\",\"...\",\"commit 阶段队列的作用是承接 sync 阶段的事务，完成最后的引擎提交，使得 sync 可以尽早的处理下一组事务，最大化组提交的效率。\",\"MySQL 磁盘 I/O 很高，有什么优化的方法？\",\"现在我们知道事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，那么如果出现 MySQL 磁盘 I/O 很高的现象，我们可以通过控制以下参数，来 \\\"延迟\\\" binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率：\",\"设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。 这个方法是基于\\\"额外的故意等待\\\"来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。\",\"将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。 但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。\",\"将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。 但是这样做的风险是，主机掉电的时候会丢数据。\",\"总结\",\"具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 的流程如下:\",\"执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：\",\"如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；\",\"如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。\",\"执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：\",\"如果一样的话就不进行后续更新流程；\",\"如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；\",\"开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。\",\"InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术 ，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。\",\"至此，一条记录更新完了。\",\"在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。\",\"事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：\",\"prepare 阶段 ：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；\",\"commit 阶段 ：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；\",\"至此，一条更新语句执行完成。\"]},\"811\":{\"c\":[\"数据库\",\"MySQL\"]},\"812\":{\"c\":[\"MySQL\",\"日志系统\",\"binlog\",\"redo log\",\"undo log\"]},\"813\":{\"h\":\"MySQL索引原理详解\",\"t\":[\"索引\",\"索引是数据的目录\",\"索引和数据存储在存储引擎中\",\"...\",\"查询优化器可以使用索引来快速定位数据，而不必针对给定查询扫描表中的每一行\",\"但是需要额外的写入和存储来维护索引\",\"索引分类\",\"按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。\",\"按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。\",\"按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。\",\"按「字段个数」分类：单列索引、联合索引。\",\"每一种存储引擎支持的索引类型不一定相同\",\"MySQL 5.5 后 InnoDB 成为默认存储引擎，同时也支持选择 MyISAM、Memory 等引擎\",\"按数据结构分类\",\"...\",\"在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：\",\"如果有主键，默认会使用主键作为聚簇索引的索引键（key）\",\"如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）\",\"在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）\",\"索引数据结构\",\"索引是提升查询速度的一种数据结构：在插入时对数据进行了排序，当然是会影响插入性能的。\",\"InnoDB 存储引擎支持的索引有：B+树索引、全文索引、R 树索引\",\"重点关注使用最广泛的 B+树索引\",\"B+树索引结构\",\"使用广泛\",\"几乎所有关系型数据库都支持 B+索引，因为在海量数据基于磁盘存储效率足够优秀。\",\"比广泛用于内存的数据结构：二叉树、哈希索引、红黑树、跳表....都优秀\",\"B+树索引特点\",\"基于磁盘的平衡树，但是树非常矮，通常是 3~4 层，能存放千万到上亿的排序数据\",\"树矮，意味着访问效率高，从千万的数据里查询一条数据，只用 3~4 次 IO\",\"容量\",\"...\",\"B+树组成\",\"根节点：存放索引\",\"中间节点（非叶子节点）：存放索引\",\"叶子节点：存放实际数据（索引+记录）\",\"...\",\"在 InnoDB 中，B+树有些许变化\",\"B+树的叶子节点之间使用双向链表连接，好处是能能往左往右遍历\",\"B+树每一个节点内容是一个数据页，数据页存放了用户的记录以及各种信息，每个数据页默认大小16KB\",\"...\",\"B+树索引组织过程\",\"所有 B+树都是从高度为 1 的树开始，随着数据插入，慢慢增加树的高度。\",\"所有的数据在插入时就已经排好序，在叶子节点内用二分查找快速定位数据\",\"随着索引记录变多，一个 16KB 的页无法存放那么多数据，就会发生 B+树的分裂，高度变为 2\",\"随着高度增加，中间节点也会随之增加，其中根节点和中间节点（非叶子节点）存放：**索引键值对（索引键+指针），**两者在 InnoDB 存储引擎中占用 6 个字节 索引键：就是排序的列 指针：指向下一层的地址\",\"单点查询\",\"B 树单个索引查询最快是 O1，平均而言也会比 B+树稍快\",\"但是 B 树的查询波动大，每个系欸但即存索引又存记录，可能在非叶子节点就能找到索引，有时候又需要到叶子节点才能找到索引\",\"B+树的非叶子节点不存放实际数据，仅仅存放索引，在数据量相同的情况下，相比 B 树，B+树的非叶子节点能存放更多索引。因此 B+树可以比 B 树更加矮胖，磁盘 IO 次数更少\",\"插入、删除效率\",\"结论：B+ 树的插入和删除效率高\",\"删除\",\"B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快。\",\"删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：\",\"...\",\"删除 B 树 0008 节点的过程，可能会导致树的复杂变化：\",\"...\",\"删除 B+ 树根节点的过程： B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形\",\"...\",\"B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形\",\"删除 B 树根节点的过程：\",\"...\",\"插入\",\"B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。\",\"而且 B+ 树会自平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。\",\"范围查询\",\"B+树所有叶子节点之间有一个链表进行连接，对范围查找非常有帮助\",\"比如：想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。\",\"聚集索引和二级索引B+树的区别\",\"InnoDB 根据索引类型不同，分为聚索引和二级索引\",\"表的数据都是存放在聚集索引的叶子节点，所以 InnoDB 引擎一定会为表创建一个聚集索引，只会保存一份，所以聚集索引只能有一个，二级索引能有多个\",\"聚集索引\",\"叶子节点：存放实际数据\",\"所有完整的用户记录都存放在聚集索引的叶子节点\",\"二级索引\",\"叶子节点：存放主键值，不存放实际数据\",\"二级索引 B+树：\",\"...\",\"回表\",\"回表：如果查询语句使用了二级索引，会先在二级索引的 B+树找到主键值，再去聚集索引 B+树种获得实际数据行。需要查两个 B+树\",\"索引覆盖\",\"只查询 建立主键索引的列或二级索引的列 的数据都可以说是发生了索引覆盖，能在非叶子节点中直接获取数据，不需要再去访问实际的数据行（回表）， 也就是只需要查一个 B+树\",\"核心概念就是通过索引就能满足查询需求，而不需要访问实际的数据行（回表操作）。\",\"如果查询只涉及到建立主键索引或者二级索引的列，数据库引擎可以直接在索引的非叶子节点中获取所需数据，而无需额外的回表操作。\",\"这样的查询过程可以在索引结构中完成，通常是在 B+ 树这样的索引结构中进行。\",\"如果SELECT的列既包含索引列，也包含其他非索引列，那么就要看具体情况是否能实现索引覆盖。\",\"GPT： 索引覆盖要求所有查询需要的列都在索引中。如果非索引列也包含在SELECT语句中，数据库引擎可能需要访问实际的数据行来获取非索引列的值，这时就不再是纯粹的索引覆盖。\",\"在某些情况下，数据库引擎可能会通过索引的叶子节点获取非索引列的值，这被称为“覆盖索引”（Covering Index）。覆盖索引是一种特殊的索引覆盖情况，允许通过索引直接满足查询需求，而不必访问实际的数据行。这种情况下，查询的性能仍然会受益于索引的使用。\",\"总的来说，如果查询中包含了索引列和其他非索引列，要关注数据库引擎是否能够通过索引覆盖或者覆盖索引来提高查询性能。这通常取决于具体的数据库系统和查询优化器的实现。\",\"索引存储\",\"数据的 2 种存储方式\",\"堆表\",\"索引组织表（MySQL 使用，说白了就是指 B+树的节点内是数据页，索引即数据，数据即索引）\",\"堆表\",\"堆表中的数据无序存放，数据的排序完全依赖于索引\",\"都是二级索引，所有的查询都需要回表\",\"Oracle、Microsoft SQL Server、PostgreSQL 早期默认支持的数据存储都是堆表结构\",\"...\",\"从图中你能看到，堆表的组织结构中，数据和索引分开存储。\",\"索引是排序后的数据，而堆表中的数据是无序的，索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生改变，且位置发生了变更，所有索引中的地址都要更新，这非常影响性能\",\"索引组织表\",\"MySQL InnoDB 存储引擎就是这样的数据组织方式\",\"Oracle、Microsoft SQL Server 后期也推出了支持索引组织表的存储方式。\",\"据根据主键排序存放在索引中，主键索引也叫聚集索引（Clustered Index）。\",\"在索引组织表中，数据即索引，索引即数据。\",\"聚集索引\",\"不需要回表\",\"二级索引\",\"优点：若行数据发生了变化，其他索引无需进行维护，除非主键发生了增删修改\",\"麻烦：需要回表（二级索引通过主键索引进行再一次查询）\",\"在“数据即索引，索引即数据”之上理解二级索引\",\"二级索引：name。 查询 name 的过程拆解\",\"SELECT id FROM idx\\\\_name WHERE name = ? SELECT \\\\* FROM User WHERE id = \\\\_id; -- 回表\",\"插入数据：可以理解成对主键索引表、二级索引表进行了一个事务操作，要么都成功，要么都不成功\",\"函数索引\",\"联合索引\",\"对回表频率高的查询，建立组合索引，走索引覆盖，减少磁盘 IO\",\"单列索引查询暴露的性能问题\",\"单列查询\",\"前置条件：表只对 class 单列建立索引\",\"查询条件：class = 3\",\"排序条件：score\",\"过程：需要先回表所有数据，建立临时表，依据 score 进行排序\",\"...\",\"using filesort 对查询性能的影响\",\"对 score 排序，排序是在内存排序，还是外部文件排序，要看排序的数据量是否超过 sort_buffer_size 大小。\",\"**内存排序：**将筛选出来的记录，存放到【内存临时表】，然后根据对应的字段进行【快速排序】\",\"外部文件排序：内存放不下时，会把一部分排序的结果放在磁盘上，空出内存空间，继续排序，所以外部排序一般使用【归并排序】。 可以这么简单理解，MySQL 将需要排序的数据分成 12 份，每一份单独排序后存在这些临时文件中，然后把这 12 个有序文件再合并成一个有序的大文件。\",\"优化：建立联合索引\",\"建立联合索引（class, score）\",\"对表建立联合索引之后，执行计划如下：\",\"...\",\"能在联合索引 B+树中走索引覆盖（减少了回表），而且 score 字段还有局部排序（减轻了排序性能消耗）\",\"联合索引最左匹配原则\",\"原则\",\"规则 1：MySQL 会从联合索引从最左边的索引列开始匹配查询条件，然后依次从从左到右的顺序匹配，如果查询条件没有使用到某个列，那么该列右边的所有列都无法使用走索引。\",\"规则 2：当查询条件中使用了某个列，但是该列的值包含范围查询，范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引\",\"规则 1\",\"...\",\"规则 2\",\"联合索引（class，scroe） select \\\\* from test where class > 2 and score = 80 // class 能走索索引，score 不能走索引\",\"B+树：\",\"...\",\"Class > 2 查询得到的记录：\",\"...\",\"可以看到，score 的记录并不是有序的，所以 score 无法走联合索引\",\"--> 索引一定是有序的列\",\"索引下推\",\"没有索引下推的查询过程\",\"...\",\"有索引下推的查询过程\",\"...\",\"索引下推的优化\",\"索引下推在 mysql 5.6 的优化机制，默认开启\",\"如果条件判断字段 在二级索引 B+树中，就会下推到 InnoDB 存储引擎层来过滤，过滤完的记录才会回表，相比没有索引下推，减少了回表次数\",\"判断联合索引字段能不能走索引\",\"联合索引 （a,b,c），下面的查询语句会不会走索引？如果走具体是哪些字段能走？\",\"select * from T where a=1 and b=2 and c=3;\",\"select * from T where a=1 and b>2 and c=3;\",\"select * from T where c=1 and a=2 and b=3;\",\"select * from T where a=2 and c=3;\",\"select * from T where b=2 and c=3;\",\"select (a,b) from T where a=1 and b>2\",\"答案：\",\"遵循最左匹配原则，所以 abc 三个字段都可以走索引，查询方式是在联合索引找到主键值后，会回主键索引找完整的数据行。\",\"根据最左匹配原则，范围查询后面的字段无法使用索引，所以 ab 可以走索引，c 无法走索引，不过 c 可以进行索引下推。\",\"abc都能走索引，因为 where 查询条件字段的顺序并不会影响，MySQL 优化器会帮我们调整字段的查询顺序，所以也是符合最左匹配原则的。\",\"a 能走索引，根据最左匹配原则，c 无法走索引，但是 c 可以被索引下推\",\"根据最左匹配原则，bc都无法走索引。\",\"a 和 b 都能走索引，查询方式是覆盖查询（索引覆盖），不需要回表\",\"where a>1 and b = 2 and c <3怎么建立索引？\",\"创建(abc)、(acb)、(ab)、(ac)联合索引，只有 a 能索引\",\"创建(cab)、(cba)、(ca)、(cb)联合索引，只有 c 能索引\",\"创建(ba)联合索引，b 和 a 都能走索引\",\"创建(bc)联合索引，b 和 c 都能走索引\",\"创建 (bac) 联合索引，b 和 a 都能走索引，但比 (ba)联合索引多了一个好处，c 字段能索引下推，会减少回表的次数；\",\"创建 (bca) 联合索引，b 和 c 都能走索引，但比 (bc)联合索引多了一个好处，a 字段能索引下推，会减少回表的次数；\",\"where a>100 and b=100 and c=123 order by d 怎么建立联合索引？\",\"如果是 bcad 联合索引的话，虽然 bca 能走索引，但是排序 d 无法利用索引（因为 a 范围查询了，而 d 是局部有序性），会发生 file sort。 不过起码能索引下推。。\",\"如果 bcda 联合索引，d 不仅能利用索引有序性（全局有序性，因为范围查询 a 排在最右边），避免 file sort，a 虽然都不了索引，但是可以索引下推，所以建立(bcda)联合索引会比较好。\",\"select * from t where a > 1 and b = 100 or c = 99 怎么优化？\",\"前置知识：联合索引用了 or，索引就会失效。or 左右两边都是独立索引才能走索引。\",\"优化：建立（b，a）联合索引 + c 单列索引\",\"索引失效\",\"索引失效会导致全表扫描\",\"对索引使用左/左右模糊匹配\",\"当使用左、左右模糊匹配会导致索引失效：like %xx、like %xx%\",\"右模糊匹配不会导致索引失效：like x%\",\"因为索引 B+树，是按照索引值有序排列存储的，只能根据前缀进行比较\",\"name like '%好'vsname like '好%'\",\"name like '%好' ：因为查询的结果可能是「你好、不好、很好」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询\",\"name like '好%'：第一个字“好”已经确定，能与其他索引比较拼音大小，进而不会导致索引失效\",\"对索引使用函数\",\"索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然没法走索引\",\"怎么优化\",\"建立一个函数索引\",\"对索引进行表达式计算\",\"索引保存的是索引字段的原始值，而不是经过 id + 1 计算后的值，自然没法走索引\",\"explain select \\\\* from t\\\\_user where id + 1 = 10;\",\"优化\",\"改成 id = 10 - 1，就可以走索引了\",\"又不是很优化\",\"在对索引进行简单的表达式计算，在特殊处理后，可以做到索引扫描，但是 mysql 没有主动实现，只能是用户自行处理。\",\"可能原因：表达式计算的情况多种多样，每种都考虑的话，代码可能臃肿。。\",\"对索引隐式类型转换\",\"索引字段是字符串类型，在条件查询中，输入的是整型，会走全表扫描\",\"索引字段是整型，在条件查询中，输入的是字符串类型，会走索引\",\"MySQL 数据类型转换规则\",\"遇到字符串和数字比较时，会自动把字符串转为数字，然后在进行比较\",\"例子：select “10” > 9\",\"如果规则是 MySQL 会将自动「字符串」转换成「数字」，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；\",\"如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select \\\"10\\\" > \\\"9\\\"，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） 那么\\\"10\\\"字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。\",\"结果：\",\"...\",\"转换的过程是使用了函数\",\"既然是使用函数，自然会索引失效\",\"相当于：\",\"select \\\\* from t\\\\_user where CAST(phone AS signed int) = 1300000001;\",\"联合索引非最左匹配\",\"联合索引的最左匹配原则\",\"对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。\",\"那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。\",\"创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。\",\"联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。\",\"比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：\",\"where a=1；\",\"where a=1 and b=2 and c=3；\",\"where a=1 and b=2；\",\"需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。\",\"但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:\",\"where b=2；\",\"where c=3；\",\"where b=2 and c=3；\",\"索引截断\",\"有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？\",\"这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。\",\"MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。\",\"索引下推\",\"从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。\",\"索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 (a, b, c) 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。\",\"比如下面这条 where a = 1 and c = 0 语句，我们可以从执行计划中的 Extra=Using index condition 使用了索引下推功能。\",\"...\",\"为什么联合索引不遵循最左匹配原则就会失效？\",\"原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。\",\"也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。\",\"where 子句的 or\",\"在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\",\"举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。\",\"select \\\\* from t\\\\_user where id = 1 or age = 18;\",\"...\",\"这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。\",\"要解决办法很简单，将 age 字段设置为索引即可。\",\"...\",\"可以看到 type=index merge， index merge 的意思就是对 id 和 age 分别进行了扫描，然后将这两个结果集进行了合并，这样做的好处就是避免了全表扫描。\",\"索引选择\",\"如何选择索引 - 优化器\",\"确定执行计划\",\"B+树只是一种存储的数据结构，具体怎么使用，还要依赖数据库的优化器，优化器决定了具体的索引选择，生成执行计划。\",\"CBO：基于成本的优化器\",\"nysql 的优化器的选择基于成本 cost，哪个索引的成本的成本越低，优先使用哪个。\",\"Cost = Server Cost + Engine Cost = CPU Cost + IO Cost\",\"Server：负责 sql 语句的执行过程\",\"Engine：负责具体的存储数据\",\"...\",\"记录成本的表\",\"server_cost\",\"engine_cost\",\"具体内容\",\"...\",\"含义\",\"**表 server_cost：**记录了 Server 层优化器各种操作的成本，这里面包括了所有 CPU Cost，其具体含义如下：\",\"disk_temptable_create_cost：创建磁盘临时表的成本，默认为20。\",\"disk_temptable_row_cost：磁盘临时表中每条记录的成本，默认为0.5。\",\"key_compare_cost：索引键值比较的成本，默认为0.05，成本最小。\",\"memory_temptable_create_cost：创建内存临时表的成本：默认为1。\",\"memory_temptable_row_cost：内存临时表中每条记录的成本，默认为0.1。\",\"row_evaluate_cost：记录间的比较成本，默认为0.1。\",\"**表 engine_cost：**记录了存储引擎层各种操作的成本，这里包含了所有的 IO Cost，具体含义如下：\",\"io_block_read_cost：从磁盘读取一个页的成本，默认值为1。\",\"memory_block_read_cost：从内存读取一个页的成本，默认值为0.25\",\"也就是说， MySQL 优化器认为从磁盘读取的开销是内存开销的 4 倍。\",\"索引应用\",\"索引优劣分析\",\"优势\",\"整个数据库中，数据表的查询速度直线提升，数据量越大时效果越明显。\",\"通过创建唯一索引，可以确保数据表中的数据唯一性，无需额外建立唯一约束。\",\"在使用分组和排序时，同样可以显著减少SQL查询的分组和排序的时间。\",\"连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。\",\"索引默认是B+Tree有序结构，基于索引字段做范围查询时，效率会明显提高。\",\"从MySQL整体架构而言，减少了查询SQL的执行时间，提高了数据库整体吞吐量。\",\"劣势\",\"建立索引会生成本地磁盘文件，需要额外的空间存储索引数据，磁盘占用率会变高。\",\"写入数据时，需要额外维护索引结构，增、删、改数据时，都需要额外操作索引。\",\"写入数据时维护索引需要额外的时间开销，执行写SQL时效率会降低，性能会下降\",\"索引陷阱\",\"主键索引陷阱\",\"陷阱：uuid 作为主键\",\"理解：uuid 能保证全局 id 唯一性，但是 B+树有序的，uuid 确实无序的随机值， uuid 会导致每次插入都需要调整树结构\",\"联合索引陷阱\",\"陷阱：索引截断\",\"理解：违反联合索引最左前缀原则\",\"前缀索引陷阱\",\"特点：是短小精悍，我们可以利用一个字段的前N个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显\",\"陷阱：没存储字段的完整值，无法使用分组、排序等 sql\",\"全文索引陷阱\",\"特点：性能比like%快 n 倍\",\"陷阱：\",\"由于全文索引是基于分词实现的，所以对一个字段建立全文索引后，MySQL会对该字段做分词处理，这些分词结果也会被存储在全文索引中，因此全文索引的文件会额外的大\",\"由于全文索引对每个字段值都会做分词，因此当修改字段值后，分词是需要时间的，所以修改字段数据后不会立马自动更新全文索引，此时需要自行写存储过程，并调用它手动更新全文索引中的数据。\",\"全文索引最大的硬伤在于对中文支持不够友好，类似于英文可以直接通过符号、空格来分词，但中文呢？一个词语来形容就是博大精深，无法精准的对一段文字做分词，因此全文索引在检索中文时，存在些许精准度问题。\",\"解决：项目规模大，可用尝试引入 Elastic Search、Solr、MeiliSearch 等搜索引擎\",\"唯一索引陷阱\",\"唯一索引查询数据时，会比普通索引快上一截，但插入数据时就不同了，因为要确保数据不重复，所以插入前会检查一遍表中是否存在相同的数据。但普通索引则不需要考虑这个问题，因此普通索引的数据插入会快一些。\",\"哈希索引陷阱\",\"哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。\",\"索引建立原则\",\"表中哪个字段建立一个索引能带来最大的性能收益？\",\"经常频繁用作查询条件的字段应酌情考虑为其创建索引。\",\"表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。\",\"建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。\",\"建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。\",\"建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。\",\"经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。\",\"对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为Hash结构。\",\"尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。\"]},\"814\":{\"c\":[\"数据库\",\"MySQL\"]},\"815\":{\"c\":[\"MySQL\",\"索引\",\"B+树\",\"性能优化\"]},\"816\":{\"h\":\"MySQL逻辑架构详解\",\"t\":[\"本文详细介绍MySQL的逻辑架构及SQL语句的执行流程。\"]},\"817\":{\"h\":\"1. MySQL架构概述\",\"t\":[\"逻辑架构\",\"执行一条 select 语句，期间发生了什么？\",\"mysql 是典型的 C/S 架构，服务端程序使用 mysqld\",\"客户端进程向服务器进程发送一段文本（SQL 语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）\",\"MySQL 逻辑架构图\",\"概念解释\",\"Connectors：客户端\",\"Connection Pool：连接池\",\"Management Services & Utilities：基础服务组件\",\"SQL Interface：SQL 接口\",\"Parser：解析器\",\"Optimizer：优化器\",\"Cache & Buffers：缓存\",\"Pluggable Storage Engines：插件式存储引擎\",\"File system：文件系统\",\"Logs：日志系统\",\"...\",\"...\",\"...\",\"架构分层关系\",\"连接层\",\"外部客户端\",\"服务层\",\"Server 层负责建立连接、分析和执行 SQL\",\"MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。\",\"另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现\",\"引擎层\",\"存储引擎层负责数据的存储和提取 支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。\",\"现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。\",\"我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同。\",\"比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引\",\"一条 SQL 的执行过程\",\"第一步：连接器\",\"连接过程\",\"连接数据库\",\"第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。\",\"连接器负责跟客户端建立连接、获取权限、维持和管理连接。\",\"连接命令一般是这么写的：mysql -h$ip -P$port -u$user -p\",\"连接的过程需要先经过 TCP 三次握手\",\"如果服务端没有启动 Mysql 服务，会报错\",\"如果服务端已经启动 Mysql 服务，完成 TCP 连接后，就会验证你的用户名和密码\",\"顺利，连接器会获取该用户的权限，然后保存起来。此后该用户在此连接的任何操作都会基于连接时保存的权限进行逻辑判断\",\"⚠️如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置\",\"注意事项\",\"查看 MySQL 服务被多少个客户端连接了\",\"命令：show processlist\",\"...\",\"空闲连接会一直占用多久\",\"MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。\",\"mysql> show variables like 'wait\\\\_timeout'; +---------------+-------+ | Variable\\\\_name | Value | +---------------+-------+ | wait\\\\_timeout | 28800 | +---------------+-------+ 1 row in set (0.00 sec)\",\"手动断开空闲的连接，使用命令：kill connection + id\",\"mysql> kill connection +6; Query OK, 0 rows affected (0.00 sec)\",\"一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错 “ERROR 2013 (HY000): Lost connection to MySQL server during query”。\",\"Mysql 有连接限制\",\"MySQL 服务支持的最大连接数由 max_connections 参数控制，比如 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示：\",\"“Too many connections”。\",\"长连接和短连接\",\"// 短连接 连接 mysql 服务（TCP 三次握手） 执行sql 断开 mysql 服务（TCP 四次挥手） // 长连接 连接 mysql 服务（TCP 三次握手） 执行sql 执行sql 执行sql .... 断开 mysql 服务（TCP 四次挥手）\",\"长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。\",\"但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。\",\"如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象\",\"如何解决长连接占用内存的问题\",\"定期断开长连接。 既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。\",\"客户端主动重置连接。 MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。\",\"这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。\",\"总结\",\"连接器的工作做完了，简单总结一下：\",\"与客户端进行 TCP 三次握手建立连接；\",\"校验客户端的用户名和密码，如果用户名或密码不对，则会报错；\",\"如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；\",\"第二步：查询缓存\",\"查询过程\",\"客户端向 MySQL 服务发送 SQL 语句\",\"MySQL 服务收到 SQL 语句\",\"解析出 SQL 语句的第一个字段，看看是什么类型的语句\",\"如果是查询语句（select），mysql 先去查缓存（Query Cache）\",\"如果之前执行过这一条命令，就会在缓存中以 key-value 形式保存在内存：key 为查询语句，value 为查询结果\",\"在缓存中查到，返回数据给客户端\",\"在缓存中查不到，就往下执行，执行完成后，查询结果也会更新到查询缓存中\",\"缓存很鸡肋\",\"对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。\",\"如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。\",\"所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。\",\"对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。\",\"TIP\",\"这里说的查询缓存是 server 层的，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool\",\"第三步：解析器 解析 SQL 语句\",\"正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成\",\"解析器解析 sql 过程\",\"第一件事：词法分析\",\"MySQL 会根据你输入的字符串识别出关键字出来。\",\"例如，SQL语句 select username from userinfo\",\"在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from：\",\"...\",\"点击图片可查看完整电子表格\",\"第二件事：语法分析\",\"根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等\",\"...\",\"如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。\",\"比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。\",\"...\",\"注意事项\",\"但是注意，表不存在或者字段不存在，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的。\",\"但是经过 MySQL 源码（5.7和8.0）得出结论是：解析器只负责检查语法和构建语法树，但是不会去查表或者字段存不存在。\",\"那在哪个阶段？？？往下看\",\"第四步：执行 SQL\",\"经过解析器后，接着就要进入执行 SQL 查询语句的流程了\",\"每条SELECT查询语句流程主要可以分为下面这三个阶段：\",\"prepare 阶段，也就是预处理阶段；\",\"optimize 阶段，也就是优化阶段；\",\"execute 阶段，也就是执行阶段；\",\"预处理器阶段\",\"本阶段完成的工作\",\"检查 SQL 查询语句中的表或者字段是否存在；\",\"将 select * 中的 * 符号，扩展为表上的所有列；\",\"检查表或字段是否存在\",\"MySQL 8.0：在 prepare 阶段，不在解析器中\",\"MySQL 5.7：在词法分析&语法分析之后，prepare 阶段之前做的。\",\"结论都一样，不是在解析器里做的\",\"优化器阶段\",\"本阶段完成的工作\",\"优化器主要负责将 SQL 查询语句的执行方案确定下来\",\"比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。\",\"输出执行计划\",\"在查询语句最前面加个 explain 命令输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引\",\"比如下图的 key 为 PRIMARY 就是使用了主键索引。\",\"...\",\"索引的类型\",\"主键索引\",\"全盘扫描\",\"...\",\"二级索引/普通索引：主键外的索引\",\"索引覆盖\",\"索引覆盖\",\"这时 product 表就有主键索引（id）和普通索引（name）。\",\"假设执行了这条查询语句：\",\"select id from product where id > 1 and name like 'i%';\",\"这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。\",\"这时，就需要优化器来决定使用哪个索引了。\",\"很显然这条查询语句是覆盖索引，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了\",\"因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。\",\"在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。\",\"...\",\"执行器阶段\",\"经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。\",\"在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。\",\"三种执行过程\",\"主键索引查询\",\"全表扫描\",\"索引下推\",\"主键索引查询\",\"查询语句为例，看看执行器是怎么工作的。\",\"select \\\\* from product where id = 1;\",\"这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：\",\"执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 id = 1 交给存储引擎，让存储引擎定位符合条件的第一条记录。\",\"存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；\",\"执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。\",\"执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。\",\"至此，这个语句就执行完成了。\",\"全表扫描\",\"举个全表扫描的例子：\",\"select \\\\* from product where name = 'iphone';\",\"这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：\",\"执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，让存储引擎读取表中的第一条记录；\",\"执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。\",\"执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；\",\"一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；\",\"执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。\",\"至此，这个语句就执行完成了。\",\"索引下推\",\"在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。\",\"索引下推能够减少二级索引在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。\",\"举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：\",\"...\",\"现在有下面这条查询语句：\",\"select \\\\* from t\\\\_user where age > 20 and reward = 100000;\",\"联合索引当遇到范围查询 (>、<) 就会停止匹配，也就是 age 字段能用到联合索引，但是 reward 字段则无法利用到索引。\",\"具体原因这里可以看这篇：索引常见面试题(opens new window)\",\"不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：\",\"Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；\",\"存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后进行回表操作，将完整的记录返回给 Server 层；\",\"Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；\",\"接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；\",\"如此往复，直到存储引擎把表中的所有记录读完。\",\"可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。\",\"而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：\",\"Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；\",\"存储引擎定位到二级索引后，先不执行回表操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给 Server 层。\",\"Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。\",\"如此往复，直到存储引擎把表中的所有记录读完。\",\"可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。\",\"当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。\",\"...\",\"总结\",\"连接器：建立连接，管理连接、校验用户身份；\",\"查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；\",\"解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；\",\"执行 SQL：执行 SQL 共有三个阶段：\",\"预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。\",\"优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划（主键索引查询、全表扫描、索引下推）；\",\"执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；\"]},\"818\":{\"c\":[\"数据库\",\"MySQL\"]},\"819\":{\"c\":[\"MySQL\",\"逻辑架构\",\"SQL执行流程\"]},\"820\":{\"h\":\"MySQL锁机制详解\",\"t\":[\"锁\",\"MySQL 有哪些锁？\",\"根据加锁的范围，可以分为 全局锁、表级锁和行锁 三类。\",\"全局锁： FTWRL\",\"表级锁：表锁、元数据锁、意向锁、AUTO-INC 锁\",\"行级锁：Record Lock、Gap Lock、Next-key Lock\",\"全局锁\",\"全局锁用法\",\"要使用全局锁，则要执行这条命令：\",\"flush tables with read lock\",\"执行后， 整个数据库就处于只读状态了 ，这时其他线程执行以下操作，都会被阻塞：\",\"对数据的增删改操作，比如 insert、delete、update等语句；\",\"对表结构的更改操作，比如 alter table、drop table 等语句。\",\"如果要释放全局锁，则要执行这条命令：\",\"unlock tables\",\"当然，当会话断开了，全局锁会被自动释放。\",\"全局锁应用场景\",\"全局锁主要应用于做 全库逻辑备份 ，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。\",\"全局锁的缺点\",\"加上全局锁，意味着整个数据库都是只读状态。\",\"那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。\",\"那有什么其他方式可以避免？\",\"有的，如果数据库的引擎支持的事务支持 可重复读的隔离级别 ，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。\",\"因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。\",\"备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务。\",\"这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。\",\"InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。\",\"但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。\",\"表级锁\",\"表级锁类型\",\"MySQL 里面表级别的锁有这几种：\",\"表锁；\",\"元数据锁（MDL;\",\"意向锁；\",\"AUTO-INC 锁；\",\"表锁\",\"如果我们想对学生表（t_student）加表锁，可以使用下面的命令：\",\"//表级别的共享锁，也就是读锁； lock tables t\\\\_student read; //表级别的独占锁，也就是写锁； lock tables t\\\\_stuent write;\",\"需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。\",\"也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。\",\"要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：\",\"unlock tables\",\"另外，当会话退出后，也会释放所有表锁。\",\"不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能， InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁 。\",\"元数据锁\",\"**元数据：**描述数据库结构、表、列、索引等信息的数据\",\"元数据锁 （MDL）\",\"我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：\",\"对一张表进行 CRUD 操作时，加的是 MDL 读锁 ；\",\"对一张表做结构变更操作的时候，加的是 MDL 写锁 ；\",\"MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。\",\"当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。\",\"反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。\",\"MDL 不需要显示调用，那它是在什么时候释放的?\",\"MDL 是在事务提交后才会释放，这意味着 事务执行期间，MDL 是一直持有的 。\",\"那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：\",\"首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；\",\"然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；\",\"接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，\",\"那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。\",\"为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？\",\"这是因为申请 MDL 锁的操作会形成一个队列，队列中 写锁获取优先级高于读锁 ，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。\",\"所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。\",\"意向锁\",\"在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」\",\"在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」\",\"也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。\",\"而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。\",\"不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：\",\"//先在表上加上意向共享锁，然后对读取的记录加共享锁 select ... lock in share mode; //先表上加上意向独占锁，然后对读取的记录加独占锁 select ... for update;\",\"意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（ lock tables ... read ）和独占表锁（ lock tables ... write ）发生冲突。\",\"表锁和行锁是满足读读共享、读写互斥、写写互斥的。\",\"如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。\",\"那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。\",\"意向锁的目的是为了快速判断表里是否有记录被加锁 。\",\"AUTO-INC 锁\",\"AUTO-INC 锁是特殊的表锁机制：锁不是在 一个事务提交后才释放，而是再执行完插入语句后就会立即释放 。\",\"表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。\",\"之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁 实现的。\",\"在插入数据时，会加一个表级别的 AUTO-INC 锁 ，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。\",\"那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。\",\"但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。\",\"轻量级锁\",\"在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种 轻量级的锁 来实现自增。\",\"一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁， 然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁 。\",\"参数控制 inc 锁 or 轻量级锁\",\"InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。\",\"当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；\",\"当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。\",\"当 innodb_autoinc_lock_mode = 1：\",\"普通 insert 语句，自增锁在申请之后就马上释放；\",\"类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；\",\"当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生 数据不一致的问题 。\",\"举个例子，考虑下面场景：\",\"session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后 两个 session 同时执行向表 t2 中插入数据 。\",\"如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：\",\"session B 先插入了两个记录，(1,1,1)、(2,2,2)；\",\"然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；\",\"之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。\",\"可以看到， session B 的 insert 语句，生成的 id 不连续 。\",\"当「主库」发生了这种情况，binlog 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 binlog_format=statement，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。\",\"但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在 从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致 。\",\"要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。\",\"所以， 当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题 。\",\"行级锁\",\"InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁\",\"前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。\",\"如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为 锁定读 。\",\"//对读取的记录加共享锁 select ... lock in share mode; //对读取的记录加独占锁 select ... for update;\",\"上面这两条语句必须在一个事务中， 因为当事务提交了，锁就会被释放 ，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。\",\"共享锁（S锁）满足读读共享，读写互斥。\",\"独占锁（X锁）满足写写互斥、读写互斥。\",\"行级锁的类型主要有三类：\",\"Record Lock，记录锁，也就是仅仅把一条记录锁上；\",\"Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；\",\"Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\",\"Record Lock\",\"Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：\",\"...\",\"当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;\",\"当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。\",\"举个例子\",\"当一个事务执行了下面这条语句：\",\"mysql > begin; mysql > select \\\\* from t\\\\_test where id = 1 for update;\",\"就是对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。\",\"当事务执行 commit 后，事务过程中生成的锁都会被释放。\",\"Gap Lock\",\"Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。\",\"假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。\",\"间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别， 间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的 。\",\"Next-Key Lock\",\"Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。\",\"锁上界，不锁下界（？，？]\",\"假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。\",\"所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。\",\"兼容问题\",\"next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的 。\",\"比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。\",\"虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。\",\"插入意向锁 （不是意向锁）\",\"一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。\",\"插入意向锁名字虽然有意向锁，但是它并 不是意向锁，它是一种特殊的间隙锁，属于行级别锁 。\",\"如果有的话，插入操作就会发生 阻塞 ，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个 插入意向锁 ，表明有事务想在某个区间插入新记录，但是现在处于等待状态。\",\"举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。\",\"当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（ PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁 ），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。\",\"如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。\",\"插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。\",\"加锁\",\"什么 sql 会加锁\",\"通的 select 语句是不会对记录加锁的，因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。\",\"如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为 锁定读\",\"//对读取的记录加共享锁(S型锁) select ... lock in share mode; //对读取的记录加独占锁(X型锁) select ... for update;\",\"怎么加行级锁\",\"行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。\",\"加锁对象是 索引\",\"加锁的基本单位是 next-key lock，next-key lock 是前开后闭区间\",\"next-key lock 在一些场景下会退化成记录锁或间隙锁\",\"在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成退化成记录锁或间隙锁\",\"唯一索引 等值查询\",\"用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：\",\"当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会 退化成「记录锁」 。\",\"当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会 退化成「间隙锁」 。\",\"记录存在的情况\",\"假设事务 A 执行了这条等值查询语句，查询的记录是「存在」于表中的。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select \\\\* from user where id = 1 for update; +----+--------+-----+ | id | name | age | +----+--------+-----+ | 1 | 路飞 | 19 | +----+--------+-----+ 1 row in set (0.02 sec)\",\"那么，事务 A 会为 id 为 1 的这条记录就会加上 X 型的记录锁 。\",\"...\",\"为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock 会退化成记录锁？\",\"原因就是在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读的问题。\",\"由于主键具有唯一性，所以 其他事务插入 id = 1 的时候，会因为主键冲突，导致无法插入 id = 1 的新记录 。这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。\",\"由于对 id = 1 加了记录锁， 其他事务无法删除该记录 ，这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。\",\"记录不存在的情况\",\"假设事务 A 执行了这条等值查询语句，查询的记录是「不存在」于表中的。\",\"mysql> begin; Query OK, 0 rows affected (0.00 sec) mysql> select \\\\* from user where id = 2 for update; Empty set (0.03 sec)\",\"通过select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"...\",\"从上图可以看到，共加了两个锁，分别是：\",\"表锁：X 类型的意向锁；\",\"行锁：X 类型的间隙锁；\",\"因此， 此时事务 A 在 id = 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)。\",\"...\",\"间隙锁的范围 (1, 5) ，是怎么确定的？\",\"如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围「右边界」，此次的事务 A 的 LOCK_DATA 是 5。\",\"然后锁范围的「左边界」是表中 id 为 5 的上一条记录的 id 值，即 1。\",\"因此，间隙锁的范围 (1, 5) 。\",\"唯一索引 范围查询\",\"范围查询和等值查询的加锁规则是不同的。\",\"当唯一索引进行范围查询时， 会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁 ：\",\"情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会 退化成记录锁 。\",\"情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：\",\"当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询， 扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁 ，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。\",\"当条件值的记录在表中，如果是「小于」条件的范围查询， 扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁 ，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。\",\"加锁对象不是 索引\",\"非唯一索引 等值查询\",\"非唯一索引 范围查询\",\"死锁\",\"死锁的发生\",\"建了一张订单表，其中 id 字段为主键索引，order_no 字段普通索引，也就是非唯一索引：\",\"CREATE TABLE t\\\\_order ( id int NOT NULL AUTO\\\\_INCREMENT, order\\\\_no int DEFAULT NULL, create\\\\_date datetime DEFAULT NULL, PRIMARY KEY ( id ), KEY index\\\\_order ( order\\\\_no ) USING BTREE ) ENGINE=InnoDB ;\",\"然后，先 t_order 表里现在已经有了 6 条记录：\",\"...\",\"假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：\",\"...\",\"可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。\",\"这里在查询记录是否存在的时候，使用了 select ... for update 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。\",\"如果没有使用 select ... for update 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：\",\"...\",\"为什么会产生死锁？\",\"可重复读隔离级别下，是存在幻读的问题。\",\"Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁 ，它是记录锁和间隙锁的组合。\",\"Record Lock，记录锁，锁的是记录本身；\",\"Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。\",\"普通的 select 语句是不会对记录加锁的，因为它是通过 MVCC 的机制实现的快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式：\",\"begin; //对读取的记录加共享锁 select ... lock in share mode; commit; //锁释放 begin; //对读取的记录加排他锁 select ... for update; commit; //锁释放\",\"行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。\",\"比如，下面事务 A 查询语句会锁住 (2, +∞] 范围的记录，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。\",\"...\",\"next-key 锁的加锁规则其实挺复杂的，在一些场景下会退化成记录锁或间隙锁。\",\"需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会全表扫描，在一行行扫描的过程中，不仅给行记录加上了行锁，还给行记录两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。\",\"回到前面死锁的例子。\",\"...\",\"事务 A 在执行下面这条语句的时候：\",\"select id from t\\\\_order where order\\\\_no = 1007 for update;\",\"我们可以通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"...\",\"从上图可以看到，共加了两个锁，分别是：\",\"表锁：X 类型的意向锁；\",\"行锁：X 类型的间隙锁；\",\"这里我们重点关注行锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：\",\"如果 LOCK_MODE 为 X ，说明是 X 型的 next-key 锁；\",\"如果 LOCK_MODE 为 X, REC_NOT_GAP ，说明是 X 型的记录锁；\",\"如果 LOCK_MODE 为 X, GAP ，说明是 X 型的间隙锁；\",\"因此，此时事务 A 在二级索引（INDEX_NAME : index_order）上加的是 X 型的 next-key 锁，锁范围是 (1006, +∞]。\",\"next-key 锁的范围 (1006, +∞]，是怎么确定的？\",\"如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围最右值，\",\"此次的事务 A 的 LOCK_DATA 是 supremum pseudo-record，表示的是 +∞。（防止插入新的数据，导致）\",\"然后锁范围的最左值是 t_order 表中最后一个记录的 index_order 的值，也就是 1006。因此，next-key 锁的范围 (1006, +∞]。\",\"TIP\",\"「当查询的记录不存在时，加 next-key lock，然后会退化为间隙锁」。为什么上面事务 A 的 next-key lock 并没有退化为间隙锁？\",\"如果表中最后一个记录的 order_no 为 1005，那么等值查询 order_no = 1006（不存在），就是 next key lock，如上面事务 A 的情况。锁范围（1006， +∞）\",\"如果表中最后一个记录的 order_no 为 1010，那么等值查询 order_no = 1006（不存在），就是间隙锁，比如下图：锁范围（1006，1010）\",\"...\",\"当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id = 1008 的记录就会被锁住：\",\"Insert into t\\\\_order (order\\\\_no, create\\\\_date) values (1008, now());\",\"因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁， 而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 select ... for update 语句并不会相互影响 。\",\"案例中的事务 A 和事务 B 在执行完后 select ... for update 语句后都持有范围为 (1006,+∞] 的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。\",\"为什么间隙锁与间隙锁之间是兼容的？\",\"间隙锁的意义只在于阻止区间被插入 ，因此是可以共存的。 一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁 ，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。\",\"这里的共同间隙包括两种场景：\",\"其一是两个间隙锁的间隙区间完全一样；\",\"其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。\",\"但是有一点要注意， next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的 。\",\"比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。\",\"虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系。X 型的记录锁与 X 型的记录锁是冲突的，比如一个事务执行了 select ... where id = 1 for update，后一个事务在执行这条语句的时候，就会被阻塞的。\",\"但是还要注意！对于这种范围为 (1006, +∞] 的 next-key lock，两个事务是可以同时持有的，不会冲突。因为 +∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系。\",\"插入意向锁是什么？\",\"注意！插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁。\",\"这段话表明尽管 插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作 。\",\"如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。\",\"插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。\",\"另外，我补充一点，插入意向锁的生成时机：\",\"每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（ PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁 ），现象就是 Insert 语句会被阻塞。\",\"Insert 语句是怎么加行级锁的？\",\"Insert 语句在正常执行时是不会生成锁结构的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为 隐式锁 来保护记录的。\",\"什么是隐式锁？\",\"当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。\",\"隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。\",\"隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景。\",\"如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的；\",\"如果 Insert 的记录和已有记录存在唯一键冲突，此时也不能插入记录；\",\"1、记录之间加有间隙锁\",\"每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（ PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁 ），现象就是 Insert 语句会被阻塞。\",\"举个例子，现在 t_order 表中，只有这些数据， order_no 是二级索引 。\",\"...\",\"现在，事务 A 执行了下面这条语句。\",\"事务 A mysql> begin; Query OK, 0 rows affected (0.01 sec) mysql> select * from t_order where order_no = 1006 for update; Empty set (0.01 sec)\",\"接着，我们执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务 A 加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"...\",\"本次的例子加的是 next-key 锁（记录锁+间隙锁），锁范围是 （1005, +∞] 。\",\"然后，有个事务 B 在这个间隙锁中，插入了一个记录，那么此时该事务 B 就会被阻塞：\",\"事务 B 插入一条记录 mysql> begin; Query OK, 0 rows affected (0.01 sec) mysql> insert into t_order(order_no, create_date) values(1010,now()); 阻塞状态。。。。\",\"接着，我们执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务 B 加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"...\",\"可以看到，事务 B 的状态为等待状态（LOCK_STATUS: WAITING），因为向事务 A 生成的 next-key 锁（记录锁+间隙锁）范围 （1005, +∞] 中插入了一条记录，所以事务 B 的插入操作生成了一个插入意向锁（ LOCK_MODE: X,INSERT_INTENTION ），锁的状态是等待状态，意味着事务 B 并没有成功获取到插入意向锁，因此事务 B 发生阻塞。\",\"2、遇到唯一键冲突\",\"如果在插入新记录时，插入了一个与「已有的记录的主键或者唯一二级索引列值相同」的记录（不过可以有多条记录的唯一二级索引列的值同时为NULL，这里不考虑这种情况），此时插入就会失败，然后对于这条记录加上了 S 型的锁 。\",\"如果主键索引重复，插入新记录的事务会给已存在的主键值重复的聚簇索引记录 添加 S 型记录锁 。\",\"如果唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录 添加 S 型 next-key 锁 。\",\"主键索引冲突\",\"下面举个「主键冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。\",\"t_order 表中的 id 字段为主键索引，并且已经存在 id 值为 5 的记录，此时有个事务，插入了一条 id 为 5 的记录，就会报主键索引冲突的错误。\",\"...\",\"但是除了报错之外，还做一个很重要的事情，就是对 id 为 5 的这条记录加上了 S 型的记录锁 。\",\"可以执行 select * from performance_schema.data_locks\\\\G; 语句，确定事务加了什么锁。\",\"...\",\"可以看到，主键索引为 5 （LOCK_DATA）的这条记录中加了锁类型为 S 型的记录锁。注意，这里 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是 S 型记录锁的话，LOCK_MODE 会显示 S, REC_NOT_GAP 。\",\"所以，在隔离级别是「可重复读」的情况下，如果在插入数据的时候，发生了主键索引冲突，插入新记录的事务会给已存在的主键值重复的聚簇索引记录 添加 S 型记录锁 。\",\"唯一二级索引冲突\",\"下面举个「唯一二级索引冲突」的例子，MySQL 8.0 版本，事务隔离级别为可重复读（默认隔离级别）。\",\"t_order 表中的 order_no 字段为唯一二级索引，并且已经存在 order_no 值为 1001 的记录，此时事务 A，插入了 order_no 为 1001 的记录，就出现了报错。\",\"...\",\"但是除了报错之外，还做一个很重要的事情，就是对 order_no 值为 1001 这条记录加上了 S 型的 next-key 锁 。\",\"我们可以执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"...\",\"可以看到， index_order 二级索引加了 S 型的 next-key 锁，范围是(-∞, 1001] 。注意，这里 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。如果是记录锁的话，LOCK_MODE 会显示 S, REC_NOT_GAP 。\",\"此时，事务 B 执行了 select * from t_order where order_no = 1001 for update; 就会阻塞，因为这条语句想加 X 型的锁，是与 S 型的锁是冲突的，所以就会被阻塞。\",\"...\",\"我们也可以从 performance_schema.data_locks 这个表中看到，事务 B 的状态（LOCK_STATUS）是等待状态，加锁的类型 X 型的记录锁（LOCK_MODE: X,REC_NOT_GAP ）。\",\"...\",\"上面的案例是针对唯一二级索引重复而插入失败的场景。\",\"接下来，分析两个事务执行过程中，执行了相同的 insert 语句的场景。\",\"现在 t_order 表中，只有这些数据， order_no 为唯一二级索引 。\",\"...\",\"在隔离级别可重复读的情况下，开启两个事务，前后执行相同的 Insert 语句，此时 事务 B 的 Insert 语句会发生阻塞 。\",\"...\",\"两个事务的加锁过程：\",\"事务 A 先插入 order_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护，此时还没有实际的锁结构（执行完这里的时候，你可以看查 performance_schema.data_locks 信息，可以看到这条记录是没有加任何锁的）；\",\"接着，事务 B 也插入 order_no 为 1006 的记录，由于事务 A 已经插入 order_no 值为 1006 的记录，所以事务 B 在插入二级索引记录时会遇到重复的唯一二级索引列值，此时事务 B 想获取一个 S 型 next-key 锁，但是事务 A 并未提交， 事务 A 插入的 order_no 值为 1006 的记录上的「隐式锁」会变「显示锁」且锁类型为 X 型的记录锁，所以事务 B 向获取 S 型 next-key 锁时会遇到锁冲突，事务 B 进入阻塞状态 。\",\"我们可以执行 select * from performance_schema.data_locks\\\\G; 语句 ，确定事务加了什么类型的锁，这里只关注在记录上加锁的类型。\",\"先看事务 A 对 order_no 为 1006 的记录加了什么锁？\",\"从下图可以看到， 事务 A 对 order_no 为 1006 记录加上了类型为 X 型的记录锁 （ 注意，这个是在执行事务 B 之后才产生的锁，没执行事务 B 之前，该记录还是隐式锁 ）。\",\"...\",\"然后看事务 B 想对 order_no 为 1006 的记录加什么锁？\",\"从下图可以看到， 事务 B 想对 order_no 为 1006 的记录加 S 型的 next-key 锁，但是由于事务 A 在该记录上持有了 X 型的记录锁，这两个锁是冲突的，所以导致事务 B 处于等待状态 。\",\"...\",\"从这个实验可以得知，并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用隐式锁保护唯一二级索引的记录。\",\"但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会 被阻塞 ， 因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的 ，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。\",\"如果 order_no 不是唯一二级索引，那么两个事务，前后执行相同的 Insert 语句，是不会发生阻塞的，就如前面的这个例子。\",\"...\",\"如何避免死锁？\",\"死锁的四个必要条件：\",\"互斥、占有且等待、不可强占用、循环等待 。\",\"只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。\",\"当有死锁发生时，解除死锁策略\",\"在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：\",\"设置事务等待锁的超时时间 。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。 在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。 当发生超时后，就出现下面这个提示：\",\"...\",\"开启主动死锁检测 。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。 将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。 当检测到死锁后，就会出现下面这个提示：\",\"...\"]},\"821\":{\"c\":[\"数据库\",\"MySQL\"]},\"822\":{\"c\":[\"MySQL\",\"锁机制\",\"并发控制\",\"性能优化\"]},\"823\":{\"h\":\"MySQL SQL执行顺序详解\",\"t\":[\"sql 执行顺序\",\"执行顺序\",\"...\",\"先执行 from、join 来确定表之间的连接关系，得到初步数据\",\"where 对数据进行初步的筛选\",\"group by 分组\",\"各组分别执行 having 中的普通筛选或聚合函数的筛选\",\"再把根据我们要的的数据进行 select，可以是普通字段查询也可以是获取聚合函数的查询结果。 如果是聚合函数，select 的查询结果会增加一条字段\",\"将查询结果去重 distinct\",\"最后合并各组的查询结果，按照 order by 的条件进行排序\",\"...\"]},\"824\":{\"c\":[\"数据库\",\"MySQL\"]},\"825\":{\"c\":[\"MySQL\",\"SQL优化\",\"查询执行\",\"性能优化\"]},\"826\":{\"h\":\"MySQL索引使用指南\",\"t\":[\"sql 索引\",\"创建索引\",\"#如果只关联一个字段为单列索引，如果关联多个字段即为联合索引或组合索引。 Create [UNIQUE | FULLTEXT] INDEX index\\\\_name ON table\\\\_name(index\\\\_col\\\\_name,...); #创建唯一索引 Create UNIQUE INDEX index\\\\_name ON table\\\\_name(index\\\\_col\\\\_name); #创建联合索引 Create FULLTEXT INDEX index\\\\_name ON table\\\\_name(index\\\\_col\\\\_name,...);\",\"查看索引\",\"SHOW INDEX FROM table\\\\_name;\",\"删除索引\",\"DROP INDEX index\\\\_table on table\\\\_name;\",\"示例\",\"name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。\",\"create index idx\\\\_user\\\\_name on tb\\\\_user(name);\",\"phone手机号字段的值，是非空且唯一的，为该字段创建唯一索引。\",\"create unique index idx\\\\_user\\\\_phone on tb\\\\_user(phone);\",\"为 profession,age,status 创建联合索引。\",\"create index idx\\\\_user\\\\_pro\\\\_age-sta on tb\\\\_user(profession,age,status);\",\"为 email 建立合适的索引来提升查询效率。\",\"creat index idx\\\\_user\\\\_email on tb\\\\_user(email);\",\"删除tb_user表中的email索引\",\"drop index idx\\\\_user\\\\_email on tb\\\\_user;\"]},\"827\":{\"c\":[\"数据库\",\"MySQL\"]},\"828\":{\"c\":[\"MySQL\",\"索引\",\"SQL优化\",\"性能调优\"]},\"829\":{\"h\":\"MySQL SQL语法详解\",\"t\":[\"sql 语法（图片失败）\",\"种类\",\"DDL（数据定义语言）\",\"create ==> 创建数据库或者表等对象\",\"drop ==> 删除数据库或者表等对象\",\"alter ==> 修改数据库或者表等对象的结构\",\"DML（数据操作语言）\",\"select ==> 查询表中数据\",\"insert ==> 向表中插入数据\",\"update ==> 更新表中数据\",\"delete ==> 删除表中数据\",\"DCL（数据控制语言）\",\"commit ==> 决定对数据库中的数据进行变更\",\"rollback ==> 取消对数据库中的数据进行变更\",\"grant ==> 赋予用户操作权限\",\"revoke ==> 取消用户的操作权限\",\"Sql 基本书写要求\",\"SQL 语句要以；结尾\",\"关键字不区分大小写，但是表中数据区分大小写\",\"关键字大写\",\"表名的首字母大写\",\"列明等小写\",\"常数的书写方式是固定的\",\"遇到字符串、日期等类型需要用到''\",\"单词间需要使用空格分割\",\"命名规则\",\"数据库和表的名称可以使用英文、数据以及下划线\",\"名称必须以英文作为开头\",\"名称不能重复\",\"select\",\"[图片下载失败]\",\"while\",\"[图片下载失败]\",\"[图片下载失败]\",\"and\",\"[图片下载失败]\",\"or\",\"[图片下载失败]\",\"in\",\"[图片下载失败]\",\"not in\",\"[图片下载失败]\",\"between\",\"[图片下载失败]\",\"like\",\"[图片下载失败]\",\"[图片下载失败]\",\"is null\",\"[图片下载失败]\",\"exists\",\"[图片下载失败]\",\"[图片下载失败]\",\"[图片下载失败]\",\"order by\",\"[图片下载失败]\",\"[图片下载失败]\",\"[图片下载失败]\",\"[图片下载失败]\",\"limit\",\"[图片下载失败]\",\"distinct\",\"[图片下载失败]\",\"[图片下载失败]\",\"join\"]},\"830\":{\"c\":[\"数据库\",\"MySQL\"]},\"831\":{\"c\":[\"MySQL\",\"SQL语法\",\"SQL基础\"]},\"832\":{\"h\":\"MySQL数据库管理指南\",\"t\":[\"本文详细介绍MySQL数据库的管理、维护及日常运维操作，帮助您高效管理数据库系统。\"]},\"833\":{\"h\":\"1. MySQL服务管理\"},\"834\":{\"h\":\"1.1 启动/停止MySQL服务器\"},\"835\":{\"h\":\"1.1.1 Linux系统\",\"t\":[\"在Linux系统上，可以使用以下命令来启动和停止MySQL服务器。请注意，确保有足够的权限执行这些操作。\",\"启动MySQL服务器：\",\"sudo service mysql start\",\"或者，取决于你的Linux发行版，也可以使用以下命令：\",\"sudo systemctl start mysql\",\"停止MySQL服务器：\",\"sudo service mysql stop\",\"或者，取决于你的Linux发行版，也可以使用以下命令：\",\"sudo systemctl stop mysql\",\"这些命令将启动或停止MySQL服务器。如果你正在使用不同的发行版或MySQL版本，请查阅相应的文档以获取更多信息。\"]},\"836\":{\"h\":\"1.1.2 Windows系统\",\"t\":[\"-- 启动MySQL net start mysql -- 创建Windows服务 sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)\",\"基本连接命令：\",\"mysql -h 地址 -P 端口 -u 用户名 -p 密码 SHOW PROCESSLIST -- 显示哪些线程正在运行 SHOW VARIABLES -- 显示系统变量信息\",\"或者\",\"在 Windows 上，MySQL 也会安装为一个服务。请通过一下步骤管理 MySQL 服务器：\",\"进入服务管理页面，找到 mysql 服务\",\"双击 mysql 服务，弹出服务对话框\",\"选择相应的操作来启动，停止或重启动 MySQL 服务器\"]},\"837\":{\"h\":\"2. 用户管理\"},\"838\":{\"h\":\"2.1 创建用户\",\"t\":[\"CREATE USER [IF NOT EXISTS] account_name IDENTIFIED BY 'password';\",\"CREATE USER 关键字后指定帐户名称。帐户名称由两部分组成：username 和 hostname，以 @ 符号分隔：username@hostname\",\"username 是用户的名称，而 hostname 是用户连接到 MySQL 服务器的主机名\",\"hostname 帐户名称的部分是可选的。如果省略它，用户可以从任何主机连接\",\"没有主机名的帐户名等效于：username@%\",\"如果 username 和 hostname 中包含空格或 - 等特殊字符，则需要将用户名和主机名分别按如下方式引用：'username'@'hostname'\",\"除了单引号 (')，还可以使用反引号 (``) 或双引号 (\\\")\",\"IDENTIFIED BY 关键字后指定用户的密码\",\"IF NOT EXISTS 选项仅在新用户不存在时有条件地创建新用户\",\"请注意，CREATE USER 语句创建了一个没有任何权限的新用户。要向用户授予权限，请使用 GRANT 语句。\"]},\"839\":{\"h\":\"2.2 删除用户\",\"t\":[\"DROP USER sqliz@localhost;\",\"如果删除的用户在删除之前已经登录了一个会话，删除后并不会影响此会话，直到会话结束。这也会会带来危险。\",\"...\"]},\"840\":{\"h\":\"2.3 重命名用户\",\"t\":[\"首先，使用管理员权限登录到MySQL服务器：\",\"mysql -u 管理员用户名 -p\",\"接下来，执行以下SQL语句，将'olduser'替换为要重命名的用户，而'newuser'是新的用户名：\",\"RENAME USER 'olduser'@'localhost' TO 'newuser'@'localhost';\",\"这个命令将在localhost上的MySQL中重命名用户。如果用户存在于不同的主机上，请相应地更改主机部分。\",\"如果用户有全局权限，你可能需要同时重命名用户及其对应的权限。例如：\",\"RENAME USER 'olduser'@'localhost' TO 'newuser'@'localhost'; UPDATE mysql.user SET user = 'newuser' WHERE user = 'olduser'; FLUSH PRIVILEGES;\",\"记得替换'olduser'和'newuser'为实际的用户名。最后，使用FLUSH PRIVILEGES;来确保更改立即生效。\"]},\"841\":{\"h\":\"2.4 修改用户密码\",\"t\":[\"在 MySQL 中，可以使用 UPDATE、SET PASSWORD、ALTER USER 语句来更改用户的密码\",\"UPDATE语法：\",\"MySQL 5.7.6 前\",\"...\",\"MySQL 5.7.6 后用户表使用列 authentication_string 来存储密码。并且，它删除了 password 列。\",\"...\",\"SET PASSWORD语法：\",\"...\",\"ALTER USER语法：\",\"...\"]},\"842\":{\"h\":\"2.5 列出用户\",\"t\":[\"查看全部用户：\",\"SELECT user, host FROM mysql.user; -- 只输出 usr、host 列 DESC mysql.user; -- 输出完整的用户表\",\"查看当前用户的认证信息：\",\"SELECT current_user();\",\"查看当前用户的信息：\",\"SELECT user();\",\"查看当前登录的用户：\",\"SHOW PROCESSLIST;\"]},\"843\":{\"h\":\"2.6 锁定用户账户\",\"t\":[\"查询用户的锁定状态：\",\"SELECT user, host, account_locked FROM mysql.user;\",\"...\",\"锁定一个现有用户：\",\"ALTER USER 'sqliz'@'%' ACCOUNT LOCK;\",\"...\",\"创建一个锁定的用户：\",\"CREATE user 'sqliz2'@'%' IDENTIFIED by 'SqLiZ9879123!' ACCOUNT LOCK;\",\"锁定用户的连接次数：\",\"MySQL 维护了一个变量 Locked_connects，它用来保存锁定的用户尝试连接到服务器的次数。\",\"当锁定的帐户尝试登录时，Locked_connects 变量的值将加 1。\",\"...\"]},\"844\":{\"h\":\"2.7 解锁用户\",\"t\":[\"ALTER USER 'sqliz'@'%', 'sqliz2'@'%' ACCOUNT UNLOCK;\"]},\"845\":{\"h\":\"3. 权限管理\"},\"846\":{\"h\":\"3.1 用户授权\",\"t\":[\"当创建了一个新用户之后，这个新的用户可以登录 MySQL 数据库服务器，但是他可能没有任何权限。只有在赋予他数据库和相关表的权限之后，他才可以进行选择数据库和查询等操作。\",\"语法：\",\"GRANT privilege_type [,privilege_type],... ON privilege_object TO user_account;\",\"privilege_type：要赋予给用户的权限。常用的包括：ALL, SELECT, UPDATE, DELETE, ALTER, DROP 以及 INSERT 等。 官方文档参考：MySQL权限\",\"privilege_object：权限对象。可以是所有对象，也可以是某个数据库中的所有对象，表等。 常用的包括：*、database.*、db_name.*、db_name.table_name、table_name 等。\",\"user_account：用户账户。它使用 username@host 的形式。\",\"权限举例：\",\"...\"]},\"847\":{\"h\":\"3.2 撤销用户权限\",\"t\":[\"REVOKE语法：\",\"REVOKE priv1 [, priv2 [, ...] ] ON [object_type] privilege_level FROM user1 [, user2 [, ...]];\",\"撤销权限类型：\",\"表列级别\",\"...\",\"数据库级别\",\"全局级别\",\"...\",\"revoke生效时机：\",\"...\"]},\"848\":{\"h\":\"3.3 显示用户权限\",\"t\":[\"显示当前用户权限：\",\"SHOW GRANTS FOR CURRENT_USER;\"]},\"849\":{\"h\":\"4. 角色管理\"},\"850\":{\"h\":\"4.1 角色概述\",\"t\":[\"对于一个线上的 MySQL 数据库服务器来说，它可能有很多使用者。其中某些用户可能具有相同的权限。\",\"作为一个数据库管理员或者运维人员，可能要对多个用户赋予相同的权限。这个过程很耗时，也很容易带来错误。\",\"MySQL 中的角色可以让你简化授权的过程。您只需要为权限相同的用户创建一个角色，并将角色赋予这些用户即可。\",\"还可以创建多个角色，授权给不同的用户。也可以为一个用户赋予多个不同的角色。\",\"...\"]},\"851\":{\"h\":\"4.2 角色操作语法\",\"t\":[\"创建角色：CREATE ROLE role_name1 [, role_name2 [, ...]];\",\"删除角色：DROP ROLE role_name1 [, role_name2 [, ...]];\",\"授权角色：\",\"...\",\"撤权角色：\",\"...\"]},\"852\":{\"h\":\"4.3 角色操作示例\",\"t\":[\"创建角色\",\"...\",\"授权角色\",\"...\",\"分配角色\",\"...\",\"显示角色\",\"...\"]},\"853\":{\"h\":\"5. 数据库备份与恢复\"},\"854\":{\"h\":\"5.1 备份数据库\",\"t\":[\"MySQL 提供了 mysqldump 工具用于从 MySQL 数据库服务器中导出数据库结构和数据。\",\"mysqldump 介绍：\",\"mysqldump 工具一般会随着安装 MySQL 数据库时自动安装。它能将一个或者多个数据库，或者数据库中的一个或者多个表导出为一个 SQL 文件，包括 DDL 语句和 DML 语句。\",\"通常，安装完 MySQL 服务器后，您可以直接使用 mysqldump 工具。\",\"如果找不到 mysqldump 工具，请将 MySQL 安装目录下的 bin 目录配置到环境变量 PATH 中。或者导航到 MySQL 安装目录下的 bin 目录下再使用 mysqldump 工具。\",\"mysqldump 语法：\",\"mysqldump --user=<username> --password=<password> --result-file=<path_to_backup_file> --databases <database_name>\",\"<username> 是登录到 MySQL 服务器的用户帐户。\",\"<password> 是 <username> 的密码。\",\"<path_to_backup_file> 是备份文件的路径。\",\"<database_name> 是你要备份的数据库的名称。如果要备份多个数据库，请用逗号分隔多个数据库的名字。\",\"实例：\",\"...\"]},\"855\":{\"h\":\"5.2 恢复数据库\",\"t\":[\"登录后用 source 命令运行 SOURCE 命令恢复数据库，如：\",\"SOURCE /bak/sakila.sql\",\"不登录直接恢复\",\"mysql --user=root --password=<password> < /bak/sakila.sql\"]},\"856\":{\"c\":[\"数据库\",\"MySQL\"]},\"857\":{\"c\":[\"MySQL\",\"数据库管理\",\"运维\",\"数据库维护\"]},\"858\":{\"h\":\"MySQL数据类型详解\",\"t\":[\"数据类型\",\"...\",\"点击图片可查看完整电子表格\"]},\"859\":{\"c\":[\"数据库\",\"MySQL\"]},\"860\":{\"c\":[\"MySQL\",\"数据类型\",\"数据库设计\"]},\"861\":{\"h\":\"Redis Hash类型详解\",\"t\":[\"hash\"]},\"862\":{\"c\":[\"数据库\",\"Redis\"]},\"863\":{\"c\":[\"Redis\",\"数据类型\",\"Hash\",\"数据结构\"]},\"864\":{\"h\":\"Redis哈希表底层结构详解\",\"t\":[\"hashtable底层结构\",\"概述\",\"可以理解成目录，要翻看内容可以直接通过目录找到页数，翻过去看\",\"hashtable 扮演者类似目录这样一个快速索引角色\",\"结构\",\"代码定义\",\"...\",\"结构图\",\"...\",\"最外层是一个 dictht，字段如下\",\"*table：指向实际 hash 存储。存储看成一个数组\",\"size：哈希大小。实际就是 dictEntry 有多少元素空间\",\"sizemask：哈希表大小的掩码表示，总是等于 size-1.这个属性和哈希值一起决定一个键一个被放在 table 数组的哪个索引上面，规则是：Index = hash&sizemask\",\"used：表示已经使用的节点数量\",\"hash 表渐进式扩容\",\"reids 把 dictht 再封装了一层：dict\",\"...\",\"结构图\",\"dict 结构里 ht[2] 包含两个 dictht 结构，也就是 2 个 hashtable\",\"dictEntry 是链表结构，用拉链法解决 hash 冲突，用的是头插法\",\"...\",\"扩容：渐进式！\",\"实际平常使用的是一个 hashtable，在触发扩容之后，就会两个 hashtable 同时使用\",\"扩容过程：往字典添加元素，发现需要扩容会进行 rehash\",\"先为新 hash 表 ht[1] 分配空间，新表大小为第一个大于等于原表 2 倍 used 的 2 次方幂 🌰原表的 used = 500，2 倍就是 1000，那大于 1000 的 2 次方幂则为 1024\",\"扩容后，同时拥有两个 hash 表 ht[0]、ht[1]。\",\"将字典的偏移索引 rehashidx 从静默状态 -1，设置为 0，表示 rehash 工作正式开始\",\"工作流程\",\"...\",\"迁移 ht[0] 的数据到 ht[1]\",\"在 rehash 期间，每次对字典执行增删改查，程序会顺带迁移当前 rehashidx 在 ht[0] 上对应的数据，并更新偏移索引。（只有被删改查的数据才会别迁移，不然一直不动）\",\"与此同时，部分情况周期函数也会进行迁移\",\"随着字典操作不断，最终在某个时间点上，ht[0] 的所有数据会被 rehash 到 ht[1] 上\",\"此时将 ht[1] 和 ht[0] 的指针互换，同时将偏移索引的值设为-1，表示 rehash 已经完成\",\"dictRehash 函数\",\"...\",\"可以看到，如果 rehashidx 刚好在一个已经删除的空位置，是会继续往下找，但是有上限 n*10\",\"n 是传进来的参数，调用时实际为 1，则最多往后找 10 个，防止因为碰到连续的空位置导致主线程操作被阻塞\",\"每次迁移一个函数，rehash 都会检查一下是否完成整个迁移\",\"总结\",\"核心是：操作时顺带迁移\",\"扩容时机\",\"负载因子表示目前 redis hashtable 的负载情况\",\"设负载因子为 k\",\"k = ht[0].used / ht[0].size\",\"k 是会大于 1 的，因为是拉链法处理扩容，且 used 是表示 dictEntry** 的使用情况\",\"何时扩容\",\"负载因子大于等于 1：说明空间非常紧张\",\"新数据实在链表上叠加的（拉链法），越来越多数据无法在 O1 时间复杂度上找到，需要遍历一次链表\",\"如果此时服务器没有执行 BGSAVE 或 BGREWRITEAOF 这两个命令 （复制命令）\",\"就发生扩容\",\"负载因子大于 5：说明 hashtable 不堪重负\",\"现在即使有复制命令在执行，也会进行 rehash 扩容\",\"缩容\",\"渐进式缩容：看负载因子 k\",\"k 小于 0.1，即负载率小于 10%，就会进行缩容\",\"新表大小为第一个大于等于原表 used 的 2 次方幂\",\"如果有BGSAVE 或 BGREWRITEAOF 这两个复制命令，缩容不会进行\",\"总结\",\"hashtable 是面试热点。。\"]},\"865\":{\"c\":[\"数据库\",\"Redis\"]},\"866\":{\"c\":[\"Redis\",\"哈希表\",\"数据结构\",\"底层实现\"]},\"867\":{\"h\":\"Redis List类型详解\",\"t\":[\"list\",\"是什么\",\"redis list 是一组连接起来的字符串集合\",\"list 最大元素个数是 2^32-1，新版是 2^64-1\",\"适合场景\",\"作为一个列表存储，属于比较底层的数据结构，可以使用的场景非常多。\",\"存储一批任务数据，一批消息等\",\"常用操作\",\"...\",\"写\",\"1. LPUSH\",\"...\",\"2. RPUSH\",\"...\",\"3. LPOP\",\"...\",\"4. RPOP\",\"...\",\"5. LREM\",\"...\",\"6. DEL\",\"...\",\"7. UNLINK\",\"...\",\"读\",\"8. LLEN\",\"...\",\"9. LRANGE\",\"...\",\"底层实现\",\"编码方式\",\"3.2 之前，list 对象有两种编码方式\",\"...\",\"3.2 之后\",\"...\",\"编码选择\",\"ZIPLIST\",\"条件\",\"列对象保存的所有字符串对象长度小于 64 字节\",\"列表对象元素个数少于 512 个，注意，这是 list 的限制，不是 ziplist 的限制\",\"ziplist 底层\",\"ziplist 底层用压缩列表实现，是一个偏向数组的结构\",\"整个 ziplist 是一起分配内存的，当插入元素时候，需要为整个 ziplist 重新分配内存，会造成内存的复制，是会消耗性能的\",\"比如列表中有三个元素：hello、niuniu、smart\",\"...\",\"可以看到三个元素都挨在一起，正如 zip 的名字一样，ziplist 内存排列得很紧凑，可以有效节约内存空间\",\"LINKEDLIST\",\"条件\",\"当列表个数或节点数据比较大会使用。\",\"ziplist 可以自动转换成 linkedlist\",\"底层\",\"linkedlist 是双向链表\",\"...\",\"可以看到，内存不够紧凑，但是删除更为灵活，能加快处理性能，空间换时间\",\"QUICKLIST\",\"ziplist 是为了在数据少的时候节约内存，linkedlist 是为了数据多的时候提高更新效率\",\"ziplist 数据稍多（不一定是个数多）时，插入数据会导致很多内存复制\",\"linkedlist 节点非常多的时候，会占用不少内存\",\"怎么办？\",\"/quicklist 来了/\",\"底层\",\"quicklist 是 ziplist 和 linkedlist 的结合结构\",\"原来 linkedlist 是单个节点，只能存一个数据。现在单个节点存一个 ziplist，即多个数据\",\"...\",\"ziplist 的优化\",\"zipslist 本身存在一个连锁更新的问题，7.0 后使用 LISTPACK 的编码模式取代了 ZIPLIST，他们本质都是一种压缩的列表\"]},\"868\":{\"c\":[\"数据库\",\"Redis\"]},\"869\":{\"c\":[\"Redis\",\"数据类型\",\"List\",\"数据结构\"]},\"870\":{\"h\":\"Redis Set类型详解\",\"t\":[\"set\",\"是什么\",\"是一个不重复、无序的字符串集合\",\"如果是 intset 编码时，其实是有序的，整体看成无序的就行\",\"适合场景\",\"适合无序集合场景，如某个用户关注了哪些公众号\",\"set 还提供了查交集，并集的功能\",\"常用操作\",\"...\",\"写\",\"1. SADD\",\"...\",\"2. SREM\",\"...\",\"读\",\"3. SISMEMBER\",\"...\",\"4. SCARD\",\"...\",\"5. SMEMBERS\",\"...\",\"6. SSCAN\",\"redis使用scan count 返回数量不准确 - 二娃的园子 - 博客园\",\"每次使用游标，都会使用上次使用后返回的游标作为本次游标参数，来延续之前的迭代过程\",\"...\",\"7. SINTER\",\"...\",\"...\",\"8. SUNION\",\"...\",\"9. SDIFF\",\"...\",\"底层实现\",\"编码方式\",\"...\",\"INTSET\",\"如果集群元素都是整数，且元素数量不超过 512 个，可以使用 INTSET 编码\",\"INTSET 排列比较紧凑，内存占用少\",\"查找时需要 二分查找\",\"...\",\"HASHTABLE\",\"不满足 INTSET 条件，就使用 HASHTABLE\",\"查询一个元素的性能很高，O1\",\"比如 set（1，2，3）在 hashtable 中以键值对形式存在就是\",\"...\"]},\"871\":{\"c\":[\"数据库\",\"Redis\"]},\"872\":{\"c\":[\"Redis\",\"数据类型\",\"Set\",\"数据结构\"]},\"873\":{\"h\":\"Redis String类型详解\",\"t\":[\"string\",\"string\",\"string 是最基本的 k-v 结构，key 是唯一表示，value 是具体的值。\",\"value 可以是字符串或数字（整数、浮点数）\",\"value 最多可以容纳的数据长度是 512M\",\"可以通过配置项修改proto-max-bulk-len\",\"常用操作\",\"常用操作聚集在 创建、查询、更新、删除\",\"...\",\"set\",\"语法：set key value\",\"扩展参数：\",\"EX\",\"PX\",\"NX\",\"XX\",\"setnx\",\"语法：setnx key value\",\"功能：用于在指定的 key 不存在时，为 key 设置指定的的值，返回值 0 表示存在，1 表示设置成功\",\"...\",\"del\",\"语法：del key\",\"返回值：成功删除了几行\",\"内部实现\",\"底层数据结构主要是 int 和 SDS（简单动态字符串）\",\"SDS\",\"SDS 不仅可以保存文本数据，还可以保存二进制数据。\",\"SDS使用len属性的值，而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在buf[]数组里的数据。\",\"因此 SDS 可以处理文本数据，保存图片，音频、视频、压缩文件等二进制数据\",\"SDS 获取字符长度的时间复杂度是 O1。因为有 len\",\"reids 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为再拼接时会检查 SDS 空间是否满足要求，如果不够会自动扩容，不会导致溢出问题\",\"sds 种类\",\"redis 中 sds 分为：sdshdr8、sdshdr16、sdshdr32、sdshdr64，他们的字段属性是一样的，区别在于对应不同大小的字符串。\",\"8、16、32、64 是指字段 len 的位数\",\"以 sdshdr8 为例\",\"...\",\"len：表示用了多少\",\"alloc：表示一共分配了多少内存\",\"alloc - len ：两个字段差就是预留空间的大小。\",\"flags：标记是哪个分类，比如 sdshdr8 就是 #define_SDS_TYPE_8 1\",\"buf：数据\",\"SDS 对 c 字符串的改进\",\"增加长度字段 len，快速返回长度\",\"增加空余空间（alloc-len），为后续追加数据留余地\",\"不再以'\\\\0'作为结束判断标准，二进制安全\",\"SDS 可以预留空间，那么预留的空间有多大呢。\",\"len 小于 1M 的情况下，则会额外预留1 倍 len 的空间\",\"len 大于 1M 的情况下，则会额外预留1MB的空间\",\"简单来说范围 min（len，1M）\",\"字符串对象的内部编码\",\"有 3 种：int、raw、embstr\",\"保存一个 int，内部：\",\"...\",\"保存一个字符串，分 2 种情况：字符串是否大于 32 字节（不同的 redis 版本不一样）\",\"小于等于 32 字节，encoding 使用 embstr\",\"...\",\"大于 32 字节，encoding 使用 raw\",\"...\",\"raw 和 embstr 的边界\",\"redis 2.+ 是 32 字节\",\"redis 3.0-4.0 是 39 字节\",\"redis 5.0 是 44 字节\",\"raw 和 embstr 的区别\",\"embstr 会通过一次内存分配来分配一块连续的内存空间来保存redisObject和SDS\",\"embstr编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次；\",\"释放 embstr编码的字符串对象同样只需要调用一次内存释放函数；\",\"因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。\",\"缺点：如果字符串的长度增加需要重新分别内存，整个 redisObject 和 sds 需要重新分配空间，所以 embstr 编码的字符串对象实际上时只读的\",\"当我们要对 embstr 编码的字符串执行任何修改指令，redis 会先将对象的编码从 embstr 转换成 raw，再执行修改\",\"注意\",\"embstr 中只会使用 sdshdr8，原因考虑阈值，并且字段 alloc 会被显式设置为 0\",\"raw 中会出现 sdshdr8-64，都有可能\",\"为什么需要 SDS\",\"c 语言中，\\\"hello\\\" 即\\\"hello\\\\0\\\"\",\"不好的地方\",\"计算字符串长度为 On\",\"追加字符串需要重新分配内存\",\"非二进制安全：这里是指能兼容'\\\\0'这种特殊字符，公平对待每一个字符，不特殊处理任何一个字符，包括特殊字符\",\"应用场景\",\"缓存对象\",\"直接缓存整个 json\",\"采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20\",\"常规计数\",\"redis 处理命令是单线程的，所以执行命令的过程是原子的。\",\"因此 string 适合计数场景\"]},\"874\":{\"c\":[\"数据库\",\"Redis\"]},\"875\":{\"c\":[\"Redis\",\"数据类型\",\"String\",\"数据结构\"]},\"876\":{\"h\":\"Redis ZSet类型详解\",\"t\":[\"zset\",\"是什么\",\"zset 就是有序集合，可以叫 sorted set。\",\"是一组按关联积分有序的字符串集合，这个分数是给抽象概念，任何指标都可以抽象成分数\",\"积分相同的情况下，按字典序排序\",\"使用场景\",\"游戏排行榜。\",\"常用操作\",\"...\",\"写\",\"1. ZADD\",\"...\",\"...\",\"2. ZREM\",\"...\",\"读\",\"3. ZCARD\",\"...\",\"4. ZRANGE\",\"...\",\"5. ZREVRANGE\",\"...\",\"6. ZCOUNT\",\"...\",\"7. ZRANK\",\"...\",\"排名由低到高，从 0 开始\",\"8. ZSCORE\",\"...\",\"底层实现\",\"编码方式\",\"...\",\"ZIPLIST\",\"list\",\"结构\",\"...\",\"条件\",\"列表对象保存的所有字符串对象长度小于 64 字节\",\"列表对象元素个数少于 128 个\",\"SKIPLIST\",\"结构\",\"SKIPLIST 是一种可以快速查找的多级链表结构，通过 skiplist 可以快速定位到数据所在，排名操作、范围查询性能高\",\"...\",\"HT\",\"就是 hashtable，配合查询可以在 O1 时机复杂度找到\",\"...\"]},\"877\":{\"c\":[\"数据库\",\"Redis\"]},\"878\":{\"c\":[\"Redis\",\"数据类型\",\"ZSet\",\"数据结构\"]},\"879\":{\"h\":\"Redis压缩列表详解\",\"t\":[\"压缩列表\",\"压缩列表是什么\",\"压缩列表：排列紧凑的列表\",\"压缩列表在 redis 中有两种编码形式\",\"ziplist\",\"listpack：5.0 引入，直到 7.0 完全取代 ziplist，成为 ziplist 的进阶版本\",\"解决什么问题\",\"压缩列表是 list 的底层数据结构，压缩列表作为底层数据结构能提供紧凑型的数据存储方式，能节约内存（节省链表指针的开销），小数据量时遍历访问性能好（连续+缓存命中率高）\",\"ziplist 整体结构\",\"虽然 listpack，但是实际聊的比较多的还是 ziplist\",\"...\",\"zlbytes：表示该 ziplist 一共占了多少字节数，这个数字包含 zlbytes 本身占据的字节\",\"zltail：尾巴节点，相对于 ziplist 的开头（起始指针）而言偏移的字节数。\",\"这个字段可以快速定位到尾部节点。\",\"例如 zl 指向开头，需要获取尾巴节点，即 ziplist 最后一个 entry 节点，可以 zl + zltail\",\"如果没有尾巴节点，就定位到 zlend，如空 ziplist\",\"zllen：表示有多少个数据节点，上图中，zllen = 3\",\"entry：表示压缩列表的数据节点\",\"zlend：一个特殊的 entry 节点，表示 ziplist 结束。\",\"entry 节点结构\",\"定义\",\"...\",\"prevlen：表示上一个节点的数据长度。通过这个字段可以定位到上一个节点的起始地址\",\"即当前地址 p-prevlen 可以跳到前一个节点的开头位置，实现从后往前的操作，所以压缩列表可以从后往前遍历\",\"如果前一个节点 entry 的大小小于 254 字节，那么 prevlen 属性只需要用 1 字节长的空间来保存这个长度值。255 是特殊字符，被 zlend 使用\",\"前一节点的长度大于等于 254 字节，那么 prevlen 属性需要 5 字节来保存这个长度值，注意 5 个字节中，第一个字节的 8bit 为 11111110，也就是 254，标志这是 5 个字节的 prelen 信息，剩下的 4 字节来表示大小\",\"encoding：编码类型。编码类型里还包含 entry 的长度信息，用于正向遍历\",\"entry-data：实际的数据\",\"encoding\",\"encoding 字段是一个整形数据，其二进制编码由内容数据的类型和内容数据的字节长度两部分组成，根据内容类型有如下几种情况\",\"...\",\"如果是 string 类型，encoding 有两部分，一般是前几位表示类型，后几位表示长度。\",\"如果是 int 类型，整体 1 字节编码，只是表示了类型，但没有大小，因为 int 的具体类型就自带了大小 int16、int32...不用要 encoding 特别标识\",\"encoding 的编码规则复杂，只要知道怎么去区分不同类型即可，不用去背具体编码。\",\"解释一下表格最后一个 xxxx 为什么只有 13 个，全 1 不能用（zlend 用了），11111110 是 int64 也不能用\",\"ziplist 查询数据\",\"1. 查询 ziplist 数据总量\",\"由于 ziplist 的 header 定义了记录节点数量的字段 zllen，通常可以在 O1 直接返回。\",\"为什么是通常呢？\",\"因为 zllen 是 2 个字节的，当 zllen 大于 65534，就存不下了，zllen 变成 0， 此时真实的 zllen 需要重新遍历得到\",\"注意\",\"list 使用 ziplist 编码的条件之一是数据对象的数量小于 512，超过就会使用 linkedlist 编码\",\"而 ziplist 这个数据结构，本身的限制是可以存 65534 个数据（也不算限制，存超了就需要重新遍历浪费 On，而不是直接 O1 返回）\",\"简而言之，list 底层使用了 ziplist 这个底层数据结构，并且自己设定了一个限制，数据量小于 512\",\"2. 查询指定数据的节点\",\"需要遍历这个压缩列表，平均 On，所以查找复杂度是比较高的\",\"3. 更新数据\",\"数据节点 entry 往后移\",\"ziplist 支持在头尾插入数据，但是平均操作时间确是 On 不是 O1，因为在头部增加一个节点会导致后面的节点都往后移动\",\"连锁更新\",\"这里有图文讲解Redis 数据结构\",\"entry 后移不叫连锁更新！\",\"连锁更新的情况：\",\"增加一个大于 254 字节的节点到头部，可能会导致后续大量entry 的 prevlen 需要更新。\",\"比如：原本每个 entry 中的 prevlen 都是 1 字节，而且每个 entry 的总字节数都接近 254。挺好的，无事发生。\",\"突然加了一个大于 254 字节的数据到头部，导致后一个 entry 的 prevlen 原本 1 字节太小了，需要重新分配大小为 5 字节，从 1 变 5，导致这个 entry 的总字节数大于 254，下一个 entry 的 prevlen 又要 1 变 5。\",\"小林的图文解释的很好。\",\"这种现象叫连锁更新，时间复杂度是 On^2\",\"连锁更新会带来性能问题，虽然实际很少遇到，但是 ziplist 最大的问题还是连锁更新导致性能不稳定\",\"listpack 优化\",\"目的：解决连锁更新\",\"ziplist 连锁更新原因分析\",\"list 是双端访问结构，而 ziplist 需要支持 list 双端访问的特性，在 entry 增加了 prevlen 字段记录上一个节点的长度，使其能够从后往前遍历。\",\"连锁更新就是 prevlen 需要字节从 1 变 5 导致的\",\"entry 的结构\",\"...\",\"对症下药\",\"需要一种不记录 prevlen，并且还可以找到上一节点的起始位置的办法\",\"listpack。\",\"listpack 节点定义\",\"...\",\"encoding-type：编码类型\",\"element-data：数据内容\",\"element-tot-len：存储整个节点除了它自身之外的长度。就是 type+data\",\"element-tot-len\",\"tot-len 所占用的每个字节的第一个 bit 用于标识是否结束。\",\"0 结束，1 结束。剩下的 7 个 bit 用来存储数据大小\",\"当我们需要查找当前元素的上一个元素，可以从 tot-len 从后往前依次查找每一个字节，找到上一个 entry 的 tot-len 结束标识，就可以算出上一个节点的受位置\",\"例子：上一个 tot-len 为 00000001 1000010，每个字节第一个 bit 标志是否结束。\",\"从后往前依次查找，把有效的 7 位拿出来，拼接在一起：0000001 000010 = 132 字节\",\"说明再往前走 132 字节就到了节点起始位置\",\"...\",\"listpack 结构设计\",\"...\",\"listpack entry 的三个字段就是上面的\",\"...\",\"总结\",\"listpack 和 ziplist 都叫压缩列表，前者是后者的进阶版，解决了连锁更新带来的性能瓶颈\",\"在结构上没太大的区别，用 element-tot-len 取代了导致连锁更新的 prevlen\"]},\"880\":{\"c\":[\"数据库\",\"Redis\"]},\"881\":{\"c\":[\"Redis\",\"压缩列表\",\"数据结构\",\"性能优化\"]},\"882\":{\"h\":\"Redis对象过期机制详解\",\"t\":[\"对象过期时间\",\"是什么\",\"redis 的过期时间是给一个 key 指定一个时间点，等达到这个时间，数据就被认为是过期数据，由 redis 进行回收\",\"为什么要过期\",\"如果不是需要常驻的数据，设置过去时间可以有效节约内存。\",\"有些场景也是需要过期时间支持：缓存\",\"如果存在时间过久，可能导致和数据源差距过大，而设置过期时间，可以很方便清除缓存以便后续再次加载进去\",\"比如分布式锁：需要一定时间后，数据自动消失，以实现最大占据时间的特性\",\"怎么设置过期时间\",\"简单的字符串对象\",\"...\",\"更通用的过期命令 EXPRIRE，可以对所有数据对象设置过期时间，也可以分秒和毫秒\",\"...\",\"key 过期多久会被删除\",\"三种过期键清除策略\",\"定时删除：在设置键过期时间的同时，创建一个定时器，让定时器在键过期时间来临，立即执行对键的删除操作，定时删除对内存比较友好，但是对 CPU 不友好，如果某个时间段比较多的 key 过期，可能会影响命令处理性能\",\"惰性删除：是指使用的时候，发现 key 过期了，此时再进行删除，\\\"只要不访问，过期不过期业务都无所谓\\\"，对 CPU 友好，对内存不友好\",\"定期删除：每隔一段时间，程序对数据库进行一次检查，每次删除一部分过期 key ，属于一种渐进式兜底策略\",\"定期删除\",\"实现起来没有那么容易\",\"主要考虑出现异常，有 key 遗漏了怎么办，以及如果程序重启，原来的定时器就随重启消失了，那就需要再启动时，对过期 key 进行一些操作，可能是重建定时器，这些都是额外的工作，引多了多余的复杂度\",\"redis 采用的\",\"redis 采用惰性删除+定期删除结合\",\"...\"]},\"883\":{\"c\":[\"数据库\",\"Redis\"]},\"884\":{\"c\":[\"Redis\",\"过期策略\",\"内存管理\",\"性能优化\"]},\"885\":{\"h\":\"Redis跳表实现详解\",\"t\":[\"跳表\",\"是什么\",\"跳表是有序集合 zset 底层数据结构，也是 zset 的灵魂所在。\",\"跳表本质还是链表\",\"...\",\"虽然链表结构简单清晰，但是查询某个节点的效率比较低，为了调高查找性能，引入了跳表。\",\"跳表在链表基础上，给链表增加了多级索引，通过索引可以一次实现多个节点的跳跃，调高性能\",\"跳表的结构\",\"Redis 数据结构\",\"结构示意图\",\"...\",\"图上的某些节点不是只有一层。比如 35，就有三层\",\"理论上，层次越高平均步长越大，并不是和上图一样绝对均衡的，节点的层高是概率随机的\",\"或者这样画\",\"...\",\"结构的好处\",\"场景 1：查找分数为 35 的数据\",\"如果是只有原始链表，需要走 4 步\",\"二级索引走一步\",\"场景 2：插入 score 为 36 的数据\",\"先定位到第一个比 score 大的位置，这里是 45，定位方式和查询类似\",\"然后构造一个新节点，假设节点层高随机到 3（随机算法决定的）\",\"补齐各层链表\",\"...\",\"标准的跳表的限制\",\"score 不能重复\",\"只有向前指针，没有回退指针\",\"⛔在 reids 中，跳表是用来支持有序集合的，所以 redis 对跳表做了一些优化：\",\"score 可以重复\",\"增加回退指针\",\"redis 的跳表实现\",\"结构图\",\"...\",\"...\",\"下面的更准确。\",\"...\",\"节点源码\",\"...\",\"ele：sds 结构，用来存储数据\",\"score：节点的分数，浮点型数据。节点排列是从小到大\",\"backwaid：指向上一个节点的回退指针。支持从表尾向表头遍历，也就是ZREVRANGE命令\",\"level：是 zskiplistLevel 结构体数组，有两个字段：\",\"forward：指向该层下一个能跳到的节点\",\"span：记录距离下一个节点的步数\",\"结构体数组：表示每个节点都可能是多层结构\",\"跳表结构体\",\"...\",\"redis 跳表单个节点有几层\",\"层次的决定，需要比较随机才能在各个场景表现出较为平均的性能，这里 redis 使用概率均衡的死了来决定新插入节点的层数：\",\"redis 跳表决定每一个节点，是否能增加一层的概率为 25%，而最大层数限制在 redis5.0 是 64 层，7.0 是 32 层\"]},\"886\":{\"c\":[\"数据库\",\"Redis\"]},\"887\":{\"c\":[\"Redis\",\"跳表\",\"数据结构\",\"性能优化\"]},\"888\":{\"h\":\"Redis单线程高性能原理解析\",\"t\":[\"redis 单线程为什么这么快\",\"快的 4 点原因\",\"基于内存设计，内存的读写速度对比磁盘和固态都快，有更高的吞吐量和低延迟。\",\"单线程，因为执行本身不是瓶颈。对比多线程，从投入产生来看，引入多线程要付出更大的时间复杂度：上下文切换，同步机制的开销等等成本很高。事实也证明单纯性的 redis 已经很高效。瓶颈通常在网络 IO。\",\"IO 多路复用\",\"高效的底层数据结构\",\"redis 单线程\",\"redis 使用单线程，能达到每秒数万级别的处理能力\",\"redis 大部分操作在内存上完成，内存操作本身快\",\"redis 选择了很多高效的数据结构，并做了很多优化，比如 ziplist、hash、跳表....\",\"有时候一种对象底层有几种实现以对应不同的场景\",\"redis 采用了多路复用机制，使其在网络 IO 操作中，能并发处理大量的客户端请求，实现高吞吐量\",\"IO 可能存在的问题\",\"一个单线程在一次完整的处理中， 会有哪些地方拖慢整个流程\",\"...\",\"redis 服务端在启动时，以及 bind 了端口，并且 listen 操作监听客户端请求，此时客户端就可以发起连接请求\",\"客户端 get 请求到来，使用 accept 建立连接\",\"调用 recv 从套接字中读取请求\",\"解析客户端发送请求，拿到参数\",\"处理请求，这里是 get，redis 通过 key 获取对应的数据\",\"最后将数据通过 send 发送给客户端\",\"哪些流程会拖沓\",\"套接字默认是阻塞模式的，可能发生在两个地方\",\"accept 时：accept 建立时间过长\",\"recv 时：客户端一直都没有发送数据\",\"怎么解决：IO 多路复用\",\"当有 IO 操作触发的时候，就会产生通知，收到通知，再去通知对应的事件，针对 IO 多路复用，reids 做了一层包装，叫 Reactor 模型\",\"Reactor\",\"本质就是监听各种事件，当事件发生，将事件分发给不同的处理器\",\"这样就不会阻塞在一个操作上，IO 多路复用让 redis 单线程也有了较大的并发度（不是并行）\"]},\"889\":{\"c\":[\"数据库\",\"Redis\"]},\"890\":{\"c\":[\"Redis\",\"性能优化\",\"单线程模型\",\"系统架构\"]},\"891\":{\"h\":\"Redis单线程与多线程模型对比\",\"t\":[\"redis 单线程还是多线程\",\"结论\",\"核心处理逻辑：redis 一直都是单线程，4.0 后对使用多线程处理异步删除的操作。\",\"辅助模块：复制模块、某些异步流程、网络 IO 解包 6.0 后用的多线程\",\"为什么选择单线程\",\"官方\",\"[图片下载失败]\",\"reids 的定位是内存的 k-v 存储，做的就是短平快的热点数据处理\",\"一般来说执行会很快，执行本身不应该成为瓶颈，而瓶颈通常在网络 IO，所以处理逻辑使用多线程不会有太多收益\",\"同时引入 多线程带来的复杂度远比现象的大\",\"1. 多线程引入的复杂度大\",\"2. 多线程带来额外的成本\",\"上下文切换成本\",\"同步机制开销，需要加锁来实现，不可忽视的 cpu 开销\",\"一个线程本身也占据内存大小，reids 这种内存数据对内存十分珍惜\"]},\"892\":{\"c\":[\"数据库\",\"Redis\"]},\"893\":{\"c\":[\"Redis\",\"线程模型\",\"性能优化\",\"系统架构\"]},\"894\":{\"h\":\"Redis内存存储结构详解\",\"t\":[\"redis 在内存中是怎么存储的\",\"redis 是内存存储，放在 redis 的数据都是以键值对形式存在内存中\",\"数据库结构\",\"reidsDb 代表 redis 数据库结构\",\"...\",\"重点关注 dict 结构\",\"...\",\"代表了我们存入的 key-value 数据\",\"平常添加数据就是往 dict 里面加\",\"结构图\",\"...\",\"reidsDb 是数据库对象，指向数据字典，字典包含平常我存储的 k-v 数据\",\"k 是字符串对象\",\"v 支持任意 redis 对象\",\"过期键\",\"reids 可以设置过期键，那么过期键存在哪里？\",\"存在 expires 字典上\",\"...\",\"如果设置了过期时间，那么存储结构如下\",\"...\",\"dict 和 expires 中的 key 对象，时机都是存储了 string 对象指针，所以是不会重复占用内容\",\"而且设置了过期时间，key 在 dict 和 expires 都会有一份。只是 expires 中指向 timestamp（过期时间）\"]},\"895\":{\"c\":[\"数据库\",\"Redis\"]},\"896\":{\"c\":[\"Redis\",\"内存管理\"]},\"897\":{\"h\":\"Redis多线程机制详解\",\"t\":[\"redis 多线程是怎么回事（未完成）\",\"redis 多线程模型\",\"随着业务发展，很多业务请求量都达到了一个曾经难以现象的高度，IO 操作确实成为了瓶颈，之前的 redis 处理流程中读取请求，发送回包都属于 IO 操作\",\"redis 多线程也不是将整个逻辑都多线程化，而是将网络 io 多线程化\",\"redis 多线程设计思路\",\"...\",\"再详细一点\",\"...\",\"...\",\"分开看\",\"什么时候启动多线程\",\"服务初始化的时候，会调用 initThreadedIO来初始化多线程\",\"根据server.io_thread来配置，如果为 1，表示只有一个主线程，那就不会再创建其他线程\",\"如果大于 1 并且不超过 128，就会进入多线程模式\",\"进入多线程模式后\",\"为多线程模式创建资源\",\"...\",\"这里为所有线程，在 io_threads_list 中创建对象\",\"提前锁定了 pthread_mutex_lock 互斥锁资源（单纯的加锁操作，锁住这个 io 线程对应的 mutex，类似不允许这个 io 线程创建多次）\",\"pthread_create就创建了多线程，子线程运行 IOThreadMain 操作，它是一个无限循环函数，也就是说子线程会一直处于运行状态，直到进程结束\",\"redis 多线程默认是关闭的，需要主动开启\",\"用户可以在redis.conf配置文件中开启\",\"...\",\"主线程视角\",\"事件循环\",\"主线程和 6.0 版本之前一样，还是用 aeMain 来处理事件循环\",\"...\",\"aeMain 是 redis 的主线程入口，再 eventloop 一直循环\",\"当有客户端连接到来，acceptTcpHandeler 被调用，主线程使用 AE 的 API 将 readQueryFromClient命令读取处理器与新连接对应的文件描述符关联起来，并初始化一个 client 绑定到这个客户端连接\",\"当 client 的读写请求过来，会调用readQueryFromClient这个方法\",\"老版本实在readQueryFromClient函数中同步完成读取、解析、执行、将回包放入客户端输出缓冲区\",\"多线程模式下：只会调用postponeClientRead将 client 加入到clients_pending_read任务队列中，后面主线程再分配 IO 线程去读取客户端请求命令\",\"...\",\"放进队列之后，主线程会在事件循环 beforeSleep 函数中，调用\"]},\"898\":{\"c\":[\"数据库\",\"Redis\"]},\"899\":{\"c\":[\"Redis\",\"多线程\",\"性能优化\",\"系统架构\"]},\"900\":{\"h\":\"Redis数据存储容量分析\",\"t\":[\"redis 能存多少数据\",\"使用 maxmemory 配置\",\"默认是注释的，也就是默认值为 0\",\"32 位操作系统中，maxmemory 是 3G，因为最大支持 4GB 内存，系统本身需要一旦内存资源\",\"64 位操作系统中，不会限制内存使用，也可以主动配置\",\"...\",\"淘汰\",\"支持 \\\"多久淘汰\\\" 策略\",\"...\",\"当达到最大内存时，Redis如何选择要删除的内容。您可以从以下行为中选择一个：\",\"volatile-lru -> 使用近似LRU进行驱逐，只针对带有过期时间的键。\",\"allkeys-lru -> 使用近似LRU对任何键进行驱逐。\",\"volatile-lfu -> 使用近似LFU进行驱逐，只针对带有过期时间的键。\",\"allkeys-lfu -> 使用近似LFU对任何键进行驱逐。\",\"volatile-random -> 移除具有过期时间的随机键。\",\"allkeys-random -> 移除任意键。\",\"volatile-ttl -> 移除最接近的过期时间(次级TTL)的键。\",\"noeviction -> 不驱逐任何东西，只是在写操作时返回错误。\",\"共 8 种策略\",\"...\",\"默认是 noeviction：如果内存到达 maxmemory，则写入操作都会失败，不会淘汰已有数据\",\"第二是多种淘汰策略\",\"...\",\"这四种策略，可以选择时 volatile，也就是设置了过期时间的 key，或者是 allkeys，即全部 key，所以一共有 8 种淘汰方式\",\"怎么选择淘汰算法\",\"由业务需求决定\",\"缓存场景：LRU、LFU\",\"数据重要：不淘汰\",\"淘汰时机\",\"每次运行读写命令都会调用processCommand函数，里面又会调用freeMemoryIfNeeded，这时候去尝试释放一些内存\"]},\"901\":{\"c\":[\"数据库\",\"Redis\"]},\"902\":{\"c\":[\"Redis\",\"存储容量\",\"性能优化\",\"内存管理\"]},\"903\":{\"h\":\"Redis LFU内存淘汰算法详解\",\"t\":[\"内存淘汰算法-LFU\",\"最不频繁淘汰算法，优先淘汰活跃最低、使用频率最低的\",\"为什么 4.0 引入 LFU\",\"LRU 能解决大部分场景，但是一下场景\",\"mart 会被淘汰\",\"...\",\"LFU\",\"回顾一下 redisObject 结构\",\"...\",\"LFU 和 LRU 不会同时开启，因此LFU 会复用 lru 这个字段来统计访问情况\",\"lru 原本 24 位，LFU 将其拆成高16 + 低 8\",\"高 16：存 ldt（Last Decrement Time）\",\"低 8：存 logc（Logistic Counter）\",\"key 是否活跃，由这两个字段综合决定\",\"...\",\"高 16 位保存上次访问的时间戳，比原来少了 8 位，因此 LFU 下时间精度是 1 分钟\",\"👁️2^16 = 65536，如果用秒作为精度，范围太小。用分钟可以表示 1092 小时，范围大点\",\"后 8 位存储访问计数\",\"访问计数的 8 bits\",\"如果上一次访问时间很久，那么访问计数就会衰减\",\"为什么要衰减，因为只是简单的增加访可计数的方法并不完美，访问的热度一直在变，比如一个key,他原来是255,夸张一点，一年没访问了，不该归零么。\",\"而本身访问，会增加访问计数。\",\"当然，最后起作用的就是访问计数。\",\"源码分析\",\"LFU 数据更新\",\"...\",\"第一步，计算次数衰减\",\"...\",\"第二步，一定概率增加访问次数\",\"...\",\"第三步，更新\",\"当前时间更新到高16位，次数更新到低8位\"]},\"904\":{\"c\":[\"数据库\",\"Redis\"]},\"905\":{\"c\":[\"Redis\",\"LFU\",\"内存淘汰\",\"算法原理\"]},\"906\":{\"h\":\"Redis LRU内存淘汰算法详解\",\"t\":[\"内存淘汰算法-LRU\",\"标准 LRU\",\"LRU 是一个流行的资源淘汰算法\",\"是什么\",\"最近最久未使用，即记录每个 key 的最近访问时间，维护一个访问时间数据\",\"redis 使用标准的 LRU 会有什么问题\",\"为所有数据维护一个顺序列表，实际就是做一个双向链表，如果 redis 数据稍微多些，这个链表就成本就很大\",\"redis 的近似 LRU\",\"Redis 近似 LRU 算法优化 - 掘金\",\"概述\",\"在 LRU 模式中，redisObject 对象中 lru 字段存储的是 key 被访问时，redis 的时钟 server.lrulock\",\"当 key 被访问时，redis 会更新这个 key 的 lru 字段\",\"但是，redis 为了保证核心单线程服务性能，缓存了 Unix 操作系统时钟，默认每 100ms 更新一次，缓存的值时 Unix 时间戳取模 2^24\",\"近似 LRU\",\"近似 lru 算法在现有的数据结构基础上采用随机取样的方式来淘汰元素，当内存不足，就执行一次近似 lru\",\"具体步骤：\",\"随机采用 n 个 key，默认 5 个\",\"根据时间戳淘汰掉最旧的 key\",\"淘汰后还是内存不足，继续采样淘汰\",\"采样范围\",\"allkeys：从所有 key 中随机采样\",\"volatile：从有过期时间的 key 随机采样\",\"对应：allkeys-lru 和 volatile-lru\",\"淘汰池优化\",\"近似 lru 的一些问题\",\"近似 lru 优点在于节约了内存，但缺点就是它不是一完整的 lru，随机采样得到的结果，其实不是全局真正的最久未访问，数据量大的时候更加\",\"redis3.0 对近似 lru 进行了一些优化\",\"新算法会维护一个大小为 16 （不是固定的，会动态调整）的候选池，池中的数据根据空闲时间长短进行排序\",\"第一次随机选取的 key 都会放入池中，然后淘汰最久未访问的。 比如选了 5 个，淘汰 1 个，池子还剩 4 个\",\"随后每次随机选取的 key，只有活性比池子里活性最小的 key 还小时，才会放入池中\",\"池子满了之后每次放一个 key 进，满之前符合的都放进\",\"当池子满了，如果有新的 key 需要放入，就会将池子中活性最低（这里的活性低就是空闲时间长）的 key 淘汰\",\"新的 key 要放入的意思：随机选取的 n 个采样里面活性最低的与池中活性最低的比较，谁更低谁被淘汰，没被淘汰的放入池子\",\"...\",\"空闲时间的计算\",\"idle = object.lru - server.lrulock\",\"淘汰池的结构\",\"Redis的淘汰池是一个字典结构，而不是链表。\",\"字典中的每个键值对都包含一个指向对象的指针，而不是相邻节点的指针。\",\"因此，在遍历淘汰池时，Redis需要使用哈希表算法来查找大于当前最大可用内存的键。\",\"...\"]},\"907\":{\"c\":[\"数据库\",\"Redis\"]},\"908\":{\"c\":[\"Redis\",\"LRU\",\"内存淘汰\",\"算法原理\"]},\"909\":{\"h\":\"Redis锁机制详解\",\"t\":[\"redis实现分布式锁的方式\",\"分布式锁就是分布式场景下的锁，比如多台不同机器上的进程，去竞争同一项资源，这个时候就需要加锁\",\"互斥性：锁的目的是获取资源的使用权，所以只让一个竞争者持有锁，这一点要尽可能保证\",\"安全性：避免锁因为异常永远不被释放。当一个竞争者在持有锁期间内，由于意外崩溃而导致未能主动解锁，其持有的锁也能够被兜底释放，并保证后续其它竞争者也能加锁\",\"对称性：同一个锁，加锁和解锁必须是同一个竞争者。不能把其他竞争者持有的锁给释放了\",\"可靠性：需要有一定程度的异常处理能力、容灾能力。\",\"分布式锁，一般会依托第三方组件实现\",\"利用 redis 实现是用的最多的一种\"]},\"910\":{\"h\":\"最简化版本\",\"t\":[\"实现方式\",\"直接用Redis的setnx命令，这个命令的语法是：setnx key value 如果key不存在，则会将key设置为value，并返回1 如果key存在，不会有任务影响，返回0 基于这个特性，我们就可以用setnx实现加锁的目的：通过setnx加锁，加锁之后其他服务无法加锁，用完之后，再通过delete解锁，\",\"流程图\",\"20240127155257\"]},\"911\":{\"h\":\"升级 1：支持过期时间\",\"t\":[\"最简化版本有一个问题\",\"如果获取锁的服务挂掉了，那么锁就一直得不到释放，就像石沉大海，杳无音信 所以，我们需要一个超时来兜底。\",\"设置过期时间\",\"Redis中有expire命令，用来设置一个key的超时时间。 但是setnx和expire不具备原子性，如果setnx获取锁之后，服务挂掉，依旧是泥牛入海。\",\"原子性问题\",\"Redis考虑到了这种场景，推出了如下执行语句：set key value nx ex seconds nx表示具备setnx 特性，ex表示增加了过期时间，最后一个参数就是过期时间的值\",\"流程图\",\"20240127155314\"]},\"912\":{\"h\":\"升级 2：超时 + 锁归属\",\"t\":[\"升级 1 存在的问题：可能服务 A 会释放掉服务 B\",\"想一下如下场景：服务A获取了锁，由于业务流程比较长，或者网络延迟、GC卡顿等原因，导致锁过期，而业务还会继续进行。 这时候，业务B已经拿到了锁，准备去执行 这个时候服务A恢复过来并做完了业务，就会释放锁，而B却还在继续执行。 在真实的分布式场景中，可能存在几十个竞争者，那么上述情况发生概率就很高，导致同一份资源频繁被不同竞争者同时访问，分布式锁也就失去了意义。 🌰想一下如下场景：基于这个场景，可以发现，问题关键在于，竞争者可以释放其他人的锁。 那么在异常情况下，就会出现问题，所以我们可以进一步给出解决方案： 🌰分布式锁需要满足谁申请谁释放原则，不能释放别人的锁，也就是说，分布式锁，是要有归属的。\",\"给锁加上 owner\",\"20240127155324\"]},\"913\":{\"h\":\"升级 3：引入 Lua\",\"t\":[\"升级 2 存在的问题\",\"升级 2 的流程：竞争者获取锁执行任务，执行完毕后，检查锁是不是自己的，最后再进行释放 这一通下操作都不是原子化的，可能锁获取的时候还是自己的，但是删除的时候已经是别人的了\",\"如何理解：锁获取的时候还是自己的，但是删除的时候已经是别人的了\",\"旧客户端删除前检查锁，显示旧客户端是 owner\",\"旧客户端准备释放锁，恰好这时候锁过期了，相当于锁被自行释放了\",\"此时，新客户端来获取到了这个锁，owner 是新客户端\",\"旧客户端执行释放操作，把新客户端的锁释放了\",\"Redis+Lua\",\"Redis还有个特性，专门整合原子操作 —— Lua \"]},\"914\":{\"h\":\"升级 3 满足：对称性，安全性，互斥性\"},\"915\":{\"h\":\"升级 4：可靠性的保证\",\"t\":[\"前面的内容，基本是基于单机考虑的，如果Redis挂掉了，那锁就不能获取了。 这个问题该如何解决呢？ 一般来说，有两种方法：\",\"主从容灾\",\"多级部署。\"]},\"916\":{\"h\":\"主从容灾\",\"t\":[\"最简单的一种方式，就是为Redis配置从节点，当主节点挂了，用从节点顶包。 但是主从切换，需要人工参与，会提高人力成本。 不过Redis已经有成熟的解决方案，也就是哨兵模式，可以灵活自动切换，不再需要人工介入。\",\"哨兵模式\",\"20240127155359\"]},\"917\":{\"h\":\"多机部署\",\"t\":[\"如果对一致性的要求高一些，可以尝试多机部署，比如Redis的RedLock，\",\"RedLcok\",\"大概的思路就是多个机器，通常是奇数个，达到一半以上同意加锁才算加锁成功，这样，可靠性会向ETCD靠近。 还不了解 etcd？一文带你快速入门（万字长文）-腾讯云开发者社区-腾讯云\",\"现在假设有5个Redis主节点，基本保证它们不会同时宕掉，获取锁和释放锁的过程中，客户端会执行以下操作：\",\"向5个Redis申请加锁\",\"只要超过一半，也就是3个Redis返回成功，那么就是获取到了锁。 如果超过一半失败，需要向每个Redis发送解锁命令\",\"由于向5个Redis发送请求，会有一定时耗，所以锁剩余持有时间，需要减去请求时间 这个可以作为判断依据，如果剩余时间已经为0，那么也是获取锁失败\",\"使用完成之后，向5个Redis发送解锁请求。\",\"20240127155408\",\"这种模式的好处在于，如果挂了2台Redis，整个集群还是可用的，给了运维更多时间来修复。 另外，单点Redis的所有手段，这种多机模式都可以使用 比如为每个节点配置哨兵模式，由于加锁是一半以上同意就成功，那么如果单个节点进行了主从切换，单个节点数据的丢失，就不会让锁失效了。\"]},\"918\":{\"h\":\"RedLock 可靠性探索\",\"t\":[\"分布式系统的三困境：NPC\",\"N：Network Delay（网络延迟）\",\"P：Process Pause（进程暂停）\",\"C：Clock Drift（时钟漂移）\",\"Network Delay\",\"当分布式锁获得返回包的时间过长，此时可能虽然加锁成功，但是已经时过境迁，锁可能很快过期。 RedLock算做了些考量，也就是前面所说的锁剩余持有时间，需要减去请求时间，如此一来，就可以一定程度解决网络延迟的问题\",\"Process Pause\",\"比如发生GC：获取锁之后GC了，处于GC执行中，然后锁超时。 其它锁想获取，这种情况几乎无解。 这时候GC回来了，那么两个进程就获取到了同一个分布式锁。（GC 回来，以为自己还持有锁，继续做任务） 也许会说，在GC回来之后，可以再去查一次啊？这里有两个问题\",\"你怎么知道GC回来了？ 这个可以在做业务之前，通过时间，进行一个粗略判断\",\"如果你判断的时候是ok的，但是判断完才开始 GC 呢？ 这点RedLock是无法解决的。\",\"Clock Drift\",\"如果竞争者A，获得了RedLock，在5台分布式机器上都加上锁。 为了方便分析，直接假设5台机器都发生了时钟漂移，锁瞬间过期了。 这时候竞争者B拿到了锁，此时A和B拿到了相同的执行权限。\",\"根据上述的分析可以看出，RedLock也不能扛住NPC的挑战，因此，单单从分布式锁本身出发，完全可靠是不可能的。 要实现一个相对可靠的分布式锁机制，还是需要和业务的配合，业务本身要幂等可重入，这样的设计可以省却很多麻烦\"]},\"919\":{\"c\":[\"数据库\",\"Redis\"]},\"920\":{\"c\":[\"Redis\",\"锁机制\",\"并发控制\",\"分布式系统\"]},\"921\":{\"h\":\"Redis分布式锁实现详解\",\"t\":[\"分布式锁\",\"分布式锁是什么\",\"分布式锁就是分布式场景下的锁，比如多台不同机器上的进程，去竞争同一项资源，这个时候就需要加锁\",\"分布式锁特性\",\"互斥性：锁的目的是获取资源的使用权，所以只让一个竞争者持有锁，这一点要尽可能保证\",\"安全性：避免锁因为异常永远不被释放。当一个竞争者在持有锁期间内，由于意外崩溃而导致未能主动解锁，其持有的锁也能够被兜底释放，并保证后续其它竞争者也能加锁\",\"对称性：同一个锁，加锁和解锁必须是同一个竞争者。不能把其他竞争者持有的锁给释放了\",\"可靠性：需要有一定程度的异常处理能力、容灾能力。\",\"常用实现方式\",\"分布式锁，一般会依托第三方组件实现\",\"利用 redis 实现是用的最多的一种\",\"最简化版本\",\"实现方式\",\"直接用Redis的setnx命令，这个命令的语法是：setnx key value\",\"如果key不存在，则会将key设置为value，并返回1\",\"如果key存在，不会有任务影响，返回0\",\"基于这个特性，我们就可以用setnx实现加锁的目的：通过setnx加锁，加锁之后其他服务无法加锁，用完之后，再通过delete解锁，\",\"流程图\",\"...\",\"升级 1：支持过期时间\",\"最简化版本有一个问题\",\"如果获取锁的服务挂掉了，那么锁就一直得不到释放，就像石沉大海，杳无音信\",\"所以，我们需要一个超时来兜底。\",\"设置过期时间\",\"Redis中有expire命令，用来设置一个key的超时时间。\",\"但是setnx和expire不具备原子性，如果setnx获取锁之后，服务挂掉，依旧是泥牛入海。\",\"原子性问题\",\"nx表示具备setnx 特性，ex表示增加了过期时间，最后一个参数就是过期时间的值\",\"流程图\",\"...\",\"升级 2：超时 + 锁归属\",\"升级 1 存在的问题：可能服务 A 会释放掉服务 B\",\"想一下如下场景：\",\"服务A获取了锁，由于业务流程比较长，或者网络延迟、GC卡顿等原因，导致锁过期，而业务还会继续进行。\",\"这时候，业务B已经拿到了锁，准备去执行\",\"这个时候服务A恢复过来并做完了业务，就会释放锁，而B却还在继续执行。\",\"在真实的分布式场景中，可能存在几十个竞争者，那么上述情况发生概率就很高，导致同一份资源频繁被不同竞争者同时访问，分布式锁也就失去了意义。\",\"🌰想一下如下场景：基于这个场景，可以发现，问题关键在于，竞争者可以释放其他人的锁。 那么在异常情况下，就会出现问题，所以我们可以进一步给出解决方案： 🌰分布式锁需要满足谁申请谁释放原则，不能释放别人的锁，也就是说，分布式锁，是要有归属的。\",\"给锁加上 owner\",\"...\",\"升级 3：引入 Lua\",\"升级 2 存在的问题\",\"升级 2 的流程：竞争者获取锁执行任务，执行完毕后，检查锁是不是自己的，最后再进行释放\",\"这一通下操作都不是原子化的，可能锁获取的时候还是自己的，但是删除的时候已经是别人的了\",\"如何理解：锁获取的时候还是自己的，但是删除的时候已经是别人的了\",\"旧客户端删除前检查锁，显示旧客户端是 owner\",\"旧客户端准备释放锁，恰好这时候锁过期了，相当于锁被自行释放了\",\"此时，新客户端来获取到了这个锁，owner 是新客户端\",\"旧客户端执行释放操作，把新客户端的锁释放了\",\"Redis+Lua\",\"Redis还有个特性，专门整合原子操作 —— Lua\",\"...\",\"升级 3 满足：对称性，安全性，互斥性\",\"升级 4：可靠性的保证\",\"前面的内容，基本是基于单机考虑的，如果Redis挂掉了，那锁就不能获取了。\",\"这个问题该如何解决呢？ 一般来说，有两种方法：\",\"主从容灾\",\"多级部署。\",\"1. 主从容灾\",\"最简单的一种方式，就是为Redis配置从节点，当主节点挂了，用从节点顶包。\",\"...\",\"但是主从切换，需要人工参与，会提高人力成本。\",\"不过Redis已经有成熟的解决方案，也就是哨兵模式，可以灵活自动切换，不再需要人工介入。\",\"哨兵模式\",\"...\",\"2. 多机部署\",\"如果对一致性的要求高一些，可以尝试多机部署，比如Redis的RedLock，\",\"RedLcok\",\"大概的思路就是多个机器，通常是奇数个，达到一半以上同意加锁才算加锁成功，这样，可靠性会向ETCD靠近。还不了解 etcd？一文带你快速入门（万字长文）-腾讯云开发者社区-腾讯云\",\"现在假设有5个Redis主节点，基本保证它们不会同时宕掉，获取锁和释放锁的过程中，客户端会执行以下操作：\",\"向5个Redis申请加锁\",\"只要超过一半，也就是3个Redis返回成功，那么就是获取到了锁。 如果超过一半失败，需要向每个Redis发送解锁命令\",\"由于向5个Redis发送请求，会有一定时耗，所以锁剩余持有时间，需要减去请求时间 这个可以作为判断依据，如果剩余时间已经为0，那么也是获取锁失败\",\"使用完成之后，向5个Redis发送解锁请求。\",\"...\",\"这种模式的好处在于，如果挂了2台Redis，整个集群还是可用的，给了运维更多时间来修复。\",\"另外，单点Redis的所有手段，这种多机模式都可以使用\",\"比如为每个节点配置哨兵模式，由于加锁是一半以上同意就成功，那么如果单个节点进行了主从切换，单个节点数据的丢失，就不会让锁失效了。\",\"3. RedLock 可靠性探索\",\"分布式系统的三困境：NPC\",\"N：Network Delay（网络延迟）\",\"P：Process Pause（进程暂停）\",\"C：Clock Drift（时钟漂移）\",\"Network Delay\",\"当分布式锁获得返回包的时间过长，此时可能虽然加锁成功，但是已经时过境迁，锁可能很快过期。\",\"RedLock算做了些考量，也就是前面所说的锁剩余持有时间，需要减去请求时间，如此一来，就可以一定程度解决网络延迟的问题\",\"Process Pause\",\"比如发生GC：获取锁之后GC了，处于GC执行中，然后锁超时。\",\"...\",\"其它锁想获取，这种情况几乎无解。\",\"这时候GC回来了，那么两个进程就获取到了同一个分布式锁。（GC 回来，以为自己还持有锁，继续做任务）\",\"...\",\"也许会说，在GC回来之后，可以再去查一次啊？这里有两个问题\",\"你怎么知道GC回来了？ 这个可以在做业务之前，通过时间，进行一个粗略判断\",\"如果你判断的时候是ok的，但是判断完才开始 GC 呢？ 这点RedLock是无法解决的。\",\"Clock Drift\",\"如果竞争者A，获得了RedLock，在5台分布式机器上都加上锁。\",\"为了方便分析，直接假设5台机器都发生了时钟漂移，锁瞬间过期了。\",\"这时候竞争者B拿到了锁，此时A和B拿到了相同的执行权限。\",\"根据上述的分析可以看出，RedLock也不能扛住NPC的挑战，因此，单单从分布式锁本身出发，完全可靠是不可能的。\",\"要实现一个相对可靠的分布式锁机制，还是需要和业务的配合，业务本身要幂等可重入，这样的设计可以省却很多麻烦\"]},\"922\":{\"c\":[\"数据库\",\"Redis\"]},\"923\":{\"c\":[\"Redis\",\"分布式锁\",\"分布式系统\",\"并发控制\"]},\"924\":{\"h\":\"Redis消息队列实现详解\",\"t\":[\"消息队列\",\"是什么\",\"传递消息的队列，有先入先出的特性。\",\"消息队列一般用于异步流程，消息分发，流量削峰\",\"消息队列可以实现高性能、高可用、高拓展的架构\",\"比较出名的消息队列\",\"ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ\",\"redis 做消息队列\",\"上面出名的消息队列，比如 kafka 都是很优秀的消息队列中间件，但是接入和维护一个消息队列中间件，还是比较繁重的事务。\",\"轻量级的消息队列能用 redis 实现\",\"List 做消息队列\",\"回顾 List\",\"是一个双端列表，可以先入先出\",\"...\",\"使用 List 相关命令就可以实现一个消息队列\",\"RPUSH\",\"LPOP\",\"缺点 1\",\"消费者无法知道 LPOP 时机，只能不停按时间间隔轮询。\",\"解决 1：阻塞版 POP\",\"BRPOP\",\"BLPOP\",\"如果没有消息，就会阻塞，直到达到超时时间，设置为 10S\",\"...\",\"缺点 2：无 ACK 机制\",\"消费者去消息后，消息就退出队列了，如果消费失败，消息还得想办法放回去，同时也不支持多人消费\",\"Pub/Sub 生产订阅模式\",\"当某个订阅者订阅了某个频道，如果生产者将消息发送到这个频道，订阅者就会收到该消息，支持多个消费者订阅相同的频道，无不干扰\",\"...\",\"用法\",\"两个客户端订阅 chanmsg 这个 channel，语法：subscribe channel\",\"...\",\"在第三个终端，连续发送 3 条信息，语法：publish channel message\",\"...\",\"在订阅者终端，两个终端均显示如下\",\"...\",\"订阅者支持订阅模式，即一个模式消息，比如 chan*，就订阅所有 chan 开头的频道\",\"...\",\"缺点\",\"不支持 ack\",\"不支持持久化，redis 重启，信息会全部丢失，所以适合处理不那么重要的信息\",\"stream 做消息队列\",\"。不重要\",\"几种方式对比\",\"List，不需要ACK，不需要消费组，可用\",\"PUB/SUB，不需要ACK，不需要持久化，可用\",\"Stream，需要ACK，需要消费组，需要持久化，可用 Stream功能最全，但是相对完备的消息队列中间件比如Kafka，可靠性还是很大差距，不支持至少一次语意，因为Redis本身的数据持久化都是有时间空隙的，如果对数据的可靠要求比较强，还是需要用完整的消息中间件。\",\"Redis这三种，是三种不同功能要求下的消息传递手段，Stream相对来说在轻量级里相对完善。\"]},\"925\":{\"c\":[\"数据库\",\"Redis\"]},\"926\":{\"c\":[\"Redis\",\"消息队列\",\"异步处理\",\"系统设计\"]},\"927\":{\"h\":\"Redis实现秒杀系统详解\",\"t\":[\"秒杀\",\"是什么\",\"秒杀通常指因为某种活动瞬时产生巨大流量的场景\",\"比如双十一0点抢10000个苹果折扣手机，这种活动通常会吸引几十万甚至数百万人参与，而且大家都盯着0点，等0点一到就是海量的请求。\",\"...\",\"问题\",\"1. 海量请求，服务要能扛住\",\"秒杀活动一开始，瞬间会有海量流量涌入，热门的商品甚至会有几百万人来抢。\",\"这个规模的流量砸下来，服务可能就挂了，活动也就GG了，收获的只有骂声。\",\"2. 不能超卖\",\"因为秒杀有时候就是赔本赚吆喝，价格可能比成本价还低。\",\"而这时候要是比原计划的数量卖多了，那到底发不发货呢？ 发货会超预算亏损，要是超卖数量过多，说不定厂子都要倒闭了；\",\"不发货会被投诉，影响商家声誉。 不管怎样，都是硬伤，只能找程序员赔钱了。\",\"3. 避免少卖\",\"少卖会比超卖好一些，商家不存在经济上的损失。但要是被眼尖的消费者发现的话，也是免不了一场麻烦的。所以我们还是要尽可能避免这种情况。\",\"4. 保证触达的用户不是黄牛\",\"黄牛可能是开脚本，一次发很多请求过来，抢到之后再转卖。但我们做活动，希望的就是回馈客户，进而吸引用户，而不是去让黄牛赚外快。因此，我们要尽量挡住黄牛的魔爪。\",\"黄牛的恶劣影响，很多时候是被低估了。\",\"不仅仅是侵害了正常用户的权益，同时由于黄牛善于使用脚本，很容易造成大量的恶意请求，让本就不富裕的服务器资源，雪上加霜。\",\"限购\",\"通常来说，为了打击黄牛，最常见的方式是限购，一个用户最多只能抢到N份，这样可以大大保障正常用户的权益。\",\"具体怎么做呢，为了性能，还是将限制逻辑加入到Redis中，所以我们的Lua脚本中\",\"第一步查询库存，第二步扣减库存\",\"需要优化为\",\"第一步查询库存，第二步查询用户已购买个数，第三步扣减库存，第四步记录用户购买数。\",\"...\",\"竞争公平：没有银弹\",\"作为追求极致的coder，我们希望还能更进一步，做到竞争公平。\",\"怎么解决呢？\",\"某个用户请求接口次数过于频繁，一般说明是用脚本在跑，可以只针对该用户做限制。\",\"针对IP做限制也是常见做的做法，但这样容易误杀，主要考虑到使用同一个网络的用户，可能都是一个出口IP。限制IP，会导致正常用户也受到影响。\",\"更好用的方案是加上一个验证码验证\",\"验证码符合91原则，90%的时间，都用在验证码输入上，所以使用脚本点击的影响会降到很低。\",\"怎么高并发\",\"主要思路：削峰、限流、异步、补偿\",\"异步\",\"可以通过消息队列实现，将抢和购解耦，还可以方便限频，不至于让 mysql 压力过大\",\"抢 使用 reids 做处理，因为 reids 处理简单的扣减请求非常快，reids 单机支持每秒几万的写入，还可以做成集群，提高扩展能力\",\"简单流程\",\"先将库存名额预加载到 redis\",\"在 redis 中进行扣减\",\"扣减成功的再通过消息队列传递到 mysql 做正在的订单生成\",\"...\",\"预计有 100w 请求量\",\"可以选择临时调度 20 个 redis 实例来支持，一个 5w/s，留点 buffer\",\"也不用用 cluster 模式，用 nginx 负载均衡就可\",\"...\",\"拒绝超卖\",\"将库存名额加载到了Redis，那就需要精确计数。\",\"我们抢购场景最核心的，有两个步骤：\",\"• 第一步，判断库存名额是否充足；\",\"• 第二步，减少库存名额，扣减成功就是抢到。\",\"...\",\"有一个问题要考虑\",\"如果第一步判断的时候还有库存，但是由于是并发操作，实际调用的时候，可能已经没有库存了，这样就会造成超卖。\",\"所以第一步和第二步都是需要原子操作的。\",\"Redis➕Lua，可以说是专门为解决原子问题而生，在Lua脚本中调用Redis的多个命令，这些命令整体上会作为原子操作来进行。\",\"redis➕Lua\",\"有了这套机制之后，我们看下访问Redis扣减库存时各种异常情况\",\"正常业务错误，比如库存用完，这种情况符合预期，直接返回给用户即可。\",\"访问Redis错误，这种情况返回给用户，让其重试即可\",\"访问Redis超时，这种情况下，其实可能库存已经扣减成功，此时不用再重试，避免产生更多的无效扣减，虽然多了一次扣减，但是总数是不变的，只会少卖不会多卖。\",\"避免少卖\",\"什么情况会这样呢？有几种可能：\",\"上面提到的，减少库存操作超时，但实际是成功的，因为超时并不会进入生成订单流程；\",\"在Redis操作成功，但是向Kafka发送消息失败，这种情况也会白白消耗Redis中的库存。\",\"...\",\"问题：证Redis库存+Kafka消耗的最终一致性\",\"说白了，我们只需要保证Redis库存+Kafka消耗的最终一致性。\",\"但是一致性问题，一直是分布式场景的恶龙\",\"• 第一种，也最简单的方式，在投递Kafka失败的情况下，增加渐进式重试；\",\"• 第二种，更安全一点，就是在第一种的基础上，将这条消息记录在磁盘上，慢慢重试；\",\"• 第三种，写磁盘之前就可能失败，可以考虑走WAL路线，但是这样做下去说不定就做成MySQL的 undo log，redo log这种WAL技术了，会相当复杂，没有必要。\",\"Redis角色\",\"Redis扮演扣减库存的角色，这个主要源自Redis比关系型存储高很多的处理性能。\",\"实际上，除了扣件库存，Redis有时候也可以扮演队列的角色，请求过来先记录在Redis，虽然不如传统消息队列可靠，但胜在轻量。\"]},\"928\":{\"c\":[\"数据库\",\"Redis\"]},\"929\":{\"c\":[\"Redis\",\"秒杀系统\",\"高并发\",\"系统设计\"]},\"930\":{\"h\":\"Redis缓存系统详解\",\"t\":[\"缓存\",\"在计算机系统中，默认两种缓存:\",\"CPU 里面的末级缓存，即 LLC，用来缓存内存中的数据，避免每次从内存中存取数据；\",\"内存中的高速页缓存，即 page cache，用来缓存磁盘中的数据，避免每次从磁盘中存取数据。\",\"...\",\"Redis 做缓存\",\"Redis场景应用一：缓存场景 - 掘金\",\"Redis由于性能高效，通常可以做数据库存储的缓存，比如给MySQL当缓存就是常见的玩法\",\"具体而言，就是将MySQL的热点数据存储在Redis中，通常业务都满足二八原则，80%的流量在20%的热点数据之上，所以缓存是可以很大程度提升系统的吞吐量\",\"怎么做\",\"一般而言，缓存分为服务器端缓存、客户端缓存\",\"服务器端缓存：服务端将数据存入Redis，可以在访问DB之后，将数据缓存，或者在回包时将回包内容以请求参数为Key缓存。\",\"客户端缓存：对服务端远程调用之后，将结果存储在客户端，这样下次请求相同数据时就能直接拿到结果，不会再远程调用，提高性能节省网络带宽。\",\"用服务端还是客户端呢？\",\"服务端缓存：其实是需要分析具体瓶颈在哪里，从服务角度来看，在目前的微服务架构下，每个服务其实都应该缓存一些热点数据，以减轻热点数据频繁请求给自己带来的压力，毕竟微服务也要有一定的互不信任原则。\",\"客户端缓存：这个就更看场景了，频繁请求的数据，就有必要做缓存。\",\"缓存的几种模式\",\"Cache-Aside Pattern：旁路缓存模式\",\"Read Through Cache Pattern：读穿透模式\",\"Write Through Cache Pattern：写穿透模式\",\"Write Behind Pattern：又叫Write Back，异步缓存写入模式\",\"Cache-Aside\",\"旁路缓存模式\",\"是最常见的模式，应用服务把缓存当作数据库的旁路，直接和缓存进行交互。\",\"读操作的流程\",\"应用服务收到查询请求后，先查询数据是否在缓存上\",\"如果在，就用缓存数据直接打包返回\",\"如果不在，就去访问数据库，从数据库查询，并放到缓存中\",\"除了查库后加载这种模式，如果业务有需要，还可以预加载数据到缓存\",\"...\",\"写操作的流程\",\"...\",\"在写操作的时候，Cache Aside模式是一般是先更新数据库，然后直接删除缓存\",\"为什么不直接更新呢？\",\"因为更新相比删除会更容易造成时序性问题\",\"举个例子： thread1更新mysql为5 -> thread2更新mysql为3 -> thread2更新缓存为3 -> thread1更新缓存为5，最终正确的数据因为时序性被覆盖了。\",\"该模式的缺点\",\"是可能会出现缓存和数据库不一致的情况。\",\"总结\",\"Cache Aside适用于读多写少的场景，比如用户信息、新闻报道等，一旦写入缓存，几乎不会进行修改。\",\"Read-Through\",\"读穿透模式\",\"和Cache Aside模式的区别主要在于： 应用服务不再和缓存直接交互，而是直接访问数据服务\",\"这个数据服务可以理解为一个代理，即单独起这么一个服务，由它来访问数据库和缓存。\",\"作为使用者来看，不知道里面到底有没有缓存，数据服务会自己来根据情况查询缓存或者数据库。\",\"查询时\",\"和 Cache Aside一样，也是缓存中有，就用从缓存中获得的数据，没有就查DB，只不过这些由数据服务托管保存，而对应用服务是透明的。\",\"...\",\"优点\",\"相比 Cache Aside，Read Through 的优势是缓存对业务透明，业务代码更简洁。\",\"缺点\",\"是缓存命中时性能不如 Cache Aside，相比直接访问缓存，还会多一次服务间调用。\",\"Write-Through\",\"对比Cache Aside\",\"在Cache Aside中，应用程序需要维护两个数据存储：一个缓存，一个数据库。\",\"这对于应用程序来说，更新操作比较麻烦，还要先更新数据库，再去删除缓存。\",\"Write Through\",\"相当于做一层封装： 由这个存储服务先写入MySQL，再同步写入Redis，这样及时加载或更新缓存数据。\",\"可以理解为，应用程序只有一个单独的访问源，而存储服务自己维护访问逻辑。\",\"当 用。\",\"...\",\"潜在使用场景\",\"Write-Through的潜在使用场景是银行系统。\",\"Write-Through 适用情况\",\"• 对缓存及时性要求更高（写入就加载了缓存，当然这种模式可能会有时序性问题）\",\"• 不能忍受数据丢失（相对Write-Behind而言）和数据不一致，当然Cache Aside也是如此\",\"总结\",\"在使用Write-Through时要特别注意的是缓存的有效性管理，否则会导致大量的缓存占用内存资源，因为这种模式下只要写入数据就加载了缓存。\",\"Write-Behind\",\"对比 Write-Through\",\"相同点：Write-Behind 和 Write-Through 都是写入时候会更新数据库、也会更新缓存。\",\"不同点：Write-Through 会把数据立即写入数据库中，然后写缓存，安全性很高。\",\"Write-Behind\",\"而 Write-Behind 是先写缓存，然后异步把数据一起写入数据库\",\"这个异步写操作是Write-Behind的最大特点，极大地降低了请求延迟并减轻了数据库的负担\",\"写操作可以用不同方式完成\",\"一种是时间上的灵活性，其中一个方式就是收集写操作并在某一时间点（比如数据库负载低的时候）慢慢写入\",\"另一种方式就是合并几个写操作成为一个批量操作，一起批量写入\",\"...\",\"代价是安全性不够\",\"比如先写入了Redis，更新操作先放在存储服务内存中，但是还没异步写入MySQL之前，存储服务崩溃了，那么数据也就丢失了\",\"缓存异常场景\",\"缓存穿透\",\"问题背景\",\"缓存穿透\",\"是指缓存和数据库中都没有的数据，而用户不断发起请求。\",\"由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。\",\"在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。\",\"...\",\"如发起为id为\\\"-1\\\"的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。\",\"解决方案\",\"接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截\",\"从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。 这样可以防止攻击用户反复用同一个id暴力攻击\",\"布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。\",\"布隆过滤器\",\"布隆(Bloom Filter)过滤器——全面讲解，建议收藏_李子捌的博客-CSDN博客\",\"布隆过滤器的关键就在于hash算法和容器大小\",\"布隆过滤器是一种比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉我们 \\\"某样东西一定不存在或者可能存在\\\"\",\"...\",\"布隆过滤器原理\",\"布隆过滤器底层是一个64位的整型，将字符串用多个Hash函数映射不同的二进制位置，将整型中对应位置设置为1。\",\"在查询的时候\",\"如果一个字符串所有Hash函数映射的值都存在，那么数据可能存在。\",\"为什么说可能呢\",\"就是因为其他字符可能占据该值，即不同的 key 但是 hash 冲突了，\",\"可以看到，布隆过滤器优缺点都很明显，优点是空间、时间消耗都很小，缺点是结果不是完全准\",\"...\",\"缓存击穿\",\"问题背景\",\"缓存击穿，一般指是指热键在过期失效的一瞬间，还没来得及重新产生，就有海量数据，直达数据库\",\"缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。\",\"解决方案\",\"热点数据支持续期，持续访问的数据可以不断续期，避免因为过期失效而被击穿\",\"发现缓存失效，重建缓存加互斥锁\",\"当线程查询缓存发现缓存不存在就会尝试加锁，线程争抢锁，拿到锁的线程就会进行查询数据库，然后重建缓存，争抢锁失败的线程，可以加一个睡眠然后循环重试\",\"...\",\"缓存雪崩\",\"问题背景\",\"缓存雪崩\",\"是指大量的应用请求因为异常无法在Redis缓存中进行处理，像雪崩一样，直接打到数据库。\",\"雪崩的原因，主要是\",\"缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机\",\"宕机算雪崩吗\",\"在一些资料里，会把Redis宕机算进来，原因是Redis宕机了也就无法处理缓存请求，但这里会觉得有些牵强，如果这里能算，缓存击穿不也可以算？\",\"所以这里建议是不把宕机考虑到雪崩里去。\",\"和缓存击穿不同的是，缓存击穿指一条热点数据在Redis没得到及时重建，缓存雪崩是一大批数据在Redis同时失效\",\"解决方案\",\"缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。\",\"重建缓存加互斥锁，当线程拿到缓存发现缓存不存在就会尝试加锁，线程争抢锁，拿到锁的线程就会进行查询数据库，然后重建缓存，争抢锁失败的线程，可以加一个睡眠然后循环重试\",\"缓存一致性\",\"缓存一致性问题是什么\",\"数据源与缓存的数据不一致\",\"比如数据源为 MySQL，缓存用 Redis\",\"以旁路缓存 Cache-Aside 为基础\",\"大方向有 3 种\",\"更新MySQL即可，不管Redis，以过期时间兜底\",\"更新MySQL之后，操作Redis\",\"异步将MySQL的更新同步到Redis\",\"方向一：更新MySQL即可，不管Redis，以过期时间兜底\",\"做法\",\"使用redis的过期时间，mysql更新时，redis不做处理，等待缓存过期失效，再从mysql拉取缓存。\",\"优点\",\"这种方式实现简单，但不一致的时间会比较明显，具体由业务来配置。\",\"redis原生接口，开发成本低，易于实现；\",\"管理成本低，出问题的概率会比较小。\",\"不足\",\"完全依赖过期时间，时间太短容易造成缓存频繁失效，太长容易有较长时间不一致，对编程者的业务能力，有一定要求。\",\"如果读请求非常频繁，且过期时间设置较长，则会产生很多脏数据。\",\"方向二：更新MySQL之后，操作Redis\",\"做法\",\"不光通过key的过期时间兜底，还需要在更新mysql时，同时尝试操作redis\",\"这里的操作分两种方式\",\"更新，直接将结果写入Redis，但实际上很少用更新\",\"删除，等待下次访问再加载回来\",\"为什么是删除而不是更新？因为更新容易带来时序性问题。\",\"举个例子\",\"假设a的初始值为2，两台业务服务器在同一时间发出两条请求：\",\"给a的值加1\",\"设置a的值为5\",\"若mysql中先执行第 1 条，再执行第 2 条，则mysql中 a 的值先变成 3 ，最终为 5 ；\",\"但由于网络传输本身有延迟，所以无法保证两条Redis更新操作谁先执行，如果第二条对应的更新先执行，Redis的数据就先变成了5，然后在加1变成了6。\",\"这就出现数据对不上的问题，相比于数据延迟而言，这更让人疑惑和不能接受。所以一般都选择删除。\",\"注意\",\"上面有提到，这里是尝试删除，这样说是这一步操作是可能失败了，失败就我们可以忽略，也就是不能让删除成为一个关键路径，影响核心流程\",\"因为有key本身的过期时间作为保障，所以最终一致性是一定达成的，主动删除redis数据只是为了减少不一致的时间\",\"优点\",\"相对方向 1，达成最终一致性的延迟更小\",\"实现成本较低，只是在方向 1 的基础上，增加了删除逻辑。\",\"不足\",\"如果更新mysql成功，删除redis却失败，就退化到了方向 1\",\"在更新时候需要额外操作Redis，带来了损耗。\",\"方向三：异步将MySQL的更新同步到Redis\",\"把我们搭建的消费服务作为mysql的一个slave，订阅mysql的binlog日志，解析日志内容，再更新到redis\",\"此方案和业务完全解耦，redis的更新对业务方透明，可以减少心智成本。\",\"...\",\"难点：如何解析MySQL的BinLog\",\"这需要对binlog文件以及MySQL有非常深入的理解\",\"同时由于binlog存在Statement/Row/Mixedlevel多种形式，分析binlog实现同步的工作量是非常大的\",\"优点\",\"和业务完全解耦，在更新mysql时，不需要做额外操作\",\"无时序性问题，可靠性强。\",\"缺点\",\"引入了消息队列这种算比较重的组件，还要单独搭建一个同步服务，维护他们是非常大的额外成本\",\"同步服务如果压力比较大，或者崩溃了，那么在较长时间内，redis中都是老旧数据\",\"方案选型\",\"首先确认产品上对延迟性的要求，如果要求极高，且数据有可能变化，别用缓存。\",\"通常来说，过期时间兜底是行之有效的办法，根据实时性期待不一样，可以增加个删除逻辑，提升一致性。\",\"从解耦层面来看，可以使用订阅binlog的模式来更新，缺点就是重，比较适合的场景是数据不过期场景\"]},\"931\":{\"c\":[\"数据库\",\"Redis\"]},\"932\":{\"c\":[\"Redis\",\"缓存\",\"性能优化\",\"系统设计\"]},\"933\":{\"h\":\"Redis实现限流器详解\",\"t\":[\"限流器\",\"面试必备：4种经典限流算法讲解\",\"面试官：来，年轻人！请手撸5种常见限流算法！ - Java填坑笔记 - 博客园\",\"阿里云二面：你对限流了解多少？\"]},\"934\":{\"c\":[\"数据库\",\"Redis\"]},\"935\":{\"c\":[\"Redis\",\"限流器\",\"系统设计\",\"高并发\"]},\"936\":{\"h\":\"Redis内存数据管理详解\",\"t\":[\"redis 的数据在内存中的组织过程\",\"本文不对 redis 的数据对象以及底层编码方式作深入展开。 仅是以 局部到全景 的思路简单理解 redis 的数据在内存中的组织过程。\",\"小林coding 图解redis\",\"Redis 源码日志\"]},\"937\":{\"h\":\"1.1 存储形式为 redisObject\",\"t\":[\"redis 是 键值对 存储，key 和 value 在 redis 中被抽象为redisObject，即对象。\",\"key： 只能是 string 对象。\",\"value： 支持丰富的对象种类，包括：string、list、set、hash、zset等。\"]},\"938\":{\"h\":\"1.2 redisObject 结构\",\"t\":[\"重点关注 type 和 encoding 字段。\",\"type：表明是哪种 redis 数据对象。\",\"encoding：表明数据对象的底层编码方式（底层数据结构）。可以看到不同的数据对象，可能采用相同的编码方式。\",\"2\"]},\"939\":{\"h\":\"1.3 实际例子\",\"t\":[\"存一条数据，redis 命令：set 我是一个key 1000\",\"redisObject 表现为👇\",\"key = \\\"我是一个key\\\" ， Object 的图示（假设用embstr编码）：\",\"3\",\"value = 1000 ，Object 的图示（假设用编码int）：\",\"4\"]},\"940\":{\"h\":\"1.3 redisObject 代码\",\"t\":[\"除了 type 和 encoding 字段外，\",\"lru：记录对象访问信息，用于内存淘汰（lru、lfu 都复用这个字段）\",\"refcount：引用计数，用来描述有几个指针指向该对象\",\"ptr：内容指针，指向实际数据\",\"// redis 6.0.10 struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr; };\",\"从上面了解到 k-v 在内存里的存储形式为 redisObject，那这些 Object 又是被如何组织管理的呢？\",\"自然是dict\"]},\"941\":{\"h\":\"2.1 dict 结构\",\"t\":[\"简单视角理解 dict 管理 redisObject\",\"简单来说，dict 是一张哈希表，Redis 所有的 key-value 都存储在里面。\",\"dict\",\"深入一点理解 dict 管理 redisObject\",\"dict 在 redis 中会有更多层的抽象，以便实现更多功能。\",\"dict+\"]},\"942\":{\"h\":\"2.2 dict 代码\",\"t\":[\"// 哈希表（字典）数据结构，Redis 的所有键值对都会存储在这里。其中包含两个哈希表。 struct dict { // 哈希表的类型，包括哈希函数，比较函数，键值的内存释放函数 dictType *type; // 存储一些额外的数据 void *privdata; // 两个哈希表，先使用ht[0],扩容时启用ht[1] dictht ht[2]; // 哈希表重置下标，指向的是哈希数组的数组下标，扩容时使用。 int rehashidx; // 绑定到哈希表的迭代器个数 int iterators; };\",\"dict 管理存储的 redisObject，那谁来组织 dict 呢？ 自然是再上一层的抽象：redisDB\"]},\"943\":{\"h\":\"3.1 redisDB 结构\",\"t\":[\"redisDB 的重点字段\",\"id：redis 启动时默认开启 16 个 DB，对应0-15 编号。可配置。\",\"dict：指向一个 dict。\",\"expires：指向一个 dict，该 dict 存储含过期时间的 k-v。\",\"redisdb\"]},\"944\":{\"h\":\"3.2 redisDb 代码\",\"t\":[\"struct redisDb { int id; // 数据库ID dict *dict; // 该数据库的键空间 dict *expires; // 设置了超时的键的超时时间 dict *blocking_keys; // 有客户端等待数据的键（BLPOP） dict *ready_keys; // 接收到PUSH操作的阻塞键 dict *watched_keys; // 用于MULTI/EXEC CAS的监视键 long long avg_ttl; // 平均生存时间（TTL），仅用于统计 unsigned long expires_cursor; // 活跃过期周期的游标。 list *defrag_later; // 稍后尝试逐个、逐渐进行碎片整理的键名列表。 }\",\"经过上面对 redisObject、dict、redisDB 的层层理解，对 redis 有了结构化、层次化的理解。\",\"接下来以全景的视角来看 redis 的组织形式\",\"redis.drawio\",\"重点结构：\",\"redisDB：默认是有 0-15 编号，共 16 个 DB ，默认是选择 0 号。\",\"dict：对 hashtable 的一层封装，添加 k-v 的地方\",\"hashtable：对 dictEntry 的一层封装，存有 table 的地址\",\"dictEntry(bucket)：存储 key-value 对象。\",\"redisObject：每个 key 和 value 都表现为一个 redisObject 对象\"]},\"945\":{\"h\":\"4.1 redis 哈希冲突如何解决\",\"t\":[\"redis 依靠 dict 哈希表来组织所有的 k-v 对象。\",\"每次添加 k-v 的时候，需要进行 hash运算 以及 掩码运算 来找到对应的插入位置，这时可能会发生哈希冲突。\",\"redis 用变种拉链法来解决哈希冲突，全景图的 dictEntry 结构有一个 next 字段，指向冲突的下一对 k-v\",\"hash\"]},\"946\":{\"h\":\"4.2 redisDB 的 expires\",\"t\":[\"在全景图的 redisDB 结构中，可以发现 *dict 、*expires 都是指向一个dict 结构。\",\"但 expires 所指向的 dict 在组织形式上会有所差异：\",\"dict 和 expires 中的 key 对象，实际都是存储了 string 对象的指针，所以是不会重复占用内存。\",\"如果设置了过期时间，key 的指针 在 dict 和 expires 都会存储一份。只是 expires 中 value 指向 timestamp（过期时间），而 dict 的 value 指向实际数据。\",\"expires\"]},\"947\":{\"c\":[\"数据库\",\"Redis\"]},\"948\":{\"c\":[\"Redis\",\"内存管理\",\"数据结构\",\"性能优化\"]},\"949\":{\"h\":\"Redis AOF混合持久化详解\",\"t\":[\"AOF优化-混合持久化\",\"混合持久化是什么？\",\"混合部署听名字似乎是同时开启RDB和AOF，实际上不是\",\"混合部署实际发生在AOF重写阶段，将当前状态保存为RDB二进制内容，写入新的AOF文件，再将重写缓冲区的内容追加到新的AOF文件，最后替代原有的AOF文件。\",\"此时的AOF文件，就不再单纯的是日志数据，而是二进制数据+日志数据的混合体，所以叫混合持久化。\",\"混合持久化解决什么问题？\",\"混合持久化是发生在原有的AOF流程，如果从这个视角来看，其实本质还是AOF，只是重写时使用了RDB进行了优化。\",\"如果从更高层面来看，这个确实是属于RDB和AOF优点的融合，属于一种折中方案吧，变成了：可读性降低的AOF 或者说 性能变差的RDB？\",\"在我看来，如果是考虑到对Redis核心处理性能的影响，那还是需要用RDB，如果是为了相对更可靠的数据记录，也就是尽可能丢失更少的数据，那还是得用AOF，同时，如果对可读性没有太大执念，那进一步开启混合持久化，是一个很好的选择，毕竟其实生产上，关注AOF可读性的情况实际比较少。\",\"怎么开启\",\"打开 redis 配置文件 redis.conf\",\"aof-use-rdb-preamble5.0之后默认是打开的，所以5.0之后只要AOF配置开启，默认就是混合持久化\",\"混合持久化开启之后，服务启动时如何加载持久化数据？\",\"如果同时启用了 AOF 和 RDB，Redis 重新启动时，会使用 AOF 文件来重建数据集，因为通常来说， AOF 的数据会更完整\",\"混合持久化还是属于AOF，所以如果有混合持久化，那肯定是优先使用混合持久化的数据。\",\"如何区别是否有AOF混合持久化的数据\",\"可以使用文件开头是否为\\\"REDIS\\\"来判断。\",\"如下例子就是开启了混合持久化的 AOF 文件\",\"...\",\"完整的具体加载流程\",\"...\",\"总结\",\"混合持久化是对AOF重写的优化，这种方式可以大大降低AOF重写的性能损耗，以及降低AOF文件的存储空间，付出的代价则是降低AOF文件的读写性\",\"实际中，很少有真正需要去人肉读AOF数据的情况，这点从5.0之后默认打开AOF混合持久化模式也能看出。\"]},\"950\":{\"c\":[\"数据库\",\"Redis\"]},\"951\":{\"c\":[\"Redis\",\"AOF\",\"持久化\",\"性能优化\"]},\"952\":{\"h\":\"Redis持久化机制详解\",\"t\":[\"持久化\",\"持久化是什么\",\"redis 跑在内存中，当程序重启或者服务崩溃，数据就会丢失，如果业务场景希望重启之后数据还在，就需要持久化，即把数据保存到可永久保存的存储设备中\",\"持久化的方式\",\"RDB\",\"简介\",\"RDB（Redis DataBase）：记录 redis 某个时刻的全部数据，本质就是数据快照，直接保存二进制数据到磁盘，后续通过加载 RDB 文件恢复数据\",\"...\",\"如何开启\",\"在 redis 的配置文件 redis.conf 中\",\"有如下配置\",\"...\",\"配置语法是 save interval num：表示每间隔interval 秒，至少有 num 条写数据操作（增删更新），会激活 RDB 持久化\",\"自动快照时， save 实际触发 bgsave 命令，因为 save 会阻塞，bgsave 是 fork 一个子进程做快照\",\"上图的意思\",\"每 900s，至少有 1 条写数据操作\",\"每 300s，至少有 10 条写数据操作\",\"每 60s，至少有 10000 条写数据操作\",\"他们是并集关系，只要满足其中一个条件，就会触发 RDB 持久化。\",\"默认配置\",\"...\",\"RDB 文件存在哪里\",\"以下参数决定文件会存在哪里\",\"...\",\"二进制文件的形式\",\"【精选】Redis（9）----RDB文件结构_rdb文件内容_cb414的博客-CSDN博客\",\"没有可读性的二进制文件，但是开头有 REDIS 关键字，后面混合持久化会用到\",\"RDB 触发时间\",\"RDB 是几分钟才做一次持久化\",\"虽然可以 fork 出子进程来做全量快照，但是一秒一次，性能开销很大。\",\"有可能上秒的快照还没完成，下一秒又来了，所以 fork 是会导致主线程阻塞的\",\"RDB 快照触发间隔比较难确定，原则不能太短\",\"RDB 具体做了什么\",\"先看看 redis RDB 持久化后的输出\",\"...\",\"流程图\",\"fork 一个子进程来专门做 RDB 持久化\",\"子进程写数据到临时的 RDB 文件\",\"写完后，用新的 RDB 文件替换旧的 RDB 文件\",\"...\",\"this method allows redis to benefit from copy-on-write s semantics\",\"执行 RDB 持久化过程，redis 依然可以继续处理操作命令，就是是能被修改的，用了写时复制技术\",\"VLDB 顶会论文 Async-fork 解读与 Redis 实践 ｜ 得物技术\",\"AOF\",\"简介\",\"AOF（Append Only File）：记录执行的每条命令，重启之后通过重放命令来恢复数据，AOF 本质是记录操作日志，后续通过日志重放恢复数据\",\"...\",\"怎么开启\",\"redis.conf\",\"...\",\"AOF 写入流程\",\"...\",\"每次执行请求，都会写入到 AOF，会不会影响执行性能\",\"肯定是会的\",\"redis 的 3 种 刷盘策略（写入策略）\",\"...\",\"appendfsync always，每次请求都刷入AOF，用官方的话说，非常慢，非常安全\",\"appendfsync everysec，每秒刷一次盘，用官方的话来说就是足够快了，但是在崩溃场景下你可能会丢失1秒的数据。\",\"appendfsync no，不主动刷盘，让操作系统自己刷，一般情况Linux会每30秒刷一次盘，这种策略下，可以说对性能的影响最小，但是如果发生崩溃，可能会丢失相对比较多的数据。\",\"redis 的建议是每秒刷一次\",\"AOF 写入细节\",\"写入 AOF 是分好几步\",\"...\",\"第一步：将数据写入AOF缓存中，这个缓存名字是aof_buf，其实就是一个sds数据\",\"...\",\"第二步：aof_buf 对应数据刷入内核缓冲区\",\"什么时候做这个事情？事实上，Redis源码中一共有4个时机，会调用一个叫flushAppendOnlyFile的函数，这个函数会使用write函数来将数据写入操作系统缓冲区：\",\"处理完事件处理后，等待下一次事件到来之前，也就是beforeSleep中。\",\"周期函数serverCron中，这也是我们打过很多次交道的老朋友了\",\"服务器退出之前的准备工作时\",\"通过配置指令关闭AOF功能时\",\"第三步：刷盘\",\"即调用系统的flush函数，刷盘其实还是在flushAppendOnlyFile函数中，是在write之后\",\"但是不一定调用了flushAppendOnlyFile，flush就一定会被调用，这里其实是支持一个刷盘时机的配置，这一步受刷盘策略影响是最深的：\",\"如果是appendfsync always策略，那么就立刻调用redis_fsync刷盘\",\"如果是AOF_FSYNC_EVERYSEC策略，满足条件后会用aof_background_fsync使用后台线程异步刷盘。\",\"AOF 例子\",\"执行如下命令\",\"...\",\"会生成如下 AOF 文件\",\"...\",\"AOF 重写\",\"AOF 是不断写入的，为了避免 AOF 不断膨胀，redis 采用重写的方式来解决\",\"Redis可以在AOF文件体积变得过大时，自动地在后台Fork一个子进程，专门对AOF进行重写。\",\"说白了，就是针对相同Key的操作，进行合并，比如同一个Key的set操作，那就是后面覆盖前面。\",\"在重写过程中，Redis不但将新的操作记录在原\",\"，而且还会记录在AOF重写缓冲区。\",\"一旦新AOF文件创建完毕，Redis 就会将重写缓冲区内容，追加到新的AOF文件，再用新AOF文件替换原来的AOF文件。\",\"...\",\"AOF达到多大会重写，实际上，这也是配置决定，默认如下，同时满足这两个条件则重写。\",\"...\",\"也就是说，超过64M的情况下，相比上次重写时的数据大一倍，则触发重写，很明显，最后实际上还是在周期函数来检查和触发的\",\"进行持久化的时机\",\"1. 主动执行 save\",\"会阻塞主线程\",\"2. 主动执 bgsave\",\"backgroundsave 不会阻塞主进程\",\"fork 一个子进程来执行快照\",\"3. 达到持久化配置的阈值\",\"4. 执行 bgsave\",\"5. 正常关闭程序\",\"执行一次阻塞持久化 save\",\"正常关闭是不会丢失数据的，崩溃才会（如果考虑主从同步，主节点没崩溃，从节点崩溃就算主节点正常关闭也会丢失数据）\",\"RDB 还是 AOF\",\"如果业务本身只是缓存数据且并不是海量访问，不用开持久化\",\"如果业务本身对数据非常重视，需要保证数据的强一致性，可以同时开启 AOF 和 RDB\",\"同时开启的情况下，只会用 AOF 来加载，但如果只有 RDB 文件而没有 AOF 文件（损坏了），是不会用 RDB 恢复数据的\",\"对上一点的解释：如果你自主选择开启 AOF，要表明数据强一致性，但是 AOF 缺失了，此时是不会用 RDB 去恢复数据，因为 RDB 可能会少了很多数据，会选择此时启动一个空库\",\"虽然 RDB 看起来没什么作用，但是 RDB 作为时间数据快照，是一个很好的兜底文件，存在磁盘中。\",\"除非你可以接受丢失几分钟级别的数据，可以只开启 RDB。\",\"单独开启 AOF，redis 不建议，因为如果决定走数据备份的方案，镜像保存始终是数据库行之有效的解决方案，所以 RDB 是默认开启的，而 AOF 不是\",\"...\"]},\"953\":{\"c\":[\"数据库\",\"Redis\"]},\"954\":{\"c\":[\"Redis\",\"持久化\",\"RDB\",\"AOF\"]},\"955\":{\"h\":\"uber.zap\",\"t\":[\"zap 是由 Uber 公司开源的一款 Go 日志库，就像它的命名一样，zap 以快著称。官方 GitHub 仓库中只用一句话来概括 zap：「在 Go 中进行快速、结构化、分级的日志记录」。这句话简单明了的概括了 zap 的核心特性，今天我们就来介绍下 zap 日志库的基本使用和高级特性，以及如何在实际应用程序中使用，来提高应用程序的可靠性。\"]},\"956\":{\"h\":\"1. zap特点\",\"t\":[\"zap 具有如下特点：\",\"快，非常快，这也是 zap 最显著的特点。速度快的原因是 zap 避免使用 interface{} 和反射，并且使用 sync.Pool 减少堆内存分配。在 zap 面前 Logrus 的执行速度只有被吊打的份，你可以在官方 GitHub 仓库中看到 zap 与不同日志库的速度对比。\",\"支持结构化日志记录。这是一个优秀的日志库必备功能。\",\"支持七种日志级别：Debug、Info、Warn、Error、DPanic、Panic、Fatal，其中 DPanic 是指在开发环境下（development）记录日志后会进行 panic。\",\"支持输出调用堆栈。\",\"支持 Hooks 机制。\"]},\"957\":{\"h\":\"2. 基本使用\",\"t\":[\"基本使用\",\"zap 基本使用方式如下：\",\"package main import ( \\\"time\\\" \\\"go.uber.org/zap\\\" ) func main() { // 生产环境 { logger, \\\\_ := zap.NewProduction() defer logger.Sync() // 刷新 buffer，保证日志最终会被输出 url := \\\"https://jianghushinian.cn/\\\" logger.Info(\\\"production failed to fetch URL\\\", zap.String(\\\"url\\\", url), // 因为没有使用 interface{} 和反射机制，所以需要指定具体类型 zap.Int(\\\"attempt\\\", 3), zap.Duration(\\\"backoff\\\", time.Second), ) } // 开发环境 { logger, \\\\_ := zap.NewDevelopment() defer logger.Sync() url := \\\"https://jianghushinian.cn/\\\" logger.Debug(\\\"development failed to fetch URL\\\", zap.String(\\\"url\\\", url), zap.Int(\\\"attempt\\\", 3), zap.Duration(\\\"backoff\\\", time.Second), ) } }\",\"zap 针对生产环境和开发环境提供了不同的函数来创建 Logger 对象。\",\"如果想在日志后面追加 key-value，则需要根据 value 的数据类型使用 zap.String、zap.Int 等方法实现。这一点在使用上显然不如 Logrus 等其他日志库来的方便，但这也是 zap 速度快的原因之一，zap 内部尽量避免使用 interface{} 和反射来提高代码执行效率。\",\"记录日志的 logger.Xxx 方法签名如下：\",\"func (log \\\\*Logger) Info(msg string, fields ...Field)\",\"其中 fields 是 zapcore.Field 类型，用来存储 key-value，并记录 value 类型，不管是 zap.String 还是 zap.Int 底层都是 zapcore.Field 类型来记录的。zap 为每一种 Go 的内置类型都定义了对应的 zap.Xxx 方法，甚至还实现 zap.Any() 来支持 interface{}。\",\"执行以上代码，控制台得到如下输出：\",\"{\\\"level\\\":\\\"info\\\",\\\"ts\\\":1679212318.10218,\\\"caller\\\":\\\"zap/main.go:16\\\",\\\"msg\\\":\\\"production failed to fetch URL\\\",\\\"url\\\":\\\"https://jianghushinian.cn/\\\",\\\"attempt\\\":3,\\\"backoff\\\":1} 2023-03-19T15:51:58.102+0800 DEBUG zap/main.go:29 development failed to fetch URL {\\\"url\\\": \\\"https://jianghushinian.cn/\\\", \\\"attempt\\\": 3, \\\"backoff\\\": \\\"1s\\\"}\",\"可以发现，通过 zap.NewProduction() 创建的日志对象输出格式为 JSON，而通过 zap.NewDevelopment() 创建的日志对象输出格式为 Text，日志后面追加的 key-value 会被转换成 JSON。并且，两者输出的字段内容也略有差异，如生产环境日志输出的时间格式为 Unix epoch 利于程序解析，而开发环境日志输出的时间格式为 ISO8601 更利于人类阅读。\",\"导致以上这些差异的原因是配置不同，我们来看下 zap.NewProduction 和 zap.NewDevelopment 的代码实现：\",\"func NewProduction(options ...Option) (\\\\*Logger, error) { return NewProductionConfig().Build(options...) } func NewProductionConfig() Config { return Config{ Level: NewAtomicLevelAt(InfoLevel), Development: false, Sampling: &SamplingConfig{ Initial: 100, Thereafter: 100, }, Encoding: \\\"json\\\", EncoderConfig: NewProductionEncoderConfig(), OutputPaths: []string{\\\"stderr\\\"}, ErrorOutputPaths: []string{\\\"stderr\\\"}, } } func NewDevelopment(options ...Option) (\\\\*Logger, error) { return NewDevelopmentConfig().Build(options...) } func NewDevelopmentConfig() Config { return Config{ Level: NewAtomicLevelAt(DebugLevel), Development: true, Encoding: \\\"console\\\", EncoderConfig: NewDevelopmentEncoderConfig(), OutputPaths: []string{\\\"stderr\\\"}, ErrorOutputPaths: []string{\\\"stderr\\\"}, } }\",\"可以看到，两者在实现思路上是一样的，都是先创建一个配置对象 zap.Config，然后再调用配置对象的 Build 方法来构建 Logger。\",\"zap.Config 定义如下：\",\"type Config struct { Level AtomicLevel json:\\\"level\\\" yaml:\\\"level\\\" Development bool json:\\\"development\\\" yaml:\\\"development\\\" DisableCaller bool json:\\\"disableCaller\\\" yaml:\\\"disableCaller\\\" DisableStacktrace bool json:\\\"disableStacktrace\\\" yaml:\\\"disableStacktrace\\\" Sampling \\\\*SamplingConfig json:\\\"sampling\\\" yaml:\\\"sampling\\\" Encoding string json:\\\"encoding\\\" yaml:\\\"encoding\\\" EncoderConfig zapcore.EncoderConfig json:\\\"encoderConfig\\\" yaml:\\\"encoderConfig\\\" OutputPaths []string json:\\\"outputPaths\\\" yaml:\\\"outputPaths\\\" ErrorOutputPaths []string json:\\\"errorOutputPaths\\\" yaml:\\\"errorOutputPaths\\\" InitialFields map[string]interface{} json:\\\"initialFields\\\" yaml:\\\"initialFields\\\" }\",\"每个配置项说明如下：\",\"Level: 日志级别。\",\"Development: 是否为开发模式。\",\"DisableCaller: 禁用调用信息，值为 true 时，日志中将不再显示记录日志时所在的函数调用文件名和行号。\",\"DisableStacktrace: 禁用堆栈跟踪捕获。\",\"Sampling: 采样策略配置，单位为每秒，作用是限制日志在每秒内的输出数量，以此来防止全局的 CPU 和 I/O 负载过高。\",\"Encoding: 指定日志编码器，目前支持 json 和 console。\",\"EncoderConfig: 编码配置，决定了日志字段格式。\",\"OutputPaths: 配置日志输出位置，URLs 或文件路径，可配置多个。\",\"ErrorOutputPaths: zap 包内部出现错误的日志输出位置，URLs 或文件路径，可配置多个，默认 os.Stderr。\",\"InitialFields: 初始化字段配置，该配置的字段会以结构化的形式打印在每条日志输出中。\",\"我们再来对比下 NewProductionEncoderConfig() 和 NewDevelopmentEncoderConfig() 这两个配置的不同：\",\"func NewProductionEncoderConfig() zapcore.EncoderConfig { return zapcore.EncoderConfig{ TimeKey: \\\"ts\\\", LevelKey: \\\"level\\\", NameKey: \\\"logger\\\", CallerKey: \\\"caller\\\", FunctionKey: zapcore.OmitKey, MessageKey: \\\"msg\\\", StacktraceKey: \\\"stacktrace\\\", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.EpochTimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } } func NewDevelopmentEncoderConfig() zapcore.EncoderConfig { return zapcore.EncoderConfig{ // Keys can be anything except the empty string. TimeKey: \\\"T\\\", LevelKey: \\\"L\\\", NameKey: \\\"N\\\", CallerKey: \\\"C\\\", FunctionKey: zapcore.OmitKey, MessageKey: \\\"M\\\", StacktraceKey: \\\"S\\\", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.CapitalLevelEncoder, EncodeTime: zapcore.ISO8601TimeEncoder, EncodeDuration: zapcore.StringDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, } }\",\"对比来看，两者有很多不同的配置，比如生产环境下 EncodeTime 值为 zapcore.EpochTimeEncoder，开发环境下 EncodeTime 值为 zapcore.ISO8601TimeEncoder。这就是生产环境日志输出的时间格式为 Unix epoch 而开发环境日志输出的时间格式为 ISO8601 的原因。\",\"zapcore.EncoderConfig 其他几个常用的配置项说明如下：\",\"MessageKey: 日志信息的键名，默认 msg。\",\"LevelKey: 日志级别的键名，默认 level。\",\"TimeKey: 日志时间的键名。\",\"EncodeLevel: 日志级别的格式，默认为小写，如 info。\",\"除了提供 zap.NewProduction() 和 zap.NewDevelopment() 两个构造函数外，zap 还提供了 zap.NewExample() 来创建一个 Logger 对象，这个方法主要用于测试，这里就不多介绍了。\",\"给语法加点糖\",\"zap 虽然速度足够快，但是多数情况下，我们并不需要极致的性能，而是想让代码写起来更爽一些。zap 为我们提供了解决方案 —— SugaredLogger。\",\"package main import ( \\\"time\\\" \\\"go.uber.org/zap\\\" ) func main() { logger, \\\\_ := zap.NewProduction() defer logger.Sync() url := \\\"https://jianghushinian.cn/\\\" sugar := logger.Sugar() sugar.Infow(\\\"production failed to fetch URL\\\", \\\"url\\\", url, \\\"attempt\\\", 3, \\\"backoff\\\", time.Second, ) sugar.Info(\\\"Info\\\") sugar.Infof(\\\"Infof: %s\\\", url) sugar.Infoln(\\\"Infoln\\\") }\",\"通过 logger.Sugar() 方法可以将一个 Logger 对象转换成一个 SugaredLogger 对象。\",\"SugaredLogger 提供了更人性化的接口，日志中追加 key-value 时不在需要 zap.String(\\\"url\\\", url) 这种显式指明类型的写法，只需要保证 key 为 string 类型，value 则可以为任意类型，能够减少我们编写的代码量。\",\"此外，为了满足不同需求，SugaredLogger 提供了四种方式输出日志：sugar.Xxx、sugar.Xxxw、sugar.Xxxf、sugar.Xxxln。\",\"执行以上代码，控制台得到如下输出：\",\"{\\\"level\\\":\\\"info\\\",\\\"ts\\\":1679217743.5967638,\\\"caller\\\":\\\"zap/sugar.go:15\\\",\\\"msg\\\":\\\"production failed to fetch URL\\\",\\\"url\\\":\\\"https://jianghushinian.cn/\\\",\\\"attempt\\\":3,\\\"backoff\\\":1} {\\\"level\\\":\\\"info\\\",\\\"ts\\\":1679217743.5969589,\\\"caller\\\":\\\"zap/sugar.go:20\\\",\\\"msg\\\":\\\"Info\\\"} {\\\"level\\\":\\\"info\\\",\\\"ts\\\":1679217743.5969741,\\\"caller\\\":\\\"zap/sugar.go:21\\\",\\\"msg\\\":\\\"Infof: https://jianghushinian.cn/\\\"} {\\\"level\\\":\\\"info\\\",\\\"ts\\\":1679217743.5969841,\\\"caller\\\":\\\"zap/sugar.go:22\\\",\\\"msg\\\":\\\"Infoln\\\"}\",\"我们知道，这种方便的写法是有一定代价的，所以开发中是否需要使用 SugaredLogger 来记录日志，需要根据程序的特点来决定。SugaredLogger 与 Logger 的性能对比同样可以在官方 GitHub 仓库中看到。\",\"定制 Logger\",\"通过查看 zap.NewProduction() 和 zap.NewDevelopment() 两个构造函数源码，我们知道可以使用 zap.Config 对象的 Build 方法创建 Logger 对象。那么我们很容易能够想到，如果要定制 Logger，只需要创建一个定制的 zap.Config 即可。\",\"package main import ( \\\"go.uber.org/zap\\\" \\\"go.uber.org/zap/zapcore\\\" ) func newCustomLogger() (\\\\*zap.Logger, error) { cfg := zap.Config{ Level: zap.NewAtomicLevelAt(zap.DebugLevel), Development: false, Encoding: \\\"json\\\", EncoderConfig: zapcore.EncoderConfig{ TimeKey: \\\"time\\\", LevelKey: \\\"level\\\", NameKey: \\\"logger\\\", CallerKey: \\\"\\\", // 不记录日志调用位置 FunctionKey: zapcore.OmitKey, MessageKey: \\\"message\\\", LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.RFC3339TimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, }, OutputPaths: []string{\\\"stdout\\\", \\\"test.log\\\"}, ErrorOutputPaths: []string{\\\"error.log\\\"}, } return cfg.Build() } func main() { logger, \\\\_ := newCustomLogger() defer logger.Sync() // 增加一个 skip 选项，触发 zap 内部 error，将错误输出到 error.log logger = logger.WithOptions(zap.AddCallerSkip(100)) logger.Info(\\\"Info msg\\\") logger.Error(\\\"Error msg\\\") }\",\"以上代码通过 newCustomLogger 函数创建了一个自定义的 Logger，同样通过先定义一个 zap.Config 然后再调用其 Build 方法来实现。\",\"配置日志分别输出到标准输出和 test.log 文件，执行以上代码，控制台和 test.log 都会得到如下输出：\",\"{\\\"level\\\":\\\"info\\\",\\\"time\\\":\\\"2023-03-19T19:19:18+08:00\\\",\\\"message\\\":\\\"Info msg\\\"} {\\\"level\\\":\\\"error\\\",\\\"time\\\":\\\"2023-03-19T19:19:18+08:00\\\",\\\"message\\\":\\\"Error msg\\\"}\",\"另外，我们还通过 logger.WithOptions() 为 Logger 对象增加了一个选项 zap.AddCallerSkip(100)，这个选项的作用是指定在通过调用栈获得行号时跳过的调用深度，因为我们的函数调用栈并不是 100 层，所以会触发 zap 内部错误，zap 会将错误日志输出到 ErrorOutputPaths 配置指定的位置中，即 error.log。\",\"error.log 得到的错误日志如下：\",\"2023-03-19 11:19:18.438824 +0000 UTC Logger.check error: failed to get caller 2023-03-19 11:19:18.44921 +0000 UTC Logger.check error: failed to get caller\",\"logger.WithOptions() 支持的选项如下：\",\"WrapCore(f func(zapcore.Core) zapcore.Core): 使用一个新的 zapcore.Core 替换掉 Logger 内部原有的的 zapcore.Core 属性。\",\"Hooks(hooks ...func(zapcore.Entry) error): 注册钩子函数，用来在日志打印时同时调用注册的钩子函数。\",\"Fields(fs ...Field): 添加公共字段。\",\"ErrorOutput(w zapcore.WriteSyncer): 指定日志组件内部出现异常时的输出位置。\",\"Development(): 将日志记录器设为开发模式，这将使 DPanic 级别日志记录错误后执行 panic()。\",\"AddCaller(): 与 WithCaller(true) 等价。\",\"WithCaller(enabled bool): 指定是否在日志输出内容中增加调用信息，即文件名和行号。\",\"AddCallerSkip(skip int): 指定在通过调用栈获取文件名和行号时跳过的调用深度。\",\"AddStacktrace(lvl zapcore.LevelEnabler): 用来指定某个日志级别及以上级别输出调用堆栈。\",\"IncreaseLevel(lvl zapcore.LevelEnabler): 提高日志级别，如果传入的 lvl 比现有级别低，则不会改变日志级别。\",\"WithFatalHook(hook zapcore.CheckWriteHook): 当出现 Fatal 级别日志时调用的钩子函数。\",\"WithClock(clock zapcore.Clock): 指定日志记录器用来确定当前时间的 zapcore.Clock 对象，默认为 time.Now 的系统时钟。\",\"创建自定义的配置对象，除了在代码中指定配置参数，也可以将这些配置项写入到 JSON 文件中，然后通过 json.Unmarshal 的方式将配置绑定到 zap.Config，可以参考官方示例。\",\"二次开发\",\"封装自己的 zap 包\",\"通过前文对 zap 的介绍，相信你对 zap 的特点和用法都已了然于心。如果你用惯了 Go log 标准库，或者是 Logrus 第三方库，那么对于 zap 所提供的 API 一定不会感到满意。因此，我基于 zap 包定制开发了自己的日志包，项目地址在这里，你可以点进去查看源码。\",\"基于 zap 定制的日志包并没有太多的逻辑，只在 zap/zapcore （zapcore 故名思义，是 zap 的核心，zap 是对 zapcore 的封装）基础上进行了很薄的一层封装，所以性能上无需担心。\",\"提示：关于定制开发的日志包设计思路这里就不讲解了，之后我会单独写一篇文章来进行解读，敬请期待（先挖个坑）。\",\"日志包对外提供了类似 Go log 标准库风格的 API，几种常见使用方式如下：\",\"像 Go log 标准库一样开箱即用\",\"package main import ( \\\"os\\\" \\\"time\\\" log \\\"github.com/jianghushinian/gokit/log/zap\\\" ) func main() { defer log.Sync() log.Info(\\\"failed to fetch URL\\\", log.String(\\\"url\\\", \\\"https://jianghushinian.cn/\\\")) log.Warn(\\\"Warn msg\\\", log.Int(\\\"attempt\\\", 3)) log.Error(\\\"Error msg\\\", log.Duration(\\\"backoff\\\", time.Second)) log.SetLevel(log.ErrorLevel) log.Info(\\\"Info msg\\\") log.Warn(\\\"Warn msg\\\") log.Error(\\\"Error msg\\\") // 替换默认 Logger file, \\\\_ := os.OpenFile(\\\"custom.log\\\", os.O\\\\_CREATE|os.O\\\\_APPEND|os.O\\\\_WRONLY, 0644) logger := log.New(file, log.InfoLevel) log.ReplaceDefault(logger) log.Info(\\\"Info msg in replace default logger after\\\") }\",\"自定义日志包提供了默认的 stdLogger 对象和 Info、Warn 等包级别的开放函数，以此实现开箱即用的效果。日志包还提供了 SetLevel 函数来支持运行时修改日志级别。\",\"另外，如果你对默认的 Logger 不满意，可以使用 log.New 来创建新的 Logger，接下来只需要通过 log.ReplaceDefault(logger) 一行代码，就可以将默认的 Logger 替换成新创建的 Logger 对象。之后通过 log.Info 来输出日志底层使用的已经是替换后的 Logger 对象了。\",\"执行以上代码，控制台输出:\",\"{\\\"level\\\":\\\"info\\\",\\\"ts\\\":\\\"2023-03-19T21:57:59+08:00\\\",\\\"msg\\\":\\\"failed to fetch URL\\\",\\\"url\\\":\\\"https://jianghushinian.cn/\\\"} {\\\"level\\\":\\\"warn\\\",\\\"ts\\\":\\\"2023-03-19T21:57:59+08:00\\\",\\\"msg\\\":\\\"Warn msg\\\",\\\"attempt\\\":3} {\\\"level\\\":\\\"error\\\",\\\"ts\\\":\\\"2023-03-19T21:57:59+08:00\\\",\\\"msg\\\":\\\"Error msg\\\",\\\"backoff\\\":1} {\\\"level\\\":\\\"error\\\",\\\"ts\\\":\\\"2023-03-19T21:57:59+08:00\\\",\\\"msg\\\":\\\"Error msg\\\"}\",\"custom.log 输出:\",\"{\\\"level\\\":\\\"info\\\",\\\"ts\\\":\\\"2023-03-19T21:57:59+08:00\\\",\\\"msg\\\":\\\"Info msg in replace default logger after\\\"}\",\"将日志输出到多个位置\",\"package main import ( \\\"os\\\" log \\\"github.com/jianghushinian/gokit/log/zap\\\" ) func main() { file, \\\\_ := os.OpenFile(\\\"test-warn.log\\\", os.O\\\\_CREATE|os.O\\\\_APPEND|os.O\\\\_WRONLY, 0644) tees := []log.TeeOption{ { Out: os.Stdout, LevelEnablerFunc: func(level log.Level) bool { return level == log.InfoLevel }, }, { Out: file, LevelEnablerFunc: func(level log.Level) bool { return level == log.WarnLevel }, }, } logger := log.NewTee(tees) defer logger.Sync() logger.Info(\\\"Info tee msg\\\") logger.Warn(\\\"Warn tee msg\\\") logger.Error(\\\"Error tee msg\\\") // 不会输出 }\",\"自定义日志包通过 log.NewTee 构造函数提供了将日志输出到多个位置的能力，log.NewTee 接收一个 log.TeeOption 列表，用来定义不同级别的日志输出方式，其本质上是定义了多个 zap.Core 对象。\",\"其中 Out 字段为日志输出目标地址，LevelEnablerFunc 用来指定日志级别。这有别于使用 log.InfoLevel 这种常量日志级别的设定，使用 LevelEnablerFunc 只需要定义一个接收 log.Level 作为参数并返回 bool 类型值的函数即可。\",\"这样如果函数内部写为 return level == log.InfoLevel 表示 Info 级别使用此配置日志对象输出，日过函数内部实现为 return level >= log.WarnLevel 则表示 Warn 及以上级别即 Warn、Error、DPanic、Panic、Fatal 级别都使用此配置对应的日志对象作为输出，更为灵活。\",\"执行以上代码，控制台输出:\",\"{\\\"level\\\":\\\"info\\\",\\\"ts\\\":\\\"2023-03-19T22:06:25+08:00\\\",\\\"msg\\\":\\\"Info tee msg\\\"}\",\"test-warn.log 输出:\",\"{\\\"level\\\":\\\"warn\\\",\\\"ts\\\":\\\"2023-03-19T22:06:25+08:00\\\",\\\"msg\\\":\\\"Warn tee msg\\\"}\",\"选项模式、Hooks、日志轮转等更多使用场景可以参考项目的使用示例。在 Gin 框架中的使用示例，可以参考这里。\",\"总结\",\"本文讲解了 Go 第三方日志库 zap 的特点及使用。\",\"zap 作为以快著称的日志库，在使用上不如 Logrus 来的方便，于是我基于 zap 定制开发了自己的日志包，并简单介绍了如何使用。\",\"关于 zap 的更多使用方式可以参考官方文档，如果你对我封装日志包感兴趣，可以查看源码。\",\"参考\",\"zap 源码: github.com/uber-go/zap\",\"zap 文档: pkg.go.dev/go.uber.org…\",\"基于 zap 开发的日志包: github.com/jianghushin…\"]},\"958\":{\"c\":[\"Go\",\"日志框架\"]},\"959\":{\"c\":[\"Go\",\"zap\",\"日志\",\"框架\"]},\"960\":{\"h\":\"Kratos微服务框架详解\",\"t\":[\"本文详细介绍Go语言Kratos微服务框架的架构和使用方法。\"]},\"961\":{\"h\":\"1. Kratos项目结构\",\"t\":[\"Kratos使用kratos-layout作为项目模板，可以通过以下命令创建新项目：\",\"kratos new <project-name>\"]},\"962\":{\"h\":\"1.1 目录结构\",\"t\":[\". ├── Dockerfile ├── LICENSE ├── Makefile ├── README.md ├── api // 下面维护了微服务使用的proto文件以及根据它们所生成的go文件 │ └── helloworld │ └── v1 │ ├── error_reason.pb.go │ ├── error_reason.proto │ ├── error_reason.swagger.json │ ├── greeter.pb.go │ ├── greeter.proto │ ├── greeter.swagger.json │ ├── greeter_grpc.pb.go │ └── greeter_http.pb.go ├── cmd // 整个项目启动的入口文件 │ └── server │ ├── main.go │ ├── wire.go // 我们使用wire来维护依赖注入 │ └── wire_gen.go ├── configs // 这里通常维护一些本地调试用的样例配置文件 │ └── config.yaml ├── generate.go ├── go.mod ├── go.sum ├── internal // 该服务所有不对外暴露的代码，通常的业务逻辑都在这下面，使用internal避免错误引用 │ ├── biz // 业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，而 repo 接口在这里定义，使用依赖倒置的原则。 │ │ ├── README.md │ │ ├── biz.go │ │ └── greeter.go │ ├── conf // 内部使用的config的结构定义，使用proto格式生成 │ │ ├── conf.pb.go │ │ └── conf.proto │ ├── data // 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra层。 │ │ ├── README.md │ │ ├── data.go │ │ └── greeter.go │ ├── server // http和grpc实例的创建和配置 │ │ ├── grpc.go │ │ ├── http.go │ │ └── server.go │ └── service // 实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换(DTO -> DO)，同时协同各类 biz 交互，但是不应处理复杂逻辑 │ ├── README.md │ ├── greeter.go │ └── service.go └── third_party // api 依赖的第三方proto ├── README.md ├── google │ └── api │ ├── annotations.proto │ ├── http.proto │ └── httpbody.proto └── validate ├── README.md └── validate.proto\"]},\"963\":{\"h\":\"2. Kratos项目初始化运行\"},\"964\":{\"h\":\"2.1 创建项目\",\"t\":[\"kratos new <project-name>\"]},\"965\":{\"h\":\"2.2 代码生成\",\"t\":[\"# 生成所有proto源码、wire等等 go generate ./...\"]},\"966\":{\"h\":\"2.3 运行项目\",\"t\":[\"# 运行项目 kratos run # 输出 INFO msg=config loaded: config.yaml format: yaml # 默认载入 configs/config.yaml 配置文件 INFO msg=[gRPC] server listening on: [::]:9000 # gRPC服务监听 9000 端口 INFO msg=[HTTP] server listening on: [::]:8000 # HTTP服务监听 8000 端口\"]},\"967\":{\"h\":\"3. Kratos CLI工具使用\"},\"968\":{\"h\":\"3.1 安装与升级\",\"t\":[\"# 安装Kratos CLI go install github.com/go-kratos/kratos/cmd/kratos/v2@latest # 升级Kratos kratos upgrade\"]},\"969\":{\"h\":\"3.2 Proto文件操作\",\"t\":[\"Kratos-layout项目中对proto文件进行了版本划分，放在了v1子目录下：\",\"# 添加proto文件 kratos proto add api/helloworld/v1/demo.proto # 生成proto代码（在proto文件同目录下生成） # 可以直接通过make命令生成 make api # 或使用kratos cli进行生成 kratos proto client api/helloworld/v1/demo.proto # 生成service代码，-t指定生成目录 kratos proto server api/helloworld/v1/demo.proto -t internal/service\"]},\"970\":{\"h\":\"3.3 常用命令\",\"t\":[\"# 运行项目 kratos run # Kratos版本升级 kratos upgrade # 查看帮助信息 kratos -h\"]},\"971\":{\"c\":[\"Go\",\"微服务\",\"框架\"]},\"972\":{\"c\":[\"Kratos\",\"Go\",\"微服务框架\",\"服务架构\"]},\"973\":{\"h\":\"Gorm\",\"t\":[\"Gorm 是 Go 语言中最受欢迎的 ORM 框架之一，它提供了强大的对象关系映射功能，使开发者能够更加便捷地操作数据库。本文将介绍 Gorm 的基本使用方法和一些高级特性。\"]},\"974\":{\"h\":\"1. Gorm简介\",\"t\":[\"官网: gorm.cn\"]},\"975\":{\"h\":\"2. 数据库连接\",\"t\":[\"使用Gorm需要先下载 mysql 驱动、gorm框架。\",\"// go <--- mysql_driver <--- gorm go get gorm.io/driver/mysql go get gorm.io/gorm\"]},\"976\":{\"h\":\"2.1 建立数据库连接\",\"t\":[\"username := \\\"root\\\" //账号 password := \\\"root\\\" //密码 host := \\\"127.0.0.1\\\" //数据库地址，可以是Ip或者域名 port := 3306 //数据库端口 Dbname := \\\"gorm\\\" //数据库名 timeout := \\\"10s\\\" //连接超时，10秒 // root:root@tcp(127.0.0.1:3306)/gorm? dsn := fmt.Sprintf(\\\"%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local&timeout=%s\\\", username, password, host, port, Dbname, timeout) //连接MYSQL, 获得DB类型实例，用于后面的数据库读写操作。 db, err := gorm.Open(mysql.Open(dsn)) if err != nil { panic(\\\"连接数据库失败, error=\\\" + err.Error()) } // 连接成功 fmt.Println(db)\"]},\"977\":{\"h\":\"2.2 配置连接选项\"},\"978\":{\"h\":\"2.2.1 事务配置\",\"t\":[\"在连接的时候带上&gorm.Config{}\",\"db, err := gorm.Open(mysql.Open(\\\"gorm.db\\\"), &gorm.Config{ SkipDefaultTransaction: true, // true 为不开启事物 })\"]},\"979\":{\"h\":\"2.2.2 命名策略\",\"t\":[\"**默认：**表名是蛇形复数，字段名是蛇形单数。 如：Student ----> students\",\"type Student struct { Name string Age int MyStudent string }\",\"相当于：\",\"CREATE TABLE students (name longtext,age bigint,my_student longtext)\",\"修改这些策略：\",\"db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{ NamingStrategy: schema.NamingStrategy{ TablePrefix: \\\"f_\\\", // 表名前缀 SingularTable: false, // 单数表名 NoLowerCase: false, // 关闭小写转换 }, })\"]},\"980\":{\"h\":\"2.2.3 日志配置\",\"t\":[\"gorm 的默认日志是打印：错误、慢sql。可以自己设置。\",\"var mysqlLogger logger.Interface // 要显示的日志等级 mysqlLogger = logger.Default.LogMode(logger.Info) db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{ Logger: mysqlLogger, })\",\"自定义日志配置：\",\"newLogger := logger.New( log.New(os.Stdout, \\\"\\\\r\\\\n\\\", log.LstdFlags), // （日志输出的目标，前缀和日志包含的内容） logger.Config{ SlowThreshold: time.Second, // 慢 SQL 阈值 LogLevel: logger.Info, // 日志级别 IgnoreRecordNotFoundError: true, // 忽略ErrRecordNotFound（记录未找到）错误 Colorful: true, // 使用彩色打印 }, ) db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{ Logger: newLogger, })\",\"如果只想某些语句显示日志：\",\"DB.Debug().First(&model)\"]},\"981\":{\"h\":\"3. 模型定义\"},\"982\":{\"h\":\"3.1 自动生成表结构\",\"t\":[\"AutoMigrate的逻辑是只新增，不删除，不修改（大小会修改）\",\"例如将 Name 修改为 Name1，进行AutoMigrate，会多出一个 name1 的字段\",\"type Student struct { ID uint // 默认使用ID作为主键 Name string Email *string // 使用指针是为了存空值，指针类型的go可以传nil，如果不是，会有一个默认值 } // 可以放多个 DB.AutoMigrate(&Student{})\"]},\"983\":{\"h\":\"3.2 字段属性配置\",\"t\":[\"使用gorm的标签进行修改\",\"Name string gorm:\\\"type:varchar(12)\\\" Name string gorm:\\\"size:2\\\"\",\"复杂示例：\",\"type StudentInfo struct { Email *string gorm:\\\"size:32\\\" // 使用指针是为了存空值 Addr string gorm:\\\"column:y_addr;size:16\\\" Gender bool gorm:\\\"default:true\\\" } type Student struct { Name string gorm:\\\"type:varchar(12);not null;comment:用户名\\\" UUID string gorm:\\\"primaryKey;unique;comment:主键\\\" Info StudentInfo gorm:\\\"embedded;embeddedPrefix:s_\\\" } // 建表语句 CREATE TABLE students ( name varchar(12) NOT NULL COMMENT '用户名', uuid varchar(191) UNIQUE COMMENT '主键', s_email varchar(32), s_y_addr varchar(16), s_gender boolean DEFAULT true, PRIMARY KEY (uuid) )\",\"常用标签：\",\"type 定义字段类型\",\"size 定义字段大小\",\"column 自定义列名\",\"primaryKey 将列定义为主键\",\"unique 将列定义为唯一键\",\"default 定义列的默认值\",\"not null 不可为空\",\"embedded 嵌套字段\",\"embeddedPrefix 嵌套字段前缀\",\"comment 注释\",\"多个标签之前用 ; 连接\"]},\"984\":{\"h\":\"4. 单表操作\"},\"985\":{\"h\":\"4.1 添加记录\",\"t\":[\"增加一条记录：\",\"email := \\\"xxx@qq.com\\\" // 创建记录 student := Student{ Name: \\\"qqh\\\", Age: 21, Gender: true, Email: &email, } // Create接收的是一个指针，而不是值 DB.Create(&student)\",\"由于我们传递的是一个指针，调用完Create之后，student这个对象上面就有该记录的信息了，如创建的id。\"]},\"986\":{\"h\":\"4.2 批量插入\",\"t\":[\"var studentList []Student for i := 0; i < 100; i++ { studentList = append(studentList, Student{ Name: fmt.Sprintf(\\\"机器人%d号\\\", i+1), Age: 21, Gender: true, Email: &email, }) } DB.Create(&studentList)\"]},\"987\":{\"h\":\"4.3 查询单条记录\"},\"988\":{\"h\":\"4.3.1 基本查询函数\",\"t\":[\"DB = DB.Session(&gorm.Session{Logger: Log}) var student Student DB.Take(&student) // SELECT * FROM students LIMIT 1 DB.First(&student) // SELECT * FROM students ORDER BY students.id LIMIT 1 DB.Last(&student) // SELECT * FROM students ORDER BY students.id DESC LIMIT 1\"]},\"989\":{\"h\":\"4.3.2 主键查询\",\"t\":[\"Take的第二个参数，默认会根据主键查询，可以是字符串，可以是数字\",\"var student Student DB.Take(&student, 2) fmt.Println(student) student = Student{} // 重新赋值 DB.Take(&student, \\\"4\\\") fmt.Println(student)\"]},\"990\":{\"h\":\"4.3.3 条件查询\",\"t\":[\"使用？作为占位符，将查询的内容放入?\",\"var student Student DB.Take(&student, \\\"name = ?\\\", \\\"机器人27号\\\") fmt.Println(student)\",\"防sql注入，将参数全部转义\",\"DB.Take(&student, \\\"name = ?\\\", \\\"机器人27号' or 1=1;#\\\") // SELECT * FROM students WHERE name = '机器人27号\\\\' or 1=1;#' LIMIT 1\"]},\"991\":{\"h\":\"4.3.4 结构体查询\",\"t\":[\"var student Student // 只能有一个主要值 student.ID = 2 //student.Name = \\\"qqh\\\" DB.Take(&student) fmt.Println(student)\"]},\"992\":{\"h\":\"4.3.5 查询结果处理\",\"t\":[\"获取查询的返回的记录数\",\"count := DB.Find(&studentList).RowsAffected\",\"是否查询失败\",\"err := DB.Find(&studentList).Error\",\"查询失败有查询为空，查询条件错误，sql语法错误。可以使用判断：\",\"var student Student err := DB.Take(&student, \\\"xx\\\").Error switch err { case gorm.ErrRecordNotFound: fmt.Println(\\\"没有找到\\\") default: fmt.Println(\\\"sql错误\\\") }\"]},\"993\":{\"h\":\"4.4 查询多条记录\",\"t\":[\"var studentList []Student DB.Find(&studentList) for _, student := range studentList { fmt.Println(student) } // 由于email是指针类型，所以看不到实际的内容 // 但是序列化之后，会转换为我们可以看得懂的方式 var studentList []Student DB.Find(&studentList) for _, student := range studentList { data, _ := json.Marshal(student) fmt.Println(string(data)) }\"]},\"994\":{\"h\":\"4.4.1 主键列表查询\",\"t\":[\"var studentList []Student DB.Find(&studentList, []int{1, 3, 5, 7}) DB.Find(&studentList, 1, 3, 5, 7) // 一样的 fmt.Println(studentList)\"]},\"995\":{\"h\":\"4.4.2 条件列表查询\",\"t\":[\"DB.Find(&studentList, \\\"name in ?\\\", []string{\\\"qqh\\\", \\\"zhangsan\\\"})\"]},\"996\":{\"h\":\"4.5 更新记录\",\"t\":[\"能查询到的记录才能删除\"]},\"997\":{\"h\":\"4.5.1 Save保存所有字段\",\"t\":[\"用于单个记录的全字段更新，它会保存所有字段，即使零值也会保存。\",\"var student Student DB.Take(&student) // 查询第一条记录 student.Age = 22 // 修改第一条记录的年龄 DB.Save(&student) // 保存修改\"]},\"998\":{\"h\":\"4.5.2 更新指定字段\",\"t\":[\"可以使用select选择要更新的字段\",\"var student Student DB.Take(&student) // 查询第一条记录 /* Update：只更新指定的单个字段。 Save（带Select）：可以选择更新多个字段，但在这里通过Select只更新一个字段。 */ DB.Model(&student).Update(\\\"age\\\", 23) // 更新年龄 DB.Select(\\\"age\\\").Save(&student)\"]},\"999\":{\"h\":\"4.5.3 批量删除\",\"t\":[\"var student Student DB.Take(&student, 10) // 查询主键为 10 的记录 DB.Delete(&student) // 删除记录 10 DB.Delete(&Student{}, []int{11, 12, 13}) // 删除主键为 11,12,13 的记录\"]},\"1000\":{\"h\":\"5. 高级查询\"},\"1001\":{\"h\":\"5.1 Where条件查询\",\"t\":[\"等价于sql语句中的where\",\"var users []Student // 查询用户名是qqh的 DB.Where(\\\"name = ?\\\", \\\"qqh\\\").Find(&users) fmt.Println(users) // 查询用户名不是qqh的 DB.Where(\\\"name <> ?\\\", \\\"qqh\\\").Find(&users) fmt.Println(users) // 查询用户名包含 如燕，李元芳的 DB.Where(\\\"name in ?\\\", []string{\\\"如燕\\\", \\\"李元芳\\\"}).Find(&users) fmt.Println(users) // 查询姓李的 DB.Where(\\\"name like ?\\\", \\\"李%\\\").Find(&users) fmt.Println(users) // 查询年龄大于23，是qq邮箱的 DB.Where(\\\"age > ? and email like ?\\\", \\\"23\\\", \\\"%@qq.com\\\").Find(&users) fmt.Println(users) // 查询是qq邮箱的，或者是女的 DB.Where(\\\"gender = ? or email like ?\\\", false, \\\"%@qq.com\\\").Find(&users) fmt.Println(users)\"]},\"1002\":{\"h\":\"5.1.1 结构体查询\",\"t\":[\"使用结构体查询，会过滤零值，并且结构体中的条件都是and关系\",\"// 会过滤零值 Age: 0 会被忽略 DB.Where(&Student{Name: \\\"李元芳\\\", Age: 0}).Find(&users) fmt.Println(users)\"]},\"1003\":{\"h\":\"5.1.2 Map查询\",\"t\":[\"不会过滤零值\",\"DB.Where(map[string]any{\\\"name\\\": \\\"李元芳\\\", \\\"age\\\": 0}).Find(&users) // SELECT * FROM students WHERE age = 0 AND name = '李元芳' fmt.Println(users)\"]},\"1004\":{\"h\":\"5.1.3 Not条件\",\"t\":[\"和where中的not等价\",\"// 排除年龄大于23的 DB.Not(\\\"age > 23\\\").Find(&users) fmt.Println(users)\"]},\"1005\":{\"h\":\"5.1.4 Or条件\",\"t\":[\"和where中的or等价\",\"DB.Or(\\\"gender = ?\\\", false).Or(\\\" email like ?\\\", \\\"%@qq.com\\\").Find(&users) fmt.Println(users)\"]},\"1006\":{\"h\":\"5.2 Select选择字段\",\"t\":[\"DB.Select(\\\"name\\\", \\\"age\\\").Find(&student) fmt.Println(student) // id列 没有被选中，会被赋零值\"]},\"1007\":{\"h\":\"5.3 排序\",\"t\":[\"根据年龄倒序\",\"var users []Student DB.Order(\\\"age desc\\\").Find(&users) fmt.Println(users) // desc 降序 // asc 升序\"]},\"1008\":{\"h\":\"5.4 分页查询\",\"t\":[\"var student []Student // 一页多少条 limit := 2 // 目标第几页 page := 4 // offset 是下一次查询的起始位置， 这里是 (4-1)*2 = 6 ,所以从 7 开始 offset := (page - 1) * limit DB.Limit(limit).Offset(offset).Find(&student) fmt.Println(student) // SELECT * FROM students LIMIT 2 OFFSET 6\"]},\"1009\":{\"h\":\"5.5 去重查询\",\"t\":[\"Distinct用法\",\"var ageList []int DB.Table(\\\"students\\\").Select(\\\"age\\\").Distinct(\\\"age\\\").Scan(&ageList) fmt.Println(ageList)\"]},\"1010\":{\"h\":\"5.6 分组查询\",\"t\":[\"// 查询男生的个数和女生的个数 type AggeGroup struct { Gender int Count int } var agge []AggeGroup DB.Table(\\\"students\\\").Select(\\\"count(id) as Count\\\", \\\"gender\\\").Group(\\\"gender\\\").Scan(&agge) fmt.Println(agge)\"]},\"1011\":{\"h\":\"5.7 原生SQL执行\",\"t\":[\"var student []Student DB.Raw(\\\"SELECT * FROM students\\\").Scan(&student) fmt.Println(student)\"]},\"1012\":{\"h\":\"5.8 子查询\",\"t\":[\"查询大于平均年龄的用户\",\"原生sql：\",\"select * from students where age > (select avg(age) from students);\",\"使用gorm\",\"var users []Student DB.Model(Student{}).Where(\\\"age > (?)\\\", DB.Model(Student{}).Select(\\\"avg(age)\\\")).Find(&users) fmt.Println(users)\"]},\"1013\":{\"h\":\"6. 事务管理\",\"t\":[\"有如下表：\",\"type User struct { ID uint `json:\\\"id\\\"` Name string `json:\\\"name\\\"` Money int `json:\\\"money\\\"` } // InnoDB引擎才支持事务，MyISAM不支持事务 // DB.Set(\\\"gorm:table_options\\\", \\\"ENGINE=InnoDB\\\").AutoMigrate(&User{})\"]},\"1014\":{\"h\":\"6.1 自动事务\",\"t\":[\"var zhangsan, lisi User DB.Take(&zhangsan, \\\"name = ?\\\", \\\"张三\\\") DB.Take(&lisi, \\\"name = ?\\\", \\\"李四\\\") // 张三给李四转账100元 DB.Transaction(func(tx *gorm.DB) error { // 先给张三-100 zhangsan.Money -= 100 err := tx.Model(&zhangsan).Update(\\\"money\\\", zhangsan.Money).Error if err != nil { fmt.Println(err) return err } // 再给李四+100 lisi.Money += 100 err = tx.Model(&lisi).Update(\\\"money\\\", lisi.Money).Error if err != nil { fmt.Println(err) return err } // 提交事务 return nil })\"]},\"1015\":{\"h\":\"6.2 手动事务\",\"t\":[\"手动开启、关闭、回滚事务\",\"// 开始事务 tx := db.Begin() // 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'） tx.Create(...) // ... // 遇到错误时回滚事务 tx.Rollback() // 否则，提交事务 tx.Commit()\",\"上面的转账示例也可以这样写：\",\"var zhangsan, lisi User DB.Take(&zhangsan, \\\"name = ?\\\", \\\"张三\\\") DB.Take(&lisi, \\\"name = ?\\\", \\\"李四\\\") // 张三给李四转账100元 tx := DB.Begin() // 先给张三-100 zhangsan.Money -= 100 err := tx.Model(&zhangsan).Update(\\\"money\\\", zhangsan.Money).Error if err != nil { tx.Rollback() } // 再给李四+100 lisi.Money += 100 err = tx.Model(&lisi).Update(\\\"money\\\", lisi.Money).Error if err != nil { tx.Rollback() } // 提交事务 tx.Commit()\"]},\"1016\":{\"c\":[\"Go\",\"ORM框架\"]},\"1017\":{\"c\":[\"Go\",\"Gorm\",\"ORM\",\"框架\"]},\"1018\":{\"h\":\"Gin框架详解\",\"t\":[\"本文详细介绍Go语言Gin框架的基础知识和使用方法。\"]},\"1019\":{\"h\":\"1. 内置的 http 库\"},\"1020\":{\"h\":\"1.1 不方便的地方\",\"t\":[\"主要体现在：\",\"参数解析与验证\",\"路由不太明了\",\"响应处理比较原始\"]},\"1021\":{\"h\":\"1.2 启动一个 web 服务端\",\"t\":[\"package main import ( \\\"encoding/json\\\" \\\"fmt\\\" \\\"net/http\\\" ) // Response 响应结构体 type Response struct { Code int `json:\\\"code\\\"` Data any `json:\\\"data\\\"` Msg string `json:\\\"msg\\\"` } // GET 处理GET请求 func GET(res http.ResponseWriter, req *http.Request) { // 获取参数 fmt.Println(req.URL.String()) // 封装响应数据 data, _ := json.Marshal(Response{ Code: 200, Data: map[string]any{}, Msg: \\\"成功\\\", }) res.Write(data) } func main() { http.HandleFunc(\\\"/index\\\", GET) // 启动一个web服务 http.ListenAndServe(\\\"localhost:8080\\\", nil) }\"]},\"1022\":{\"h\":\"2. Gin 的初始化\"},\"1023\":{\"h\":\"2.1 安装 gin 库\",\"t\":[\"go get github.com/gin-gonic/gin\"]},\"1024\":{\"h\":\"2.2 Hello world\",\"t\":[\"熟悉一下gin框架的默认三板斧：\",\"package main import \\\"github.com/gin-gonic/gin\\\" func main() { // 1 初始化gin引擎 r := gin.Default() // 2 设置路由 r.GET(\\\"/\\\", func(c *gin.Context) { c.String(200, \\\"hello world\\\") }) // 3 监听运行 r.Run(\\\":8080\\\") }\"]},\"1025\":{\"h\":\"2.3 知识扩展\"},\"1026\":{\"h\":\"内网运行\",\"t\":[\"让内网中的其他人访问，地址不要写 127.0.0.1 本地的回环地址即可：\",\"r.Run(\\\":8080\\\") // 等价于 r.Run(\\\"0.0.0.0:8080\\\")\"]},\"1027\":{\"h\":\"关闭日志的debug输出\",\"t\":[\"不想看到gin默认的那些debug输出：\",\"Gin Debug输出\",\"设置运行模式即可，默认是 debug：\",\"gin.SetMode(\\\"release\\\")\"]},\"1028\":{\"h\":\"3. Gin 响应\",\"t\":[\"gin提供了很多响应的方法：string、json、html等等\"]},\"1029\":{\"h\":\"3.1 Json 响应\",\"t\":[\"200是http的状态码，但是一般还会有业务状态码是另外统一封装的：\",\"c.JSON(200, gin.H{ \\\"code\\\": 0, \\\"msg\\\": \\\"ok\\\", })\"]},\"1030\":{\"h\":\"3.2 封装业务状态码\",\"t\":[\"type Code int // 业务状态码 const ( RoleErrCode Code = 1001 NetworkErrCode Code = 1002 ) // 业务状态码对应的具体含义 var codeMap = map[Code]string{ RoleErrCode: \\\"权限错误\\\", NetworkErrCode: \\\"网络错误\\\", }\"]},\"1031\":{\"h\":\"3.3 html 响应\",\"t\":[\"前后端分离的时代，也很少使用后端返回模板，知道怎么用就好。\",\"将 html 的模版文件放在 templates 下：\",\"使用LoadHTMLGlob加载一个目录下的所有html文件，也可以使用LoadHTMLFiles加载单个html文件\",\"load 之后，下面才能用这个文件名\",\"func main() { r := gin.Default() // 加载模板 只有这里加载了模板，下面才能用 r.LoadHTMLGlob(\\\"templates/*\\\") //r.LoadHTMLFiles(\\\"templates/index.html\\\") r.GET(\\\"\\\", func(c *gin.Context) { c.HTML(200, \\\"index.html\\\", nil) // HTML的第三个参数是可以向HTML中传递数据 }) r.Run(\\\":8080\\\") }\"]},\"1032\":{\"h\":\"3.4 响应文件\",\"t\":[\"设置 Content-Type，唤起浏览器的下载\",\"只能是 get 请求\",\"// 设置响应头Content-Type为application/octet-stream，表示这是一个二进制文件流 c.Header(\\\"Content-Type\\\", \\\"application/octet-stream\\\") // 设置Content-Disposition响应头，attachment表示这是一个附件 // filename=\\\"3.文件下载.go\\\"用于指定下载下来的文件名 c.Header(\\\"Content-Disposition\\\", \\\"attachment; filename=\\\\\\\"3.文件下载.go\\\\\\\"\\\") // 发送文件到客户端，文件路径为\\\"./3.文件下载.go\\\" // 浏览器会根据前面的响应头信息，提示用户下载该文件 c.File(\\\"./3.文件下载.go\\\")\",\"最佳实践：\",\"调下载接口的请求，后端不返回实际文件内容，而是生成一个临时下载地址\",\"前端构造a标签，再请求这个接口唤起浏览器下载\",\"<a href=\\\"文件路径\\\" download=\\\"文件名\\\">文件下载</a>\",\"文件下载示例\"]},\"1033\":{\"h\":\"3.5 配置静态文件\",\"t\":[\"gin也可以通过内置方法构造静态文件的路径。\",\"静态文件的路径，不能再被路由使用了：\",\"r.Static(\\\"static\\\", \\\"static\\\") // 第一个参数是别名，第二个才是实际路径 r.StaticFile(\\\"abcd\\\", \\\"static/abc.txt\\\")\"]},\"1034\":{\"h\":\"4. 获取请求参数\"},\"1035\":{\"h\":\"4.1 查询参数\",\"t\":[\"比如：http://xxxxx/xxx?key=xxx&name=xxxx&name=yyyy 这种就被称为查询参数\",\"查询参数不是GET请求专属的，post请求也可以有\",\"name := c.Query(\\\"name\\\") age := c.DefaultQuery(\\\"age\\\", \\\"25\\\") keyList := c.QueryArray(\\\"key\\\") fmt.Println(name, age, keyList)\",\"例如请求 ?name=fengfeng&age=123&key=123&key=124，输出为：\",\"fengfeng 123 [123 124]\"]},\"1036\":{\"h\":\"4.2 动态参数\",\"t\":[\"查询参数的模式：/users?id=123\",\"动态参数模式：/users/123\",\"实现方式：\",\"r.GET(\\\"users/:id\\\", func(c *gin.Context) { userID := c.Param(\\\"id\\\") fmt.Println(userID) })\"]},\"1037\":{\"h\":\"4.3 表单参数\",\"t\":[\"一般专指 form 表单。\",\"注意！接口测试工具能走通的，前端请求不一定可以走通的情况：\",\"get请求带请求体\",\"ws加请求头\",\"获取表单参数的方法：\",\"// 从POST请求中获取表单字段\\\"name\\\"的值 name := c.PostForm(\\\"name\\\") // 从POST请求中获取表单字段\\\"age\\\"的值，同时检查该字段是否存在 age, ok := c.GetPostForm(\\\"age\\\") // 输出获取到的\\\"name\\\"值 fmt.Println(name) // 输出获取到的\\\"age\\\"值和一个布尔值，表示该字段是否存在 fmt.Println(age, ok)\",\"实现一个文件上传功能：\",\"文件上传示例\",\"// 方式 1： // c.SaveUploadedFile会将上传的文件保存到服务器上的指定路径 // 参数fileHeader是文件头信息，\\\"uploads/xxx/yyy/\\\"+fileHeader.Filename是目标路径 fileHeader, err := c.FormFile(\\\"file\\\") err = c.SaveUploadedFile(fileHeader, \\\"uploads/xxx/yyy/\\\" + fileHeader.Filename) fmt.Println(err) // 方式 2： r.POST(\\\"users\\\", func(c *gin.Context) { // 从请求中获取文件头 fileHeader, err := c.FormFile(\\\"file\\\") if err != nil { // 如果获取文件头出现错误，打印错误并返回 fmt.Println(err) return } // 输出文件名 fmt.Println(fileHeader.Filename) // 输出文件大小（单位：字节） fmt.Println(fileHeader.Size) // 打开文件 file, _ := fileHeader.Open() // 读取文件内容 byteData, _ := io.ReadAll(file) // 将文件内容写入名为 \\\"xxx.jpg\\\" 的文件 err = os.WriteFile(\\\"xxx.jpg\\\", byteData, 0666) // 输出可能出现的错误 fmt.Println(err) })\"]},\"1038\":{\"h\":\"5. bind 绑定器\",\"t\":[\"Gin的bind功能可以将HTTP请求的各种数据格式（如JSON、XML、表单数据等）自动解析并绑定到结构体中\",\"ShouldBind()这个方法会根据请求的Content-Type自动选择合适的绑定器\"]},\"1039\":{\"h\":\"5.1 查询参数\",\"t\":[\"// 定义一个User结构体，用于存储绑定的数据 type User struct { // Name字段对应URL查询参数中的\\\"name\\\" Name string `form:\\\"name\\\"` // Age字段对应URL查询参数中的\\\"age\\\" Age int `form:\\\"age\\\"` } // 创建一个User结构体实例，用于接收绑定的数据 var user User // 使用ShouldBindQuery方法将URL查询参数绑定到user结构体 // ShouldBindQuery会根据结构体字段的form标签从URL查询参数中解析数据 err := c.ShouldBindQuery(&user) // 打印绑定后的user结构体和可能出现的错误 fmt.Println(user, err) // 返回绑定后的数据作为JSON响应 c.JSON(200, gin.H{ \\\"name\\\": user.Name, \\\"age\\\": user.Age, })\"]},\"1040\":{\"h\":\"5.2 路径参数\",\"t\":[\"package main import ( \\\"fmt\\\" \\\"github.com/gin-gonic/gin\\\" ) type User struct { Name string `uri:\\\"name\\\"` ID int `uri:\\\"id\\\"` } func main() { r := gin.Default() r.GET(\\\"/user/:name/:id\\\", func(c *gin.Context) { var user User // 使用ShouldBindUri方法将URI路径参数绑定到user结构体 err := c.ShouldBindUri(&user) // 打印绑定后的user结构体和可能出现的错误 fmt.Println(user, err) // 返回绑定后的数据作为JSON响应 c.JSON(200, gin.H{ \\\"name\\\": user.Name, \\\"id\\\": user.ID, }) }) r.Run() // 默认监听并在 0.0.0.0:8080 上启动服务 })\"]},\"1041\":{\"h\":\"5.3 表单参数\",\"t\":[\"// 定义一个User结构体，用于存储绑定的数据 type User struct { // Name字段对应表单数据或查询参数中的\\\"name\\\" Name string `form:\\\"name\\\"` // Age字段对应表单数据或查询参数中的\\\"age\\\" Age int `form:\\\"age\\\"` } // 创建一个User结构体实例，用于接收绑定的数据 var user User // 使用ShouldBind方法将请求数据绑定到user结构体 // ShouldBind会根据请求的Content-Type自动选择合适的绑定器 // 如果请求是application/x-www-form-urlencoded或multipart/form-data，它会从表单数据中提取 // 如果请求是application/json，它会从JSON数据中提取 err := c.ShouldBind(&user) // 打印绑定后的user结构体和可能出现的错误 fmt.Println(user, err) // 返回绑定后的数据作为JSON响应 c.JSON(200, gin.H{ \\\"name\\\": user.Name, \\\"age\\\": user.Age, })\"]},\"1042\":{\"h\":\"5.4 Json 参数\",\"t\":[\"type User struct { Name string `json:\\\"name\\\"` Age int `json:\\\"age\\\"` } var user User err := c.ShouldBindJSON(&user) fmt.Println(user, err)\"]},\"1043\":{\"h\":\"5.5 Header 参数\",\"t\":[\"// 定义一个User结构体，用于存储从请求头中绑定的数据 type User struct { // Name字段对应请求头中的\\\"Name\\\" Name string `header:\\\"Name\\\"` // Age字段对应请求头中的\\\"Age\\\" Age int `header:\\\"Age\\\"` // UserAgent字段对应请求头中的\\\"User-Agent\\\" UserAgent string `header:\\\"User-Agent\\\"` }\"]},\"1044\":{\"c\":[\"Go\",\"Web框架\"]},\"1045\":{\"c\":[\"Go\",\"Gin\",\"Web开发\"]},\"1046\":{\"h\":\"Go语言bcrypt加密详解\",\"t\":[\"本文详细介绍Go语言中bcrypt加密的原理及实现方法。\"]},\"1047\":{\"h\":\"1. 密码安全概述\"},\"1048\":{\"h\":\"1.1 攻击密码的主要方法\",\"t\":[\"字典攻击：使用包含常见密码的字典尝试破解密码\",\"暴力攻击：通过尝试所有可能的字符组合来破解密码\"]},\"1049\":{\"h\":\"1.2 彩虹表\",\"t\":[\"彩虹表是一个用于加密散列函数逆运算的预先计算好的表（就是在网上搜集的各种字符组合的Hash加密结果）。\"]},\"1050\":{\"h\":\"2. 密码加密策略\"},\"1051\":{\"h\":\"2.1 加密与加盐\",\"t\":[\"加密：Hash加密，即使两层md5算法加密，还是可能通过彩虹表的方式破译\",\"加盐：人为的通过一组随机字符与用户原密码的组合形成一个新的字符，从而增加破译的难度\"]},\"1052\":{\"h\":\"2.2 加盐的安全性\",\"t\":[\"密码使用了盐，但没有为每个密码使用唯一的盐，那么攻击者要做的就是手动生成彩虹表，对每个组合使用盐，然后进行查找。\",\"如果你对每个密码使用唯一的盐，则攻击者需要针对每个密码为每个组合生成一个列表再去查找。这是另外一种类型的攻击，即暴力攻击。\"]},\"1053\":{\"h\":\"2.3 暴力破解\",\"t\":[\"暴力攻击通过反复尝试猜测密码来破解密码。\"]},\"1054\":{\"h\":\"2.4 传统加密算法的局限\",\"t\":[\"MD5或SHA-1（或SHA-256，SHA-512等）是消息摘要算法，旨在快速验证给定消息是否未被篡改。\",\"与慢速哈希（例如bcrypt，scrypt和pbkdf2）不同，MD5、SHA-x不是为密码设计的算法。\"]},\"1055\":{\"h\":\"3. bcrypt加密原理\"},\"1056\":{\"h\":\"3.1 bcrypt哈希字符串的组成\",\"t\":[\"bcrypt哈希由多个部分组成。这些部分用于确定创建哈希的设置，从而可以在不需要任何其他信息的情况下对其进行验证。\",\"bcrypt哈希组成\",\"上图是一个bcrypt哈希的示例图，其由四部分组成：\",\"Prefix：说明了使用的bcrypt的版本\",\"Cost：是进行哈希的次数 - 数字越大生成bcrypt的速度越慢，成本越大。同样也意味着如果密码库被盗，攻击者想通过暴力破解的方法猜测出用户密码的成本变得越昂贵\",\"Salt：是添加到要进行哈希的字符串中的随机字符（21.25个字符），所以使用bcrypt时不需要我们在表里单独存储Salt\",\"Hashed Text：是明文字符串最终被bcrypt应用这些设置哈希后的哈希文本\",\"如果用户使用非常简单的密码例如password或123456，另外无论什么方法：每个密码加单独的盐进行哈希，使用bcrypt进行哈希等等，还是能被猜测出来的，所以在用户设置密码时应该禁止他们输入简单的密码。\"]},\"1057\":{\"h\":\"4. Go语言中使用bcrypt\"},\"1058\":{\"h\":\"4.1 bcrypt包介绍\",\"t\":[\"通过golang.org/x/crypto/bcrypt包提供使用bcrypt函数。\",\"bcrypt包只提供了三个函数：\",\"bcrypt.CompareHashAndPassword()：用于比对bcrypt哈希字符串和提供的密码明文文本是否匹配\",\"bcrypt.GenerateFromPassword()：以给定的Cost返回密码的bcrypt哈希。如果给定的成本小于MinCost，则将成本设置为DefaultCost（10）\",\"bcrypt.Cost()：返回用于创建给定bcrypt哈希的哈希成本。将来密码系统为了应对更大的计算能力而增加哈希成本时，该功能可以用于确定哪些密码需要更新\"]},\"1059\":{\"h\":\"4.2 使用示例\",\"t\":[\"// ./handler/password_hashing.go package handler import ( \\\"fmt\\\" \\\"golang.org/x/crypto/bcrypt\\\" \\\"net/http\\\" ) func HashPassword(password string) (string, error) { bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14) return string(bytes), err } func CheckPasswordHash(password, hash string) bool { err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil } func GetHashingCost(hashedPassword []byte) int { cost, _ := bcrypt.Cost(hashedPassword) // 为了简单忽略错误处理 return cost } func PassWordHashingHandler(w http.ResponseWriter, r *http.Request) { password := \\\"secret\\\" hash, _ := HashPassword(password) // 为了简单忽略错误处理 fmt.Fprintln(w, \\\"Password:\\\", password) fmt.Fprintln(w, \\\"Hash: \\\", hash) match := CheckPasswordHash(password, hash) fmt.Fprintln(w, \\\"Match: \\\", match) cost := GetHashingCost([]byte(hash)) fmt.Fprintln(w, \\\"Cost: \\\", cost) }\",\"输出结果：\",\"Password: secret Hash: $2a$14$Ael8nW7UF/En/iI7LGdyBuaIO8VREbL2CAShRN0EUQHqtmOHXh.XK Match: true Cost: 14\"]},\"1060\":{\"c\":[\"Go\",\"加密\"]},\"1061\":{\"c\":[\"Go\",\"bcrypt\",\"密码加密\",\"安全\"]},\"1062\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"1063\":{\"h\":\"Back End\"},\"1064\":{\"h\":\"Data Structure\"},\"1065\":{\"h\":\"GMP\"},\"1066\":{\"h\":\"Feature\"},\"1067\":{\"h\":\"Grammar\"},\"1068\":{\"h\":\"Library\"},\"1069\":{\"h\":\"Advanced\"},\"1070\":{\"h\":\"Basis\"},\"1071\":{\"h\":\"Framework\"},\"1072\":{\"h\":\"Application\"},\"1073\":{\"h\":\"High Availability\"},\"1074\":{\"h\":\"Basis\"},\"1075\":{\"h\":\"Principle\"},\"1076\":{\"h\":\"Sql\"},\"1077\":{\"h\":\"Data Object\"},\"1078\":{\"h\":\"Operating Principle\"},\"1079\":{\"h\":\"Application\"},\"1080\":{\"h\":\"Basis\"},\"1081\":{\"h\":\"Persistence\"},\"1082\":{\"h\":\"Logframework\"},\"1083\":{\"h\":\"Framework\"},\"1084\":{\"h\":\"Microservices Framework\"},\"1085\":{\"h\":\"ORMframework\"},\"1086\":{\"h\":\"Webframework\"},\"1087\":{\"h\":\"Encipherframework\"}},\"dirtCount\":0,\"index\":[[\"旨在快速验证给定消息是否未被篡改\",{\"1\":{\"1054\":1}}],[\"旨在为\",{\"1\":{\"249\":1}}],[\"暴力破解\",{\"0\":{\"1053\":1}}],[\"暴力攻击通过反复尝试猜测密码来破解密码\",{\"1\":{\"1053\":1}}],[\"暴力攻击\",{\"1\":{\"1048\":1}}],[\"人为的通过一组随机字符与用户原密码的组合形成一个新的字符\",{\"1\":{\"1051\":1}}],[\"人们也称之为命令解释器\",{\"1\":{\"190\":1}}],[\"彩虹表是一个用于加密散列函数逆运算的预先计算好的表\",{\"1\":{\"1049\":1}}],[\"彩虹表\",{\"0\":{\"1049\":1}}],[\"唤起浏览器的下载\",{\"1\":{\"1032\":1}}],[\"知识扩展\",{\"0\":{\"1025\":1}}],[\"知道怎么用就好\",{\"1\":{\"1031\":1}}],[\"知道x\",{\"1\":{\"249\":1}}],[\"知道\",{\"1\":{\"217\":1}}],[\"熟悉一下gin框架的默认三板斧\",{\"1\":{\"1024\":1}}],[\"库\",{\"0\":{\"1019\":1,\"1023\":1}}],[\"张三给李四转账100元\",{\"1\":{\"1014\":1,\"1015\":1}}],[\"张三\",{\"1\":{\"1014\":1,\"1015\":1}}],[\"降序\",{\"1\":{\"1007\":1}}],[\"批量删除\",{\"0\":{\"999\":1}}],[\"批量插入\",{\"0\":{\"986\":1}}],[\"阈值\",{\"1\":{\"980\":1}}],[\"慢\",{\"1\":{\"980\":1}}],[\"慢sql\",{\"1\":{\"980\":1}}],[\"慢慢写入\",{\"1\":{\"930\":1}}],[\"慢慢重试\",{\"1\":{\"927\":1}}],[\"慢慢增加树的高度\",{\"1\":{\"813\":1}}],[\"账号\",{\"1\":{\"976\":1}}],[\"驱动\",{\"1\":{\"975\":1}}],[\"官网\",{\"1\":{\"974\":1}}],[\"官方\",{\"1\":{\"891\":1,\"955\":1}}],[\"官方文档参考\",{\"1\":{\"846\":1}}],[\"官方建议每个缓冲区空间必须大于\",{\"1\":{\"807\":1}}],[\"官方提供的一个并发安全的一个\",{\"1\":{\"512\":1}}],[\"官方提供了一个并发安全的\",{\"1\":{\"509\":1}}],[\"官方仓库也提供了一个插件列表\",{\"1\":{\"229\":1}}],[\"官方的公开镜像仓库\",{\"1\":{\"99\":1}}],[\"官方的图标包\",{\"1\":{\"6\":1}}],[\"官方申请\",{\"1\":{\"12\":1}}],[\"领域实体的转换\",{\"1\":{\"962\":1}}],[\"偏重业务的含义\",{\"1\":{\"962\":1}}],[\"偏移量的地方做了aaa\",{\"1\":{\"810\":2}}],[\"混淆在一起\",{\"1\":{\"962\":1}}],[\"混合部署实际发生在aof重写阶段\",{\"1\":{\"949\":1}}],[\"混合部署听名字似乎是同时开启rdb和aof\",{\"1\":{\"949\":1}}],[\"混合持久化还是属于aof\",{\"1\":{\"949\":1}}],[\"混合持久化开启之后\",{\"1\":{\"949\":1}}],[\"混合持久化是对aof重写的优化\",{\"1\":{\"949\":1}}],[\"混合持久化是发生在原有的aof流程\",{\"1\":{\"949\":1}}],[\"混合持久化是什么\",{\"1\":{\"949\":1}}],[\"混合持久化解决什么问题\",{\"1\":{\"949\":1}}],[\"混合持久化\",{\"1\":{\"949\":1}}],[\"混合加密\",{\"1\":{\"249\":1}}],[\"混合使用\",{\"1\":{\"33\":1}}],[\"及以上级别即\",{\"1\":{\"957\":1}}],[\"级别都使用此配置对应的日志对象作为输出\",{\"1\":{\"957\":1}}],[\"级别使用此配置日志对象输出\",{\"1\":{\"957\":1}}],[\"级别日志时调用的钩子函数\",{\"1\":{\"957\":1}}],[\"级别日志记录错误后执行\",{\"1\":{\"957\":1}}],[\"敬请期待\",{\"1\":{\"957\":1}}],[\"作用是限制日志在每秒内的输出数量\",{\"1\":{\"957\":1}}],[\"作为占位符\",{\"1\":{\"990\":1}}],[\"作为以快著称的日志库\",{\"1\":{\"957\":1}}],[\"作为参数并返回\",{\"1\":{\"957\":1}}],[\"作为时间数据快照\",{\"1\":{\"952\":1}}],[\"作为使用者来看\",{\"1\":{\"930\":1}}],[\"作为追求极致的coder\",{\"1\":{\"927\":1}}],[\"作为结束判断标准\",{\"1\":{\"873\":1}}],[\"作为主键\",{\"1\":{\"813\":1}}],[\"作为协调者\",{\"1\":{\"765\":1,\"810\":1}}],[\"作为一个列表存储\",{\"1\":{\"867\":1}}],[\"作为一个数据库管理员或者运维人员\",{\"1\":{\"850\":1}}],[\"作为一个\",{\"1\":{\"265\":1}}],[\"作为一个消息字段类型使用\",{\"1\":{\"229\":1}}],[\"作为临时文件\",{\"1\":{\"223\":1}}],[\"作为函数的参数\",{\"1\":{\"30\":2}}],[\"利于程序解析\",{\"1\":{\"957\":1}}],[\"利用慢查询日志\",{\"1\":{\"807\":1}}],[\"利用了回滚段实现了多版本查询数据\",{\"1\":{\"770\":1}}],[\"利用mmap\",{\"1\":{\"226\":1}}],[\"利用\",{\"1\":{\"122\":1,\"123\":1,\"243\":1,\"249\":1,\"909\":1,\"921\":1}}],[\"利用bitmap进行排序\",{\"1\":{\"20\":1}}],[\"利用bitmap去重\",{\"1\":{\"20\":1}}],[\"今天我们就来介绍下\",{\"1\":{\"955\":1}}],[\"损坏了\",{\"1\":{\"952\":1}}],[\"周期函数servercron中\",{\"1\":{\"952\":1}}],[\"肯定是会的\",{\"1\":{\"952\":1}}],[\"肯定无法走索引\",{\"1\":{\"813\":1}}],[\"｜\",{\"1\":{\"952\":1}}],[\"顶会论文\",{\"1\":{\"952\":1}}],[\"精选\",{\"1\":{\"952\":1}}],[\"精确一次\",{\"0\":{\"706\":1},\"1\":{\"705\":1}}],[\"精确匹配\",{\"1\":{\"587\":1,\"655\":1,\"656\":1}}],[\"跑在内存中\",{\"1\":{\"952\":1}}],[\"付出的代价则是降低aof文件的读写性\",{\"1\":{\"949\":1}}],[\"毕竟其实生产上\",{\"1\":{\"949\":1}}],[\"毕竟微服务也要有一定的互不信任原则\",{\"1\":{\"930\":1}}],[\"掩码运算\",{\"1\":{\"945\":1}}],[\"逐渐进行碎片整理的键名列表\",{\"1\":{\"944\":1}}],[\"逐个击破\",{\"1\":{\"20\":1}}],[\"阿里云二面\",{\"1\":{\"933\":1}}],[\"年轻人\",{\"1\":{\"933\":1}}],[\"年龄有效\",{\"1\":{\"543\":1}}],[\"年龄不合理\",{\"1\":{\"543\":1}}],[\"年龄不能为负数\",{\"1\":{\"543\":1}}],[\"难点\",{\"1\":{\"930\":1}}],[\"订阅mysql的binlog日志\",{\"1\":{\"930\":1}}],[\"订阅者支持订阅模式\",{\"1\":{\"924\":1}}],[\"订阅者就会收到该消息\",{\"1\":{\"924\":1}}],[\"达成最终一致性的延迟更小\",{\"1\":{\"930\":1}}],[\"达到持久化配置的阈值\",{\"1\":{\"952\":1}}],[\"达到一半以上同意加锁才算加锁成功\",{\"1\":{\"917\":1,\"921\":1}}],[\"达到释放内存的效果\",{\"1\":{\"817\":1}}],[\"易于实现\",{\"1\":{\"930\":1}}],[\"易混淆的概念\",{\"0\":{\"171\":1}}],[\"像\",{\"1\":{\"957\":1}}],[\"像雪崩一样\",{\"1\":{\"930\":1}}],[\"像挂载设备的操作几乎都不用你手动做\",{\"1\":{\"223\":1}}],[\"争抢锁失败的线程\",{\"1\":{\"930\":2}}],[\"热点数据支持续期\",{\"1\":{\"930\":1}}],[\"热门的商品甚至会有几百万人来抢\",{\"1\":{\"927\":1}}],[\"李四\",{\"1\":{\"1014\":1,\"1015\":1}}],[\"李\",{\"1\":{\"1001\":1}}],[\"李元芳\",{\"1\":{\"1001\":1,\"1002\":1,\"1003\":2}}],[\"李元芳的\",{\"1\":{\"1001\":1}}],[\"李子捌的博客\",{\"1\":{\"930\":1}}],[\"李文周的博客\",{\"1\":{\"229\":1}}],[\"失败就我们可以忽略\",{\"1\":{\"930\":1}}],[\"失去了缓存的意义\",{\"1\":{\"930\":1}}],[\"失效时也会触发valueunbound方法\",{\"1\":{\"637\":1}}],[\"极大地降低了请求延迟并减轻了数据库的负担\",{\"1\":{\"930\":1}}],[\"极其简单\",{\"1\":{\"249\":1}}],[\"潜在使用场景\",{\"1\":{\"930\":1}}],[\"潜在的不足之处\",{\"1\":{\"720\":1}}],[\"旁路缓存模式\",{\"1\":{\"930\":2}}],[\"频繁请求的数据\",{\"1\":{\"930\":1}}],[\"频繁的\",{\"1\":{\"760\":1}}],[\"证redis库存+kafka消耗的最终一致性\",{\"1\":{\"927\":1}}],[\"证书的层级有三级\",{\"1\":{\"249\":1}}],[\"证书链\",{\"1\":{\"249\":1}}],[\"证书有效期\",{\"1\":{\"249\":1}}],[\"证书认证机构\",{\"1\":{\"249\":2}}],[\"证书权威机构\",{\"1\":{\"249\":1}}],[\"扣减成功就是抢到\",{\"1\":{\"927\":1}}],[\"扣减成功的再通过消息队列传递到\",{\"1\":{\"927\":1}}],[\"拒绝超卖\",{\"1\":{\"927\":1}}],[\"留点\",{\"1\":{\"927\":1}}],[\"留在\",{\"1\":{\"756\":1,\"810\":1}}],[\"抢\",{\"1\":{\"927\":1}}],[\"抢到之后再转卖\",{\"1\":{\"927\":1}}],[\"压力过大\",{\"1\":{\"927\":1}}],[\"压缩列表作为底层数据结构能提供紧凑型的数据存储方式\",{\"1\":{\"879\":1}}],[\"压缩列表是\",{\"1\":{\"879\":1}}],[\"压缩列表是什么\",{\"1\":{\"879\":1}}],[\"压缩列表在\",{\"1\":{\"879\":1}}],[\"压缩列表\",{\"1\":{\"879\":2},\"2\":{\"881\":1}}],[\"压缩文件等二进制数据\",{\"1\":{\"873\":1}}],[\"压缩索引尤其在有大量重复前缀的情况下有效\",{\"1\":{\"807\":1}}],[\"压缩\",{\"1\":{\"807\":1}}],[\"压缩了标头\",{\"1\":{\"249\":1}}],[\"削峰\",{\"1\":{\"927\":1}}],[\"竞争公平\",{\"1\":{\"927\":1}}],[\"竞争者获取锁执行任务\",{\"1\":{\"913\":1,\"921\":1}}],[\"竞争者可以释放其他人的锁\",{\"1\":{\"912\":1,\"921\":1}}],[\"限流器\",{\"1\":{\"933\":1},\"2\":{\"935\":1}}],[\"限流\",{\"1\":{\"927\":1}}],[\"限购\",{\"1\":{\"927\":1}}],[\"限制ip\",{\"1\":{\"927\":1}}],[\"限制使用\",{\"1\":{\"807\":1}}],[\"限制最大为\",{\"1\":{\"770\":1}}],[\"限制分割次数\",{\"1\":{\"502\":1}}],[\"限制\",{\"1\":{\"459\":1}}],[\"雪崩的原因\",{\"1\":{\"930\":1}}],[\"雪上加霜\",{\"1\":{\"927\":1}}],[\"雪花算法生成\",{\"1\":{\"727\":1}}],[\"雪花算法可以在分布式环境中生成唯一的id\",{\"1\":{\"92\":1}}],[\"雪花算法将时间戳\",{\"1\":{\"92\":1}}],[\"雪花算法的实现主要由以下几个组成部分\",{\"1\":{\"92\":1}}],[\"雪花算法\",{\"1\":{\"92\":2},\"2\":{\"94\":1}}],[\"雪花算法详解\",{\"0\":{\"92\":1}}],[\"黄牛的恶劣影响\",{\"1\":{\"927\":1}}],[\"黄牛可能是开脚本\",{\"1\":{\"927\":1}}],[\"希望的就是回馈客户\",{\"1\":{\"927\":1}}],[\"希望得到\",{\"1\":{\"453\":1}}],[\"商家不存在经济上的损失\",{\"1\":{\"927\":1}}],[\"少卖会比超卖好一些\",{\"1\":{\"927\":1}}],[\"价格可能比成本价还低\",{\"1\":{\"927\":1}}],[\"活动也就gg了\",{\"1\":{\"927\":1}}],[\"活跃过期周期的游标\",{\"1\":{\"944\":1}}],[\"活跃的事务列表中\",{\"1\":{\"787\":1}}],[\"活跃的事务列表中最小的事务id\",{\"1\":{\"744\":1}}],[\"活跃会话数减1\",{\"1\":{\"625\":1}}],[\"活跃会话数加1\",{\"1\":{\"625\":1}}],[\"活跃\",{\"1\":{\"226\":1}}],[\"活跃页\",{\"1\":{\"217\":1}}],[\"瞬间会有海量流量涌入\",{\"1\":{\"927\":1}}],[\"海量请求\",{\"1\":{\"927\":1}}],[\"海量数据\",{\"2\":{\"22\":1}}],[\"海量数据处理方法应用\",{\"1\":{\"20\":1}}],[\"海量数据处理场景\",{\"1\":{\"20\":1}}],[\"海量数据处理的常用方法\",{\"1\":{\"20\":1}}],[\"海量数据处理\",{\"1\":{\"20\":2}}],[\"海量数据处理技术与方案\",{\"0\":{\"20\":1}}],[\"几种常见使用方式如下\",{\"1\":{\"957\":1}}],[\"几种方式对比\",{\"1\":{\"924\":1}}],[\"几乎不会进行修改\",{\"1\":{\"930\":1}}],[\"几乎所有关系型数据库都支持\",{\"1\":{\"813\":1}}],[\"腾讯云\",{\"1\":{\"917\":1,\"921\":1}}],[\"腾讯云开发者社区\",{\"1\":{\"917\":1,\"921\":1}}],[\"万字长文\",{\"1\":{\"917\":1,\"921\":1}}],[\"万一断电重启\",{\"1\":{\"751\":1,\"810\":1}}],[\"哨兵模式\",{\"1\":{\"916\":1,\"921\":1}}],[\"专门对aof进行重写\",{\"1\":{\"952\":1}}],[\"专门整合原子操作\",{\"1\":{\"913\":1,\"921\":1}}],[\"专门用来缓存文件数据的\",{\"1\":{\"810\":1}}],[\"专门用于处理http请求\",{\"1\":{\"666\":1}}],[\"专门用于配合shared\",{\"1\":{\"33\":1}}],[\"恰好这时候锁过期了\",{\"1\":{\"913\":1,\"921\":1}}],[\"🌰分布式锁需要满足谁申请谁释放原则\",{\"1\":{\"912\":1,\"921\":1}}],[\"🌰想一下如下场景\",{\"1\":{\"912\":1,\"921\":1}}],[\"🌰原表的\",{\"1\":{\"864\":1}}],[\"杳无音信\",{\"1\":{\"911\":1,\"921\":1}}],[\"升序\",{\"1\":{\"1007\":1}}],[\"升级kratos\",{\"1\":{\"968\":1}}],[\"升级\",{\"0\":{\"911\":1,\"912\":1,\"913\":1,\"914\":1,\"915\":1},\"1\":{\"912\":1,\"913\":2,\"921\":8}}],[\"升高\",{\"1\":{\"760\":1,\"810\":1}}],[\"谁更低谁被淘汰\",{\"1\":{\"906\":1}}],[\"谁抢到锁谁就执行\",{\"1\":{\"23\":1}}],[\"池子满了之后每次放一个\",{\"1\":{\"906\":1}}],[\"池子还剩\",{\"1\":{\"906\":1}}],[\"池中的数据根据空闲时间长短进行排序\",{\"1\":{\"906\":1}}],[\"采样策略配置\",{\"1\":{\"957\":1}}],[\"采样范围\",{\"1\":{\"906\":1}}],[\"采用重写的方式来解决\",{\"1\":{\"952\":1}}],[\"采用了多路复用机制\",{\"1\":{\"888\":1}}],[\"采用惰性删除+定期删除结合\",{\"1\":{\"882\":1}}],[\"采用的\",{\"1\":{\"882\":1}}],[\"采用将\",{\"1\":{\"873\":1}}],[\"采用这个策略\",{\"1\":{\"810\":1}}],[\"采用在文件尾部追加写入文件的方式\",{\"1\":{\"754\":1}}],[\"采用\",{\"1\":{\"751\":1,\"873\":1}}],[\"采用轮询的方法\",{\"1\":{\"226\":2}}],[\"采用引用计数器的方法\",{\"1\":{\"33\":1}}],[\"近似\",{\"1\":{\"906\":5}}],[\"夸张一点\",{\"1\":{\"903\":1}}],[\"策略\",{\"1\":{\"900\":1}}],[\"淘汰池的结构\",{\"1\":{\"906\":1}}],[\"淘汰池优化\",{\"1\":{\"906\":1}}],[\"淘汰后还是内存不足\",{\"1\":{\"906\":1}}],[\"淘汰时机\",{\"1\":{\"900\":1}}],[\"淘汰\",{\"1\":{\"900\":1,\"906\":2}}],[\"老版本实在readqueryfromclient函数中同步完成读取\",{\"1\":{\"897\":1}}],[\"老调度器有几个缺点\",{\"1\":{\"381\":1}}],[\"绑定器\",{\"0\":{\"1038\":1}}],[\"绑定到哈希表的迭代器个数\",{\"1\":{\"942\":1}}],[\"绑定到这个客户端连接\",{\"1\":{\"897\":1}}],[\"绑定网络端口和ip地址\",{\"1\":{\"226\":2}}],[\"辅助模块\",{\"1\":{\"891\":1}}],[\"辅助索引\",{\"1\":{\"813\":1}}],[\"瓶颈通常在网络\",{\"1\":{\"888\":1}}],[\"瓶颈不是cpu\",{\"1\":{\"226\":1}}],[\"⛔在\",{\"1\":{\"885\":1}}],[\"补偿\",{\"1\":{\"927\":1}}],[\"补齐各层链表\",{\"1\":{\"885\":1}}],[\"补充\",{\"1\":{\"249\":2}}],[\"步\",{\"1\":{\"885\":1}}],[\"遗漏了怎么办\",{\"1\":{\"882\":1}}],[\"友好\",{\"1\":{\"882\":1}}],[\"惰性删除\",{\"1\":{\"882\":1}}],[\"拼接在一起\",{\"1\":{\"879\":1}}],[\"拼接字符串不会造成缓冲区溢出\",{\"1\":{\"873\":1}}],[\"挺好的\",{\"1\":{\"879\":1}}],[\"尾巴节点\",{\"1\":{\"879\":1}}],[\"尾随空格\",{\"1\":{\"770\":1}}],[\"游戏排行榜\",{\"1\":{\"876\":1}}],[\"积分相同的情况下\",{\"1\":{\"876\":1}}],[\"音频\",{\"1\":{\"873\":1}}],[\"音乐\",{\"1\":{\"223\":1}}],[\"功能\",{\"1\":{\"873\":1}}],[\"博客园\",{\"1\":{\"870\":1,\"933\":1}}],[\"何时扩容\",{\"1\":{\"864\":1}}],[\"何时发送数据等问题进行管理\",{\"1\":{\"249\":1}}],[\"期间\",{\"1\":{\"864\":1}}],[\"期间发生了什么\",{\"1\":{\"810\":1,\"817\":1}}],[\"迁移\",{\"1\":{\"864\":1}}],[\"渐进式缩容\",{\"1\":{\"864\":1}}],[\"渐进式\",{\"1\":{\"864\":1}}],[\"冲突了\",{\"1\":{\"930\":1}}],[\"冲突\",{\"1\":{\"864\":1}}],[\"扮演者类似目录这样一个快速索引角色\",{\"1\":{\"864\":1}}],[\"翻过去看\",{\"1\":{\"864\":1}}],[\"翻译\",{\"1\":{\"351\":1}}],[\"概述\",{\"1\":{\"864\":1,\"906\":1}}],[\"概念解释\",{\"1\":{\"817\":1}}],[\"概念\",{\"0\":{\"305\":1}}],[\"概念与用途\",{\"0\":{\"300\":1}}],[\"登录后用\",{\"1\":{\"855\":1}}],[\"登录信息等都存储在服务端\",{\"1\":{\"249\":1}}],[\"您应该使用\",{\"1\":{\"1015\":1}}],[\"您可以从以下行为中选择一个\",{\"1\":{\"900\":1}}],[\"您可以直接使用\",{\"1\":{\"854\":1}}],[\"您只需要为权限相同的用户创建一个角色\",{\"1\":{\"850\":1}}],[\"介绍\",{\"1\":{\"854\":1}}],[\"介于两者之间\",{\"1\":{\"810\":1}}],[\"撤权角色\",{\"1\":{\"851\":1}}],[\"撤销权限类型\",{\"1\":{\"847\":1}}],[\"撤销用户权限\",{\"0\":{\"847\":1}}],[\"撤销已经执行的修改\",{\"1\":{\"737\":1}}],[\"撤销操作\",{\"1\":{\"214\":1}}],[\"授权角色\",{\"1\":{\"851\":1,\"852\":1}}],[\"授权给不同的用户\",{\"1\":{\"850\":1}}],[\"角色操作示例\",{\"0\":{\"852\":1}}],[\"角色操作语法\",{\"0\":{\"851\":1}}],[\"角色概述\",{\"0\":{\"850\":1}}],[\"角色管理\",{\"0\":{\"849\":1}}],[\"权限错误\",{\"1\":{\"1030\":1}}],[\"权限举例\",{\"1\":{\"846\":1}}],[\"权限对象\",{\"1\":{\"846\":1}}],[\"权限管理\",{\"0\":{\"845\":1},\"2\":{\"192\":1}}],[\"记得替换\",{\"1\":{\"840\":1}}],[\"记录未找到\",{\"1\":{\"980\":1}}],[\"记录日志的\",{\"1\":{\"957\":1}}],[\"记录日志后会进行\",{\"1\":{\"956\":1}}],[\"记录执行的每条命令\",{\"1\":{\"952\":1}}],[\"记录对象访问信息\",{\"1\":{\"940\":1}}],[\"记录距离下一个节点的步数\",{\"1\":{\"885\":1}}],[\"记录加上了类型为\",{\"1\":{\"820\":1}}],[\"记录之间加有间隙锁\",{\"1\":{\"820\":1}}],[\"记录不存在的情况\",{\"1\":{\"820\":1}}],[\"记录存在的情况\",{\"1\":{\"820\":1}}],[\"记录锁\",{\"1\":{\"820\":3}}],[\"记录锁+间隙锁\",{\"1\":{\"783\":1,\"820\":2}}],[\"记录间的比较成本\",{\"1\":{\"813\":1}}],[\"记录成本的表\",{\"1\":{\"813\":1}}],[\"记录行数据最终被修改成什么样了\",{\"1\":{\"810\":1}}],[\"记录进行擦除\",{\"1\":{\"810\":1}}],[\"记录在\",{\"1\":{\"788\":1}}],[\"记录真实数据部分除了我们定义的字段\",{\"1\":{\"770\":1}}],[\"记录与记录之间是通过链表组织的\",{\"1\":{\"770\":1}}],[\"记录头信息中包含的内容很多\",{\"1\":{\"770\":1}}],[\"记录头信息\",{\"1\":{\"770\":4}}],[\"记录的主键索引上加的是间隙锁\",{\"1\":{\"820\":1}}],[\"记录的顺序要么先记\",{\"1\":{\"820\":1}}],[\"记录的语句就是原始语句\",{\"1\":{\"820\":1}}],[\"记录的真实数据处不会存储该列的一部分数据\",{\"1\":{\"770\":1}}],[\"记录的真实数据\",{\"1\":{\"770\":2}}],[\"记录的额外信息\",{\"1\":{\"770\":1}}],[\"记录的是在某个数据页做了什么修改\",{\"1\":{\"810\":1}}],[\"记录的是更新\",{\"1\":{\"810\":2}}],[\"记录的是对数据页的物理修改操作\",{\"1\":{\"753\":1}}],[\"记录的是\",{\"1\":{\"737\":2}}],[\"记录是按照行来存储的\",{\"1\":{\"770\":1}}],[\"记录被修改前的数据\",{\"1\":{\"753\":1}}],[\"记录\",{\"1\":{\"753\":2,\"820\":1,\"952\":1}}],[\"记录还会进一步被分成一个个组\",{\"1\":{\"748\":1}}],[\"记录下来\",{\"1\":{\"744\":1}}],[\"记录中的两个隐藏列\",{\"1\":{\"743\":1,\"744\":1,\"810\":1}}],[\"记录和重放sql语句\",{\"1\":{\"737\":1}}],[\"记录关键操作和异常情况\",{\"1\":{\"605\":1}}],[\"记录警告\",{\"1\":{\"600\":1}}],[\"记录性能信息\",{\"1\":{\"600\":1}}],[\"记录开始时间\",{\"1\":{\"600\":1}}],[\"记录响应信息\",{\"1\":{\"596\":1}}],[\"记录请求开始时间\",{\"1\":{\"626\":1}}],[\"记录请求处理时间\",{\"1\":{\"579\":1,\"584\":1}}],[\"记录请求信息\",{\"1\":{\"579\":1,\"584\":1,\"596\":1,\"600\":1,\"626\":1}}],[\"记录一次\",{\"1\":{\"529\":1}}],[\"记录有多少次请求打到了\",{\"1\":{\"516\":1}}],[\"记录了存储引擎层各种操作的成本\",{\"1\":{\"813\":1}}],[\"记录了\",{\"1\":{\"813\":1}}],[\"记录了某个数据页做了什么修改\",{\"1\":{\"752\":1,\"810\":1}}],[\"记录了完成一条更新操作后\",{\"1\":{\"737\":1}}],[\"记录了此次事务\",{\"1\":{\"737\":2,\"810\":2}}],[\"记录了用户信息和过期时间等\",{\"1\":{\"249\":1}}],[\"记录了使用的加密算法信息\",{\"1\":{\"249\":1}}],[\"记录就绪的事件\",{\"1\":{\"226\":1}}],[\"记录指针\",{\"1\":{\"217\":1}}],[\"记录生成id的时间\",{\"1\":{\"92\":1}}],[\"替换成新创建的\",{\"1\":{\"957\":1}}],[\"替换默认\",{\"1\":{\"957\":1}}],[\"替换掉\",{\"1\":{\"957\":1}}],[\"替换为要重命名的用户\",{\"1\":{\"840\":1}}],[\"替换或更新数据\",{\"1\":{\"249\":1}}],[\"帐户名称的部分是可选的\",{\"1\":{\"838\":1}}],[\"帐户名称由两部分组成\",{\"1\":{\"838\":1}}],[\"弹出服务对话框\",{\"1\":{\"836\":1}}],[\"赋予用户操作权限\",{\"1\":{\"829\":1}}],[\"赋值运算符\",{\"1\":{\"442\":1}}],[\"赋值流程\",{\"1\":{\"332\":1}}],[\"赋值之前\",{\"1\":{\"311\":1}}],[\"赋值前后的结构变化\",{\"0\":{\"311\":1}}],[\"占有且等待\",{\"1\":{\"820\":1}}],[\"占用18个字节\",{\"1\":{\"770\":1}}],[\"占用\",{\"1\":{\"770\":3}}],[\"占用比较大的系统开销\",{\"1\":{\"405\":1}}],[\"占用系统端口\",{\"1\":{\"237\":1}}],[\"占用系统资源\",{\"1\":{\"237\":2}}],[\"占用的字节数之和\",{\"1\":{\"770\":1}}],[\"占用的字节数\",{\"1\":{\"770\":2}}],[\"占用的内存更小\",{\"1\":{\"229\":1}}],[\"占用的位数也根据具体情况而定\",{\"1\":{\"92\":1}}],[\"占用的位数根据具体情况而定\",{\"1\":{\"92\":1}}],[\"∞\",{\"1\":{\"820\":1}}],[\"遇到错误时回滚事务\",{\"1\":{\"1015\":1}}],[\"遇到字符串\",{\"1\":{\"829\":1}}],[\"遇到字符串和数字比较时\",{\"1\":{\"813\":1}}],[\"遇到唯一键冲突\",{\"1\":{\"820\":1}}],[\"案例中的事务\",{\"1\":{\"820\":1}}],[\"范围大点\",{\"1\":{\"903\":1}}],[\"范围太小\",{\"1\":{\"903\":1}}],[\"范围是\",{\"1\":{\"820\":1}}],[\"范围\",{\"1\":{\"820\":1}}],[\"范围的记录\",{\"1\":{\"820\":1}}],[\"范围查询性能高\",{\"1\":{\"876\":1}}],[\"范围查询和等值查询的加锁规则是不同的\",{\"1\":{\"820\":1}}],[\"范围查询了\",{\"1\":{\"813\":1}}],[\"范围查询后面的字段无法使用索引\",{\"1\":{\"813\":1}}],[\"范围查询的字段可以用到联合索引\",{\"1\":{\"813\":1}}],[\"范围查询\",{\"1\":{\"813\":1,\"820\":2}}],[\"死锁的四个必要条件\",{\"1\":{\"820\":1}}],[\"死锁的发生\",{\"1\":{\"820\":1}}],[\"死锁\",{\"1\":{\"820\":1}}],[\"于表中的\",{\"1\":{\"820\":2}}],[\"于是我基于\",{\"1\":{\"957\":1}}],[\"于是锁就释放了\",{\"1\":{\"820\":1}}],[\"于是事物\",{\"1\":{\"820\":1}}],[\"于是就造成了循环等待\",{\"1\":{\"820\":1}}],[\"于是就只能通过全表扫描的方式来查询\",{\"1\":{\"813\":1}}],[\"于是就发生了幻读\",{\"1\":{\"793\":1}}],[\"于是就可以通过它找到修改前的记录\",{\"1\":{\"770\":1,\"788\":1}}],[\"于是\",{\"1\":{\"81\":1}}],[\"退化成记录锁\",{\"1\":{\"820\":1}}],[\"退化成\",{\"1\":{\"820\":2}}],[\"退出循环\",{\"1\":{\"817\":1}}],[\"退出\",{\"1\":{\"141\":1}}],[\"退出容器\",{\"0\":{\"141\":1}}],[\"兼容问题\",{\"1\":{\"820\":1}}],[\"兼顾了异步复制和同步复制的优点\",{\"1\":{\"810\":1}}],[\"型\",{\"1\":{\"820\":3}}],[\"型关系\",{\"1\":{\"820\":3}}],[\"型的锁是冲突的\",{\"1\":{\"820\":2}}],[\"型的锁\",{\"1\":{\"820\":2}}],[\"型的间隙锁\",{\"1\":{\"820\":1}}],[\"型的\",{\"1\":{\"820\":14}}],[\"型的记录锁是冲突的\",{\"1\":{\"820\":2}}],[\"型的记录锁与\",{\"1\":{\"820\":2}}],[\"型的记录锁\",{\"1\":{\"820\":10}}],[\"型间隙锁\",{\"1\":{\"820\":1}}],[\"型间隙锁和\",{\"1\":{\"820\":1}}],[\"型与\",{\"1\":{\"820\":8}}],[\"型记录锁的话\",{\"1\":{\"820\":1}}],[\"型记录锁\",{\"1\":{\"820\":6}}],[\"型记录锁后\",{\"1\":{\"820\":2}}],[\"间隙锁的意义只在于阻止区间被插入\",{\"1\":{\"820\":1}}],[\"间隙锁的范围\",{\"1\":{\"820\":2}}],[\"间隙锁之间是兼容的\",{\"1\":{\"820\":1}}],[\"间隙锁虽然存在\",{\"1\":{\"820\":1}}],[\"间隙锁\",{\"1\":{\"820\":5}}],[\"满之前符合的都放进\",{\"1\":{\"906\":1}}],[\"满足条件后会用aof\",{\"1\":{\"952\":1}}],[\"满足\",{\"0\":{\"914\":1},\"1\":{\"921\":1}}],[\"满足写写互斥\",{\"1\":{\"820\":1}}],[\"满足读读共享\",{\"1\":{\"820\":1}}],[\"满二叉树\",{\"0\":{\"60\":1}}],[\"面前\",{\"1\":{\"956\":1}}],[\"面试官\",{\"1\":{\"933\":1}}],[\"面试必备\",{\"1\":{\"933\":1}}],[\"面对\",{\"1\":{\"820\":1}}],[\"面向切面编程\",{\"1\":{\"698\":1}}],[\"面向对象的三大特性\",{\"1\":{\"33\":1}}],[\"面向对象\",{\"1\":{\"564\":1},\"2\":{\"32\":1}}],[\"轻量级的消息队列能用\",{\"1\":{\"924\":1}}],[\"轻量级的锁\",{\"1\":{\"820\":1}}],[\"轻量级锁\",{\"1\":{\"820\":2}}],[\"修饰的字段加上轻量级锁\",{\"1\":{\"820\":1}}],[\"修饰的字段的值是连续递增的\",{\"1\":{\"820\":1}}],[\"修饰的字段赋值递增的值\",{\"1\":{\"820\":1}}],[\"修改第一条记录的年龄\",{\"1\":{\"997\":1}}],[\"修改这些策略\",{\"1\":{\"979\":1}}],[\"修改用户密码\",{\"0\":{\"841\":1}}],[\"修改用户的组\",{\"1\":{\"208\":1}}],[\"修改数据库或者表等对象的结构\",{\"1\":{\"829\":1}}],[\"修改了表字段\",{\"1\":{\"820\":1}}],[\"修改了哪些数据等\",{\"1\":{\"753\":1}}],[\"修改完成后\",{\"1\":{\"817\":1}}],[\"修改响应对象\",{\"1\":{\"591\":1}}],[\"修改响应内容\",{\"1\":{\"579\":1}}],[\"修改请求对象\",{\"1\":{\"591\":1}}],[\"修改为非\",{\"1\":{\"531\":1}}],[\"修改为\",{\"1\":{\"525\":1,\"982\":1}}],[\"修改\",{\"1\":{\"30\":1,\"249\":1,\"730\":1,\"752\":1,\"810\":2}}],[\"修改在大多场景下结果一样\",{\"1\":{\"23\":1}}],[\"掉这个长事务\",{\"1\":{\"820\":1}}],[\"校验用户身份\",{\"1\":{\"817\":1}}],[\"校验客户端的用户名和密码\",{\"1\":{\"817\":1}}],[\"举一个具体的例子\",{\"1\":{\"817\":1}}],[\"举个全表扫描的例子\",{\"1\":{\"817\":1}}],[\"举个拳击比赛的例子\",{\"1\":{\"764\":1,\"810\":1}}],[\"举个例子\",{\"1\":{\"487\":1,\"810\":1,\"813\":1,\"820\":4,\"930\":2}}],[\"推出了如下执行语句\",{\"1\":{\"911\":1}}],[\"推出的查询优化策略\",{\"1\":{\"817\":1}}],[\"推荐\",{\"1\":{\"429\":1,\"505\":1}}],[\"经过上面对\",{\"1\":{\"944\":1}}],[\"经过解析器后\",{\"1\":{\"817\":1}}],[\"经历完优化器后\",{\"1\":{\"817\":1}}],[\"经常根据范围取值\",{\"1\":{\"813\":1}}],[\"经常频繁用作查询条件的字段应酌情考虑为其创建索引\",{\"1\":{\"813\":1}}],[\"经常做模糊查询的字段\",{\"1\":{\"807\":1}}],[\"经常会遇到想忽略指定字段修改的问题\",{\"1\":{\"488\":1}}],[\"经常导致对接口重复调度用\",{\"1\":{\"23\":1}}],[\"讲\",{\"1\":{\"817\":1}}],[\"词法分析\",{\"1\":{\"817\":1}}],[\"断开\",{\"1\":{\"817\":2}}],[\"断言原理\",{\"0\":{\"469\":1}}],[\"断言陷阱\",{\"0\":{\"468\":1}}],[\"断言\",{\"1\":{\"315\":1}}],[\"维持和管理连接\",{\"1\":{\"817\":1}}],[\"维护他们是非常大的额外成本\",{\"1\":{\"930\":1}}],[\"维护一个访问时间数据\",{\"1\":{\"906\":1}}],[\"维护一个左闭右开的区间\",{\"1\":{\"86\":1}}],[\"维护了一个变量\",{\"1\":{\"843\":1}}],[\"维护及日常运维操作\",{\"1\":{\"832\":1}}],[\"维护会话和状态管理\",{\"1\":{\"647\":1}}],[\"维护和扩展性\",{\"1\":{\"249\":1}}],[\"视图等\",{\"1\":{\"817\":1}}],[\"视频等二进制数据\",{\"1\":{\"249\":1}}],[\"视频\",{\"1\":{\"223\":1,\"873\":1}}],[\"逻辑架构图\",{\"1\":{\"817\":1}}],[\"逻辑架构\",{\"1\":{\"817\":1},\"2\":{\"819\":1}}],[\"逻辑运算符\",{\"0\":{\"443\":1},\"1\":{\"442\":1}}],[\"违反联合索引最左前缀原则\",{\"1\":{\"813\":1}}],[\"劣势\",{\"1\":{\"813\":1}}],[\"倍就是\",{\"1\":{\"864\":1}}],[\"倍\",{\"1\":{\"813\":2,\"864\":1,\"873\":1}}],[\"截断的字段不会在\",{\"1\":{\"813\":1}}],[\"右边界\",{\"1\":{\"820\":1}}],[\"右模糊匹配不会导致索引失效\",{\"1\":{\"813\":1}}],[\"右子树所有节点的值大于根节点\",{\"1\":{\"62\":1}}],[\"遵循最左匹配原则\",{\"1\":{\"813\":1}}],[\"答案\",{\"1\":{\"813\":1}}],[\"答案是不合适的\",{\"1\":{\"23\":1}}],[\"减轻了排序性能消耗\",{\"1\":{\"813\":1}}],[\"减少堆内存分配\",{\"1\":{\"956\":1}}],[\"减少库存操作超时\",{\"1\":{\"927\":1}}],[\"减少库存名额\",{\"1\":{\"927\":1}}],[\"减少回表次数\",{\"1\":{\"813\":1}}],[\"减少了查询sql的执行时间\",{\"1\":{\"813\":1}}],[\"减少了回表次数\",{\"1\":{\"813\":1}}],[\"减少了回表\",{\"1\":{\"813\":1}}],[\"减少了内核和用户空间大量的数据拷贝和内存分配\",{\"1\":{\"226\":1}}],[\"减少磁盘\",{\"1\":{\"813\":1}}],[\"减少维护开销\",{\"1\":{\"807\":1}}],[\"减少阻塞操作\",{\"1\":{\"603\":1}}],[\"减少\",{\"1\":{\"512\":1}}],[\"减少延迟\",{\"1\":{\"175\":1}}],[\"份\",{\"1\":{\"813\":1}}],[\"归并排序\",{\"1\":{\"813\":1}}],[\"归档日志\",{\"1\":{\"737\":1,\"810\":2}}],[\"排除年龄大于23的\",{\"1\":{\"1004\":1}}],[\"排列紧凑的列表\",{\"1\":{\"879\":1}}],[\"排列比较紧凑\",{\"1\":{\"870\":1}}],[\"排名操作\",{\"1\":{\"876\":1}}],[\"排名由低到高\",{\"1\":{\"876\":1}}],[\"排在最右边\",{\"1\":{\"813\":1}}],[\"排在最前面的请求被最优先处理\",{\"1\":{\"249\":1}}],[\"排序等\",{\"1\":{\"813\":1}}],[\"排序是在内存排序\",{\"1\":{\"813\":1}}],[\"排序\",{\"0\":{\"1007\":1},\"1\":{\"813\":2}}],[\"排序条件\",{\"1\":{\"813\":1}}],[\"走索引覆盖\",{\"1\":{\"813\":1}}],[\"据根据主键排序存放在索引中\",{\"1\":{\"813\":1}}],[\"日过函数内部实现为\",{\"1\":{\"957\":1}}],[\"日期等类型需要用到\",{\"1\":{\"829\":1}}],[\"日的节点\",{\"1\":{\"813\":1}}],[\"日所在的叶子节点\",{\"1\":{\"813\":1}}],[\"日之间的订单\",{\"1\":{\"813\":1}}],[\"日和\",{\"1\":{\"813\":1}}],[\"日志输出的目标\",{\"1\":{\"980\":1}}],[\"日志配置\",{\"0\":{\"980\":1}}],[\"日志框架\",{\"2\":{\"958\":1}}],[\"日志轮转等更多使用场景可以参考项目的使用示例\",{\"1\":{\"957\":1}}],[\"日志包还提供了\",{\"1\":{\"957\":1}}],[\"日志包对外提供了类似\",{\"1\":{\"957\":1}}],[\"日志时间的键名\",{\"1\":{\"957\":1}}],[\"日志信息的键名\",{\"1\":{\"957\":1}}],[\"日志后面追加的\",{\"1\":{\"957\":1}}],[\"日志库的基本使用和高级特性\",{\"1\":{\"955\":1}}],[\"日志库\",{\"1\":{\"955\":1}}],[\"日志格式要设置为\",{\"1\":{\"820\":1}}],[\"日志与\",{\"1\":{\"810\":1}}],[\"日志丢失的风险\",{\"1\":{\"810\":1}}],[\"日志空间大小是固定\",{\"1\":{\"810\":1}}],[\"日志只能用于归档\",{\"1\":{\"810\":1}}],[\"日志的文件名叫\",{\"1\":{\"810\":1}}],[\"日志的格式\",{\"0\":{\"742\":1}}],[\"日志去同步\",{\"1\":{\"807\":1}}],[\"日志系统\",{\"0\":{\"802\":1},\"1\":{\"817\":1},\"2\":{\"812\":1}}],[\"日志系统的工作过程\",{\"1\":{\"733\":1}}],[\"日志中追加\",{\"1\":{\"957\":1}}],[\"日志中将不再显示记录日志时所在的函数调用文件名和行号\",{\"1\":{\"957\":1}}],[\"日志中\",{\"1\":{\"770\":1,\"788\":1}}],[\"日志页\",{\"1\":{\"770\":1}}],[\"日志重写方式\",{\"1\":{\"757\":1}}],[\"日志重写\",{\"0\":{\"757\":1},\"1\":{\"757\":1}}],[\"日志\",{\"1\":{\"730\":1,\"761\":1,\"810\":6},\"2\":{\"959\":1}}],[\"日志级别的格式\",{\"1\":{\"957\":1}}],[\"日志级别的键名\",{\"1\":{\"957\":1}}],[\"日志级别\",{\"1\":{\"590\":1,\"957\":1,\"980\":1}}],[\"日志记录等功能的理想选择\",{\"1\":{\"612\":1}}],[\"日志记录\",{\"1\":{\"576\":1,\"579\":1}}],[\"日志文件里面\",{\"1\":{\"810\":1}}],[\"日志文件是最新的\",{\"1\":{\"751\":1}}],[\"日志文件不会自动删除\",{\"1\":{\"223\":1}}],[\"日志文件中每个关键词被搜索的总次数\",{\"1\":{\"79\":1}}],[\"月12\",{\"1\":{\"813\":1}}],[\"月\",{\"1\":{\"813\":3}}],[\"叶子节点\",{\"1\":{\"813\":3}}],[\"根节点\",{\"1\":{\"813\":1}}],[\"根据年龄倒序\",{\"1\":{\"1007\":1}}],[\"根据实时性期待不一样\",{\"1\":{\"930\":1}}],[\"根据上述的分析可以看出\",{\"1\":{\"918\":1,\"921\":1}}],[\"根据上面\",{\"1\":{\"374\":1}}],[\"根据时间戳淘汰掉最旧的\",{\"1\":{\"906\":1}}],[\"根据server\",{\"1\":{\"897\":1}}],[\"根据内容类型有如下几种情况\",{\"1\":{\"879\":1}}],[\"根据加锁的范围\",{\"1\":{\"820\":1}}],[\"根据执行计划执行\",{\"1\":{\"817\":1}}],[\"根据词法分析的结果\",{\"1\":{\"817\":1}}],[\"根据最左匹配原则\",{\"1\":{\"813\":3}}],[\"根据索引类型不同\",{\"1\":{\"813\":1}}],[\"根据业务属性的不同\",{\"1\":{\"807\":1}}],[\"根据业务将各类参数调整到合适的大小\",{\"1\":{\"807\":1}}],[\"根据库表结构\",{\"1\":{\"807\":1}}],[\"根据mysql的官方文档the\",{\"1\":{\"770\":1}}],[\"根据acks参数的配置\",{\"1\":{\"710\":1}}],[\"根据所选的确认级别\",{\"1\":{\"710\":1}}],[\"根据http请求类型调用以下方法\",{\"1\":{\"666\":1}}],[\"根据header中的加密算法和payload中的用户信息以及密钥key来生成\",{\"1\":{\"249\":1}}],[\"根据请求类型调用doget\",{\"1\":{\"661\":1}}],[\"根据值自行判断变量类型\",{\"1\":{\"436\":1}}],[\"根据\",{\"1\":{\"367\":1}}],[\"根据自身的资源利用情况\",{\"1\":{\"162\":1}}],[\"根据具体场景变通\",{\"1\":{\"88\":1}}],[\"根据给定qq号码\",{\"1\":{\"20\":1}}],[\"早被写入到\",{\"1\":{\"810\":1}}],[\"早期默认支持的数据存储都是堆表结构\",{\"1\":{\"813\":1}}],[\"早期版本的相同语义\",{\"1\":{\"249\":1}}],[\"早期的\",{\"1\":{\"249\":1}}],[\"额外的故意等待\",{\"1\":{\"810\":1}}],[\"延迟\",{\"1\":{\"810\":2}}],[\"延迟调用\",{\"1\":{\"474\":1},\"2\":{\"296\":1}}],[\"承接\",{\"1\":{\"810\":1}}],[\"承载范围\",{\"1\":{\"807\":1}}],[\"绿色这一组事务的\",{\"1\":{\"810\":1}}],[\"做法\",{\"1\":{\"930\":2}}],[\"做缓存\",{\"1\":{\"930\":1}}],[\"做缓存限流\",{\"1\":{\"715\":1}}],[\"做正在的订单生成\",{\"1\":{\"927\":1}}],[\"做处理\",{\"1\":{\"927\":1}}],[\"做到竞争公平\",{\"1\":{\"927\":1}}],[\"做消息队列\",{\"1\":{\"924\":3}}],[\"做的就是短平快的热点数据处理\",{\"1\":{\"891\":1}}],[\"做一次\",{\"1\":{\"810\":1}}],[\"做了一层包装\",{\"1\":{\"888\":1}}],[\"做了一次组写入\",{\"1\":{\"810\":1}}],[\"做了个改进\",{\"1\":{\"810\":1}}],[\"落盘\",{\"1\":{\"810\":1}}],[\"碰到处于\",{\"1\":{\"810\":1}}],[\"剩下的\",{\"1\":{\"879\":2}}],[\"剩下的就是\",{\"1\":{\"810\":1}}],[\"剩余的位数用来表示时间戳的偏移量\",{\"1\":{\"92\":1}}],[\"套数据库\",{\"1\":{\"810\":1}}],[\"套接字默认是阻塞模式的\",{\"1\":{\"888\":1}}],[\"套接字\",{\"1\":{\"226\":1}}],[\"理论上\",{\"1\":{\"885\":1}}],[\"理论上只要记录在\",{\"1\":{\"810\":1}}],[\"理解servlet有助于更深入地理解这些框架的工作原理\",{\"1\":{\"644\":1}}],[\"理解panic的传递\",{\"1\":{\"478\":1}}],[\"理解\",{\"0\":{\"451\":1},\"1\":{\"813\":2}}],[\"理解i\",{\"1\":{\"226\":1}}],[\"端再根据\",{\"1\":{\"810\":1}}],[\"端口号这些都不是必须的\",{\"1\":{\"249\":1}}],[\"端口进行入侵检测\",{\"1\":{\"243\":1}}],[\"端口耗尽\",{\"1\":{\"237\":1}}],[\"端口资源是有限的\",{\"1\":{\"237\":1}}],[\"端口范围等\",{\"1\":{\"125\":1}}],[\"端口范围\",{\"1\":{\"122\":1}}],[\"端口\",{\"1\":{\"117\":1,\"226\":1,\"237\":1,\"836\":1,\"966\":2}}],[\"端口映射\",{\"0\":{\"117\":1}}],[\"牺牲数据安全性\",{\"1\":{\"810\":1}}],[\"牺牲性能\",{\"1\":{\"810\":1}}],[\"较取值为\",{\"1\":{\"810\":1}}],[\"画了一个图\",{\"1\":{\"810\":1}}],[\"画个图理解一下\",{\"1\":{\"523\":1}}],[\"顺利\",{\"1\":{\"817\":1}}],[\"顺着\",{\"1\":{\"810\":1}}],[\"顺序\",{\"1\":{\"820\":1}}],[\"顺序写\",{\"1\":{\"810\":6}}],[\"顺序写入的性能通常比随机写入高\",{\"1\":{\"754\":1}}],[\"顺序写入\",{\"1\":{\"754\":1,\"760\":1}}],[\"顺序错乱可能导致依赖关系无法满足\",{\"1\":{\"719\":1}}],[\"感兴趣的可以自己去查查\",{\"1\":{\"810\":1}}],[\"感知到客户端的fin报文后\",{\"1\":{\"226\":1}}],[\"典型主从架构\",{\"1\":{\"807\":1}}],[\"典型的字段包括\",{\"1\":{\"190\":2}}],[\"架设了\",{\"1\":{\"807\":1}}],[\"架构分层关系\",{\"1\":{\"817\":1}}],[\"架构优化方案\",{\"1\":{\"807\":1}}],[\"架构优化与\",{\"1\":{\"807\":1}}],[\"架构设计\",{\"2\":{\"167\":1,\"234\":1}}],[\"架构\",{\"0\":{\"155\":1},\"1\":{\"817\":1},\"2\":{\"24\":1}}],[\"充分利用索引覆盖\",{\"1\":{\"807\":1}}],[\"充当\",{\"1\":{\"104\":1}}],[\"核数\",{\"1\":{\"807\":1}}],[\"核心处理逻辑\",{\"1\":{\"891\":1}}],[\"核心是\",{\"1\":{\"864\":1}}],[\"核心概念就是通过索引就能满足查询需求\",{\"1\":{\"813\":1}}],[\"核心的\",{\"1\":{\"807\":1}}],[\"核心特性\",{\"0\":{\"698\":1}}],[\"核心态时\",{\"1\":{\"220\":1}}],[\"偶发高峰类业务的连接数配置\",{\"1\":{\"807\":1}}],[\"固态硬盘\",{\"1\":{\"807\":1}}],[\"情景\",{\"1\":{\"807\":3}}],[\"情况二\",{\"1\":{\"820\":1}}],[\"情况一\",{\"1\":{\"820\":1}}],[\"情况下更安全\",{\"1\":{\"810\":1}}],[\"情况\",{\"1\":{\"770\":1}}],[\"①\",{\"1\":{\"807\":1}}],[\"③\",{\"1\":{\"807\":1}}],[\"⑤\",{\"1\":{\"807\":1}}],[\"②\",{\"1\":{\"807\":1}}],[\"亦是磁盘io速率\",{\"1\":{\"807\":1}}],[\"明确仅返回一条数据的语句可以使用limit\",{\"1\":{\"807\":1}}],[\"明文传输改为二进制格式\",{\"1\":{\"240\":1}}],[\"明文传输\",{\"1\":{\"240\":2}}],[\"必要情况下可以强制指定索引\",{\"1\":{\"807\":1}}],[\"必须建立索引\",{\"1\":{\"813\":1}}],[\"必须保持一致才能保证主从数据一致\",{\"1\":{\"810\":1}}],[\"必须走\",{\"1\":{\"807\":1}}],[\"必须要对mysql真正的熟悉才行\",{\"1\":{\"807\":1}}],[\"必须在事务提交之后\",{\"1\":{\"810\":1}}],[\"必须在代码中显式处理的异常\",{\"1\":{\"538\":1}}],[\"必须在同一个包下\",{\"1\":{\"461\":1}}],[\"必须是内置函数\",{\"1\":{\"441\":1}}],[\"必须为每个\",{\"1\":{\"229\":1}}],[\"必须初始化为另一具体的变量\",{\"1\":{\"33\":1}}],[\"别用缓存\",{\"1\":{\"930\":1}}],[\"别\",{\"1\":{\"807\":1}}],[\"别名\",{\"1\":{\"229\":1}}],[\"挖坑\",{\"1\":{\"807\":3}}],[\"误区\",{\"1\":{\"807\":1}}],[\"定制开发了自己的日志包\",{\"1\":{\"957\":1}}],[\"定制的日志包并没有太多的逻辑\",{\"1\":{\"957\":1}}],[\"定制\",{\"1\":{\"957\":1}}],[\"定位方式和查询类似\",{\"1\":{\"885\":1}}],[\"定时删除对内存比较友好\",{\"1\":{\"882\":1}}],[\"定时删除\",{\"1\":{\"882\":1}}],[\"定期删除\",{\"1\":{\"882\":2}}],[\"定期断开长连接\",{\"1\":{\"817\":1}}],[\"定期审查索引\",{\"1\":{\"807\":1}}],[\"定义列的默认值\",{\"1\":{\"983\":1}}],[\"定义字段大小\",{\"1\":{\"983\":1}}],[\"定义字段类型\",{\"1\":{\"983\":1}}],[\"定义字段时应尽可能使用not\",{\"1\":{\"807\":1}}],[\"定义的服务层\",{\"1\":{\"962\":1}}],[\"定义如下\",{\"1\":{\"957\":1}}],[\"定义哈希槽\",{\"1\":{\"723\":1}}],[\"定义了记录节点数量的字段\",{\"1\":{\"879\":1}}],[\"定义了空闲连接的最大空闲时长\",{\"1\":{\"817\":1}}],[\"定义了以下核心方法\",{\"1\":{\"664\":1}}],[\"定义了一组方法的集合\",{\"1\":{\"298\":1}}],[\"定义两个简单的接口\",{\"1\":{\"471\":1}}],[\"定义一个user结构体\",{\"1\":{\"1039\":1,\"1041\":1,\"1043\":1}}],[\"定义一个函数\",{\"1\":{\"470\":1}}],[\"定义一个函数为纯虚函数\",{\"1\":{\"33\":1}}],[\"定义一个函数为虚函数\",{\"1\":{\"33\":1}}],[\"定义一个接口\",{\"1\":{\"470\":1}}],[\"定义一个结构体\",{\"1\":{\"466\":1,\"470\":2}}],[\"定义接口\",{\"1\":{\"699\":1}}],[\"定义接口b\",{\"1\":{\"466\":1}}],[\"定义接口a\",{\"1\":{\"466\":1}}],[\"定义方式\",{\"1\":{\"440\":1}}],[\"定义服务\",{\"1\":{\"229\":1}}],[\"定义proto版本\",{\"1\":{\"229\":1}}],[\"定义x\",{\"1\":{\"36\":1}}],[\"定义类中的静态成员函数\",{\"1\":{\"33\":1}}],[\"定义类中的静态成员变量\",{\"1\":{\"33\":1}}],[\"定义\",{\"0\":{\"70\":1},\"1\":{\"33\":3,\"243\":3,\"246\":3,\"879\":1}}],[\"定义纯虚函数是为了实现一个接口\",{\"1\":{\"33\":1}}],[\"定义他为虚函数是为了允许用基类的指针来调用子类的这个函数\",{\"1\":{\"33\":1}}],[\"定义指针变量及时初始化\",{\"1\":{\"33\":1}}],[\"元数据\",{\"1\":{\"820\":1}}],[\"元数据锁\",{\"1\":{\"820\":4}}],[\"元余和重复索引\",{\"1\":{\"807\":1}}],[\"元素的时候\",{\"1\":{\"453\":1}}],[\"聚集索引\",{\"1\":{\"813\":2}}],[\"聚集索引和二级索引b+树的区别\",{\"1\":{\"813\":1}}],[\"聚集索引记录中和事务有关的两个隐藏列\",{\"0\":{\"788\":1}}],[\"聚簇索引\",{\"1\":{\"813\":1}}],[\"聚簇索引可以加速主键查找\",{\"1\":{\"807\":1}}],[\"聚族索引\",{\"1\":{\"807\":1}}],[\"联合索引当遇到范围查询\",{\"1\":{\"817\":1}}],[\"联合索引比多个单值索引查询效率要高\",{\"1\":{\"813\":1}}],[\"联合索引陷阱\",{\"1\":{\"813\":1}}],[\"联合索引里的\",{\"1\":{\"813\":1}}],[\"联合索引就会失效\",{\"1\":{\"813\":1}}],[\"联合索引要能正确使用需要遵循最左匹配原则\",{\"1\":{\"813\":1}}],[\"联合索引的最左匹配原则\",{\"1\":{\"813\":1}}],[\"联合索引的话\",{\"1\":{\"813\":1}}],[\"联合索引非最左匹配\",{\"1\":{\"813\":1}}],[\"联合索引用了\",{\"1\":{\"813\":1}}],[\"联合索引会比较好\",{\"1\":{\"813\":1}}],[\"联合索引多了一个好处\",{\"1\":{\"813\":2}}],[\"联合索引最左匹配原则\",{\"1\":{\"813\":1}}],[\"联合索引\",{\"1\":{\"807\":1,\"813\":13}}],[\"联系\",{\"1\":{\"249\":1}}],[\"换成\",{\"1\":{\"807\":1}}],[\"换一个角度看\",{\"1\":{\"770\":1}}],[\"掘金\",{\"1\":{\"807\":4,\"906\":1,\"930\":1}}],[\"马上执行\",{\"1\":{\"795\":1}}],[\"往后移\",{\"1\":{\"879\":1}}],[\"往字典添加元素\",{\"1\":{\"864\":1}}],[\"往事务\",{\"1\":{\"820\":1}}],[\"往表\",{\"1\":{\"820\":1}}],[\"往下看\",{\"1\":{\"817\":1}}],[\"往插入一个\",{\"1\":{\"794\":1}}],[\"往外传递\",{\"1\":{\"479\":1}}],[\"条写数据操作\",{\"1\":{\"952\":4}}],[\"条\",{\"1\":{\"930\":2}}],[\"条信息\",{\"1\":{\"924\":1}}],[\"条记录\",{\"1\":{\"794\":2,\"820\":1}}],[\"条件列表查询\",{\"0\":{\"995\":1}}],[\"条件查询\",{\"0\":{\"990\":1}}],[\"条件\",{\"1\":{\"867\":2,\"870\":1,\"876\":1}}],[\"条件没有用到索引列\",{\"1\":{\"820\":1}}],[\"条件的范围查询\",{\"1\":{\"820\":3}}],[\"条件等等\",{\"1\":{\"817\":1}}],[\"条件中的\",{\"1\":{\"810\":1}}],[\"条件二\",{\"1\":{\"770\":1}}],[\"条件一\",{\"1\":{\"770\":1}}],[\"条件指示符\",{\"1\":{\"36\":1}}],[\"条件编译\",{\"1\":{\"36\":2},\"2\":{\"38\":1}}],[\"针对生产环境和开发环境提供了不同的函数来创建\",{\"1\":{\"957\":1}}],[\"针对ip做限制也是常见做的做法\",{\"1\":{\"927\":1}}],[\"针对参数\",{\"1\":{\"810\":2}}],[\"针对为什么需要\",{\"1\":{\"810\":1}}],[\"针对不同层面有不同的优化方案\",{\"1\":{\"807\":1}}],[\"针对\",{\"1\":{\"783\":2,\"810\":1,\"820\":2,\"888\":1}}],[\"针对这两个难点\",{\"1\":{\"79\":1}}],[\"似乎又产生了幻觉一样\",{\"1\":{\"780\":1}}],[\"性别=男\",{\"1\":{\"780\":2}}],[\"性能开销很大\",{\"1\":{\"952\":1}}],[\"性能开销较大\",{\"1\":{\"552\":1}}],[\"性能变差的rdb\",{\"1\":{\"949\":1}}],[\"性能比like\",{\"1\":{\"813\":1}}],[\"性能会下降\",{\"1\":{\"813\":1}}],[\"性能不佳\",{\"1\":{\"810\":1}}],[\"性能调优\",{\"1\":{\"807\":1},\"2\":{\"828\":1}}],[\"性能最好\",{\"1\":{\"730\":1,\"761\":1}}],[\"性能最差了\",{\"1\":{\"730\":1,\"761\":1}}],[\"性能较好\",{\"1\":{\"727\":1}}],[\"性能差异理解\",{\"1\":{\"770\":1}}],[\"性能差\",{\"1\":{\"727\":1}}],[\"性能\",{\"1\":{\"710\":1,\"755\":1,\"810\":1}}],[\"性能更高\",{\"1\":{\"646\":1}}],[\"性能考虑\",{\"0\":{\"603\":1}}],[\"性能警告\",{\"1\":{\"600\":1}}],[\"性能监控filter\",{\"0\":{\"600\":1}}],[\"性能监控\",{\"1\":{\"579\":1},\"2\":{\"809\":1}}],[\"性能没那么好\",{\"1\":{\"527\":1}}],[\"性能问题\",{\"1\":{\"520\":1}}],[\"性能对比\",{\"1\":{\"505\":1,\"770\":1}}],[\"性能提示\",{\"1\":{\"496\":1}}],[\"性能分析\",{\"0\":{\"363\":1}}],[\"性能优化\",{\"1\":{\"502\":1,\"807\":1},\"2\":{\"18\":1,\"19\":1,\"809\":1,\"815\":1,\"822\":1,\"825\":1,\"881\":1,\"884\":1,\"887\":1,\"890\":1,\"893\":1,\"899\":1,\"902\":1,\"932\":1,\"948\":1,\"951\":1}}],[\"女\",{\"1\":{\"780\":1}}],[\"男\",{\"1\":{\"780\":1}}],[\"幻读场景2\",{\"0\":{\"794\":1}}],[\"幻读场景1\",{\"0\":{\"793\":1}}],[\"幻读就是发生在这种违和的场景\",{\"1\":{\"793\":1}}],[\"幻读的另一种解释\",{\"0\":{\"780\":1}}],[\"幻读\",{\"0\":{\"779\":1}}],[\"脏读\",{\"0\":{\"777\":1}}],[\"脏的数据页\",{\"1\":{\"751\":1}}],[\"隔离级别下的幻读问题\",{\"1\":{\"820\":1}}],[\"隔离级别的事务来说\",{\"1\":{\"810\":1}}],[\"隔离级别\",{\"1\":{\"801\":1},\"2\":{\"798\":1}}],[\"隔离级别是启动事务时生成一个\",{\"1\":{\"810\":1}}],[\"隔离级别是\",{\"1\":{\"784\":1}}],[\"隔离级别是在每个\",{\"1\":{\"810\":1}}],[\"隔离级别是在\",{\"1\":{\"784\":1}}],[\"隔离级别以及实现原理\",{\"1\":{\"773\":1}}],[\"隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致\",{\"1\":{\"774\":1}}],[\"隔离性\",{\"1\":{\"774\":1}}],[\"填充到50个字节\",{\"1\":{\"770\":1}}],[\"毛\",{\"1\":{\"770\":4}}],[\"毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛\",{\"1\":{\"770\":1}}],[\"毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛\",{\"1\":{\"770\":1}}],[\"毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛毛\",{\"1\":{\"770\":1}}],[\"毛毛毛毛毛毛\",{\"1\":{\"770\":2}}],[\"省略一堆\",{\"1\":{\"770\":4}}],[\"测试环境\",{\"1\":{\"770\":1}}],[\"测试指定包\",{\"1\":{\"391\":1}}],[\"溢出的数据会存放到\",{\"1\":{\"770\":1}}],[\"溢出页\",{\"1\":{\"770\":4}}],[\"溢出页等等\",{\"1\":{\"770\":1}}],[\"吗\",{\"1\":{\"770\":2,\"810\":1}}],[\"逆序存放\",{\"1\":{\"770\":1}}],[\"真实数据占用的字节数\",{\"1\":{\"770\":1}}],[\"真实数据占用的字节数是\",{\"1\":{\"770\":2}}],[\"真实数据\",{\"1\":{\"770\":3}}],[\"真正的执行更新记录的操作\",{\"1\":{\"810\":2}}],[\"真正负责在网络上传输具体数据的是会话层以下的\",{\"1\":{\"249\":1}}],[\"真正管理了容器的生命周期\",{\"1\":{\"103\":1}}],[\"连锁更新就是\",{\"1\":{\"879\":1}}],[\"连锁更新原因分析\",{\"1\":{\"879\":1}}],[\"连锁更新会带来性能问题\",{\"1\":{\"879\":1}}],[\"连锁更新的情况\",{\"1\":{\"879\":1}}],[\"连锁更新\",{\"1\":{\"879\":1}}],[\"连续发送\",{\"1\":{\"924\":1}}],[\"连续+缓存命中率高\",{\"1\":{\"879\":1}}],[\"连续的\",{\"1\":{\"770\":1}}],[\"连表查询时\",{\"1\":{\"813\":1}}],[\"连表查询时尽量不要关联太多表\",{\"1\":{\"807\":1}}],[\"连接成功\",{\"1\":{\"976\":1}}],[\"连接mysql\",{\"1\":{\"976\":1}}],[\"连接超时\",{\"1\":{\"976\":1}}],[\"连接后\",{\"1\":{\"817\":1}}],[\"连接的过程需要先经过\",{\"1\":{\"817\":1}}],[\"连接命令一般是这么写的\",{\"1\":{\"817\":1}}],[\"连接数据库失败\",{\"1\":{\"976\":1}}],[\"连接数据库\",{\"1\":{\"817\":1}}],[\"连接过程\",{\"1\":{\"817\":1}}],[\"连接器的工作做完了\",{\"1\":{\"817\":1}}],[\"连接器就会自动将它断开\",{\"1\":{\"817\":1}}],[\"连接器会获取该用户的权限\",{\"1\":{\"817\":1}}],[\"连接器负责跟客户端建立连接\",{\"1\":{\"817\":1}}],[\"连接器\",{\"1\":{\"817\":2}}],[\"连接器自会判断用户身份\",{\"1\":{\"810\":1}}],[\"连接主库的\",{\"1\":{\"810\":1}}],[\"连接池\",{\"1\":{\"807\":1,\"817\":1}}],[\"连接层优化\",{\"1\":{\"807\":1}}],[\"连接层\",{\"1\":{\"800\":1,\"817\":1}}],[\"连接建立相对简单\",{\"1\":{\"249\":1}}],[\"连接运行\",{\"1\":{\"249\":1}}],[\"连接设计更低的延迟\",{\"1\":{\"249\":1}}],[\"连接加载网页文档资源的时间\",{\"1\":{\"249\":1}}],[\"连接可以复用\",{\"1\":{\"249\":1}}],[\"连接状态\",{\"1\":{\"249\":1}}],[\"连接相关的头字段\",{\"1\":{\"249\":1}}],[\"连接\",{\"1\":{\"249\":2,\"817\":2,\"983\":1}}],[\"连接型\",{\"1\":{\"243\":1}}],[\"连接型攻击\",{\"1\":{\"243\":1}}],[\"连接失败\",{\"1\":{\"226\":1}}],[\"连接服务器\",{\"1\":{\"226\":2}}],[\"连接符\",{\"1\":{\"157\":1}}],[\"索引等信息的数据\",{\"1\":{\"820\":1}}],[\"索引等信息单独存储在一个独占表空间\",{\"1\":{\"770\":1}}],[\"索引常见面试题\",{\"1\":{\"817\":1}}],[\"索引的类型\",{\"1\":{\"817\":1}}],[\"索引的叶子节点存放了数据在堆表中的地址\",{\"1\":{\"813\":1}}],[\"索引建立原则\",{\"1\":{\"813\":1}}],[\"索引陷阱\",{\"1\":{\"813\":1}}],[\"索引默认是b+tree有序结构\",{\"1\":{\"813\":1}}],[\"索引优劣分析\",{\"1\":{\"813\":1}}],[\"索引应用\",{\"1\":{\"813\":1}}],[\"索引选择\",{\"1\":{\"813\":1}}],[\"索引截断\",{\"1\":{\"813\":2}}],[\"索引字段是整型\",{\"1\":{\"813\":1}}],[\"索引字段是字符串类型\",{\"1\":{\"813\":1}}],[\"索引字段尽量选择多个\",{\"1\":{\"807\":1}}],[\"索引保存的是索引字段的原始值\",{\"1\":{\"813\":2}}],[\"索引失效会导致全表扫描\",{\"1\":{\"813\":1}}],[\"索引失效\",{\"1\":{\"813\":1}}],[\"索引就会失效\",{\"1\":{\"813\":1}}],[\"索引下推能够减少二级索引在查询时的回表操作\",{\"1\":{\"817\":1}}],[\"索引下推的大概原理是\",{\"1\":{\"813\":1}}],[\"索引下推的优化\",{\"1\":{\"813\":1}}],[\"索引下推在\",{\"1\":{\"813\":1}}],[\"索引下推\",{\"1\":{\"813\":2,\"817\":3}}],[\"索引一定是有序的列\",{\"1\":{\"813\":1}}],[\"索引即数据\",{\"1\":{\"813\":3}}],[\"索引组织表\",{\"1\":{\"813\":2}}],[\"索引存储\",{\"1\":{\"813\":1}}],[\"索引覆盖要求所有查询需要的列都在索引中\",{\"1\":{\"813\":1}}],[\"索引覆盖\",{\"1\":{\"813\":2,\"817\":2}}],[\"索引键值比较的成本\",{\"1\":{\"813\":1}}],[\"索引键值对\",{\"1\":{\"813\":1}}],[\"索引键\",{\"1\":{\"813\":1}}],[\"索引键+指针\",{\"1\":{\"813\":1}}],[\"索引+记录\",{\"1\":{\"813\":1}}],[\"索引数据结构\",{\"1\":{\"813\":1}}],[\"索引分类\",{\"1\":{\"813\":1}}],[\"索引和数据存储在存储引擎中\",{\"1\":{\"813\":1}}],[\"索引和锁\",{\"1\":{\"807\":1}}],[\"索引是排序后的数据\",{\"1\":{\"813\":1}}],[\"索引是提升查询速度的一种数据结构\",{\"1\":{\"813\":1}}],[\"索引是数据的目录\",{\"1\":{\"813\":1}}],[\"索引是优化查询的关键\",{\"1\":{\"803\":1}}],[\"索引页\",{\"1\":{\"810\":1}}],[\"索引结构\",{\"1\":{\"807\":2}}],[\"索引结构优化业务sql语句\",{\"1\":{\"807\":1}}],[\"索引可以影响锁的粒度和类型\",{\"1\":{\"807\":1}}],[\"索引可以理解为地址\",{\"1\":{\"20\":1}}],[\"索引\",{\"1\":{\"807\":2,\"813\":1,\"820\":2,\"826\":1},\"2\":{\"815\":1,\"828\":1}}],[\"索引调优\",{\"1\":{\"807\":1}}],[\"索引体系\",{\"0\":{\"803\":1}}],[\"索引段\",{\"1\":{\"770\":1}}],[\"索引段和回滚段等\",{\"1\":{\"770\":1}}],[\"看起来没什么作用\",{\"1\":{\"952\":1}}],[\"看起来就像下面这样\",{\"1\":{\"770\":1}}],[\"看起来就像这样\",{\"1\":{\"249\":1}}],[\"看负载因子\",{\"1\":{\"864\":1}}],[\"看不到\",{\"1\":{\"793\":1}}],[\"看看执行器是怎么工作的\",{\"1\":{\"817\":1}}],[\"看看是什么类型的语句\",{\"1\":{\"817\":1}}],[\"看看有什么区别\",{\"1\":{\"770\":1}}],[\"看看里面有什么文件\",{\"1\":{\"770\":1}}],[\"看能不能成功创建一张表\",{\"1\":{\"770\":1}}],[\"各组分别执行\",{\"1\":{\"823\":1}}],[\"各自之间数据分开存储\",{\"1\":{\"807\":1}}],[\"各个事务按顺序做\",{\"1\":{\"767\":1,\"810\":1}}],[\"各层作用\",{\"1\":{\"249\":2}}],[\"合理的设计库表结构\",{\"1\":{\"807\":1}}],[\"合并一次刷盘\",{\"1\":{\"767\":1,\"810\":1}}],[\"合起来是json\",{\"1\":{\"488\":1}}],[\"●\",{\"1\":{\"767\":3}}],[\"宣布比赛正式开始\",{\"1\":{\"764\":1,\"810\":1}}],[\"裁判\",{\"1\":{\"764\":4,\"810\":4}}],[\"阶段队列的作用是承接\",{\"1\":{\"810\":1}}],[\"阶段队列的作用是\",{\"1\":{\"810\":2}}],[\"阶段后\",{\"1\":{\"810\":1}}],[\"阶段之前做的\",{\"1\":{\"817\":1}}],[\"阶段之前\",{\"1\":{\"810\":1}}],[\"阶段之中\",{\"1\":{\"810\":1}}],[\"阶段融合在了\",{\"1\":{\"810\":1}}],[\"阶段不再让事务各自执行\",{\"1\":{\"810\":1}}],[\"阶段不变\",{\"1\":{\"767\":1,\"810\":1}}],[\"阶段拆分为三个过程\",{\"1\":{\"810\":1}}],[\"阶段拆分为3个过程\",{\"1\":{\"767\":1}}],[\"阶段结束才能释放锁\",{\"1\":{\"810\":1}}],[\"阶段的事务\",{\"1\":{\"810\":2}}],[\"阶段的\",{\"1\":{\"810\":3}}],[\"阶段跟踪事务\",{\"1\":{\"810\":1}}],[\"阶段和\",{\"1\":{\"810\":1}}],[\"阶段和提交\",{\"1\":{\"764\":1,\"810\":1}}],[\"阶段\",{\"1\":{\"764\":1,\"765\":2,\"767\":4,\"810\":19,\"817\":4}}],[\"阶段进行中间代码生成和优化\",{\"1\":{\"395\":1}}],[\"崩溃才会\",{\"1\":{\"952\":1}}],[\"崩溃了\",{\"1\":{\"810\":1}}],[\"崩溃\",{\"1\":{\"810\":1}}],[\"崩溃恢复的情况\",{\"1\":{\"810\":2}}],[\"崩溃恢复\",{\"1\":{\"810\":1}}],[\"崩溃恢复以后这个事务无效\",{\"1\":{\"763\":1,\"810\":1}}],[\"崩溃如何回滚\",{\"1\":{\"810\":1}}],[\"崩溃后\",{\"1\":{\"739\":1,\"810\":1}}],[\"丢失了这条更新语句\",{\"1\":{\"763\":1,\"810\":1}}],[\"锁瞬间过期了\",{\"1\":{\"918\":1,\"921\":1}}],[\"锁可能很快过期\",{\"1\":{\"918\":1,\"921\":1}}],[\"锁获取的时候还是自己的\",{\"1\":{\"913\":1,\"921\":1}}],[\"锁归属\",{\"0\":{\"912\":1},\"1\":{\"921\":1}}],[\"锁住这个\",{\"1\":{\"897\":1}}],[\"锁住的范围是\",{\"1\":{\"820\":1}}],[\"锁住的就是一个点\",{\"1\":{\"820\":2}}],[\"锁住的是一条记录\",{\"1\":{\"820\":1}}],[\"锁时会遇到锁冲突\",{\"1\":{\"820\":1}}],[\"锁范围\",{\"1\":{\"820\":2}}],[\"锁范围是\",{\"1\":{\"820\":2}}],[\"锁范围内插入了一条记录\",{\"1\":{\"783\":1}}],[\"锁释放\",{\"1\":{\"820\":2}}],[\"锁释放掉\",{\"1\":{\"820\":1}}],[\"锁会退化成间隙锁\",{\"1\":{\"820\":2}}],[\"锁会\",{\"1\":{\"820\":1}}],[\"锁或者间隙锁\",{\"1\":{\"820\":2}}],[\"锁上界\",{\"1\":{\"820\":1}}],[\"锁不会退化成间隙锁\",{\"1\":{\"820\":1}}],[\"锁不兼容\",{\"1\":{\"820\":3}}],[\"锁不是在\",{\"1\":{\"820\":1}}],[\"锁兼容\",{\"1\":{\"820\":1}}],[\"锁之分的\",{\"1\":{\"820\":1}}],[\"锁和\",{\"1\":{\"820\":1}}],[\"锁定用户的连接次数\",{\"1\":{\"843\":1}}],[\"锁定用户账户\",{\"0\":{\"843\":1}}],[\"锁定一个现有用户\",{\"1\":{\"843\":1}}],[\"锁定一个范围\",{\"1\":{\"820\":3}}],[\"锁定读\",{\"1\":{\"820\":2}}],[\"锁就会被释放\",{\"1\":{\"820\":2}}],[\"锁就只针对每个队列进行保护\",{\"1\":{\"810\":1}}],[\"锁再对大量数据进行插入的时候\",{\"1\":{\"820\":1}}],[\"锁是特殊的表锁机制\",{\"1\":{\"820\":1}}],[\"锁的目的是获取资源的使用权\",{\"1\":{\"909\":1,\"921\":1}}],[\"锁的状态是等待状态\",{\"1\":{\"820\":1}}],[\"锁的范围\",{\"1\":{\"820\":3}}],[\"锁的加锁规则其实挺复杂的\",{\"1\":{\"820\":1}}],[\"锁的就是两个值之间的空隙\",{\"1\":{\"820\":1}}],[\"锁的是记录本身\",{\"1\":{\"820\":1}}],[\"锁的过程中\",{\"1\":{\"820\":1}}],[\"锁的操作会形成一个队列\",{\"1\":{\"820\":1}}],[\"锁的使用\",{\"1\":{\"512\":1}}],[\"锁粒度减小了\",{\"1\":{\"810\":1}}],[\"锁来保证事务提交的顺序\",{\"1\":{\"810\":1}}],[\"锁信息等等\",{\"1\":{\"810\":1}}],[\"锁\",{\"1\":{\"795\":1,\"820\":26}}],[\"锁竞争激烈\",{\"1\":{\"766\":1,\"810\":1}}],[\"锁机制\",{\"1\":{\"760\":1,\"801\":1},\"2\":{\"822\":1,\"920\":1}}],[\"产生\",{\"1\":{\"759\":1}}],[\"产生的\",{\"1\":{\"755\":1,\"810\":3}}],[\"产生了外部内存碎片\",{\"1\":{\"217\":1}}],[\"刷新\",{\"1\":{\"957\":1}}],[\"刷新到磁盘\",{\"1\":{\"810\":1}}],[\"刷新到硬盘\",{\"1\":{\"810\":3}}],[\"刷入到磁盘\",{\"1\":{\"810\":1}}],[\"刷入到磁盘之后\",{\"1\":{\"763\":2,\"810\":2}}],[\"刷到磁盘上的频率\",{\"1\":{\"810\":1}}],[\"刷写到磁盘上的\",{\"1\":{\"753\":1}}],[\"刷盘其实还是在flushappendonlyfile函数中\",{\"1\":{\"952\":1}}],[\"刷盘的时机\",{\"1\":{\"810\":3}}],[\"刷盘的数据继续进行事务的提交\",{\"1\":{\"810\":1}}],[\"刷盘操作\",{\"1\":{\"810\":1}}],[\"刷盘操作合并成一个\",{\"1\":{\"810\":1}}],[\"刷盘操作合并成1个\",{\"1\":{\"767\":1}}],[\"刷盘时机是在事务提交的时候\",{\"1\":{\"810\":1}}],[\"刷盘\",{\"1\":{\"766\":3,\"810\":9,\"952\":1}}],[\"刷盘到存储表数据的文件\",{\"1\":{\"751\":1}}],[\"刷盘策略\",{\"0\":{\"749\":1,\"760\":1},\"1\":{\"952\":1}}],[\"磁盘占用率会变高\",{\"1\":{\"813\":1}}],[\"磁盘临时表中每条记录的成本\",{\"1\":{\"813\":1}}],[\"磁盘的\",{\"1\":{\"810\":1}}],[\"磁盘\",{\"1\":{\"751\":1,\"766\":1,\"810\":3,\"813\":1}}],[\"竹子爱熊猫\",{\"1\":{\"749\":1}}],[\"深入一点理解\",{\"1\":{\"941\":1}}],[\"深入探寻数据库内存与buffer\",{\"1\":{\"749\":1}}],[\"深入学习文章推荐\",{\"1\":{\"749\":1}}],[\"深拷贝执行结果\",{\"1\":{\"33\":1}}],[\"深拷贝不仅拷贝值\",{\"1\":{\"33\":1}}],[\"深拷贝\",{\"1\":{\"33\":2}}],[\"刚好在一个已经删除的空位置\",{\"1\":{\"864\":1}}],[\"刚好这个表有更新操作\",{\"1\":{\"817\":1}}],[\"刚启动的时候\",{\"1\":{\"810\":1}}],[\"刚刚提到了\",{\"1\":{\"748\":1}}],[\"刚才我们在\",{\"1\":{\"223\":1}}],[\"判定方法\",{\"1\":{\"744\":1,\"789\":1}}],[\"判断库存名额是否充足\",{\"1\":{\"927\":1}}],[\"判断记录的\",{\"1\":{\"817\":1}}],[\"判断你输入的这个\",{\"1\":{\"817\":1}}],[\"判断联合索引字段能不能走索引\",{\"1\":{\"813\":1}}],[\"判断输入的语句是否符合\",{\"1\":{\"810\":1}}],[\"判断是否将\",{\"1\":{\"530\":1}}],[\"判断有无读写事件发生\",{\"1\":{\"226\":2}}],[\"判断左侧窗口是否要收缩\",{\"1\":{\"88\":1}}],[\"判断\",{\"1\":{\"33\":1}}],[\"串成一个链表\",{\"1\":{\"742\":1,\"810\":1}}],[\"串行化\",{\"1\":{\"782\":1,\"784\":1}}],[\"串行\",{\"1\":{\"249\":1}}],[\"认识\",{\"0\":{\"740\":1,\"752\":1}}],[\"认为可信则继续往下走\",{\"1\":{\"249\":1}}],[\"试想以下场景\",{\"1\":{\"739\":1,\"751\":1}}],[\"试图访问属于内核空间的内存会引发硬件异常\",{\"1\":{\"220\":1}}],[\"待落盘的脏数据页记录\",{\"1\":{\"810\":1}}],[\"待执行的语句执行过程\",{\"1\":{\"735\":1}}],[\"待补充内容\",{\"1\":{\"178\":1,\"184\":1,\"185\":1,\"724\":1}}],[\"待补充server相关内容\",{\"1\":{\"159\":1}}],[\"待补充producer相关内容\",{\"1\":{\"158\":1}}],[\"名称不能重复\",{\"1\":{\"829\":1}}],[\"名称必须以英文作为开头\",{\"1\":{\"829\":1}}],[\"名称是否正确等\",{\"1\":{\"734\":1}}],[\"名称以\",{\"1\":{\"123\":1}}],[\"影响核心流程\",{\"1\":{\"930\":1}}],[\"影响商家声誉\",{\"1\":{\"927\":1}}],[\"影响从库的数据\",{\"1\":{\"810\":1}}],[\"影响主库的数据\",{\"1\":{\"810\":1}}],[\"影响读请求的执行\",{\"1\":{\"730\":1}}],[\"影响了事务执行效率\",{\"1\":{\"727\":1}}],[\"杜宇数据延迟敏感的业务\",{\"1\":{\"730\":1}}],[\"仍有一个从库有最新数据\",{\"1\":{\"730\":1,\"761\":1}}],[\"仍然是这些框架的基础\",{\"1\":{\"644\":1}}],[\"半同步复制的方式\",{\"1\":{\"810\":1}}],[\"半同步复制\",{\"1\":{\"810\":1}}],[\"半同步模式\",{\"1\":{\"730\":1,\"761\":1}}],[\"半连接\",{\"1\":{\"249\":1}}],[\"半连接和全连接队列\",{\"1\":{\"226\":1}}],[\"跨库跨表\",{\"1\":{\"727\":1}}],[\"跨库跨表关联查询问题\",{\"1\":{\"727\":1}}],[\"跨平台\",{\"1\":{\"564\":1}}],[\"美团\",{\"1\":{\"727\":1}}],[\"美团leaf\",{\"1\":{\"23\":1}}],[\"水平拆分是把相同的表结构分散到不同的数据库和不同的数据表中\",{\"1\":{\"727\":1}}],[\"水平切分\",{\"1\":{\"727\":1}}],[\"水平触发\",{\"1\":{\"226\":1}}],[\"垂直拆分一般是按照业务和功能的维度进行拆分\",{\"1\":{\"727\":1}}],[\"垂直切分\",{\"1\":{\"727\":1}}],[\"垂直切分和水平切分\",{\"1\":{\"727\":1}}],[\"槽\",{\"1\":{\"723\":1}}],[\"号\",{\"1\":{\"944\":1}}],[\"号分区\",{\"1\":{\"723\":2}}],[\"号码\",{\"1\":{\"20\":2}}],[\"客户不用关心别的客户减肥情况\",{\"1\":{\"723\":1}}],[\"客户之间没什么交互\",{\"1\":{\"723\":1}}],[\"客户分区\",{\"0\":{\"723\":1}}],[\"客户端缓存\",{\"1\":{\"930\":3}}],[\"客户端会执行以下操作\",{\"1\":{\"917\":1,\"921\":1}}],[\"客户端一直都没有发送数据\",{\"1\":{\"888\":1}}],[\"客户端向\",{\"1\":{\"817\":1}}],[\"客户端主动重置连接\",{\"1\":{\"817\":1}}],[\"客户端进程向服务器进程发送一段文本\",{\"1\":{\"817\":1}}],[\"客户端先通过连接器建立连接\",{\"1\":{\"810\":1}}],[\"客户端连接池\",{\"1\":{\"807\":2}}],[\"客户端连续发起多次请求\",{\"1\":{\"23\":1}}],[\"客户端连续发起两次请求\",{\"1\":{\"23\":1}}],[\"客户端与连接层的优化\",{\"1\":{\"807\":1}}],[\"客户端的一些操作可以批量化完成\",{\"1\":{\"807\":1}}],[\"客户端的请求\",{\"1\":{\"102\":1}}],[\"客户端就会直接读取\",{\"1\":{\"747\":1,\"810\":1}}],[\"客户端将sql查询语句发送到服务器\",{\"1\":{\"734\":1}}],[\"客户端感知不到\",{\"1\":{\"681\":1}}],[\"客户端再发送\",{\"1\":{\"249\":1}}],[\"客户端和服务端都共享了三个随机数\",{\"1\":{\"249\":1}}],[\"客户端和服务端的\",{\"1\":{\"237\":1}}],[\"客户端回应\",{\"1\":{\"249\":1}}],[\"客户端验证完证书后\",{\"1\":{\"249\":1}}],[\"客户端收到证书后\",{\"1\":{\"249\":1}}],[\"客户端收到该返回后自动重新请求一个token\",{\"1\":{\"23\":1}}],[\"客户端确认回应\",{\"1\":{\"249\":1}}],[\"客户端发起的连接请求\",{\"1\":{\"734\":1}}],[\"客户端发起第一次请求\",{\"1\":{\"23\":1}}],[\"客户端发送sql语句\",{\"1\":{\"734\":1}}],[\"客户端发送\",{\"1\":{\"249\":2}}],[\"客户端打招呼\",{\"1\":{\"249\":1}}],[\"客户端错误\",{\"1\":{\"249\":1}}],[\"客户端不知道真实的服务器\",{\"1\":{\"240\":1}}],[\"客户端校验服务端的数字证书的过程\",{\"1\":{\"240\":1,\"249\":1}}],[\"客户端请求报文正确\",{\"1\":{\"240\":1}}],[\"客户端请求报文有误\",{\"1\":{\"240\":1}}],[\"客户端请求的资源发生了变动\",{\"1\":{\"240\":1}}],[\"客户端宕机\",{\"1\":{\"226\":1}}],[\"客户端正常发起关闭\",{\"1\":{\"226\":1}}],[\"客户端套接字\",{\"1\":{\"226\":2}}],[\"客户端结构体\",{\"1\":{\"226\":1}}],[\"客户端\",{\"0\":{\"101\":1},\"1\":{\"237\":2,\"661\":1,\"817\":1,\"888\":1}}],[\"客户端负责发送操作指令\",{\"1\":{\"100\":1}}],[\"客户端无法接收到\",{\"1\":{\"23\":1}}],[\"微妙后\",{\"1\":{\"810\":1}}],[\"微信通知分区\",{\"1\":{\"722\":1}}],[\"微服务框架\",{\"2\":{\"972\":1}}],[\"微服务\",{\"0\":{\"232\":1},\"2\":{\"230\":1,\"231\":1,\"233\":1,\"234\":1,\"971\":1}}],[\"微服务架构中设计接口时的重要原则\",{\"1\":{\"23\":1}}],[\"风控子业务一个分区\",{\"1\":{\"722\":1}}],[\"显然\",{\"1\":{\"810\":1}}],[\"显然可以金融服务一个分区\",{\"1\":{\"722\":1}}],[\"显示旧客户端是\",{\"1\":{\"913\":1,\"921\":1}}],[\"显示角色\",{\"1\":{\"852\":1}}],[\"显示用户权限\",{\"0\":{\"848\":1}}],[\"显示系统变量信息\",{\"1\":{\"836\":1}}],[\"显示哪些线程正在运行\",{\"1\":{\"836\":1}}],[\"显示锁\",{\"1\":{\"820\":1}}],[\"显示详细的优化决策\",{\"1\":{\"398\":1}}],[\"显示月份\",{\"1\":{\"210\":1}}],[\"显示年份\",{\"1\":{\"210\":1}}],[\"显示当前用户权限\",{\"1\":{\"848\":1}}],[\"显示当前时间\",{\"1\":{\"210\":1}}],[\"显示当前目录\",{\"1\":{\"201\":1}}],[\"显示当前进程状态\",{\"1\":{\"195\":1}}],[\"显示全部文件\",{\"1\":{\"201\":1}}],[\"显示日志\",{\"1\":{\"146\":2}}],[\"显示最近创建的容器\",{\"1\":{\"140\":1}}],[\"显示docker的系统信息\",{\"1\":{\"132\":1}}],[\"显示docker的版本信息\",{\"1\":{\"132\":1}}],[\"金融服务分为\",{\"1\":{\"722\":1}}],[\"金融服务\",{\"1\":{\"722\":1}}],[\"金融交易系统\",{\"1\":{\"719\":1}}],[\"某样东西一定不存在或者可能存在\",{\"1\":{\"930\":1}}],[\"某个时刻的全部数据\",{\"1\":{\"952\":1}}],[\"某个用户请求接口次数过于频繁\",{\"1\":{\"927\":1}}],[\"某个字段的最大长度是100字节\",{\"1\":{\"770\":1}}],[\"某些异步流程\",{\"1\":{\"891\":1}}],[\"某些不会做范围查询的字段建立索引\",{\"1\":{\"807\":1}}],[\"某些依赖性任务必须按特定顺序执行\",{\"1\":{\"719\":1}}],[\"某行记录\",{\"1\":{\"763\":1}}],[\"某种类型不限于结构体\",{\"1\":{\"460\":1}}],[\"某种东西过多一般会意味着\",{\"1\":{\"237\":1}}],[\"支撑\",{\"1\":{\"810\":1}}],[\"支付子业务一个分区\",{\"1\":{\"722\":1}}],[\"支付\",{\"1\":{\"719\":1}}],[\"支持输出调用堆栈\",{\"1\":{\"956\":1}}],[\"支持七种日志级别\",{\"1\":{\"956\":1}}],[\"支持结构化日志记录\",{\"1\":{\"956\":1}}],[\"支持丰富的对象种类\",{\"1\":{\"937\":1}}],[\"支持多个消费者订阅相同的频道\",{\"1\":{\"924\":1}}],[\"支持多客户端连接\",{\"1\":{\"776\":1}}],[\"支持过期时间\",{\"0\":{\"911\":1},\"1\":{\"921\":1}}],[\"支持任意\",{\"1\":{\"894\":1}}],[\"支持从表尾向表头遍历\",{\"1\":{\"885\":1}}],[\"支持在头尾插入数据\",{\"1\":{\"879\":1}}],[\"支持索引类型是\",{\"1\":{\"817\":1}}],[\"支持\",{\"1\":{\"817\":1,\"900\":1,\"956\":1}}],[\"支持以下几种模式\",{\"1\":{\"587\":1}}],[\"支持动态加载类和使用类\",{\"1\":{\"552\":1}}],[\"支持了更多的并发\",{\"1\":{\"378\":1}}],[\"支持响应分块\",{\"1\":{\"249\":1}}],[\"支持服务器主动推送资源\",{\"1\":{\"240\":1}}],[\"支持的选项如下\",{\"1\":{\"957\":1}}],[\"支持的密码套件列表\",{\"1\":{\"249\":1}}],[\"支持的数据类型\",{\"1\":{\"229\":1}}],[\"支持的网络模式\",{\"0\":{\"122\":1}}],[\"支持组消费\",{\"1\":{\"164\":1}}],[\"电商订单处理\",{\"1\":{\"719\":1}}],[\"电子宠物\",{\"1\":{\"13\":1}}],[\"准备去执行\",{\"1\":{\"912\":1,\"921\":1}}],[\"准备\",{\"1\":{\"810\":1}}],[\"准备阶段\",{\"1\":{\"764\":1,\"810\":1}}],[\"准备好唤醒的条件\",{\"1\":{\"265\":1}}],[\"准确消费一次\",{\"1\":{\"717\":1}}],[\"决定了日志字段格式\",{\"1\":{\"957\":1}}],[\"决定了data字段如何解析和操作\",{\"1\":{\"302\":1}}],[\"决定对数据库中的数据进行变更\",{\"1\":{\"829\":1}}],[\"决定是否立即向producer发送确认或者等待同步副本的确认\",{\"1\":{\"710\":1}}],[\"甚至还实现\",{\"1\":{\"957\":1}}],[\"甚至可以不动非叶子节点\",{\"1\":{\"813\":1}}],[\"甚至可能因为某些原因都没发送过数据\",{\"1\":{\"709\":1}}],[\"甚至引发严重的金融风险\",{\"1\":{\"719\":1}}],[\"甚至于只完成一点操作\",{\"1\":{\"36\":1}}],[\"框架之一\",{\"1\":{\"973\":1}}],[\"框架中的使用示例\",{\"1\":{\"957\":1}}],[\"框架\",{\"2\":{\"701\":1,\"959\":1,\"971\":1,\"1017\":1}}],[\"框架架构\",{\"0\":{\"100\":1}}],[\"事实上\",{\"1\":{\"952\":1}}],[\"事实也证明单纯性的\",{\"1\":{\"888\":1}}],[\"事先估计一下查询需要哪些索引\",{\"1\":{\"807\":1}}],[\"事务配置\",{\"0\":{\"978\":1}}],[\"事务过程中生成的锁都会被释放\",{\"1\":{\"820\":1}}],[\"事务执行期间\",{\"1\":{\"820\":1}}],[\"事务执行中间过程的\",{\"1\":{\"810\":1}}],[\"事务执行过程中看到的数据\",{\"1\":{\"783\":1}}],[\"事务执行过程中\",{\"1\":{\"760\":1,\"810\":1}}],[\"事务没提交的时候\",{\"1\":{\"810\":2}}],[\"事务线程不用等待所有的从库复制成功响应\",{\"1\":{\"810\":1}}],[\"事务处理过程中\",{\"1\":{\"810\":1}}],[\"事务处理结束后\",{\"1\":{\"774\":1}}],[\"事务隐式开启\",{\"1\":{\"810\":1}}],[\"事务是mysql的重要特性\",{\"1\":{\"801\":1}}],[\"事务机制\",{\"0\":{\"801\":1}}],[\"事务访问数据的可见性判断\",{\"0\":{\"789\":1}}],[\"事务隔离级别为可重复读\",{\"1\":{\"820\":2}}],[\"事务隔离级别\",{\"0\":{\"781\":1}}],[\"事务a开始更改表中所有数据的性别字段\",{\"1\":{\"780\":1}}],[\"事务由\",{\"1\":{\"765\":1,\"810\":1}}],[\"事务提交\",{\"1\":{\"810\":2}}],[\"事务提交完成后\",{\"1\":{\"810\":1}}],[\"事务提交之后发生了崩溃\",{\"1\":{\"810\":1}}],[\"事务提交之前发生了崩溃\",{\"1\":{\"810\":1}}],[\"事务提交时使用\",{\"1\":{\"765\":1}}],[\"事务提交后\",{\"1\":{\"763\":2,\"810\":1}}],[\"事务提交的时候\",{\"1\":{\"760\":1,\"810\":1}}],[\"事务readview\",{\"1\":{\"744\":1}}],[\"事务的acid特性\",{\"0\":{\"774\":1}}],[\"事务的提交过程有两个阶段\",{\"1\":{\"765\":1,\"810\":1}}],[\"事务的提交\",{\"1\":{\"765\":1,\"810\":1}}],[\"事务的\",{\"1\":{\"743\":1,\"765\":1,\"810\":4}}],[\"事务期间的多次读取同一条数据\",{\"1\":{\"743\":1,\"810\":1}}],[\"事务id\",{\"1\":{\"742\":1,\"770\":1,\"810\":1}}],[\"事务\",{\"1\":{\"714\":1,\"744\":1,\"765\":3,\"789\":1,\"793\":7,\"794\":3,\"810\":3,\"820\":16},\"2\":{\"798\":1}}],[\"事务管理\",{\"0\":{\"1013\":1},\"1\":{\"698\":1}}],[\"事件循环\",{\"1\":{\"897\":1}}],[\"事件处理\",{\"1\":{\"615\":1}}],[\"事件进行处理\",{\"1\":{\"226\":1}}],[\"事件\",{\"1\":{\"226\":1,\"638\":1}}],[\"事件要需要一个子进程或者线程来处理\",{\"1\":{\"226\":1}}],[\"事件的话\",{\"1\":{\"226\":1}}],[\"事件驱动io\",{\"1\":{\"226\":1}}],[\"线程争抢锁\",{\"1\":{\"930\":2}}],[\"线程去读取客户端请求命令\",{\"1\":{\"897\":1}}],[\"线程去回放\",{\"1\":{\"730\":1,\"761\":1}}],[\"线程创建多次\",{\"1\":{\"897\":1}}],[\"线程对应的\",{\"1\":{\"897\":1}}],[\"线程模型\",{\"2\":{\"893\":1}}],[\"线程来处理复制的请求\",{\"1\":{\"810\":1}}],[\"线程也比较多\",{\"1\":{\"810\":1}}],[\"线程的上下文切换开销远远大于线程执行开销\",{\"1\":{\"807\":1}}],[\"线程\",{\"1\":{\"730\":2,\"761\":1,\"810\":2,\"820\":3}}],[\"线程安全\",{\"1\":{\"689\":1}}],[\"线程安全问题\",{\"0\":{\"689\":1}}],[\"线程不安全\",{\"1\":{\"689\":1}}],[\"线程是运行\",{\"1\":{\"384\":1}}],[\"变\",{\"1\":{\"879\":3}}],[\"变成\",{\"1\":{\"879\":1}}],[\"变成了\",{\"1\":{\"810\":2,\"949\":1}}],[\"变长字段长度\",{\"1\":{\"770\":6}}],[\"变长字段长度列表\",{\"1\":{\"770\":18}}],[\"变长字段字节数列表所占用的字节数\",{\"1\":{\"770\":1}}],[\"变长字段字节数列表\",{\"1\":{\"770\":1}}],[\"变长字段的真实数据占用的字节数\",{\"1\":{\"770\":1}}],[\"变长字段实际存储的数据的长度\",{\"1\":{\"770\":1}}],[\"变化\",{\"1\":{\"682\":1}}],[\"变量的值将加\",{\"1\":{\"843\":1}}],[\"变量的生命周期\",{\"0\":{\"439\":1}}],[\"变量引用\",{\"1\":{\"568\":1}}],[\"变量类型不仅仅局限于结构体类型\",{\"1\":{\"460\":1}}],[\"变量默认为零值\",{\"1\":{\"436\":1}}],[\"变量命名\",{\"1\":{\"435\":1}}],[\"变量大小不确定\",{\"0\":{\"415\":1}}],[\"变量\",{\"1\":{\"190\":1,\"433\":1}}],[\"部署到servlet容器\",{\"1\":{\"659\":1}}],[\"部署和访问\",{\"0\":{\"659\":1}}],[\"部分情况周期函数也会进行迁移\",{\"1\":{\"864\":1}}],[\"部分显示了\",{\"1\":{\"817\":1}}],[\"部分\",{\"1\":{\"452\":1}}],[\"部分层次对应\",{\"1\":{\"249\":1}}],[\"掌握servlet的核心概念和使用方法对于理解其他java\",{\"1\":{\"644\":1}}],[\"已有的记录的主键或者唯一二级索引列值相同\",{\"1\":{\"820\":1}}],[\"已删除该模块\",{\"1\":{\"817\":1}}],[\"已解决\",{\"1\":{\"710\":1}}],[\"已上线\",{\"1\":{\"641\":1}}],[\"已离线\",{\"1\":{\"641\":2}}],[\"已经很高效\",{\"1\":{\"888\":1}}],[\"已经完成\",{\"1\":{\"864\":1}}],[\"已经插入\",{\"1\":{\"820\":1}}],[\"已经对表加了一个范围\",{\"1\":{\"820\":1}}],[\"已经确定\",{\"1\":{\"813\":1}}],[\"已经确认的消息也不会丢失\",{\"1\":{\"710\":1}}],[\"已经被持久化磁盘了\",{\"1\":{\"810\":1}}],[\"已经写入了\",{\"1\":{\"810\":1}}],[\"已经写入磁盘\",{\"1\":{\"751\":1,\"810\":1}}],[\"已经刷入磁盘的数据都会从\",{\"1\":{\"810\":1}}],[\"已经持久化\",{\"1\":{\"752\":1,\"810\":1}}],[\"已经提交的事务生成的\",{\"1\":{\"744\":1,\"789\":1}}],[\"已经存在于\",{\"1\":{\"531\":1}}],[\"已经满了\",{\"1\":{\"374\":1}}],[\"钝化到磁盘\",{\"1\":{\"638\":1}}],[\"购物车对象随会话\",{\"1\":{\"638\":1}}],[\"购物车对象即将随会话\",{\"1\":{\"638\":1}}],[\"购物车更新等\",{\"1\":{\"615\":1}}],[\"稍后尝试逐个\",{\"1\":{\"944\":1}}],[\"稍后\",{\"1\":{\"637\":1}}],[\"触发\",{\"1\":{\"957\":1}}],[\"触发时间\",{\"1\":{\"952\":1}}],[\"触发器\",{\"1\":{\"817\":1}}],[\"触发valueunbound方法\",{\"1\":{\"637\":1}}],[\"触发valuebound方法\",{\"1\":{\"637\":1}}],[\"触发再平衡\",{\"1\":{\"165\":2}}],[\"触发再平衡的情况\",{\"1\":{\"165\":1}}],[\"供全局使用\",{\"1\":{\"624\":1}}],[\"供人们查看\",{\"1\":{\"249\":1}}],[\"收获的只有骂声\",{\"1\":{\"927\":1}}],[\"收集用户访问数据\",{\"1\":{\"615\":1}}],[\"收到通知\",{\"1\":{\"888\":1}}],[\"收到请求\",{\"1\":{\"584\":1}}],[\"收到响应报文后会立即关闭连接\",{\"1\":{\"249\":1}}],[\"观察者模式\",{\"1\":{\"614\":1}}],[\"敏感信息处理\",{\"1\":{\"604\":1}}],[\"考虑下面场景\",{\"1\":{\"820\":1}}],[\"考虑实现缓存机制\",{\"1\":{\"603\":1}}],[\"考虑合并或使用共享组件\",{\"1\":{\"603\":1}}],[\"考虑使用bytes\",{\"1\":{\"502\":1}}],[\"考虑使用指针返回\",{\"1\":{\"429\":1}}],[\"身份验证filter\",{\"0\":{\"598\":1}}],[\"身份验证和授权\",{\"1\":{\"579\":1}}],[\"拦截请求\",{\"1\":{\"591\":1}}],[\"拦截能力\",{\"1\":{\"578\":1}}],[\"匹配优先级\",{\"0\":{\"656\":1}}],[\"匹配所有未被其他servlet匹配的请求\",{\"1\":{\"655\":1}}],[\"匹配所有请求\",{\"1\":{\"587\":1}}],[\"匹配所有以\",{\"1\":{\"587\":1,\"655\":1}}],[\"匹配\",{\"1\":{\"587\":1,\"655\":1}}],[\"耗费更多内存\",{\"1\":{\"770\":1}}],[\"耗时\",{\"1\":{\"584\":1}}],[\"耗尽\",{\"1\":{\"243\":1}}],[\"继续做任务\",{\"1\":{\"918\":1,\"921\":1}}],[\"继续采样淘汰\",{\"1\":{\"906\":1}}],[\"继续执行\",{\"1\":{\"820\":1}}],[\"继续执行新的更新操作\",{\"1\":{\"810\":1}}],[\"继续向存储引擎索要下一条记录\",{\"1\":{\"817\":1}}],[\"继续排序\",{\"1\":{\"813\":1}}],[\"继续处理\",{\"1\":{\"598\":1,\"599\":1,\"601\":1}}],[\"继续处理请求\",{\"1\":{\"584\":1,\"591\":1,\"600\":1}}],[\"继承了java语言的安全特性\",{\"1\":{\"646\":1}}],[\"继承\",{\"1\":{\"33\":1,\"564\":1}}],[\"监控重要属性的变化\",{\"1\":{\"615\":1}}],[\"监控应用性能\",{\"1\":{\"579\":1}}],[\"监听运行\",{\"1\":{\"1024\":1}}],[\"监听servletrequest属性的添加\",{\"1\":{\"621\":1}}],[\"监听servletrequest的创建和销毁\",{\"1\":{\"621\":1}}],[\"监听servletcontext属性的添加\",{\"1\":{\"619\":1}}],[\"监听servletcontext的创建和销毁\",{\"1\":{\"619\":1}}],[\"监听对象绑定到httpsession或从httpsession解除绑定\",{\"1\":{\"620\":1}}],[\"监听httpsession的钝化和活化\",{\"1\":{\"620\":1}}],[\"监听httpsession的创建和销毁\",{\"1\":{\"620\":1}}],[\"监听httpsession属性的添加\",{\"1\":{\"620\":1}}],[\"监听器用于监听servlet上下文\",{\"1\":{\"684\":1}}],[\"监听器\",{\"0\":{\"684\":1},\"1\":{\"614\":1}}],[\"监听dns查询\",{\"1\":{\"243\":1}}],[\"监听网络端口\",{\"1\":{\"226\":2}}],[\"控制台输出\",{\"1\":{\"957\":2}}],[\"控制台和\",{\"1\":{\"957\":1}}],[\"控制台得到如下输出\",{\"1\":{\"957\":2}}],[\"控制\",{\"1\":{\"760\":1}}],[\"控制资源访问权限\",{\"1\":{\"579\":1}}],[\"控制变量或函数的生命周期和作用域\",{\"1\":{\"33\":1}}],[\"静态文件的路径\",{\"1\":{\"1033\":1}}],[\"静态方法是属于类的\",{\"1\":{\"573\":1}}],[\"静态方法不能调用非静态成员\",{\"0\":{\"573\":1}}],[\"静态成员函数没有this指针\",{\"1\":{\"33\":1}}],[\"静态成员函数\",{\"1\":{\"33\":1}}],[\"静态成员变量\",{\"1\":{\"33\":1}}],[\"稳健性\",{\"1\":{\"564\":1}}],[\"泛型等特性\",{\"1\":{\"564\":1}}],[\"抽象\",{\"1\":{\"564\":1}}],[\"└──\",{\"1\":{\"538\":4,\"962\":17}}],[\"│\",{\"1\":{\"538\":3,\"962\":49}}],[\"严重错误\",{\"1\":{\"538\":1}}],[\"├──\",{\"1\":{\"538\":7,\"962\":38}}],[\"干扰了程序的正常指令流\",{\"1\":{\"537\":1}}],[\"尝试使用原子操作\",{\"1\":{\"531\":1}}],[\"尝试用\",{\"1\":{\"531\":1}}],[\"尝试在\",{\"1\":{\"531\":1}}],[\"尝试从\",{\"1\":{\"529\":1}}],[\"底层都是\",{\"1\":{\"957\":1}}],[\"底层数据结构\",{\"1\":{\"885\":1,\"938\":1}}],[\"底层数据结构主要是\",{\"1\":{\"873\":1}}],[\"底层使用了\",{\"1\":{\"879\":1}}],[\"底层用压缩列表实现\",{\"1\":{\"867\":1}}],[\"底层\",{\"1\":{\"867\":3}}],[\"底层实现\",{\"1\":{\"867\":1,\"870\":1,\"876\":1},\"2\":{\"866\":1}}],[\"底层调用\",{\"1\":{\"531\":1}}],[\"底层还是使用的\",{\"1\":{\"516\":1}}],[\"计数重置为\",{\"1\":{\"530\":1}}],[\"计数小于脏数据的数量\",{\"1\":{\"530\":1}}],[\"计数\",{\"1\":{\"530\":1}}],[\"计算次数衰减\",{\"1\":{\"903\":1}}],[\"计算字符串长度为\",{\"1\":{\"873\":1}}],[\"计算后的值\",{\"1\":{\"813\":1}}],[\"计算最大\",{\"1\":{\"770\":1}}],[\"计算总价等方法\",{\"1\":{\"638\":1}}],[\"计算请求处理时间\",{\"1\":{\"626\":1}}],[\"计算处理时间\",{\"1\":{\"600\":1}}],[\"计算乘法逆元d\",{\"1\":{\"249\":1}}],[\"计算e的乘法逆元d\",{\"1\":{\"249\":1}}],[\"计算机网络基础知识汇总\",{\"0\":{\"249\":1}}],[\"计算机网络安全详解\",{\"0\":{\"243\":1}}],[\"计算机网络应用层详解\",{\"0\":{\"240\":1}}],[\"计算机网络传输层详解\",{\"0\":{\"237\":1}}],[\"计算机网络\",{\"0\":{\"236\":1},\"1\":{\"249\":1},\"2\":{\"238\":1,\"241\":1,\"244\":1,\"247\":1,\"250\":1}}],[\"计算密集型的场景适合阻塞io\",{\"1\":{\"226\":1}}],[\"计算哈希值并映射到哈希槽\",{\"1\":{\"723\":1}}],[\"计算哈希值\",{\"1\":{\"77\":1}}],[\"计算\",{\"1\":{\"20\":1,\"240\":1,\"249\":5}}],[\"晋升\",{\"1\":{\"530\":1}}],[\"九\",{\"0\":{\"528\":1}}],[\"拿到锁的线程就会进行查询数据库\",{\"1\":{\"930\":2}}],[\"拿到参数\",{\"1\":{\"888\":1}}],[\"拿去\",{\"1\":{\"820\":1}}],[\"拿锁去操作的协程需要一直等待这个线性时间复杂度的过程完成\",{\"1\":{\"527\":1}}],[\"拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对\",{\"1\":{\"75\":1}}],[\"改数据时\",{\"1\":{\"813\":1}}],[\"改成\",{\"1\":{\"813\":1}}],[\"改进一点东西\",{\"1\":{\"770\":1}}],[\"改为对于的\",{\"1\":{\"524\":1}}],[\"改善的优化技术现在可被实施\",{\"1\":{\"249\":1}}],[\"置为\",{\"1\":{\"518\":1}}],[\"遍历期间\",{\"1\":{\"532\":1}}],[\"遍历所有元素\",{\"1\":{\"514\":1,\"515\":1}}],[\"遍历文件中的40亿个qq号码\",{\"1\":{\"20\":1}}],[\"删掉\",{\"1\":{\"810\":1}}],[\"删\",{\"1\":{\"512\":1,\"518\":1,\"526\":1,\"813\":1}}],[\"删除主键为\",{\"1\":{\"999\":1}}],[\"删除记录\",{\"1\":{\"999\":1}}],[\"删除记录的时候\",{\"1\":{\"770\":1}}],[\"删除redis却失败\",{\"1\":{\"930\":1}}],[\"删除角色\",{\"1\":{\"851\":1}}],[\"删除后并不会影响此会话\",{\"1\":{\"839\":1}}],[\"删除表中数据\",{\"1\":{\"829\":1}}],[\"删除数据库或者表等对象\",{\"1\":{\"829\":1}}],[\"删除数据卷\",{\"0\":{\"111\":1}}],[\"删除tb\",{\"1\":{\"826\":1}}],[\"删除索引\",{\"1\":{\"826\":1}}],[\"删除节点的时候非常复杂\",{\"1\":{\"813\":1}}],[\"删除效率\",{\"1\":{\"813\":1}}],[\"删除\",{\"1\":{\"741\":1,\"810\":3,\"813\":5,\"873\":1,\"930\":1}}],[\"删除等事务性操作\",{\"1\":{\"730\":1}}],[\"删除元素\",{\"1\":{\"514\":1}}],[\"删除资源\",{\"1\":{\"249\":1}}],[\"删除到内核红黑树\",{\"1\":{\"226\":1}}],[\"删除2行\",{\"1\":{\"214\":1}}],[\"删除组\",{\"1\":{\"208\":1}}],[\"删除用户\",{\"0\":{\"839\":1}}],[\"删除用户和家目录\",{\"1\":{\"207\":1}}],[\"删除用户但保留家目录\",{\"1\":{\"207\":1}}],[\"删除前会询问用户是否确认\",{\"1\":{\"202\":1}}],[\"删除文件或目录\",{\"1\":{\"202\":1}}],[\"删除一个空的目录\",{\"1\":{\"201\":1}}],[\"删除一次和多次删除都是把数据删除\",{\"1\":{\"23\":1}}],[\"删除所有容器\",{\"1\":{\"142\":1}}],[\"删除全部容器\",{\"1\":{\"142\":1}}],[\"删除全部的镜像\",{\"1\":{\"137\":1}}],[\"删除容器\",{\"0\":{\"142\":1},\"1\":{\"142\":1}}],[\"删除多个镜像\",{\"1\":{\"137\":1}}],[\"删除指定的镜像\",{\"1\":{\"137\":1}}],[\"删除镜像\",{\"0\":{\"137\":1}}],[\"删除新元素\",{\"1\":{\"52\":1}}],[\"删除key\",{\"1\":{\"23\":1}}],[\"删除某个资源多次结果一致\",{\"1\":{\"23\":1}}],[\"删除操作的场景\",{\"1\":{\"64\":1}}],[\"删除操作\",{\"1\":{\"23\":2,\"820\":1}}],[\"盲点\",{\"0\":{\"511\":1}}],[\"报错\",{\"1\":{\"510\":1}}],[\"报文格式\",{\"1\":{\"249\":1}}],[\"报文分配时间戳数值\",{\"1\":{\"237\":1}}],[\"统一写\",{\"1\":{\"810\":1}}],[\"统一写入\",{\"1\":{\"737\":1,\"759\":1}}],[\"统一资源名称\",{\"1\":{\"249\":1}}],[\"统一资源定位符\",{\"1\":{\"249\":1}}],[\"统一资源标识符\",{\"1\":{\"249\":1}}],[\"统计信息收集\",{\"1\":{\"804\":1}}],[\"统计分析\",{\"1\":{\"612\":1,\"615\":1}}],[\"统计子串出现次数\",{\"1\":{\"497\":1}}],[\"蓝球\",{\"1\":{\"489\":1}}],[\"匿名嵌套\",{\"1\":{\"490\":1}}],[\"匿名嵌套profile时序列化后的json串为单层的\",{\"1\":{\"489\":1}}],[\"匿名字段的方法可以被外部结构体重写\",{\"1\":{\"464\":1}}],[\"篮球\",{\"1\":{\"489\":4}}],[\"足球\",{\"1\":{\"489\":5}}],[\"说白了\",{\"1\":{\"927\":1,\"952\":1}}],[\"说白了就是指\",{\"1\":{\"813\":1}}],[\"说不定厂子都要倒闭了\",{\"1\":{\"927\":1}}],[\"说是在解析器做的\",{\"1\":{\"817\":1}}],[\"说句题外话\",{\"1\":{\"488\":1}}],[\"说明了使用的bcrypt的版本\",{\"1\":{\"1056\":1}}],[\"说明再往前走\",{\"1\":{\"879\":1}}],[\"说明空间非常紧张\",{\"1\":{\"864\":1}}],[\"说明是\",{\"1\":{\"820\":3}}],[\"说明使用了索引下推\",{\"1\":{\"817\":1}}],[\"说明查询使用了索引\",{\"1\":{\"807\":1}}],[\"说明我们的推论是正确的\",{\"1\":{\"770\":1}}],[\"说明遍历\",{\"1\":{\"453\":1}}],[\"说明服务端主动关闭了连接\",{\"1\":{\"237\":1}}],[\"说明系统删除某些文件失败\",{\"1\":{\"223\":1}}],[\"说明\",{\"1\":{\"122\":1,\"138\":1,\"810\":2,\"864\":1}}],[\"`header\",{\"1\":{\"1043\":3}}],[\"`uri\",{\"1\":{\"1040\":2}}],[\"`form\",{\"1\":{\"1039\":2,\"1041\":2}}],[\"``\",{\"1\":{\"838\":1}}],[\"`json\",{\"1\":{\"485\":1,\"486\":2,\"487\":3,\"488\":3,\"489\":17,\"490\":3,\"491\":2,\"1013\":3,\"1021\":3,\"1042\":2}}],[\"`\",{\"1\":{\"484\":1,\"485\":1,\"486\":2,\"487\":3,\"488\":3,\"489\":17,\"490\":3,\"491\":4,\"1013\":3,\"1021\":3,\"1039\":2,\"1040\":2,\"1041\":2,\"1042\":2,\"1043\":3}}],[\"`key1\",{\"1\":{\"484\":1}}],[\"点原因\",{\"1\":{\"888\":1}}],[\"点\",{\"1\":{\"479\":1}}],[\"点击图片可查看完整电子表格\",{\"1\":{\"229\":1,\"249\":5,\"817\":1,\"858\":1}}],[\"点击了支付按钮进行扣款\",{\"1\":{\"23\":1}}],[\"迟迟没有recover\",{\"1\":{\"479\":1}}],[\"捕获后当前函数体的剩余代码不再执行\",{\"1\":{\"479\":1}}],[\"捕获异常\",{\"1\":{\"478\":1}}],[\"捕获\",{\"1\":{\"478\":1,\"479\":1,\"509\":1}}],[\"捕获方式\",{\"0\":{\"478\":1}}],[\"配合查询可以在\",{\"1\":{\"876\":1}}],[\"配合场景\",{\"1\":{\"753\":1}}],[\"配合\",{\"0\":{\"475\":1},\"1\":{\"709\":1}}],[\"配置静态文件\",{\"0\":{\"1033\":1}}],[\"配置连接选项\",{\"0\":{\"977\":1}}],[\"配置连接池参数\",{\"1\":{\"640\":1}}],[\"配置指定的位置中\",{\"1\":{\"957\":1}}],[\"配置日志分别输出到标准输出和\",{\"1\":{\"957\":1}}],[\"配置日志输出位置\",{\"1\":{\"957\":1}}],[\"配置语法是\",{\"1\":{\"952\":1}}],[\"配置文件\",{\"1\":{\"949\":1,\"966\":1}}],[\"配置一样的最大连接数可以吗\",{\"1\":{\"807\":1}}],[\"配置信息等\",{\"1\":{\"615\":1}}],[\"配置外部化\",{\"1\":{\"605\":1}}],[\"配置web\",{\"0\":{\"588\":1,\"627\":1,\"658\":1}}],[\"配置简单\",{\"1\":{\"246\":2}}],[\"配置自己的\",{\"1\":{\"122\":2,\"125\":1}}],[\"配置\",{\"0\":{\"1\":1,\"2\":1},\"1\":{\"122\":2,\"126\":1,\"766\":1,\"810\":2,\"900\":1},\"2\":{\"15\":1,\"481\":1}}],[\"嵌套字段前缀\",{\"1\":{\"983\":1}}],[\"嵌套字段\",{\"1\":{\"983\":1}}],[\"嵌套接口\",{\"1\":{\"471\":1}}],[\"嵌入\",{\"1\":{\"462\":2}}],[\"⚠️如果一个用户已经建立了连接\",{\"1\":{\"817\":1}}],[\"⚠️注意\",{\"1\":{\"469\":1}}],[\"⚠️\",{\"1\":{\"461\":1}}],[\"⚠️值列表的个数必须\",{\"1\":{\"448\":1}}],[\"零值\",{\"1\":{\"459\":1}}],[\"普通的\",{\"1\":{\"820\":3}}],[\"普通索引\",{\"1\":{\"813\":1,\"817\":1}}],[\"普通\",{\"1\":{\"743\":1,\"783\":1,\"810\":2,\"820\":1}}],[\"普通指针常用于引用变量\",{\"1\":{\"459\":1}}],[\"普通指针特性\",{\"0\":{\"459\":1}}],[\"普通用户需要授权才能访问\",{\"1\":{\"223\":1}}],[\"叫\",{\"1\":{\"456\":1,\"888\":1}}],[\"映射\",{\"1\":{\"456\":1}}],[\"映射到指定地址的任意端口\",{\"1\":{\"117\":1}}],[\"映射到指定地址的指定端口\",{\"1\":{\"117\":1}}],[\"循环等待\",{\"1\":{\"820\":1}}],[\"循环\",{\"1\":{\"817\":2}}],[\"循环写\",{\"1\":{\"757\":1,\"810\":1}}],[\"循环写重做日志文件组是以\",{\"1\":{\"757\":1}}],[\"循环迭代的是切片在迭代开始时的状态\",{\"1\":{\"453\":1}}],[\"循环在开始前就已经确定了切片的长度\",{\"1\":{\"453\":1}}],[\"循环会在完成遍历原本切片长度后停止\",{\"1\":{\"453\":1}}],[\"循环终止问题\",{\"1\":{\"453\":1}}],[\"循环控制条件\",{\"1\":{\"451\":1}}],[\"怎么开启\",{\"1\":{\"949\":1,\"952\":1}}],[\"怎么做\",{\"1\":{\"930\":1}}],[\"怎么高并发\",{\"1\":{\"927\":1}}],[\"怎么选择淘汰算法\",{\"1\":{\"900\":1}}],[\"怎么解决呢\",{\"1\":{\"927\":1}}],[\"怎么解决\",{\"1\":{\"888\":1}}],[\"怎么设置过期时间\",{\"1\":{\"882\":1}}],[\"怎么办\",{\"1\":{\"867\":1}}],[\"怎么加行级锁\",{\"1\":{\"820\":1}}],[\"怎么优化\",{\"1\":{\"813\":2}}],[\"怎么建立联合索引\",{\"1\":{\"813\":1}}],[\"怎么处理\",{\"1\":{\"770\":1}}],[\"怎么实现\",{\"1\":{\"453\":1,\"462\":1}}],[\"怎么判断两个浮点数相等\",{\"1\":{\"33\":1}}],[\"坑\",{\"1\":{\"453\":2}}],[\"陷阱\",{\"0\":{\"453\":1},\"1\":{\"813\":4}}],[\"覆盖索引是一种特殊的索引覆盖情况\",{\"1\":{\"813\":1}}],[\"覆盖索引可以显著减少数据访问次数\",{\"1\":{\"807\":1}}],[\"覆盖索引\",{\"1\":{\"807\":1,\"813\":1}}],[\"覆盖写入\",{\"1\":{\"452\":1}}],[\"覆盖网络\",{\"1\":{\"122\":1}}],[\"格式下只会记录一个\",{\"1\":{\"810\":1}}],[\"格式都有一个\",{\"1\":{\"810\":1}}],[\"格式\",{\"1\":{\"469\":1,\"752\":1,\"810\":1}}],[\"格式可以对\",{\"1\":{\"452\":1}}],[\"格式定义的\",{\"1\":{\"229\":1}}],[\"属性需要\",{\"1\":{\"879\":1}}],[\"属性只需要用\",{\"1\":{\"879\":1}}],[\"属性\",{\"1\":{\"873\":1,\"957\":1}}],[\"属性实现的\",{\"1\":{\"820\":1}}],[\"属性替换\",{\"1\":{\"634\":1,\"635\":1}}],[\"属性移除\",{\"1\":{\"634\":1,\"635\":1}}],[\"属性添加\",{\"1\":{\"634\":1,\"635\":1}}],[\"属性监听器\",{\"0\":{\"632\":1}}],[\"属性监控\",{\"1\":{\"615\":1}}],[\"属性变更监控\",{\"1\":{\"614\":1}}],[\"属性变更等\",{\"1\":{\"612\":1}}],[\"属性顺序\",{\"1\":{\"448\":1}}],[\"属于一种折中方案吧\",{\"1\":{\"949\":1}}],[\"属于一种渐进式兜底策略\",{\"1\":{\"882\":1}}],[\"属于比较底层的数据结构\",{\"1\":{\"867\":1}}],[\"属于行级别锁\",{\"1\":{\"820\":1}}],[\"属于\",{\"1\":{\"747\":1}}],[\"属于哪一层\",{\"1\":{\"747\":1}}],[\"属于读一条记录的过程\",{\"1\":{\"734\":1}}],[\"属于非法操作\",{\"1\":{\"573\":1}}],[\"属于文本插入替换\",{\"1\":{\"33\":1}}],[\"算术异常\",{\"1\":{\"540\":1}}],[\"算术运算符\",{\"1\":{\"442\":1}}],[\"算法在现有的数据结构基础上采用随机取样的方式来淘汰元素\",{\"1\":{\"906\":1}}],[\"算法优化\",{\"1\":{\"906\":1}}],[\"算法原理\",{\"2\":{\"905\":1,\"908\":1}}],[\"算法获取该证书的\",{\"1\":{\"240\":1,\"249\":1}}],[\"算法\",{\"0\":{\"39\":1},\"1\":{\"249\":1,\"727\":1},\"2\":{\"21\":1,\"47\":1,\"48\":1,\"56\":1,\"66\":1,\"83\":1,\"84\":1,\"89\":1,\"90\":1,\"93\":1}}],[\"运维\",{\"2\":{\"857\":1}}],[\"运算符优先级\",{\"0\":{\"445\":1}}],[\"运算符大体上也分为以下几种\",{\"1\":{\"442\":1}}],[\"运行项目\",{\"0\":{\"966\":1},\"1\":{\"966\":1,\"970\":1}}],[\"运行完\",{\"1\":{\"378\":1}}],[\"运行一个容器并加入到\",{\"1\":{\"119\":1}}],[\"运行\",{\"1\":{\"98\":1}}],[\"运行时异常\",{\"1\":{\"538\":1}}],[\"运行时调用了runtime\",{\"1\":{\"264\":1}}],[\"运行时分配\",{\"1\":{\"33\":1}}],[\"运行时不存在函数调用\",{\"1\":{\"33\":1}}],[\"浮点数\",{\"1\":{\"873\":1}}],[\"浮点数不能用\",{\"1\":{\"33\":1}}],[\"浮点型数据\",{\"1\":{\"885\":1}}],[\"浮点型\",{\"1\":{\"440\":1}}],[\"布隆\",{\"1\":{\"930\":1}}],[\"布隆过滤器优缺点都很明显\",{\"1\":{\"930\":1}}],[\"布隆过滤器底层是一个64位的整型\",{\"1\":{\"930\":1}}],[\"布隆过滤器原理\",{\"1\":{\"930\":1}}],[\"布隆过滤器是一种比较巧妙的概率型数据结构\",{\"1\":{\"930\":1}}],[\"布隆过滤器的关键就在于hash算法和容器大小\",{\"1\":{\"930\":1}}],[\"布隆过滤器\",{\"1\":{\"20\":1,\"930\":2}}],[\"布尔型\",{\"1\":{\"440\":1}}],[\"局部到全景\",{\"1\":{\"936\":1}}],[\"局部变量则存在于栈内存\",{\"1\":{\"571\":1}}],[\"局部变量周期是函数存活时间\",{\"1\":{\"439\":1}}],[\"局部变量\",{\"1\":{\"439\":1,\"689\":1}}],[\"局部静态变量\",{\"1\":{\"33\":1}}],[\"声明方法可能抛出ioexception\",{\"1\":{\"542\":1}}],[\"声明格式\",{\"1\":{\"437\":1}}],[\"声明变量\",{\"1\":{\"436\":1}}],[\"声明变量格式\",{\"1\":{\"435\":1}}],[\"声明客户端套接字\",{\"1\":{\"226\":1}}],[\"首个字符不能是数字\",{\"1\":{\"435\":1}}],[\"首先确认产品上对延迟性的要求\",{\"1\":{\"930\":1}}],[\"首先要记录相应的\",{\"1\":{\"810\":4}}],[\"首先会记录相应的\",{\"1\":{\"753\":1}}],[\"首先读取\",{\"1\":{\"529\":1}}],[\"首先来看几种结构体嵌套的示例\",{\"1\":{\"489\":1}}],[\"首先经过扫描器\",{\"1\":{\"395\":1}}],[\"首先获取sudog\",{\"1\":{\"264\":1}}],[\"首先明确一点\",{\"1\":{\"249\":1}}],[\"首先客户端会使用同样的\",{\"1\":{\"240\":1,\"249\":1}}],[\"首先\",{\"1\":{\"240\":1,\"249\":1,\"405\":1,\"521\":1,\"820\":1,\"840\":1}}],[\"隐式锁就是在\",{\"1\":{\"820\":1}}],[\"隐式锁是\",{\"1\":{\"820\":1}}],[\"隐式锁\",{\"1\":{\"820\":3}}],[\"隐式开启事务\",{\"1\":{\"810\":2}}],[\"隐式返回命名的返回值\",{\"1\":{\"427\":2}}],[\"隐藏列来作为\",{\"1\":{\"820\":1}}],[\"隐藏列的值就变成了事务\",{\"1\":{\"793\":1}}],[\"隐藏列里\",{\"1\":{\"788\":1}}],[\"隐藏列不止两个\",{\"1\":{\"788\":1}}],[\"隐藏字段所占字节\",{\"1\":{\"770\":1}}],[\"隐藏字段\",{\"1\":{\"770\":1}}],[\"隐藏字段了\",{\"1\":{\"770\":1}}],[\"隐藏\",{\"1\":{\"33\":1}}],[\"隐藏的区别\",{\"1\":{\"33\":1}}],[\"汇编实现分析\",{\"0\":{\"423\":1}}],[\"尽管\",{\"1\":{\"820\":2}}],[\"尽管在能符合分配到栈的场景\",{\"1\":{\"408\":1}}],[\"尽量使用联合索引代替单值索引\",{\"1\":{\"813\":1}}],[\"尽量使用最简单的类型代替复杂的类型\",{\"1\":{\"807\":1}}],[\"尽量建立前缀索引\",{\"1\":{\"807\":1}}],[\"尽量避免索引字段值为null\",{\"1\":{\"807\":1}}],[\"尽量避免深分页的情况出现\",{\"1\":{\"807\":1}}],[\"尽量在\",{\"1\":{\"807\":1}}],[\"尽量在栈上分配内存\",{\"1\":{\"405\":1}}],[\"尽量将大事务拆分为小事务执行\",{\"1\":{\"807\":1}}],[\"尽量用\",{\"1\":{\"526\":1}}],[\"尽量的挡住\",{\"1\":{\"518\":1}}],[\"逃到堆上\",{\"1\":{\"407\":1}}],[\"逃逸到了堆\",{\"1\":{\"410\":1}}],[\"逃逸情景\",{\"0\":{\"408\":1}}],[\"逃逸过程\",{\"0\":{\"406\":1}}],[\"逃逸是什么\",{\"0\":{\"404\":1}}],[\"逃逸分析\",{\"0\":{\"399\":1}}],[\"禁用堆栈跟踪捕获\",{\"1\":{\"957\":1}}],[\"禁用调用信息\",{\"1\":{\"957\":1}}],[\"禁用函数内联和优化\",{\"1\":{\"398\":1}}],[\"禁用优化\",{\"1\":{\"392\":1}}],[\"扫描到终止范围查询的记录时\",{\"1\":{\"820\":3}}],[\"扫描的行数和返回的行数\",{\"1\":{\"807\":1}}],[\"扫描叶子节点\",{\"1\":{\"770\":1}}],[\"扫描器会对源码进行词法分析\",{\"1\":{\"395\":1}}],[\"扫描器\",{\"1\":{\"394\":1}}],[\"扫描时是线性扫描\",{\"1\":{\"226\":2}}],[\"展示完整的文件路径\",{\"1\":{\"392\":1}}],[\"销毁临时表\",{\"1\":{\"807\":1}}],[\"销毁servlet\",{\"1\":{\"664\":1}}],[\"销毁和属性变更等\",{\"1\":{\"614\":1}}],[\"销毁阶段\",{\"0\":{\"592\":1},\"1\":{\"629\":1,\"630\":1,\"631\":1}}],[\"销毁中\",{\"1\":{\"584\":1,\"592\":1}}],[\"销毁\",{\"1\":{\"381\":1,\"612\":1,\"662\":1}}],[\"废弃的调度器模型\",{\"0\":{\"381\":1}}],[\"详细分析看\",{\"1\":{\"452\":1}}],[\"详细如下\",{\"1\":{\"374\":1}}],[\"详细介绍docker的常用命令\",{\"1\":{\"130\":1}}],[\"哦哦哦\",{\"1\":{\"374\":1}}],[\"岂不是八股错了\",{\"1\":{\"374\":1}}],[\"回来\",{\"1\":{\"918\":1,\"921\":1}}],[\"回来调度\",{\"1\":{\"374\":1}}],[\"回到前面死锁的例子\",{\"1\":{\"820\":1}}],[\"回表操作\",{\"1\":{\"813\":1}}],[\"回表\",{\"1\":{\"813\":4}}],[\"回滚事务\",{\"1\":{\"810\":1,\"1015\":1}}],[\"回滚段\",{\"1\":{\"770\":1}}],[\"回滚日志\",{\"0\":{\"738\":1},\"1\":{\"737\":1,\"775\":1,\"802\":1,\"810\":3}}],[\"回答没有准备好\",{\"1\":{\"764\":1,\"810\":1}}],[\"回答\",{\"1\":{\"760\":2,\"783\":1}}],[\"回放\",{\"1\":{\"730\":1,\"761\":1,\"810\":2}}],[\"回顾一下\",{\"1\":{\"903\":1}}],[\"回顾\",{\"0\":{\"526\":1},\"1\":{\"924\":1}}],[\"回收代价比较小\",{\"1\":{\"405\":1}}],[\"回想八股\",{\"1\":{\"374\":1}}],[\"回环网络\",{\"1\":{\"126\":1}}],[\"突然加了一个大于\",{\"1\":{\"879\":1}}],[\"突然宕机了\",{\"1\":{\"763\":2,\"810\":2}}],[\"突然又调度了一下\",{\"1\":{\"374\":1}}],[\"突破了\",{\"1\":{\"226\":1}}],[\"依然可以继续处理操作命令\",{\"1\":{\"952\":1}}],[\"依靠\",{\"1\":{\"945\":1}}],[\"依靠jvm实现\",{\"1\":{\"564\":1}}],[\"依旧是泥牛入海\",{\"1\":{\"911\":1,\"921\":1}}],[\"依旧会频繁宕机\",{\"1\":{\"807\":1}}],[\"依赖的第三方proto\",{\"1\":{\"962\":1}}],[\"依赖的是不同的\",{\"1\":{\"520\":1}}],[\"依赖注入示例\",{\"0\":{\"699\":1}}],[\"依赖注入\",{\"1\":{\"698\":1},\"2\":{\"702\":1}}],[\"依次调度\",{\"1\":{\"374\":1}}],[\"依据\",{\"1\":{\"243\":1,\"813\":1}}],[\"却不能保证两者的提交顺序一致\",{\"1\":{\"766\":1,\"810\":1}}],[\"却是最先被调度\",{\"1\":{\"373\":1}}],[\"却想为分区创建2个副本\",{\"1\":{\"177\":1}}],[\"扩容时使用\",{\"1\":{\"942\":1}}],[\"扩容时启用ht\",{\"1\":{\"942\":1}}],[\"扩容时机\",{\"1\":{\"864\":1}}],[\"扩容后\",{\"1\":{\"864\":1}}],[\"扩容过程\",{\"1\":{\"864\":1}}],[\"扩容\",{\"1\":{\"864\":2}}],[\"扩容规则\",{\"0\":{\"345\":1}}],[\"扩容示例\",{\"0\":{\"344\":1}}],[\"扩展参数\",{\"1\":{\"873\":1}}],[\"扩展为表上的所有列\",{\"1\":{\"817\":1}}],[\"扩展思路\",{\"1\":{\"723\":1}}],[\"扩展名匹配\",{\"1\":{\"587\":1,\"655\":1,\"656\":1}}],[\"扩展名替换为\",{\"1\":{\"229\":1}}],[\"扩展方法\",{\"1\":{\"249\":1}}],[\"追加到新的aof文件\",{\"1\":{\"952\":1}}],[\"追加字符串需要重新分配内存\",{\"1\":{\"873\":1}}],[\"追加元素时\",{\"1\":{\"337\":1}}],[\"追上了\",{\"1\":{\"810\":1}}],[\"追踪请求\",{\"1\":{\"249\":1}}],[\"键值的内存释放函数\",{\"1\":{\"942\":1}}],[\"键值对初始化\",{\"0\":{\"447\":1}}],[\"键值对\",{\"1\":{\"937\":1},\"2\":{\"335\":1}}],[\"键不会被重复访问\",{\"1\":{\"532\":1}}],[\"键与值使用冒号分隔\",{\"1\":{\"484\":1}}],[\"键盘等等设备也都可以在这里找到\",{\"1\":{\"223\":1}}],[\"低\",{\"1\":{\"903\":2}}],[\"低位\",{\"1\":{\"330\":1}}],[\"低地址\",{\"1\":{\"217\":1,\"423\":1}}],[\"桶\",{\"1\":{\"328\":1}}],[\"拉链法通过链表结构来解决哈希冲突\",{\"1\":{\"322\":1}}],[\"拉链法\",{\"0\":{\"322\":1},\"1\":{\"864\":1}}],[\"拉取某些资源到本地\",{\"1\":{\"249\":1}}],[\"超时\",{\"0\":{\"912\":1},\"1\":{\"921\":1}}],[\"超时控制\",{\"2\":{\"285\":1}}],[\"超过64m的情况下\",{\"1\":{\"952\":1}}],[\"超过就会使用\",{\"1\":{\"879\":1}}],[\"超过这个值\",{\"1\":{\"817\":1}}],[\"超级filter\",{\"1\":{\"605\":1}}],[\"超级用户都可以访问系统中的任何文件\",{\"1\":{\"190\":1}}],[\"超级用户账号的用户\",{\"1\":{\"190\":1}}],[\"超级用户在系统中享有特权\",{\"1\":{\"190\":1}}],[\"超级用户\",{\"1\":{\"190\":1}}],[\"切片完全复制\",{\"0\":{\"346\":1}}],[\"切片扩容机制\",{\"0\":{\"343\":1}}],[\"切片复制\",{\"0\":{\"342\":1}}],[\"切片截取遵循左闭右开原则\",{\"1\":{\"341\":1}}],[\"切片截取\",{\"0\":{\"341\":1}}],[\"切片可以通过多种方式进行初始化\",{\"1\":{\"340\":1}}],[\"切片初始化\",{\"0\":{\"340\":1}}],[\"切片操作\",{\"0\":{\"339\":1}}],[\"切片在go语言中由三部分组成\",{\"1\":{\"338\":1}}],[\"切片的数据结构\",{\"0\":{\"338\":1}}],[\"切片\",{\"1\":{\"337\":1,\"436\":1,\"456\":1},\"2\":{\"348\":1}}],[\"切片基本概念\",{\"0\":{\"337\":1}}],[\"切走\",{\"1\":{\"265\":1}}],[\"切换到\",{\"1\":{\"641\":1}}],[\"切换出来\",{\"1\":{\"374\":1}}],[\"切换账号\",{\"1\":{\"205\":1}}],[\"切换目录\",{\"1\":{\"201\":1}}],[\"入\",{\"1\":{\"810\":1}}],[\"入队列\",{\"1\":{\"265\":1}}],[\"入参是\",{\"1\":{\"229\":1}}],[\"递增索引\",{\"1\":{\"265\":2}}],[\"递归删除整个文件夹\",{\"1\":{\"209\":1}}],[\"递归删除\",{\"1\":{\"202\":1}}],[\"流量削峰\",{\"1\":{\"924\":1}}],[\"流量优化示意图\",{\"1\":{\"715\":1}}],[\"流量优化\",{\"0\":{\"715\":1}}],[\"流量型\",{\"1\":{\"243\":2}}],[\"流量型攻击\",{\"1\":{\"243\":1}}],[\"流转来的\",{\"1\":{\"525\":1}}],[\"流程图\",{\"1\":{\"264\":1,\"910\":1,\"911\":1,\"921\":2,\"952\":1}}],[\"若mysql中先执行第\",{\"1\":{\"930\":1}}],[\"若行数据发生了变化\",{\"1\":{\"813\":1}}],[\"若设置了参数\",{\"1\":{\"770\":1}}],[\"若找到\",{\"1\":{\"529\":1}}],[\"若连\",{\"1\":{\"529\":1}}],[\"若在\",{\"1\":{\"529\":1}}],[\"若在当前的函数体没有recover\",{\"1\":{\"479\":1}}],[\"若\",{\"1\":{\"529\":2}}],[\"若希望从某个case开始按顺序往下执行\",{\"1\":{\"450\":1}}],[\"若sendx等于dataqsiz\",{\"1\":{\"264\":1}}],[\"若为\",{\"1\":{\"20\":1}}],[\"缓冲区\",{\"1\":{\"807\":1}}],[\"缓冲池\",{\"0\":{\"746\":1},\"1\":{\"810\":1}}],[\"缓冲发送\",{\"1\":{\"264\":2}}],[\"缓存用\",{\"1\":{\"930\":1}}],[\"缓存一致性问题是什么\",{\"1\":{\"930\":1}}],[\"缓存一致性\",{\"1\":{\"930\":1}}],[\"缓存数据的过期时间设置随机\",{\"1\":{\"930\":1}}],[\"缓存中数据大批量到过期时间\",{\"1\":{\"930\":1}}],[\"缓存雪崩是一大批数据在redis同时失效\",{\"1\":{\"930\":1}}],[\"缓存雪崩\",{\"1\":{\"930\":2}}],[\"缓存击穿指一条热点数据在redis没得到及时重建\",{\"1\":{\"930\":1}}],[\"缓存击穿不也可以算\",{\"1\":{\"930\":1}}],[\"缓存击穿是指缓存中没有但数据库中有的数据\",{\"1\":{\"930\":1}}],[\"缓存击穿\",{\"1\":{\"930\":2}}],[\"缓存有效时间可以设置短点\",{\"1\":{\"930\":1}}],[\"缓存穿透\",{\"1\":{\"930\":2}}],[\"缓存异常场景\",{\"1\":{\"930\":1}}],[\"缓存的几种模式\",{\"1\":{\"930\":1}}],[\"缓存的值时\",{\"1\":{\"906\":1}}],[\"缓存分为服务器端缓存\",{\"1\":{\"930\":1}}],[\"缓存了\",{\"1\":{\"906\":1}}],[\"缓存场景\",{\"1\":{\"900\":1,\"930\":1}}],[\"缓存对象\",{\"1\":{\"873\":1}}],[\"缓存提升性能\",{\"1\":{\"873\":1}}],[\"缓存很鸡肋\",{\"1\":{\"817\":1}}],[\"缓存在操作系统的文件系统中\",{\"1\":{\"810\":1}}],[\"缓存在\",{\"1\":{\"810\":2}}],[\"缓存\",{\"1\":{\"807\":1,\"817\":1,\"882\":1,\"930\":1},\"2\":{\"932\":1}}],[\"缓存什么\",{\"0\":{\"748\":1},\"1\":{\"810\":1}}],[\"缓存处理\",{\"1\":{\"734\":1}}],[\"缓存里面\",{\"1\":{\"730\":1}}],[\"缓存控制\",{\"1\":{\"579\":1}}],[\"缓存技术\",{\"1\":{\"249\":1}}],[\"缓存投毒\",{\"1\":{\"243\":1}}],[\"异步将mysql的更新同步到redis\",{\"1\":{\"930\":2}}],[\"异步缓存写入模式\",{\"1\":{\"930\":1}}],[\"异步处理\",{\"2\":{\"926\":1}}],[\"异步复制\",{\"1\":{\"810\":1}}],[\"异步\",{\"1\":{\"810\":1,\"927\":2}}],[\"异步模式\",{\"1\":{\"730\":2,\"761\":2}}],[\"异步i\",{\"1\":{\"226\":1}}],[\"异步io\",{\"1\":{\"226\":1}}],[\"异步io模型\",{\"1\":{\"226\":1}}],[\"异常重启会出现什么现象\",{\"1\":{\"810\":2}}],[\"异常重启之后数据不会丢失\",{\"1\":{\"756\":1,\"810\":1}}],[\"异常处理\",{\"1\":{\"564\":1},\"2\":{\"548\":1}}],[\"异常处理机制\",{\"0\":{\"539\":1}}],[\"异常基类\",{\"1\":{\"538\":1}}],[\"异常基础\",{\"0\":{\"536\":1}}],[\"异常的分类\",{\"0\":{\"538\":1}}],[\"异常的概念\",{\"0\":{\"537\":1}}],[\"异常是一个事件\",{\"1\":{\"537\":1}}],[\"异常是程序运行过程中出现的非正常情况\",{\"1\":{\"536\":1}}],[\"异常\",{\"1\":{\"249\":1,\"478\":1}}],[\"全景图的\",{\"1\":{\"945\":1}}],[\"全面讲解\",{\"1\":{\"930\":1}}],[\"全\",{\"1\":{\"879\":1}}],[\"全库逻辑备份\",{\"1\":{\"820\":1}}],[\"全表扫描\",{\"1\":{\"817\":3}}],[\"全表扫描或索引扫描\",{\"1\":{\"734\":1}}],[\"全盘扫描\",{\"1\":{\"817\":1}}],[\"全权负责整队的操作\",{\"1\":{\"810\":1}}],[\"全部写满就从头开始\",{\"1\":{\"810\":1}}],[\"全部调度完了\",{\"1\":{\"374\":1}}],[\"全文索引最大的硬伤在于对中文支持不够友好\",{\"1\":{\"813\":1}}],[\"全文索引陷阱\",{\"1\":{\"813\":1}}],[\"全文索引\",{\"1\":{\"803\":1,\"813\":1}}],[\"全拿\",{\"1\":{\"374\":1}}],[\"全连接\",{\"1\":{\"249\":1}}],[\"全局级别\",{\"1\":{\"847\":1}}],[\"全局锁的缺点\",{\"1\":{\"820\":1}}],[\"全局锁主要应用于做\",{\"1\":{\"820\":1}}],[\"全局锁应用场景\",{\"1\":{\"820\":1}}],[\"全局锁会被自动释放\",{\"1\":{\"820\":1}}],[\"全局锁用法\",{\"1\":{\"820\":1}}],[\"全局锁\",{\"1\":{\"820\":3}}],[\"全局有序性\",{\"1\":{\"813\":1}}],[\"全局\",{\"1\":{\"727\":1}}],[\"全局过滤器\",{\"1\":{\"587\":1}}],[\"全局变量\",{\"1\":{\"33\":1,\"439\":1}}],[\"全局唯一id可用\",{\"1\":{\"23\":1}}],[\"拆包\",{\"1\":{\"249\":1}}],[\"粘包\",{\"1\":{\"249\":1}}],[\"验证码符合91原则\",{\"1\":{\"927\":1}}],[\"验证web\",{\"1\":{\"607\":1}}],[\"验证所有用户输入\",{\"1\":{\"604\":1}}],[\"验证逻辑\",{\"1\":{\"596\":1}}],[\"验证用户身份\",{\"1\":{\"579\":1,\"596\":1}}],[\"验证并发安全\",{\"0\":{\"515\":1}}],[\"验证加密通信\",{\"1\":{\"249\":1}}],[\"验证流程\",{\"1\":{\"249\":1}}],[\"至少有\",{\"1\":{\"952\":4}}],[\"至少调用\",{\"1\":{\"810\":1}}],[\"至少还有一个从库有最新的数据\",{\"1\":{\"810\":1}}],[\"至少一次\",{\"1\":{\"705\":1}}],[\"至少在两种不同状态下运行\",{\"1\":{\"220\":1}}],[\"至此\",{\"1\":{\"249\":1,\"810\":4,\"817\":2}}],[\"摘要算法\",{\"1\":{\"249\":2}}],[\"密钥长度\",{\"1\":{\"249\":1}}],[\"密钥交换算法\",{\"1\":{\"249\":1}}],[\"密码加密\",{\"2\":{\"1061\":1}}],[\"密码加密策略\",{\"0\":{\"1050\":1}}],[\"密码使用了盐\",{\"1\":{\"1052\":1}}],[\"密码安全概述\",{\"0\":{\"1047\":1}}],[\"密码\",{\"1\":{\"836\":1,\"976\":1}}],[\"密码套件是\",{\"1\":{\"249\":1}}],[\"密码占位符\",{\"1\":{\"190\":2}}],[\"密码学\",{\"2\":{\"83\":1,\"84\":1}}],[\"出子进程来做全量快照\",{\"1\":{\"952\":1}}],[\"出问题的概率会比较小\",{\"1\":{\"930\":1}}],[\"出了服务端随机数\",{\"1\":{\"249\":1}}],[\"出现了半成功状态\",{\"1\":{\"810\":1}}],[\"出现了前后两次读到的数据不一样的情况\",{\"1\":{\"778\":1}}],[\"出现了指针之间相互指向\",{\"1\":{\"33\":1}}],[\"出现内部碎片\",{\"1\":{\"217\":1}}],[\"出现过以下几种重要的\",{\"1\":{\"190\":1}}],[\"出现的次数\",{\"0\":{\"79\":1}}],[\"出现的第一个位置索引\",{\"1\":{\"43\":1}}],[\"确实无序的随机值\",{\"1\":{\"813\":1}}],[\"确定事务加了什么类型的锁\",{\"1\":{\"820\":2}}],[\"确定事务加了什么锁\",{\"1\":{\"820\":1}}],[\"确定事务\",{\"1\":{\"820\":2}}],[\"确定执行计划\",{\"1\":{\"813\":1}}],[\"确定哈希槽的数量\",{\"1\":{\"723\":1}}],[\"确定哈希函数\",{\"1\":{\"723\":1}}],[\"确定变量是分配在栈上还是堆上\",{\"1\":{\"399\":1}}],[\"确定编译的包列表\",{\"1\":{\"396\":1}}],[\"确认机制\",{\"1\":{\"709\":1}}],[\"确认\",{\"1\":{\"249\":1}}],[\"确保有足够的权限执行这些操作\",{\"1\":{\"835\":1}}],[\"确保有没有收到最后一次挥手\",{\"1\":{\"237\":1}}],[\"确保主键唯一性\",{\"1\":{\"807\":1}}],[\"确保操作的原子性\",{\"1\":{\"714\":1}}],[\"确保操作的唯一性和数据的准确性\",{\"1\":{\"23\":1}}],[\"确保消息至少被处理一次\",{\"1\":{\"711\":1}}],[\"确保消息的可靠接收\",{\"1\":{\"709\":1}}],[\"确保在发送失败时能够重新尝试发送消息\",{\"1\":{\"709\":1}}],[\"确保进行适当的同步处理\",{\"1\":{\"689\":1}}],[\"确保filter类在正确的包中\",{\"1\":{\"607\":1}}],[\"确保代码符合语言规范\",{\"1\":{\"395\":1}}],[\"确保服务的持续性\",{\"1\":{\"176\":1}}],[\"确保同一订单在不同状态下不能重复处理\",{\"1\":{\"23\":1}}],[\"确保特定字段组合的唯一性\",{\"1\":{\"23\":1}}],[\"确保系统在多次重复调用同一个接口时不会产生副作用\",{\"1\":{\"23\":1}}],[\"抓包握手过程\",{\"1\":{\"249\":1}}],[\"公司开源的一款\",{\"1\":{\"955\":1}}],[\"公平对待每一个字符\",{\"1\":{\"873\":1}}],[\"公共构造函数数量\",{\"1\":{\"556\":1}}],[\"公证中心\",{\"1\":{\"249\":1}}],[\"公钥加密该随机数通过\",{\"1\":{\"249\":1}}],[\"公钥加密\",{\"1\":{\"249\":1}}],[\"公钥解密\",{\"1\":{\"249\":1}}],[\"公钥其实是根据私钥生成的\",{\"1\":{\"249\":1}}],[\"公钥\",{\"1\":{\"249\":2}}],[\"持续访问的数据可以不断续期\",{\"1\":{\"930\":1}}],[\"持久化过程\",{\"1\":{\"952\":1}}],[\"持久化后的输出\",{\"1\":{\"952\":1}}],[\"持久化的方式\",{\"1\":{\"952\":1}}],[\"持久化是什么\",{\"1\":{\"952\":1}}],[\"持久化\",{\"1\":{\"952\":4},\"2\":{\"951\":1,\"954\":1}}],[\"持久化到磁盘\",{\"1\":{\"756\":1,\"760\":1,\"765\":2,\"810\":7}}],[\"持久化到磁盘即可\",{\"1\":{\"752\":1,\"810\":1}}],[\"持久性\",{\"1\":{\"774\":1,\"810\":1}}],[\"持久连接\",{\"1\":{\"249\":1}}],[\"持有者信息\",{\"1\":{\"249\":1}}],[\"阮一峰的网络日志\",{\"1\":{\"249\":2}}],[\"场景举例\",{\"1\":{\"765\":1}}],[\"场景\",{\"1\":{\"249\":2,\"265\":2,\"747\":1,\"760\":3,\"885\":2}}],[\"求x\",{\"1\":{\"249\":1}}],[\"^\",{\"1\":{\"249\":1,\"423\":1,\"444\":1,\"446\":3}}],[\"解读与\",{\"1\":{\"952\":1}}],[\"解包\",{\"1\":{\"891\":1}}],[\"解除死锁策略\",{\"1\":{\"820\":1}}],[\"解除绑定\",{\"1\":{\"637\":1}}],[\"解锁用户\",{\"0\":{\"844\":1}}],[\"解锁\",{\"1\":{\"529\":1}}],[\"解释一下表格最后一个\",{\"1\":{\"879\":1}}],[\"解释\",{\"1\":{\"441\":1,\"793\":1}}],[\"解析日志内容\",{\"1\":{\"930\":1}}],[\"解析客户端发送请求\",{\"1\":{\"888\":1}}],[\"解析出\",{\"1\":{\"817\":1}}],[\"解析语句\",{\"1\":{\"734\":1}}],[\"解析编译参数\",{\"1\":{\"396\":1}}],[\"解析器只负责检查语法和构建语法树\",{\"1\":{\"817\":1}}],[\"解析器就会给报错\",{\"1\":{\"817\":1}}],[\"解析器解析\",{\"1\":{\"817\":1}}],[\"解析器会通过词法分析识别出关键字\",{\"1\":{\"810\":1}}],[\"解析器将token流解析为抽象语法树\",{\"1\":{\"395\":1}}],[\"解析器\",{\"1\":{\"394\":1,\"817\":4}}],[\"解析\",{\"1\":{\"344\":1,\"479\":1,\"817\":2,\"897\":1}}],[\"解密后的明文hash值\",{\"1\":{\"249\":1}}],[\"解密过程\",{\"1\":{\"249\":1}}],[\"解决了连锁更新带来的性能瓶颈\",{\"1\":{\"879\":1}}],[\"解决连锁更新\",{\"1\":{\"879\":1}}],[\"解决什么问题\",{\"1\":{\"879\":1}}],[\"解决\",{\"1\":{\"810\":1,\"813\":1,\"924\":1}}],[\"解决幻读的方法\",{\"0\":{\"795\":1}}],[\"解决这个问题也很简单\",{\"1\":{\"770\":1}}],[\"解决方式\",{\"1\":{\"727\":4}}],[\"解决方案的场景\",{\"1\":{\"751\":1}}],[\"解决方案\",{\"1\":{\"20\":1,\"607\":1,\"608\":1,\"609\":1,\"751\":1,\"757\":1,\"930\":3}}],[\"解决哈希冲突的方法\",{\"0\":{\"321\":1}}],[\"解决办法\",{\"1\":{\"243\":2}}],[\"解决单页表的内存占用问题\",{\"1\":{\"217\":1}}],[\"φ\",{\"1\":{\"249\":3}}],[\"私钥签名\",{\"1\":{\"249\":1}}],[\"私钥才能解密\",{\"1\":{\"249\":1}}],[\"私钥加密同理\",{\"1\":{\"249\":1}}],[\"私钥解密\",{\"1\":{\"249\":2}}],[\"私钥\",{\"1\":{\"249\":3}}],[\"随后每次随机选取的\",{\"1\":{\"906\":1}}],[\"随便选两个质数23和61\",{\"1\":{\"249\":1}}],[\"随着业务发展\",{\"1\":{\"897\":1}}],[\"随着字典操作不断\",{\"1\":{\"864\":1}}],[\"随着高度增加\",{\"1\":{\"813\":1}}],[\"随着索引记录变多\",{\"1\":{\"813\":1}}],[\"随着数据插入\",{\"1\":{\"813\":1}}],[\"随着技术的发展\",{\"1\":{\"644\":1}}],[\"随着方法的调用结束而消亡\",{\"1\":{\"571\":1}}],[\"随着\",{\"1\":{\"249\":1}}],[\"随机选取的\",{\"1\":{\"906\":1}}],[\"随机选取两个质数p和q\",{\"1\":{\"249\":1}}],[\"随机采样得到的结果\",{\"1\":{\"906\":1}}],[\"随机采样\",{\"1\":{\"906\":1}}],[\"随机采用\",{\"1\":{\"906\":1}}],[\"随机算法决定的\",{\"1\":{\"885\":1}}],[\"随机写\",{\"1\":{\"810\":5}}],[\"随机写入是指数据写入磁盘的不同位置\",{\"1\":{\"754\":1}}],[\"随机写入\",{\"1\":{\"754\":1}}],[\"随机指定端口\",{\"1\":{\"139\":1}}],[\"随机\",{\"1\":{\"77\":1,\"770\":1}}],[\"拥有一个最新的服务器和新点的浏览器进行交互就足够了\",{\"1\":{\"249\":1}}],[\"移除最接近的过期时间\",{\"1\":{\"900\":1}}],[\"移除任意键\",{\"1\":{\"900\":1}}],[\"移除具有过期时间的随机键\",{\"1\":{\"900\":1}}],[\"移除和替换\",{\"1\":{\"614\":1,\"619\":1,\"620\":1,\"621\":1}}],[\"移除了\",{\"1\":{\"249\":1}}],[\"移动硬盘\",{\"1\":{\"223\":1}}],[\"移动文件\",{\"1\":{\"209\":1}}],[\"移动文件与目录\",{\"1\":{\"202\":1}}],[\"移动函数\",{\"1\":{\"33\":1}}],[\"节省链表指针的开销\",{\"1\":{\"879\":1}}],[\"节省了很多回表操作\",{\"1\":{\"817\":1}}],[\"节省了多次打开\",{\"1\":{\"249\":1}}],[\"节省磁盘资源\",{\"1\":{\"807\":1}}],[\"节点排列是从小到大\",{\"1\":{\"885\":1}}],[\"节点源码\",{\"1\":{\"885\":1}}],[\"节点的分数\",{\"1\":{\"885\":1}}],[\"节点的层高是概率随机的\",{\"1\":{\"885\":1}}],[\"节点的过程\",{\"1\":{\"813\":2}}],[\"节点定义\",{\"1\":{\"879\":1}}],[\"节点结构\",{\"1\":{\"879\":1}}],[\"节点非常多的时候\",{\"1\":{\"867\":1}}],[\"节点之间数据不会同步\",{\"1\":{\"807\":1}}],[\"节点2\",{\"1\":{\"807\":1}}],[\"节点1\",{\"1\":{\"807\":1}}],[\"节点上\",{\"0\":{\"175\":1}}],[\"节点\",{\"0\":{\"173\":1},\"1\":{\"173\":2,\"177\":2,\"879\":2}}],[\"节点和\",{\"0\":{\"173\":1}}],[\"凭借\",{\"1\":{\"249\":2}}],[\"行锁的释放时机是在事务提交\",{\"1\":{\"820\":1}}],[\"行锁\",{\"1\":{\"820\":2}}],[\"行数据\",{\"1\":{\"820\":1}}],[\"行级锁加锁规则比较复杂\",{\"1\":{\"820\":1}}],[\"行级锁的类型主要有三类\",{\"1\":{\"820\":1}}],[\"行级锁\",{\"1\":{\"820\":2}}],[\"行了\",{\"1\":{\"810\":1}}],[\"行溢出后\",{\"1\":{\"770\":1}}],[\"行记录存储方式\",{\"1\":{\"770\":1}}],[\"行格式决定\",{\"1\":{\"770\":1}}],[\"行格式在发生行溢出后的处理\",{\"1\":{\"770\":1}}],[\"行格式把这些值为\",{\"1\":{\"770\":1}}],[\"行格式是\",{\"1\":{\"770\":1}}],[\"行格式默认设置成\",{\"1\":{\"770\":1}}],[\"行格式\",{\"1\":{\"770\":6}}],[\"行格式有哪些\",{\"1\":{\"770\":1}}],[\"行为\",{\"1\":{\"710\":1}}],[\"行\",{\"1\":{\"249\":1,\"770\":4}}],[\"行时\",{\"1\":{\"220\":1}}],[\"构建出语法树\",{\"1\":{\"810\":1}}],[\"构建可扩展性\",{\"1\":{\"249\":1}}],[\"构造函数提供了将日志输出到多个位置的能力\",{\"1\":{\"957\":1}}],[\"构造函数注入\",{\"1\":{\"699\":1}}],[\"构造函数操作\",{\"0\":{\"556\":1}}],[\"构成一个小组\",{\"1\":{\"164\":1}}],[\"头\",{\"1\":{\"249\":1}}],[\"头部字段是\",{\"1\":{\"249\":1}}],[\"头部字段\",{\"1\":{\"249\":1}}],[\"头部字段集合\",{\"1\":{\"249\":1}}],[\"头部压缩\",{\"1\":{\"240\":1}}],[\"头部就会使用时间戳选项\",{\"1\":{\"237\":1}}],[\"跟踪在线用户数量\",{\"1\":{\"615\":1}}],[\"跟后来的版本不同\",{\"1\":{\"249\":1}}],[\"跟硬件和内核版本有关\",{\"1\":{\"217\":1}}],[\"过期时间兜底是行之有效的办法\",{\"1\":{\"930\":1}}],[\"过期时间\",{\"1\":{\"894\":1,\"946\":1}}],[\"过期时间等信息\",{\"1\":{\"249\":1}}],[\"过期键\",{\"1\":{\"894\":1}}],[\"过期策略\",{\"2\":{\"884\":1}}],[\"过期不过期业务都无所谓\",{\"1\":{\"882\":1}}],[\"过期了\",{\"1\":{\"882\":1}}],[\"过期\",{\"1\":{\"882\":1}}],[\"过期多久会被删除\",{\"1\":{\"882\":1}}],[\"过滤完的记录才会回表\",{\"1\":{\"813\":1}}],[\"过滤阶段\",{\"0\":{\"591\":1}}],[\"过滤器用于拦截请求和响应\",{\"1\":{\"683\":1}}],[\"过滤器销毁时调用\",{\"1\":{\"584\":1}}],[\"过滤器初始化时调用\",{\"1\":{\"584\":1}}],[\"过滤器\",{\"0\":{\"683\":1},\"1\":{\"578\":1,\"930\":1}}],[\"过程如下\",{\"1\":{\"817\":1,\"820\":1}}],[\"过程如下图\",{\"1\":{\"740\":1,\"810\":1}}],[\"过程\",{\"1\":{\"813\":1,\"817\":1}}],[\"过程后\",{\"1\":{\"525\":1}}],[\"过程中不加锁\",{\"1\":{\"820\":1}}],[\"过程中加了什么锁\",{\"1\":{\"820\":2}}],[\"过程中\",{\"1\":{\"525\":1}}],[\"过程中也不会执行上层的剩余代码\",{\"1\":{\"479\":1}}],[\"过多如何解决\",{\"1\":{\"237\":1}}],[\"过多的影响也有不同\",{\"1\":{\"237\":1}}],[\"过多的时候\",{\"1\":{\"237\":1}}],[\"过多的危害\",{\"1\":{\"237\":1}}],[\"签名算法\",{\"1\":{\"249\":1}}],[\"签名\",{\"1\":{\"249\":2}}],[\"签名信息\",{\"1\":{\"249\":1}}],[\"签发证书的过程\",{\"1\":{\"240\":1,\"249\":1}}],[\"净荷信息\",{\"1\":{\"249\":1}}],[\"具备封装\",{\"1\":{\"564\":1}}],[\"具备了传输除纯文本\",{\"1\":{\"249\":1}}],[\"具有如下特点\",{\"1\":{\"956\":1}}],[\"具有极高的可信度\",{\"1\":{\"249\":1}}],[\"具有时效性的一种验证身份的手段\",{\"1\":{\"249\":1}}],[\"具体做了什么\",{\"1\":{\"952\":1}}],[\"具体由业务来配置\",{\"1\":{\"930\":1}}],[\"具体步骤\",{\"1\":{\"906\":1}}],[\"具体方式如下\",{\"1\":{\"820\":1}}],[\"具体原因这里可以看这篇\",{\"1\":{\"817\":1}}],[\"具体含义如下\",{\"1\":{\"813\":1}}],[\"具体内容\",{\"1\":{\"813\":1}}],[\"具体怎么做呢\",{\"1\":{\"927\":1}}],[\"具体怎么使用\",{\"1\":{\"813\":1}}],[\"具体怎么存储由存储引擎决定\",{\"1\":{\"770\":1}}],[\"具体更新一条记录\",{\"1\":{\"810\":2}}],[\"具体详细过程如下\",{\"1\":{\"810\":1}}],[\"具体是几个字符\",{\"1\":{\"807\":1}}],[\"具体是怎么保存\",{\"1\":{\"770\":1}}],[\"具体情况分为\",{\"1\":{\"770\":1}}],[\"具体如下\",{\"1\":{\"765\":1,\"810\":1}}],[\"具体细节往下看\",{\"1\":{\"753\":1}}],[\"具体来说\",{\"1\":{\"753\":1}}],[\"具体可以分为两种方式\",{\"1\":{\"727\":1}}],[\"具体而言\",{\"1\":{\"720\":1,\"930\":1}}],[\"具体的每一个操作的\",{\"1\":{\"810\":1}}],[\"具体的配合过程\",{\"1\":{\"753\":1}}],[\"具体的分库和分表规则\",{\"1\":{\"727\":1}}],[\"具体的格式如下\",{\"1\":{\"484\":1}}],[\"具体的生成过程如下\",{\"1\":{\"92\":1}}],[\"具体编译过程\",{\"0\":{\"395\":1}}],[\"具体要看字符串的编码方式\",{\"1\":{\"352\":1}}],[\"具体选择规则我们后面会介绍\",{\"1\":{\"176\":1}}],[\"具体思路\",{\"1\":{\"79\":1}}],[\"具体实现\",{\"1\":{\"20\":1}}],[\"暂且称之为session\",{\"1\":{\"249\":1}}],[\"暂停消费\",{\"1\":{\"165\":1}}],[\"暂停和删除五种状态\",{\"1\":{\"98\":1}}],[\"域\",{\"1\":{\"249\":1}}],[\"工作流程\",{\"1\":{\"864\":1}}],[\"工作正式开始\",{\"1\":{\"864\":1}}],[\"工作原理\",{\"1\":{\"576\":1,\"612\":1}}],[\"工作\",{\"1\":{\"367\":1}}],[\"工作过程\",{\"1\":{\"249\":1}}],[\"工具一般会随着安装\",{\"1\":{\"854\":1}}],[\"工具用于从\",{\"1\":{\"854\":1}}],[\"工具\",{\"1\":{\"854\":3},\"2\":{\"27\":1,\"215\":1}}],[\"硬盘cookie不会被删除\",{\"1\":{\"249\":1}}],[\"硬盘cookie\",{\"1\":{\"249\":1}}],[\"缺失了\",{\"1\":{\"952\":1}}],[\"缺少状态意味着如果后续处理需要前面的信息\",{\"1\":{\"249\":1}}],[\"缺点就是重\",{\"1\":{\"930\":1}}],[\"缺点是结果不是完全准\",{\"1\":{\"930\":1}}],[\"缺点是编程复杂性较高\",{\"1\":{\"226\":1}}],[\"缺点\",{\"1\":{\"226\":2,\"552\":1,\"723\":1,\"873\":1,\"924\":3,\"930\":2}}],[\"队列中\",{\"1\":{\"820\":1}}],[\"队列是有互斥锁进行保护的\",{\"1\":{\"381\":1}}],[\"队列总数自增1\",{\"1\":{\"264\":1}}],[\"队列没满\",{\"1\":{\"257\":1}}],[\"队列里的请求没有轻重缓急的优先级\",{\"1\":{\"249\":1}}],[\"队列\",{\"1\":{\"249\":1,\"381\":1}}],[\"队列的实际长度\",{\"1\":{\"226\":1}}],[\"队头阻塞与短连接和长连接无关\",{\"1\":{\"249\":1}}],[\"队头阻塞\",{\"1\":{\"249\":1}}],[\"均摊到多个\",{\"1\":{\"249\":1}}],[\"昂贵\",{\"1\":{\"249\":1}}],[\"短信通知分区\",{\"1\":{\"722\":1}}],[\"短连接的缺点相当严重\",{\"1\":{\"249\":1}}],[\"短连接\",{\"1\":{\"249\":1,\"817\":1}}],[\"短链接缺点\",{\"1\":{\"249\":1}}],[\"短链接\",{\"1\":{\"249\":2}}],[\"妨碍了服务器的处理\",{\"1\":{\"249\":1}}],[\"绝对url\",{\"1\":{\"249\":1}}],[\"太长容易有较长时间不一致\",{\"1\":{\"930\":1}}],[\"太长\",{\"1\":{\"249\":1}}],[\"拖入浏览器窗口\",{\"1\":{\"249\":1}}],[\"锚点\",{\"1\":{\"249\":1}}],[\"片段标识符\",{\"1\":{\"249\":1}}],[\"👁️2^16\",{\"1\":{\"903\":1}}],[\"📎高性能mysql第三版\",{\"1\":{\"807\":1}}],[\"👇等价👇\",{\"1\":{\"440\":1}}],[\"😕\",{\"1\":{\"249\":1}}],[\"😁😁summary😁😁\",{\"1\":{\"223\":1}}],[\"😁\",{\"1\":{\"223\":18}}],[\"资源的释放\",{\"0\":{\"474\":1}}],[\"资源管理\",{\"2\":{\"296\":1}}],[\"资源位置发生变动\",{\"1\":{\"249\":1}}],[\"资源还是第一次更新的状态\",{\"1\":{\"249\":1}}],[\"资源不存在\",{\"1\":{\"249\":1,\"676\":1}}],[\"既能提升并发性\",{\"1\":{\"820\":1}}],[\"既能访问用户空间内存\",{\"1\":{\"220\":1}}],[\"既然断开连接后就会释放连接占用的内存资源\",{\"1\":{\"817\":1}}],[\"既然是使用函数\",{\"1\":{\"813\":1}}],[\"既然只依靠\",{\"1\":{\"810\":1}}],[\"既然runtime里stirng的定义有stringstruct结构\",{\"1\":{\"354\":1}}],[\"既不存在于\",{\"1\":{\"531\":1}}],[\"既是安全的也是幂等的\",{\"1\":{\"249\":1}}],[\"幂\",{\"1\":{\"249\":1}}],[\"幂等\",{\"1\":{\"249\":2}}],[\"幂等性\",{\"2\":{\"25\":1}}],[\"幂等性常见解决方案\",{\"1\":{\"23\":1}}],[\"幂等性常见的实现方法\",{\"1\":{\"23\":1}}],[\"幂等性如下表\",{\"1\":{\"23\":1}}],[\"幂等性可以增加系统的可靠性\",{\"1\":{\"23\":1}}],[\"幂等性是分布式系统\",{\"1\":{\"23\":1}}],[\"幂等性设计\",{\"1\":{\"23\":1}}],[\"破坏\",{\"1\":{\"249\":1}}],[\"清理操作\",{\"1\":{\"683\":1}}],[\"清理临时文件等\",{\"1\":{\"615\":1}}],[\"清理某个目录下的所有缓存数据\",{\"1\":{\"249\":1}}],[\"清零a中\",{\"1\":{\"446\":1}}],[\"清晰\",{\"1\":{\"33\":1}}],[\"里插入\",{\"1\":{\"820\":1}}],[\"里并没有\",{\"1\":{\"810\":1}}],[\"里不需要保存值为\",{\"1\":{\"770\":1}}],[\"里有一张名为\",{\"1\":{\"770\":1}}],[\"里的信息\",{\"1\":{\"810\":1}}],[\"里的数据\",{\"1\":{\"810\":2}}],[\"里的内容是\",{\"1\":{\"770\":2}}],[\"里的完整事务写入到\",{\"1\":{\"760\":1,\"810\":1}}],[\"里的\",{\"1\":{\"756\":3,\"810\":10}}],[\"里的脏页数据持久化到磁盘\",{\"1\":{\"752\":1,\"810\":1}}],[\"里的字段与记录中的两个隐藏列进行对比\",{\"1\":{\"789\":1}}],[\"里的字段\",{\"1\":{\"743\":1,\"744\":1,\"810\":1}}],[\"里发送给服务器\",{\"1\":{\"249\":1}}],[\"里\",{\"1\":{\"249\":1,\"739\":1,\"741\":1,\"810\":2,\"817\":1}}],[\"里面的末级缓存\",{\"1\":{\"930\":1}}],[\"里面又会调用freememoryifneeded\",{\"1\":{\"900\":1}}],[\"里面加\",{\"1\":{\"894\":1}}],[\"里面记录的是主库分配的自增值\",{\"1\":{\"820\":1}}],[\"里面记录了这条更新语句\",{\"1\":{\"763\":1,\"810\":1}}],[\"里面表级别的锁有这几种\",{\"1\":{\"820\":1}}],[\"里面\",{\"1\":{\"770\":1,\"810\":2}}],[\"里面就行\",{\"1\":{\"770\":1}}],[\"里面没有记录这条更新语句\",{\"1\":{\"763\":1,\"810\":1}}],[\"里面包含了日期和减了多少斤\",{\"1\":{\"723\":1}}],[\"里面包含几个字段\",{\"1\":{\"229\":1}}],[\"里面有一个\",{\"1\":{\"516\":1}}],[\"里面有一大堆数字命名的文件夹\",{\"1\":{\"223\":1}}],[\"里面再保存\",{\"1\":{\"456\":1}}],[\"里面保存了实现了该接口的实际类型的方法地址\",{\"1\":{\"307\":1}}],[\"里面所有类型的一个抽象\",{\"1\":{\"302\":1}}],[\"里面也有\",{\"1\":{\"223\":1}}],[\"里面是自动挂载的设备\",{\"1\":{\"223\":1}}],[\"里面存储着一个数字\",{\"1\":{\"223\":1}}],[\"含义\",{\"1\":{\"249\":2,\"813\":1}}],[\"规则是\",{\"1\":{\"864\":1}}],[\"规则\",{\"1\":{\"813\":4}}],[\"规定报文必须是\",{\"1\":{\"249\":1}}],[\"规定了八种方法\",{\"1\":{\"249\":1}}],[\"规范继承这个类的程序员必须实现这个函数\",{\"1\":{\"33\":1}}],[\"十六\",{\"1\":{\"807\":1}}],[\"十六进制\",{\"1\":{\"770\":3}}],[\"十六进制的\",{\"1\":{\"249\":1}}],[\"十七\",{\"1\":{\"807\":2}}],[\"十二\",{\"1\":{\"749\":1}}],[\"十有八九要到\",{\"1\":{\"223\":1}}],[\"空闲时间的计算\",{\"1\":{\"906\":1}}],[\"空闲连接会一直占用多久\",{\"1\":{\"817\":1}}],[\"空闲空间\",{\"1\":{\"748\":1}}],[\"空格来分词\",{\"1\":{\"813\":1}}],[\"空格分隔\",{\"1\":{\"137\":1}}],[\"空出内存空间\",{\"1\":{\"813\":1}}],[\"空位都以0补齐\",{\"1\":{\"569\":1}}],[\"空间是否满足要求\",{\"1\":{\"873\":1}}],[\"空间是不够的\",{\"1\":{\"265\":1}}],[\"空间索引\",{\"1\":{\"803\":1}}],[\"空间换时间\",{\"1\":{\"526\":1,\"867\":1}}],[\"空字符串\",{\"1\":{\"436\":1}}],[\"空字符串就是\",{\"1\":{\"351\":1}}],[\"空接口的动态类型和动态值示例\",{\"1\":{\"303\":1}}],[\"空接口的结构\",{\"0\":{\"301\":1}}],[\"空接口在运行时由以下结构表示\",{\"1\":{\"301\":1}}],[\"空接口可以接受任意数据类型\",{\"1\":{\"300\":1}}],[\"空接口\",{\"0\":{\"299\":1,\"467\":1}}],[\"空行\",{\"1\":{\"249\":1}}],[\"形式保存在内存\",{\"1\":{\"817\":1}}],[\"形式更详细地说明报文\",{\"1\":{\"249\":1}}],[\"形成数字证书\",{\"1\":{\"240\":1,\"249\":1}}],[\"起始指针\",{\"1\":{\"879\":1}}],[\"起始行\",{\"1\":{\"249\":1}}],[\"起到一个规范的作用\",{\"1\":{\"33\":1}}],[\"灵活性\",{\"1\":{\"249\":1}}],[\"光靠消息队列是做不到不重复消费的\",{\"1\":{\"712\":1}}],[\"光纤等\",{\"1\":{\"249\":1}}],[\"光标闪烁效果设为平滑\",{\"1\":{\"3\":1}}],[\"光标移动时的平滑动画效果\",{\"1\":{\"3\":1}}],[\"光标异常丝滑\",{\"1\":{\"3\":1}}],[\"层次化的理解\",{\"1\":{\"944\":1}}],[\"层次的决定\",{\"1\":{\"885\":1}}],[\"层次越高平均步长越大\",{\"1\":{\"885\":1}}],[\"层在判断其他的查询条件\",{\"1\":{\"817\":1}}],[\"层在判断该记录的\",{\"1\":{\"817\":1}}],[\"层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录\",{\"1\":{\"817\":2}}],[\"层部分负责的事情\",{\"1\":{\"817\":1}}],[\"层每从存储引擎读到一条记录就会发送给客户端\",{\"1\":{\"817\":1}}],[\"层实现\",{\"1\":{\"817\":1}}],[\"层实现的日志\",{\"1\":{\"759\":1,\"810\":1}}],[\"层负责建立连接\",{\"1\":{\"817\":1}}],[\"层优化器各种操作的成本\",{\"1\":{\"813\":1}}],[\"层进行条件判断\",{\"1\":{\"813\":1}}],[\"层再比对\",{\"1\":{\"813\":1}}],[\"层从存储引擎层获取到数据行后\",{\"1\":{\"813\":1}}],[\"层开始更新记录\",{\"1\":{\"810\":2}}],[\"层更新记录前\",{\"1\":{\"810\":4}}],[\"层生成的日志\",{\"1\":{\"810\":1}}],[\"层会生成一条\",{\"1\":{\"759\":1}}],[\"层的查询缓存\",{\"1\":{\"817\":1}}],[\"层的\",{\"1\":{\"747\":1,\"759\":1,\"810\":1,\"817\":1}}],[\"层的日志\",{\"1\":{\"737\":1}}],[\"层还会生成一条\",{\"1\":{\"737\":1,\"810\":1}}],[\"层就读到了该\",{\"1\":{\"525\":1}}],[\"层之间加入了\",{\"1\":{\"249\":1}}],[\"层处理的数据包丢失检测和重传可以阻止所有流\",{\"1\":{\"249\":1}}],[\"层数不同\",{\"1\":{\"249\":1}}],[\"层\",{\"1\":{\"249\":2,\"810\":2,\"813\":3,\"817\":4,\"885\":2,\"957\":1,\"962\":2}}],[\"层通信\",{\"1\":{\"249\":2}}],[\"参与者\",{\"1\":{\"764\":4,\"810\":4}}],[\"参考\",{\"1\":{\"743\":1,\"957\":1}}],[\"参考资料\",{\"0\":{\"266\":1,\"283\":1,\"315\":1,\"333\":1}}],[\"参考模型\",{\"1\":{\"249\":2}}],[\"参数fileheader是文件头信息\",{\"1\":{\"1037\":1}}],[\"参数解析与验证\",{\"1\":{\"1020\":1}}],[\"参数的时候\",{\"1\":{\"820\":1}}],[\"参数的作用机制\",{\"1\":{\"710\":1}}],[\"参数设置的值\",{\"1\":{\"810\":1}}],[\"参数需要设置为\",{\"1\":{\"810\":1}}],[\"参数为\",{\"1\":{\"810\":3}}],[\"参数优化\",{\"1\":{\"807\":1}}],[\"参数控制的\",{\"1\":{\"817\":1}}],[\"参数控制的是什么\",{\"1\":{\"810\":1}}],[\"参数控制\",{\"1\":{\"756\":1,\"810\":3,\"817\":1,\"820\":1}}],[\"参数动态的调整大小\",{\"1\":{\"755\":1,\"810\":1}}],[\"参数决定的\",{\"1\":{\"810\":1}}],[\"参数决定\",{\"1\":{\"739\":1}}],[\"参数异常\",{\"1\":{\"543\":1}}],[\"参数传递\",{\"0\":{\"454\":1}}],[\"参数化查询\",{\"1\":{\"243\":1}}],[\"参数\",{\"0\":{\"1042\":1,\"1043\":1},\"1\":{\"226\":5,\"237\":1,\"249\":1,\"458\":1,\"709\":1,\"810\":8,\"820\":1}}],[\"参数说明\",{\"1\":{\"139\":1}}],[\"参数来控制数据库的\",{\"1\":{\"810\":1}}],[\"参数来启用\",{\"1\":{\"121\":1}}],[\"参数来指定端口映射\",{\"1\":{\"117\":1}}],[\"参数指定\",{\"1\":{\"119\":1}}],[\"参数时如果本地目录不存在\",{\"1\":{\"113\":2}}],[\"参数类型和数目有所不同\",{\"1\":{\"33\":1}}],[\"参数是int类型的\",{\"1\":{\"33\":1}}],[\"故名思义\",{\"1\":{\"957\":1}}],[\"故障隔离\",{\"1\":{\"249\":1}}],[\"故用\",{\"1\":{\"30\":1}}],[\"互斥性\",{\"0\":{\"914\":1},\"1\":{\"909\":1,\"921\":2}}],[\"互斥\",{\"1\":{\"820\":1}}],[\"互斥锁资源\",{\"1\":{\"897\":1}}],[\"互斥锁\",{\"1\":{\"516\":1}}],[\"互相配合来提供一个拥有并发读写能力\",{\"1\":{\"512\":1}}],[\"互质是指两个数的公约数只有1\",{\"1\":{\"249\":1}}],[\"互质的小奇数e\",{\"1\":{\"249\":2}}],[\"互联网层主要使用的协议是ip\",{\"1\":{\"249\":1}}],[\"互操作性\",{\"1\":{\"249\":1}}],[\"互动模式\",{\"1\":{\"202\":1}}],[\"适当设置\",{\"1\":{\"810\":1}}],[\"适当分页\",{\"1\":{\"807\":1}}],[\"适当的索引策略可以减少锁冲突\",{\"1\":{\"807\":1}}],[\"适当的日志记录\",{\"1\":{\"605\":1}}],[\"适用情况\",{\"1\":{\"930\":1}}],[\"适用对象不同\",{\"1\":{\"810\":1}}],[\"适用站点都可以根据需要来指定\",{\"1\":{\"249\":1}}],[\"适用于需要虚拟机作为独立网络节点的场景\",{\"1\":{\"246\":1}}],[\"适用于需要多个虚拟机进行内部通信并共同访问外部网络的场景\",{\"1\":{\"246\":1}}],[\"适用场景\",{\"1\":{\"246\":1}}],[\"适合计数场景\",{\"1\":{\"873\":1}}],[\"适合无序集合场景\",{\"1\":{\"870\":1}}],[\"适合场景\",{\"1\":{\"867\":1,\"870\":1}}],[\"适合对消息传递可靠性有要求\",{\"1\":{\"705\":1}}],[\"适合对消息传递可靠性不高的场景\",{\"1\":{\"705\":1}}],[\"适合完全二叉树的存储\",{\"1\":{\"65\":1}}],[\"适合频繁插入\",{\"1\":{\"64\":1}}],[\"哔哩哔哩\",{\"1\":{\"246\":1,\"315\":1}}],[\"桥接模式是一种虚拟机网络连接模式\",{\"1\":{\"246\":1}}],[\"桥接\",{\"1\":{\"246\":1}}],[\"桥接bridged\",{\"1\":{\"246\":1}}],[\"桥接网卡\",{\"1\":{\"121\":1}}],[\"意向独占锁\",{\"1\":{\"820\":2}}],[\"意向共享锁和意向独占锁是表级锁\",{\"1\":{\"820\":1}}],[\"意向共享锁\",{\"1\":{\"820\":1}}],[\"意向锁的目的是为了快速判断表里是否有记录被加锁\",{\"1\":{\"820\":1}}],[\"意向锁\",{\"1\":{\"820\":5}}],[\"意味code字段着最多可以存储50\",{\"1\":{\"770\":1}}],[\"意味着事务\",{\"1\":{\"820\":1}}],[\"意味着\",{\"1\":{\"820\":1}}],[\"意味着整个数据库都是只读状态\",{\"1\":{\"820\":1}}],[\"意味着访问效率高\",{\"1\":{\"813\":1}}],[\"意味着写入到了操作系统的文件缓存\",{\"1\":{\"810\":2}}],[\"意味着需要从磁盘读写更多的数据\",{\"1\":{\"770\":1}}],[\"意味着数据库每次读写都是以\",{\"1\":{\"770\":1}}],[\"意味着服务端需要创建更多的子进程或者线程\",{\"1\":{\"226\":1}}],[\"意思是多次执行相同的操作\",{\"1\":{\"249\":1}}],[\"意义\",{\"1\":{\"243\":1}}],[\"伪造\",{\"1\":{\"243\":1}}],[\"反之\",{\"1\":{\"820\":1}}],[\"反射的一个重要应用是动态代理\",{\"1\":{\"559\":1}}],[\"反射的主要api\",{\"0\":{\"554\":1}}],[\"反射的优缺点\",{\"0\":{\"552\":1}}],[\"反射的概念\",{\"0\":{\"551\":1}}],[\"反射提供了一种在运行时检查和修改程序行为的方式\",{\"1\":{\"551\":1}}],[\"反射\",{\"1\":{\"550\":1,\"564\":1},\"2\":{\"561\":1}}],[\"反射基础\",{\"0\":{\"550\":1}}],[\"反射攻击\",{\"1\":{\"243\":1}}],[\"反序列化时忽略此字段\",{\"1\":{\"486\":1}}],[\"反序列化时使用小写name\",{\"1\":{\"485\":1,\"486\":1}}],[\"反序列化的时候忽略掉结构体中的某个字段\",{\"1\":{\"486\":1}}],[\"反序列化\",{\"0\":{\"483\":1}}],[\"反向代理\",{\"1\":{\"240\":2,\"249\":1}}],[\"受害者\",{\"1\":{\"243\":1}}],[\"造成过大压力\",{\"1\":{\"930\":1}}],[\"造成资源的大量消耗而不能向正常的请求提供服务\",{\"1\":{\"243\":1}}],[\"造成网络堵塞\",{\"1\":{\"243\":1}}],[\"造成目标主机不能处理其他udp的请求\",{\"1\":{\"243\":1}}],[\"造成用户的钱多扣了\",{\"1\":{\"23\":1}}],[\"洪水攻击\",{\"1\":{\"243\":3}}],[\"花钱买可靠的ddos防护服务\",{\"1\":{\"243\":1}}],[\"花括号让s1和s2变成局部对象\",{\"1\":{\"33\":1}}],[\"丧失对外服务的能力\",{\"1\":{\"243\":1}}],[\"量大\",{\"1\":{\"243\":1}}],[\"群殴\",{\"1\":{\"243\":1}}],[\"污染\",{\"1\":{\"243\":1}}],[\"手机\",{\"1\":{\"638\":1}}],[\"手动开启\",{\"1\":{\"1015\":1}}],[\"手动事务\",{\"0\":{\"1015\":1}}],[\"手动断开空闲的连接\",{\"1\":{\"817\":1}}],[\"手动抛出异常\",{\"1\":{\"543\":1}}],[\"手动更换公共的dns服务器\",{\"1\":{\"243\":2}}],[\"手写实现智能指针需要哪些函数\",{\"1\":{\"33\":1}}],[\"取代了导致连锁更新的\",{\"1\":{\"879\":1}}],[\"取决于你的linux发行版\",{\"1\":{\"835\":2}}],[\"取消用户的操作权限\",{\"1\":{\"829\":1}}],[\"取消对数据库中的数据进行变更\",{\"1\":{\"829\":1}}],[\"取消等\",{\"1\":{\"719\":1}}],[\"取消以及传递请求相关的值\",{\"1\":{\"270\":1}}],[\"取不到所有元素的地址\",{\"1\":{\"453\":1}}],[\"取而代之的是唯一标识id\",{\"1\":{\"249\":1}}],[\"取得控制权篡改dns解析结果\",{\"1\":{\"243\":1}}],[\"取模\",{\"1\":{\"79\":1}}],[\"攻击密码的主要方法\",{\"0\":{\"1048\":1}}],[\"攻击会导致数据库压力过大\",{\"1\":{\"930\":1}}],[\"攻击防护\",{\"2\":{\"245\":1}}],[\"攻击可能包括来自世界各地的大量数据包\",{\"1\":{\"243\":1}}],[\"攻击的实际来源被隐藏\",{\"1\":{\"243\":1}}],[\"攻击目标\",{\"1\":{\"243\":2}}],[\"攻击\",{\"1\":{\"243\":2}}],[\"攻击者想通过暴力破解的方法猜测出用户密码的成本变得越昂贵\",{\"1\":{\"1056\":1}}],[\"攻击者对udp的\",{\"1\":{\"243\":1}}],[\"攻击者劫持\",{\"1\":{\"243\":1}}],[\"攻击手段\",{\"1\":{\"243\":2}}],[\"劫持\",{\"1\":{\"243\":1}}],[\"颁发者\",{\"1\":{\"240\":1,\"249\":1}}],[\"握手数据都是明文\",{\"1\":{\"249\":1}}],[\"握手后的通信使用\",{\"1\":{\"249\":1}}],[\"握手过程流程图\",{\"1\":{\"249\":1}}],[\"握手\",{\"1\":{\"240\":2,\"249\":2}}],[\"版本不一样\",{\"1\":{\"873\":1}}],[\"版本移除的是\",{\"1\":{\"817\":1}}],[\"版本直接将查询缓存删掉了\",{\"1\":{\"817\":1}}],[\"版本实现了\",{\"1\":{\"817\":1}}],[\"版本中\",{\"1\":{\"810\":2}}],[\"版本之前一样\",{\"1\":{\"897\":1}}],[\"版本之前用的行格式\",{\"1\":{\"770\":1}}],[\"版本之后增加的一种复制方式\",{\"1\":{\"810\":1}}],[\"版本之后\",{\"1\":{\"770\":2}}],[\"版本开始\",{\"1\":{\"770\":1,\"817\":1,\"820\":1}}],[\"版本链\",{\"1\":{\"786\":1}}],[\"版本链里找到满足其可见性的记录\",{\"1\":{\"743\":1,\"810\":1}}],[\"版本链如下图\",{\"1\":{\"742\":1,\"810\":1}}],[\"版本已移除查询缓存这一特性\",{\"1\":{\"734\":1}}],[\"版本号是否支持\",{\"1\":{\"249\":1}}],[\"版本号\",{\"1\":{\"249\":2}}],[\"版本\",{\"1\":{\"249\":1,\"770\":1,\"810\":1,\"820\":2}}],[\"版本差异\",{\"1\":{\"240\":1}}],[\"版本定义的阈值也是不同的\",{\"1\":{\"217\":1}}],[\"请手撸5种常见限流算法\",{\"1\":{\"933\":1}}],[\"请用逗号分隔多个数据库的名字\",{\"1\":{\"854\":1}}],[\"请将\",{\"1\":{\"854\":1}}],[\"请相应地更改主机部分\",{\"1\":{\"840\":1}}],[\"请使用\",{\"1\":{\"838\":1}}],[\"请通过一下步骤管理\",{\"1\":{\"836\":1}}],[\"请查阅相应的文档以获取更多信息\",{\"1\":{\"835\":1}}],[\"请注意\",{\"1\":{\"835\":1,\"838\":1}}],[\"请求过来先记录在redis\",{\"1\":{\"927\":1}}],[\"请求量\",{\"1\":{\"927\":1}}],[\"请求到来\",{\"1\":{\"888\":1}}],[\"请求乱码\",{\"0\":{\"687\":1}}],[\"请求次数\",{\"1\":{\"682\":1}}],[\"请求转发是服务器内部的跳转\",{\"1\":{\"681\":1}}],[\"请求转发\",{\"0\":{\"681\":1}}],[\"请求转发与重定向\",{\"0\":{\"680\":1}}],[\"请求和响应对象\",{\"0\":{\"668\":1}}],[\"请求和响应了\",{\"1\":{\"249\":1}}],[\"请求属性替换\",{\"1\":{\"635\":1}}],[\"请求属性移除\",{\"1\":{\"635\":1}}],[\"请求属性添加\",{\"1\":{\"635\":1}}],[\"请求结束\",{\"1\":{\"626\":1}}],[\"请求开始\",{\"1\":{\"626\":1}}],[\"请求参数被多次读取导致流关闭\",{\"1\":{\"609\":1}}],[\"请求参数读取问题\",{\"0\":{\"609\":1}}],[\"请求参数等\",{\"1\":{\"579\":1}}],[\"请求阶段\",{\"1\":{\"596\":2}}],[\"请求将被拦截\",{\"1\":{\"591\":1}}],[\"请求处理\",{\"1\":{\"662\":1}}],[\"请求处理后\",{\"1\":{\"591\":1}}],[\"请求处理后的操作\",{\"1\":{\"591\":1}}],[\"请求处理前\",{\"1\":{\"591\":1,\"683\":1}}],[\"请求处理前的操作\",{\"1\":{\"591\":1,\"683\":1}}],[\"请求处理完成\",{\"1\":{\"584\":1,\"596\":1}}],[\"请求处理完成后的操作\",{\"1\":{\"584\":1}}],[\"请求流程\",{\"1\":{\"512\":1}}],[\"请求获取图片\",{\"1\":{\"249\":1}}],[\"请求由单行指令构成\",{\"1\":{\"249\":1}}],[\"请求头部将\",{\"1\":{\"249\":1}}],[\"请求头字段cookie\",{\"1\":{\"249\":1}}],[\"请求时\",{\"1\":{\"249\":1}}],[\"请求行里则不会出现\",{\"1\":{\"249\":1}}],[\"请求从服务器获取资源\",{\"1\":{\"249\":1}}],[\"请求方法\",{\"1\":{\"249\":1}}],[\"请求示例\",{\"1\":{\"249\":1}}],[\"请求实例\",{\"1\":{\"249\":1}}],[\"请求报文有误\",{\"1\":{\"249\":1}}],[\"请求报文有错误\",{\"1\":{\"240\":1}}],[\"请求报文\",{\"1\":{\"249\":2}}],[\"请求\",{\"1\":{\"243\":1,\"249\":5,\"519\":1,\"635\":3,\"1032\":1}}],[\"请求的资源不存在\",{\"1\":{\"240\":1}}],[\"请求的资源权限不够\",{\"1\":{\"240\":1}}],[\"请怎么设计和实现\",{\"1\":{\"20\":1}}],[\"临时重定向\",{\"1\":{\"240\":1}}],[\"临时文件可能起到很重要的作用\",{\"1\":{\"223\":1}}],[\"永久重定向\",{\"1\":{\"240\":1}}],[\"独占表锁\",{\"1\":{\"820\":2}}],[\"独占锁\",{\"1\":{\"820\":2}}],[\"独立的列\",{\"1\":{\"807\":1}}],[\"独立部署代理中间件\",{\"1\":{\"730\":1}}],[\"独立性\",{\"1\":{\"246\":1}}],[\"独立于应用层的具体协议\",{\"1\":{\"237\":1}}],[\"独享与进程相关的数据结构\",{\"1\":{\"217\":1}}],[\"之所以客户端显示的时候是直接显示所有记录的\",{\"1\":{\"817\":1}}],[\"之上理解二级索引\",{\"1\":{\"813\":1}}],[\"之间\",{\"1\":{\"789\":1}}],[\"之间的部分\",{\"1\":{\"810\":2}}],[\"之间的位置\",{\"1\":{\"770\":2}}],[\"之间的相互配合\",{\"0\":{\"736\":1}}],[\"之间的切换\",{\"1\":{\"381\":1}}],[\"之间共享和访问\",{\"1\":{\"516\":1,\"522\":1}}],[\"之间回绕\",{\"1\":{\"237\":1}}],[\"之前的\",{\"1\":{\"897\":1}}],[\"之前的版本\",{\"1\":{\"817\":2}}],[\"之前已提交的记录都不会丢失\",{\"1\":{\"810\":1}}],[\"之前\",{\"1\":{\"452\":1,\"453\":1,\"737\":1,\"810\":1,\"820\":3,\"867\":1}}],[\"之前握手信息是否有被中途篡改过\",{\"1\":{\"249\":1}}],[\"之前传输的\",{\"1\":{\"249\":1}}],[\"之前做了啥完全记不住\",{\"1\":{\"249\":1}}],[\"之\",{\"1\":{\"249\":1}}],[\"之分多用在html页面里标记引用的其他资源\",{\"1\":{\"249\":1}}],[\"之后通过\",{\"1\":{\"957\":1}}],[\"之后通过gc回收才能释放\",{\"1\":{\"405\":1}}],[\"之后我会单独写一篇文章来进行解读\",{\"1\":{\"957\":1}}],[\"之后才产生的锁\",{\"1\":{\"820\":1}}],[\"之后可以在插入数据时\",{\"1\":{\"820\":1}}],[\"之后就会被从库\",{\"1\":{\"810\":1}}],[\"之后事务\",{\"1\":{\"793\":2}}],[\"之后引入了\",{\"1\":{\"770\":1}}],[\"之后随着程序的运行\",{\"1\":{\"748\":1,\"810\":1}}],[\"之后会\",{\"1\":{\"479\":1}}],[\"之后的版本已经更改\",{\"1\":{\"453\":1}}],[\"之后又到了\",{\"1\":{\"374\":1}}],[\"之后都是对称密钥加密的密文\",{\"1\":{\"249\":1}}],[\"之后对该服务器每一次请求中都通过\",{\"1\":{\"249\":1}}],[\"之后必须要有一个\",{\"1\":{\"249\":1}}],[\"之后再接分区编号\",{\"1\":{\"157\":1}}],[\"之后\",{\"1\":{\"113\":1,\"249\":1,\"452\":1,\"737\":1,\"810\":1,\"813\":1,\"820\":1,\"867\":1,\"1031\":1}}],[\"之后被替换的文本参与编译\",{\"1\":{\"33\":1}}],[\"长字符串\",{\"1\":{\"770\":1}}],[\"长度不够50字节的字符串\",{\"1\":{\"770\":1}}],[\"长度<50\",{\"1\":{\"497\":1}}],[\"长度\",{\"1\":{\"338\":1}}],[\"长连接的好处就是可以减少建立连接和断开连接的过程\",{\"1\":{\"817\":1}}],[\"长连接和短连接\",{\"1\":{\"817\":1}}],[\"长连接也叫\",{\"1\":{\"249\":1}}],[\"长连接\",{\"1\":{\"249\":1,\"817\":1}}],[\"长连接能处理的最大请求数量\",{\"1\":{\"237\":1}}],[\"长格式列出\",{\"1\":{\"201\":1}}],[\"状态后\",{\"1\":{\"810\":1}}],[\"状态设置为\",{\"1\":{\"765\":1,\"810\":3}}],[\"状态设计的目的\",{\"1\":{\"237\":1}}],[\"状态是由\",{\"1\":{\"525\":1}}],[\"状态是为了优化\",{\"1\":{\"524\":1}}],[\"状态维护\",{\"1\":{\"240\":1}}],[\"状态码会在响应开始时发送\",{\"1\":{\"249\":1}}],[\"状态码\",{\"1\":{\"240\":1,\"249\":1}}],[\"状态的\",{\"1\":{\"810\":1}}],[\"状态的连接可能被重用\",{\"1\":{\"237\":2}}],[\"状态的产生\",{\"1\":{\"237\":1}}],[\"状态\",{\"0\":{\"524\":1,\"525\":1},\"1\":{\"237\":2,\"523\":2,\"525\":2,\"531\":1,\"810\":1}}],[\"状态标识\",{\"1\":{\"23\":1}}],[\"序列化到磁盘\",{\"1\":{\"638\":1}}],[\"序列化结果中没有email和hobby字段\",{\"1\":{\"488\":1}}],[\"序列化的时候不会忽略这些字段\",{\"1\":{\"487\":1}}],[\"序列化与反序列化默认情况下使用结构体的字段名\",{\"1\":{\"485\":1}}],[\"序列化\",{\"0\":{\"483\":1},\"2\":{\"231\":1}}],[\"序列号是32位\",{\"1\":{\"237\":1}}],[\"序列号占用的位数根据需求可以灵活调整\",{\"1\":{\"92\":1}}],[\"序列号\",{\"1\":{\"92\":1}}],[\"协调者\",{\"1\":{\"764\":4,\"810\":4}}],[\"协调者与参与者之间的协作\",{\"1\":{\"764\":1}}],[\"协调器会通知所有消费者新的分配情况\",{\"1\":{\"165\":1}}],[\"协调器根据当前消费者组的成员重新分配主题的分区\",{\"1\":{\"165\":1}}],[\"协程被称为\",{\"1\":{\"378\":1}}],[\"协商缓存就是与服务端协商之后\",{\"1\":{\"249\":1}}],[\"协商缓存\",{\"1\":{\"249\":1}}],[\"协议时尤为重要\",{\"1\":{\"810\":1}}],[\"协议需要向\",{\"1\":{\"249\":1}}],[\"协议版本信息现在会随着每个请求发送\",{\"1\":{\"249\":1}}],[\"协议的应用十分有限\",{\"1\":{\"249\":1}}],[\"协议的放大\",{\"1\":{\"243\":1}}],[\"协议并没有版本号\",{\"1\":{\"249\":1}}],[\"协议也被称为是\",{\"1\":{\"249\":1}}],[\"协议最初是个非常简单的协议\",{\"1\":{\"249\":1}}],[\"协议名\",{\"1\":{\"249\":1}}],[\"协议里\",{\"1\":{\"249\":2}}],[\"协议有良好的扩展性\",{\"1\":{\"249\":1}}],[\"协议规定报文必须有\",{\"1\":{\"249\":1}}],[\"协议举例\",{\"1\":{\"249\":1}}],[\"协议缺陷攻击\",{\"1\":{\"243\":1}}],[\"协议\",{\"1\":{\"249\":3},\"2\":{\"230\":1}}],[\"命名策略\",{\"0\":{\"979\":1}}],[\"命名规则\",{\"1\":{\"829\":1}}],[\"命名返回值\",{\"0\":{\"427\":1}}],[\"命名空间相关\",{\"1\":{\"229\":2}}],[\"命令例子\",{\"1\":{\"873\":1}}],[\"命令恢复数据库\",{\"1\":{\"855\":1}}],[\"命令运行\",{\"1\":{\"855\":1}}],[\"命令输出这条\",{\"1\":{\"817\":1}}],[\"命令后\",{\"1\":{\"785\":1}}],[\"命令替换\",{\"1\":{\"190\":1}}],[\"命令行\",{\"2\":{\"152\":1,\"213\":1,\"216\":1}}],[\"命令docker\",{\"1\":{\"145\":1}}],[\"命令参数可选项\",{\"1\":{\"140\":1}}],[\"命令的时候\",{\"1\":{\"110\":1}}],[\"命令\",{\"1\":{\"104\":1,\"132\":1,\"147\":1,\"214\":1,\"223\":1,\"785\":1,\"817\":1,\"939\":1,\"952\":1}}],[\"建表语句\",{\"1\":{\"983\":1}}],[\"建了一张订单表\",{\"1\":{\"820\":1}}],[\"建议收藏\",{\"1\":{\"930\":1}}],[\"建议使用有意义的url模式\",{\"1\":{\"657\":1}}],[\"建议使用web\",{\"1\":{\"595\":1}}],[\"建议在\",{\"1\":{\"229\":1}}],[\"建立数据库连接\",{\"0\":{\"976\":1}}],[\"建立时间过长\",{\"1\":{\"888\":1}}],[\"建立合适的索引来提升查询效率\",{\"1\":{\"826\":1}}],[\"建立索引的字段\",{\"1\":{\"813\":2}}],[\"建立索引会生成本地磁盘文件\",{\"1\":{\"813\":1}}],[\"建立\",{\"1\":{\"813\":1}}],[\"建立联合索引\",{\"1\":{\"813\":3}}],[\"建立临时表\",{\"1\":{\"813\":1}}],[\"建立组合索引\",{\"1\":{\"813\":1}}],[\"建立主键索引的列或二级索引的列\",{\"1\":{\"813\":1}}],[\"建立全文索引来代替\",{\"1\":{\"807\":1}}],[\"建立中间表\",{\"1\":{\"807\":1}}],[\"建立客户端\",{\"1\":{\"734\":1}}],[\"建立连接\",{\"1\":{\"817\":1,\"888\":1}}],[\"建立连接要有\",{\"1\":{\"249\":1}}],[\"建立连接和关闭连接都是非常\",{\"1\":{\"249\":1}}],[\"建立特殊的连接隧道\",{\"1\":{\"249\":1}}],[\"建立sockaddr结构体\",{\"1\":{\"226\":1}}],[\"建立一个函数索引\",{\"1\":{\"813\":1}}],[\"建立一个套接字\",{\"1\":{\"226\":1}}],[\"建立一个\",{\"1\":{\"226\":1}}],[\"建立qq号码与二进制位之间的映射\",{\"1\":{\"20\":1}}],[\"导图\",{\"1\":{\"249\":1}}],[\"导入\",{\"1\":{\"229\":1}}],[\"导入路径之间没有关联\",{\"1\":{\"229\":1}}],[\"导入路径和\",{\"1\":{\"229\":2}}],[\"导入路径也用于构造输出文件名\",{\"1\":{\"229\":1}}],[\"导入路径用于确定一个\",{\"1\":{\"229\":1}}],[\"导入路径的模式通常由控制整个依赖树的某些构建工具\",{\"1\":{\"229\":1}}],[\"导入路径的映射可能非常大\",{\"1\":{\"229\":1}}],[\"导入路径是在\",{\"1\":{\"229\":1}}],[\"导入路径由\",{\"1\":{\"229\":1}}],[\"导入路径\",{\"1\":{\"229\":2}}],[\"导致以上这些差异的原因是配置不同\",{\"1\":{\"957\":1}}],[\"导致同一份资源频繁被不同竞争者同时访问\",{\"1\":{\"912\":1,\"921\":1}}],[\"导致锁过期\",{\"1\":{\"912\":1,\"921\":1}}],[\"导致的\",{\"1\":{\"879\":1}}],[\"导致这个\",{\"1\":{\"879\":1}}],[\"导致后一个\",{\"1\":{\"879\":1}}],[\"导致死锁\",{\"1\":{\"820\":1}}],[\"导致\",{\"1\":{\"820\":1}}],[\"导致无法插入\",{\"1\":{\"820\":1}}],[\"导致无法一次性装入内存的数据处理\",{\"1\":{\"20\":1}}],[\"导致消息处理失败\",{\"1\":{\"706\":1}}],[\"导致程序直接被终止\",{\"1\":{\"509\":1}}],[\"导致程序崩溃\",{\"1\":{\"33\":1}}],[\"导致栈空间不足\",{\"1\":{\"408\":1}}],[\"导致频繁的线程阻塞和取消阻塞操作增加了系统开销\",{\"1\":{\"381\":1}}],[\"导致未授权访问或数据泄露\",{\"1\":{\"243\":1}}],[\"导致大量的网络数据发送给\",{\"1\":{\"243\":1}}],[\"导致time\",{\"1\":{\"237\":1}}],[\"导致效率降低\",{\"1\":{\"33\":1}}],[\"导致用户认为没有提交成功\",{\"1\":{\"23\":1}}],[\"输入的是字符串类型\",{\"1\":{\"813\":1}}],[\"输入的是整型\",{\"1\":{\"813\":1}}],[\"输入验证\",{\"1\":{\"604\":1}}],[\"输入文件\",{\"1\":{\"229\":1}}],[\"输出可能出现的错误\",{\"1\":{\"1037\":1}}],[\"输出获取到的\",{\"1\":{\"1037\":2}}],[\"输出为\",{\"1\":{\"1035\":1}}],[\"输出完整的用户表\",{\"1\":{\"842\":1}}],[\"输出执行计划\",{\"1\":{\"817\":1}}],[\"输出响应内容\",{\"0\":{\"677\":1}}],[\"输出html内容\",{\"1\":{\"652\":1}}],[\"输出编码\",{\"1\":{\"604\":1}}],[\"输出不会混乱\",{\"1\":{\"511\":1}}],[\"输出\",{\"1\":{\"458\":2,\"460\":1,\"466\":2,\"470\":2,\"471\":2,\"483\":1,\"496\":2,\"957\":2,\"966\":1}}],[\"输出具体的代码计划\",{\"1\":{\"392\":1}}],[\"输出汇编代码\",{\"1\":{\"392\":1}}],[\"输出名\",{\"1\":{\"391\":1}}],[\"输出结果如下\",{\"1\":{\"488\":1}}],[\"输出结果也是如此\",{\"1\":{\"374\":1}}],[\"输出结果\",{\"0\":{\"368\":1},\"1\":{\"487\":1,\"1059\":1}}],[\"输出结果是什么\",{\"1\":{\"367\":1}}],[\"输出有什么不同\",{\"1\":{\"367\":1}}],[\"输出文件大小\",{\"1\":{\"1037\":1}}],[\"输出文件名\",{\"1\":{\"1037\":1}}],[\"输出文件与输入文件放在相同的相对目录中\",{\"1\":{\"229\":1}}],[\"输出文件放在以\",{\"1\":{\"229\":2}}],[\"输出文件的名称是通过将\",{\"1\":{\"229\":1}}],[\"输出的目录\",{\"1\":{\"229\":1}}],[\"输出内容到文档\",{\"1\":{\"209\":1}}],[\"输出内容到控制台\",{\"1\":{\"209\":1}}],[\"输出内容\",{\"1\":{\"209\":1}}],[\"任务失败\",{\"1\":{\"719\":1}}],[\"任务的执行顺序可能直接影响结果\",{\"1\":{\"719\":1}}],[\"任务调度\",{\"1\":{\"719\":1}}],[\"任何指标都可以抽象成分数\",{\"1\":{\"876\":1}}],[\"任何顺序错乱可能导致账户数据不一致\",{\"1\":{\"719\":1}}],[\"任何文件在计算中都可以表示成二进制码串\",{\"1\":{\"75\":1}}],[\"任意类型\",{\"1\":{\"229\":1}}],[\"称之为别名\",{\"1\":{\"229\":1}}],[\"称为临键锁\",{\"1\":{\"820\":1}}],[\"称为间隙锁\",{\"1\":{\"820\":1}}],[\"称为记录锁\",{\"1\":{\"820\":1}}],[\"称为\",{\"1\":{\"121\":1}}],[\"枚举一般用常量表示\",{\"1\":{\"441\":1}}],[\"枚举类型的第一个选项的标识符必须是0\",{\"1\":{\"229\":1}}],[\"枚举\",{\"1\":{\"229\":1}}],[\"向5个redis发送解锁请求\",{\"1\":{\"917\":1,\"921\":1}}],[\"向5个redis申请加锁\",{\"1\":{\"917\":1,\"921\":1}}],[\"向表中插入数据\",{\"1\":{\"829\":1}}],[\"向表中新插入了一条\",{\"1\":{\"793\":1}}],[\"向获取\",{\"1\":{\"820\":1}}],[\"向该表插入一条\",{\"1\":{\"820\":1}}],[\"向右读就是真实数据\",{\"1\":{\"770\":2}}],[\"向左读就是记录头信息\",{\"1\":{\"770\":1}}],[\"向上传递\",{\"1\":{\"479\":1}}],[\"向channel发送数据分为三种方式\",{\"1\":{\"264\":1}}],[\"向channel写入一条数据\",{\"1\":{\"256\":1}}],[\"向服务器发送数据\",{\"1\":{\"249\":1}}],[\"向资源提交数据\",{\"1\":{\"249\":1}}],[\"向\",{\"1\":{\"243\":1,\"249\":2}}],[\"向前和向后兼容\",{\"1\":{\"229\":1}}],[\"向客户端发送数据\",{\"1\":{\"226\":2}}],[\"平常添加数据就是往\",{\"1\":{\"894\":1}}],[\"平均生存时间\",{\"1\":{\"944\":1}}],[\"平均\",{\"1\":{\"879\":1}}],[\"平均而言也会比\",{\"1\":{\"813\":1}}],[\"平台无关性\",{\"1\":{\"646\":1}}],[\"平台无关的机制来实现对数据的序列化\",{\"1\":{\"229\":1}}],[\"平滑效果smooth开启后\",{\"1\":{\"3\":1}}],[\"他原来是255\",{\"1\":{\"903\":1}}],[\"他们是并集关系\",{\"1\":{\"952\":1}}],[\"他们的字段属性是一样的\",{\"1\":{\"873\":1}}],[\"他们本质都是一种压缩的列表\",{\"1\":{\"867\":1}}],[\"他们相互不冲突\",{\"1\":{\"820\":1}}],[\"他才可以进行选择数据库和查询等操作\",{\"1\":{\"846\":1}}],[\"他拥有name\",{\"1\":{\"229\":1}}],[\"他可以直接用\",{\"1\":{\"223\":1}}],[\"边缘触发\",{\"1\":{\"226\":1}}],[\"边缘触发和水平触发\",{\"1\":{\"226\":1}}],[\"双端访问的特性\",{\"1\":{\"879\":1}}],[\"双击\",{\"1\":{\"836\":1}}],[\"双\",{\"1\":{\"810\":1}}],[\"双主架构\",{\"1\":{\"807\":1}}],[\"双主双写+热备份\",{\"1\":{\"807\":1}}],[\"双主双写\",{\"1\":{\"807\":1}}],[\"双1\",{\"1\":{\"766\":1,\"810\":1}}],[\"双引号和反引号\",{\"1\":{\"361\":1}}],[\"双方根据已经得到的三个随机数\",{\"1\":{\"249\":1}}],[\"双向通信\",{\"1\":{\"246\":1}}],[\"双链表中则存放着将要通过epoll\",{\"1\":{\"226\":1}}],[\"双指针\",{\"2\":{\"90\":1}}],[\"链接生成可执行文件\",{\"1\":{\"396\":1}}],[\"链表中所有元素都是sudog结构\",{\"1\":{\"259\":1}}],[\"链表维护就绪事件\",{\"1\":{\"226\":1}}],[\"链路层负责在网络的物理媒介上发送和接收数据\",{\"1\":{\"249\":1}}],[\"链路层\",{\"1\":{\"249\":2}}],[\"链式处理\",{\"1\":{\"578\":1}}],[\"链式结构\",{\"0\":{\"64\":1}}],[\"链式实现需要通过遍历找到最底层的最右节点\",{\"1\":{\"54\":1}}],[\"链式\",{\"0\":{\"54\":1}}],[\"红黑树的根节点\",{\"1\":{\"226\":1}}],[\"红黑树这种保存所有待检测的\",{\"1\":{\"226\":1}}],[\"红黑树是个高效的数据结构\",{\"1\":{\"226\":1}}],[\"红黑树\",{\"1\":{\"226\":1,\"813\":1}}],[\"处于gc执行中\",{\"1\":{\"918\":1,\"921\":1}}],[\"处于等待状态\",{\"1\":{\"820\":1}}],[\"处于\",{\"1\":{\"237\":2,\"810\":1}}],[\"处于这个模式下的\",{\"1\":{\"125\":1}}],[\"处理完事件处理后\",{\"1\":{\"952\":1}}],[\"处理简单的扣减请求非常快\",{\"1\":{\"927\":1}}],[\"处理流程中读取请求\",{\"1\":{\"897\":1}}],[\"处理请求\",{\"1\":{\"888\":1}}],[\"处理命令是单线程的\",{\"1\":{\"873\":1}}],[\"处理结果\",{\"1\":{\"817\":1}}],[\"处理客户端连接\",{\"1\":{\"800\":1}}],[\"处理客户端请求\",{\"1\":{\"664\":1}}],[\"处理大事务时不必写入磁盘\",{\"1\":{\"755\":1}}],[\"处理新增\",{\"1\":{\"730\":1}}],[\"处理逻辑\",{\"1\":{\"689\":2}}],[\"处理trace请求\",{\"1\":{\"666\":1}}],[\"处理options请求\",{\"1\":{\"666\":1}}],[\"处理head请求\",{\"1\":{\"666\":1}}],[\"处理delete请求\",{\"1\":{\"666\":1}}],[\"处理put请求\",{\"1\":{\"666\":1}}],[\"处理post请求\",{\"1\":{\"666\":1}}],[\"处理get请求\",{\"1\":{\"666\":1,\"1021\":1}}],[\"处理用户切换账号的情况\",{\"1\":{\"641\":1}}],[\"处理时间超过1秒\",{\"1\":{\"600\":1}}],[\"处理时间\",{\"1\":{\"600\":1,\"626\":1}}],[\"处理会话相关的操作\",{\"1\":{\"579\":1}}],[\"处理业务逻辑\",{\"1\":{\"546\":1}}],[\"处理其他类型的异常\",{\"1\":{\"540\":1}}],[\"处理特定类型的异常\",{\"1\":{\"540\":1}}],[\"处理map的时候可以用多重赋值写法\",{\"1\":{\"449\":1}}],[\"处理错误\",{\"1\":{\"425\":1}}],[\"处理\",{\"0\":{\"475\":1},\"1\":{\"226\":1,\"512\":2,\"530\":1,\"730\":1,\"810\":1,\"962\":1}}],[\"学习一下\",{\"1\":{\"226\":1}}],[\"学生认证可免费使用\",{\"1\":{\"12\":1}}],[\"zapcore\",{\"1\":{\"957\":44}}],[\"zap特点\",{\"0\":{\"956\":1}}],[\"zap\",{\"0\":{\"955\":1},\"1\":{\"955\":5,\"956\":5,\"957\":79},\"2\":{\"959\":1}}],[\"zadd\",{\"1\":{\"876\":1}}],[\"zllen\",{\"1\":{\"879\":7}}],[\"zlend\",{\"1\":{\"879\":4}}],[\"zl\",{\"1\":{\"879\":2}}],[\"zltail\",{\"1\":{\"879\":2}}],[\"zlbytes\",{\"1\":{\"879\":2}}],[\"zskiplistlevel\",{\"1\":{\"885\":1}}],[\"zscore\",{\"1\":{\"876\":1}}],[\"zset等\",{\"1\":{\"937\":1}}],[\"zset\",{\"1\":{\"876\":2,\"885\":2},\"2\":{\"878\":1}}],[\"zset类型详解\",{\"0\":{\"876\":1}}],[\"zcount\",{\"1\":{\"876\":1}}],[\"zcard\",{\"1\":{\"876\":1}}],[\"zrank\",{\"1\":{\"876\":1}}],[\"zrange\",{\"1\":{\"876\":1}}],[\"zrevrange\",{\"1\":{\"876\":1}}],[\"zrem\",{\"1\":{\"876\":1}}],[\"zipslist\",{\"1\":{\"867\":1}}],[\"zip\",{\"1\":{\"867\":1}}],[\"ziplist\",{\"1\":{\"867\":14,\"876\":1,\"879\":21,\"888\":1}}],[\"zzz\",{\"1\":{\"810\":2}}],[\"zhangsan\",{\"1\":{\"995\":1,\"1014\":5,\"1015\":5}}],[\"zh\",{\"1\":{\"249\":3}}],[\"zhonghuasheng\",{\"1\":{\"243\":1}}],[\"zeromq\",{\"1\":{\"924\":1}}],[\"zero\",{\"1\":{\"226\":2,\"427\":1}}],[\"zookeeper等\",{\"1\":{\"23\":1}}],[\"检查锁是不是自己的\",{\"1\":{\"913\":1,\"921\":1}}],[\"检查表或字段是否存在\",{\"1\":{\"817\":2}}],[\"检查\",{\"1\":{\"817\":1}}],[\"检查该消息id是否已存在于set中\",{\"1\":{\"714\":1}}],[\"检查url模式是否正确匹配目标请求\",{\"1\":{\"607\":1}}],[\"检查用户是否已登录\",{\"1\":{\"598\":1}}],[\"检查请求参数和头信息\",{\"1\":{\"591\":1}}],[\"检查类信息\",{\"0\":{\"555\":1}}],[\"检查型异常\",{\"1\":{\"538\":3}}],[\"检查自上次加载\",{\"1\":{\"529\":1}}],[\"检查字符串是否包含字符集合中的任何字符\",{\"1\":{\"497\":1}}],[\"检查字符串是否包含子串\",{\"1\":{\"497\":1}}],[\"检查goos+goarch路径\",{\"1\":{\"396\":1}}],[\"检查的方式很粗暴\",{\"1\":{\"226\":1}}],[\"检查token是否在redis中\",{\"1\":{\"23\":1}}],[\"让内网中的其他人访问\",{\"1\":{\"1026\":1}}],[\"让内核来检查是否有网络事件产生\",{\"1\":{\"226\":1}}],[\"让操作系统自己刷\",{\"1\":{\"952\":1}}],[\"让其重试即可\",{\"1\":{\"927\":1}}],[\"让其他事务得以继续执行\",{\"1\":{\"820\":1}}],[\"让本就不富裕的服务器资源\",{\"1\":{\"927\":1}}],[\"让定时器在键过期时间来临\",{\"1\":{\"882\":1}}],[\"让存储引擎读取表中的第一条记录\",{\"1\":{\"817\":1}}],[\"让存储引擎定位符合条件的第一条记录\",{\"1\":{\"817\":1}}],[\"让\",{\"1\":{\"810\":3}}],[\"让这个\",{\"1\":{\"524\":1}}],[\"让这些请求到了\",{\"1\":{\"518\":1}}],[\"让我们通过汇编代码分析多返回值的实现机制\",{\"1\":{\"423\":1}}],[\"让一组可复用的函数运行在一组线程之上\",{\"1\":{\"378\":1}}],[\"让服务器做个验证\",{\"1\":{\"249\":1}}],[\"让服务器带宽\",{\"1\":{\"243\":1}}],[\"让客户端收到信息后发起断开tcp连接\",{\"1\":{\"237\":1}}],[\"让某种类型对象获得另一个类型对象的属性和方法\",{\"1\":{\"33\":1}}],[\"阻塞版\",{\"1\":{\"924\":1}}],[\"阻塞状态\",{\"1\":{\"820\":1}}],[\"阻塞\",{\"1\":{\"820\":1}}],[\"阻塞后\",{\"1\":{\"820\":1}}],[\"阻塞主线程\",{\"1\":{\"510\":1,\"511\":1}}],[\"阻塞发送\",{\"1\":{\"264\":2}}],[\"阻塞获取\",{\"1\":{\"226\":4}}],[\"阻塞和非阻塞io应用场景\",{\"1\":{\"226\":1}}],[\"阻塞i\",{\"1\":{\"226\":1}}],[\"阻塞io\",{\"1\":{\"226\":1}}],[\"挂起\",{\"1\":{\"226\":1}}],[\"挂载一个本地主机文件作为数据卷\",{\"0\":{\"115\":1}}],[\"挂载一个主机目录作为数据卷\",{\"0\":{\"113\":1}}],[\"挂载到容器里\",{\"1\":{\"110\":1}}],[\"挂载主机目录的默认权限是读写\",{\"1\":{\"113\":1}}],[\"挂载主机目录\",{\"1\":{\"105\":1}}],[\"信用卡号等\",{\"1\":{\"604\":1}}],[\"信任的一方签发的证书\",{\"1\":{\"249\":1}}],[\"信号驱动\",{\"1\":{\"226\":2}}],[\"信息会全部丢失\",{\"1\":{\"924\":1}}],[\"信息写入\",{\"1\":{\"810\":1}}],[\"信息是明文传输\",{\"1\":{\"249\":1}}],[\"信息发送给服务器\",{\"1\":{\"249\":1}}],[\"信息化\",{\"1\":{\"249\":1}}],[\"信息安全\",{\"1\":{\"243\":1}}],[\"信息\",{\"1\":{\"223\":1,\"249\":1,\"820\":1,\"879\":1}}],[\"探测客户端的心跳\",{\"1\":{\"226\":1}}],[\"读操作的流程\",{\"1\":{\"930\":1}}],[\"读操作阻塞在channel的goroutine列表\",{\"1\":{\"261\":1}}],[\"读穿透模式\",{\"1\":{\"930\":2}}],[\"读读\",{\"1\":{\"820\":1}}],[\"读锁还在占用着\",{\"1\":{\"820\":1}}],[\"读锁\",{\"1\":{\"820\":6}}],[\"读已提交\",{\"1\":{\"782\":1}}],[\"读未提交\",{\"1\":{\"782\":1,\"784\":1}}],[\"读提交隔离级别是\",{\"1\":{\"796\":1}}],[\"读提交隔离级别的工作原理\",{\"0\":{\"796\":1}}],[\"读提交隔离级别\",{\"1\":{\"743\":1}}],[\"读提交\",{\"1\":{\"743\":1,\"784\":2,\"810\":2}}],[\"读不到\",{\"1\":{\"524\":1}}],[\"读到了过期数据\",{\"1\":{\"777\":1}}],[\"读到\",{\"1\":{\"524\":1}}],[\"读\",{\"0\":{\"529\":1,\"532\":1},\"1\":{\"511\":1,\"512\":1,\"518\":1,\"524\":1,\"526\":1,\"810\":1,\"867\":1,\"870\":1,\"876\":1}}],[\"读写互斥\",{\"1\":{\"820\":3}}],[\"读写分离怎么实现\",{\"1\":{\"730\":1}}],[\"读写分离概念\",{\"1\":{\"730\":1}}],[\"读写分离\",{\"1\":{\"730\":1,\"807\":1},\"2\":{\"732\":1}}],[\"读写是非阻塞的\",{\"1\":{\"257\":1}}],[\"读写时是阻塞的\",{\"1\":{\"256\":1}}],[\"读取文件内容\",{\"1\":{\"1037\":1}}],[\"读取文件异常\",{\"1\":{\"541\":1}}],[\"读取数据的时候才能根据这个\",{\"1\":{\"770\":1}}],[\"读取并不以\",{\"1\":{\"770\":1}}],[\"读取配置参数\",{\"1\":{\"640\":1}}],[\"读取都是调用chanrecv函数做数据接收\",{\"1\":{\"265\":1}}],[\"读取也是\",{\"1\":{\"256\":1}}],[\"读取内核缓冲区的数据\",{\"1\":{\"226\":1}}],[\"读完后准备写\",{\"1\":{\"226\":1}}],[\"读性能提升\",{\"1\":{\"176\":1}}],[\"想一下如下场景\",{\"1\":{\"912\":1,\"921\":1}}],[\"想对\",{\"1\":{\"820\":2}}],[\"想获取一个\",{\"1\":{\"820\":1}}],[\"想知道\",{\"1\":{\"813\":1}}],[\"想要在嵌套的结构体为空值时\",{\"1\":{\"489\":1}}],[\"想要变成嵌套的json串\",{\"1\":{\"489\":1}}],[\"想要执行\",{\"1\":{\"381\":1}}],[\"想要连接的ip\",{\"1\":{\"226\":1}}],[\"想要连接的端口号\",{\"1\":{\"226\":1}}],[\"想在任何时候都能直接调用\",{\"1\":{\"223\":1}}],[\"想在单片机的内存中同时运行两个程序是做不到的\",{\"1\":{\"217\":1}}],[\"设负载因子为\",{\"1\":{\"864\":1}}],[\"设定一个处理线程只能同时有一个事务在执行\",{\"1\":{\"760\":1}}],[\"设计表结构时\",{\"1\":{\"807\":1}}],[\"设计的初衷就是为了让一个数据页中可以存放更多的行记录\",{\"1\":{\"770\":1}}],[\"设计\",{\"1\":{\"237\":1}}],[\"设备文件在\",{\"1\":{\"223\":1}}],[\"设置运行模式即可\",{\"1\":{\"1027\":1}}],[\"设置路由\",{\"1\":{\"1024\":1}}],[\"设置了超时的键的超时时间\",{\"1\":{\"944\":1}}],[\"设置a的值为5\",{\"1\":{\"930\":1}}],[\"设置太长会导致正常情况也没法使用\",{\"1\":{\"930\":1}}],[\"设置过期时间\",{\"1\":{\"911\":1,\"921\":1}}],[\"设置过去时间可以有效节约内存\",{\"1\":{\"882\":1}}],[\"设置指定的的值\",{\"1\":{\"873\":1}}],[\"设置事务等待锁的超时时间\",{\"1\":{\"820\":1}}],[\"设置成\",{\"1\":{\"817\":1}}],[\"设置组提交的两个参数\",{\"1\":{\"810\":1}}],[\"设置的上限是\",{\"1\":{\"810\":1}}],[\"设置content\",{\"1\":{\"1032\":1}}],[\"设置cookie为httponly和secure\",{\"1\":{\"692\":1}}],[\"设置cors头信息\",{\"1\":{\"601\":1}}],[\"设置会话超时时间\",{\"1\":{\"691\":1}}],[\"设置状态码\",{\"1\":{\"676\":1}}],[\"设置内容类型\",{\"1\":{\"675\":1}}],[\"设置响应状态\",{\"0\":{\"676\":1}}],[\"设置响应头content\",{\"1\":{\"1032\":1}}],[\"设置响应头\",{\"0\":{\"675\":1},\"1\":{\"675\":1}}],[\"设置响应内容类型\",{\"1\":{\"652\":1}}],[\"设置响应编码\",{\"1\":{\"599\":1,\"688\":1}}],[\"设置请求编码\",{\"1\":{\"599\":1}}],[\"设置字段值\",{\"1\":{\"557\":1}}],[\"设置私有字段可访问\",{\"1\":{\"557\":1}}],[\"设置加载标志为\",{\"1\":{\"531\":2}}],[\"设置返回值\",{\"1\":{\"477\":1}}],[\"设置编译阶段允许访问的包\",{\"1\":{\"392\":1}}],[\"设置只有一个\",{\"1\":{\"367\":1}}],[\"设置为大于\",{\"1\":{\"810\":1}}],[\"设置为\",{\"0\":{\"374\":1},\"1\":{\"367\":1,\"525\":1,\"810\":3,\"820\":1,\"864\":1,\"924\":1}}],[\"设置为1为开启\",{\"1\":{\"237\":1}}],[\"设置系统时间\",{\"1\":{\"210\":1}}],[\"设置在一段延迟后自动保存文件\",{\"1\":{\"3\":1}}],[\"设置\",{\"0\":{\"3\":1},\"1\":{\"122\":1,\"1032\":1}}],[\"找到上一个\",{\"1\":{\"879\":1}}],[\"找到\",{\"1\":{\"836\":1}}],[\"找到这一行\",{\"1\":{\"810\":1}}],[\"找到数据文件\",{\"1\":{\"770\":1}}],[\"找一个与φ\",{\"1\":{\"249\":2}}],[\"找一找临时文件抢救一下\",{\"1\":{\"223\":1}}],[\"找\",{\"1\":{\"223\":1,\"512\":1}}],[\"～\",{\"1\":{\"223\":1,\"810\":2}}],[\"浏览器\",{\"1\":{\"661\":1}}],[\"浏览器会根据前面的响应头信息\",{\"1\":{\"1032\":1}}],[\"浏览器会将sessionid放置到请求头中\",{\"1\":{\"249\":1}}],[\"浏览器会记录新的url\",{\"1\":{\"240\":1}}],[\"浏览器收到响应后通常会保存下\",{\"1\":{\"249\":1}}],[\"浏览器收到证书后可以使用\",{\"1\":{\"240\":1,\"249\":1}}],[\"浏览器关闭后就消失了\",{\"1\":{\"249\":1}}],[\"浏览器可以在获取资源后直接跳转到它指示的位置\",{\"1\":{\"249\":1}}],[\"浏览器配置就是那里面\",{\"1\":{\"223\":1}}],[\"浏览器和服务器迅速扩展内容使其用途更广\",{\"1\":{\"249\":1}}],[\"浏览器和\",{\"1\":{\"223\":1}}],[\"桌面等文件夹\",{\"1\":{\"223\":1}}],[\"桌面版\",{\"1\":{\"223\":1}}],[\"放进队列之后\",{\"1\":{\"897\":1}}],[\"放进全局队列\",{\"1\":{\"374\":1}}],[\"放心\",{\"1\":{\"810\":1}}],[\"放回\",{\"1\":{\"381\":1}}],[\"放到全局队列\",{\"1\":{\"374\":1}}],[\"放入到\",{\"1\":{\"373\":1}}],[\"放好\",{\"1\":{\"265\":1}}],[\"放在了v1子目录下\",{\"1\":{\"969\":1}}],[\"放在\",{\"1\":{\"249\":1,\"894\":1}}],[\"放在malloc的内存池里\",{\"1\":{\"217\":1}}],[\"放大\",{\"1\":{\"243\":1}}],[\"放大攻击\",{\"1\":{\"243\":1}}],[\"放一份当前文本的\",{\"1\":{\"223\":1}}],[\"安装\",{\"0\":{\"1023\":1}}],[\"安装kratos\",{\"1\":{\"968\":1}}],[\"安装与升级\",{\"0\":{\"968\":1}}],[\"安装目录下的\",{\"1\":{\"854\":2}}],[\"安装完\",{\"1\":{\"854\":1}}],[\"安装的一些工具\",{\"1\":{\"223\":1}}],[\"安装在这里比较好\",{\"1\":{\"223\":1}}],[\"安全框架\",{\"1\":{\"698\":1}}],[\"安全考虑\",{\"0\":{\"604\":1}}],[\"安全限制问题\",{\"1\":{\"552\":1}}],[\"安全\",{\"1\":{\"249\":2},\"2\":{\"1061\":1}}],[\"安全性很高\",{\"1\":{\"930\":1}}],[\"安全性和性能折中的方案就是参数\",{\"1\":{\"810\":1}}],[\"安全性\",{\"0\":{\"914\":1},\"1\":{\"249\":1,\"646\":1,\"909\":1,\"921\":2}}],[\"安全协议\",{\"1\":{\"249\":1},\"2\":{\"245\":1}}],[\"安全散列算法\",{\"1\":{\"73\":1}}],[\"安全加密\",{\"0\":{\"72\":1}}],[\"盘之类的设备\",{\"1\":{\"223\":1}}],[\"盘的内容\",{\"1\":{\"223\":1}}],[\"盘自动给我挂载到\",{\"1\":{\"223\":1}}],[\"盘\",{\"1\":{\"223\":2}}],[\"差不多意思\",{\"1\":{\"462\":1}}],[\"差不多\",{\"1\":{\"223\":1,\"770\":1}}],[\"鼠标\",{\"1\":{\"223\":1}}],[\"你对限流了解多少\",{\"1\":{\"933\":1}}],[\"你怎么知道gc回来了\",{\"1\":{\"918\":1,\"921\":1}}],[\"你可能需要同时重命名用户及其对应的权限\",{\"1\":{\"840\":1}}],[\"你可以点进去查看源码\",{\"1\":{\"957\":1}}],[\"你可以在官方\",{\"1\":{\"956\":1}}],[\"你可以在定义消息类型的字段时使用package说明符\",{\"1\":{\"229\":1}}],[\"你可以看查\",{\"1\":{\"820\":1}}],[\"你可以看到\",{\"1\":{\"223\":1}}],[\"你可以判断出sql语句是否有效地使用了索引\",{\"1\":{\"807\":1}}],[\"你可以对指针进行算术运算\",{\"1\":{\"460\":1}}],[\"你好\",{\"1\":{\"813\":1}}],[\"你就可以在写数据时只写主库\",{\"1\":{\"810\":1}}],[\"你在主库上执行的结果并不是你在从库执行的结果\",{\"1\":{\"810\":1}}],[\"你会先连接到这个数据库上\",{\"1\":{\"817\":1}}],[\"你会观察到使用的虚拟内存空间很大\",{\"1\":{\"810\":1}}],[\"你会发现\",{\"1\":{\"223\":1}}],[\"你不就连不上了\",{\"1\":{\"807\":1}}],[\"你应该要清楚系统的性能瓶颈在哪儿\",{\"1\":{\"807\":1}}],[\"你只能将它指向\",{\"1\":{\"459\":1}}],[\"你也不知道\",{\"1\":{\"249\":1}}],[\"你超级用户想用当然可以\",{\"1\":{\"223\":1}}],[\"你的\",{\"1\":{\"223\":1}}],[\"你的代码中不应该有打印\",{\"1\":{\"88\":1}}],[\"你想打开某些设备看看里面的内容\",{\"1\":{\"223\":1}}],[\"你修改这个数字就可以修改屏幕亮度\",{\"1\":{\"223\":1}}],[\"存有\",{\"1\":{\"944\":1}}],[\"存一条数据\",{\"1\":{\"939\":1}}],[\"存\",{\"1\":{\"903\":2}}],[\"存超了就需要重新遍历浪费\",{\"1\":{\"879\":1}}],[\"存到\",{\"1\":{\"770\":1}}],[\"存元素\",{\"1\":{\"265\":1}}],[\"存在磁盘中\",{\"1\":{\"952\":1}}],[\"存在的问题\",{\"1\":{\"912\":1,\"913\":1,\"921\":2}}],[\"存在些许精准度问题\",{\"1\":{\"813\":1}}],[\"存在且value有效\",{\"1\":{\"529\":1}}],[\"存在\",{\"1\":{\"524\":1,\"527\":1,\"820\":2,\"894\":1}}],[\"存在安全风险的问题\",{\"1\":{\"249\":1}}],[\"存在问题\",{\"1\":{\"249\":1}}],[\"存在这里的文件\",{\"1\":{\"223\":1}}],[\"存放在buf\",{\"1\":{\"873\":1}}],[\"存放到\",{\"1\":{\"813\":1}}],[\"存放主键值\",{\"1\":{\"813\":1}}],[\"存放实际数据\",{\"1\":{\"813\":2}}],[\"存放索引\",{\"1\":{\"813\":2}}],[\"存放的是回滚数据的区的集合\",{\"1\":{\"770\":1}}],[\"存放\",{\"1\":{\"516\":1,\"770\":2,\"813\":1}}],[\"存放自己的配置文件等等信息\",{\"1\":{\"223\":1}}],[\"存放很多程序的配置信息\",{\"1\":{\"223\":1}}],[\"存放着可执行文件或可执行文件的链接\",{\"1\":{\"223\":1}}],[\"存储含过期时间的\",{\"1\":{\"943\":1}}],[\"存储形式为\",{\"0\":{\"937\":1}}],[\"存储服务崩溃了\",{\"1\":{\"930\":1}}],[\"存储容量\",{\"2\":{\"902\":1}}],[\"存储整个节点除了它自身之外的长度\",{\"1\":{\"879\":1}}],[\"存储看成一个数组\",{\"1\":{\"864\":1}}],[\"存储\",{\"1\":{\"864\":1,\"873\":1,\"891\":1,\"937\":1,\"944\":1}}],[\"存储空间占用\",{\"1\":{\"770\":1}}],[\"存储空间的大小\",{\"1\":{\"33\":1}}],[\"存储的一行行记录会被存放在这里\",{\"1\":{\"748\":1}}],[\"存储引擎提供了个\",{\"1\":{\"820\":1}}],[\"存储引擎提供了一种\",{\"1\":{\"820\":1}}],[\"存储引擎默认的事务隔离级别正是可重复读\",{\"1\":{\"820\":1}}],[\"存储引擎定位到二级索引后\",{\"1\":{\"817\":1}}],[\"存储引擎在二级索引定位到记录后\",{\"1\":{\"817\":1}}],[\"存储引擎根据二级索引的\",{\"1\":{\"817\":1}}],[\"存储引擎根据执行器的请求进行数据的读取\",{\"1\":{\"734\":1}}],[\"存储引擎把下一条记录取出后就将其返回给执行器\",{\"1\":{\"817\":1}}],[\"存储引擎通过主键索引的\",{\"1\":{\"817\":1}}],[\"存储引擎就是这样的数据组织方式\",{\"1\":{\"813\":1}}],[\"存储引擎支持的索引有\",{\"1\":{\"813\":1}}],[\"存储引擎实现的日志\",{\"1\":{\"810\":1}}],[\"存储引擎生成的\",{\"1\":{\"810\":1}}],[\"存储引擎会根据不同的场景选择不同的列作为索引\",{\"1\":{\"813\":1}}],[\"存储引擎会先写\",{\"1\":{\"810\":1}}],[\"存储引擎会自动将溢出的数据存放到\",{\"1\":{\"770\":1}}],[\"存储引擎设计了一个\",{\"1\":{\"810\":1}}],[\"存储引擎层负责数据的存储和提取\",{\"1\":{\"817\":1}}],[\"存储引擎层来过滤\",{\"1\":{\"813\":1}}],[\"存储引擎层生成的日志\",{\"1\":{\"810\":2}}],[\"存储引擎层\",{\"1\":{\"800\":1,\"813\":1}}],[\"存储引擎磁盘管理的最小单元\",{\"1\":{\"770\":1}}],[\"存储引擎是用\",{\"1\":{\"770\":2}}],[\"存储引擎是参与者\",{\"1\":{\"765\":1,\"810\":1}}],[\"存储引擎\",{\"1\":{\"770\":2},\"2\":{\"772\":1}}],[\"存储引擎中的\",{\"1\":{\"817\":1}}],[\"存储引擎中占用\",{\"1\":{\"813\":1}}],[\"存储引擎中\",{\"1\":{\"765\":1,\"810\":1}}],[\"存储引擎有\",{\"1\":{\"757\":1,\"810\":1}}],[\"存储引擎以16kb大小的页作为磁盘与内存交互的基本单位\",{\"1\":{\"748\":1}}],[\"存储引擎的日志\",{\"1\":{\"737\":1,\"810\":1}}],[\"存储引擎操作\",{\"1\":{\"734\":1}}],[\"存储引擎接口\",{\"1\":{\"734\":1}}],[\"存储数据不丢失\",{\"1\":{\"710\":1}}],[\"存储阶段的ack机制\",{\"1\":{\"710\":1}}],[\"存储阶段\",{\"0\":{\"710\":1},\"1\":{\"708\":1,\"709\":1,\"713\":1}}],[\"存储方式\",{\"1\":{\"571\":1}}],[\"存储当前channel由于缓冲区\",{\"1\":{\"259\":1}}],[\"存储管理\",{\"2\":{\"225\":1}}],[\"存储一些额外的数据\",{\"1\":{\"942\":1}}],[\"存储一些程序的临时文件\",{\"1\":{\"223\":1}}],[\"存储一批任务数据\",{\"1\":{\"867\":1}}],[\"存储一个地址\",{\"1\":{\"33\":1}}],[\"存储在系统密码文件\",{\"1\":{\"190\":1}}],[\"管理存储的\",{\"1\":{\"942\":1}}],[\"管理\",{\"1\":{\"941\":2}}],[\"管理成本低\",{\"1\":{\"930\":1}}],[\"管理员用户名\",{\"1\":{\"840\":1}}],[\"管理连接\",{\"1\":{\"817\":1}}],[\"管理和分配计算机资源\",{\"1\":{\"220\":1}}],[\"管道\",{\"1\":{\"190\":1}}],[\"诸如命令行解释器\",{\"1\":{\"220\":1}}],[\"未完成\",{\"1\":{\"897\":1}}],[\"未使用的索引\",{\"1\":{\"807\":1}}],[\"未被修改\",{\"1\":{\"531\":1}}],[\"未命中的情况\",{\"1\":{\"530\":1}}],[\"未初始化的指针的零值是\",{\"1\":{\"459\":1}}],[\"未发生写操作\",{\"1\":{\"217\":1}}],[\"未开启swap\",{\"1\":{\"217\":1}}],[\"子查询\",{\"0\":{\"1012\":1}}],[\"子进程写数据到临时的\",{\"1\":{\"952\":1}}],[\"子进程进行写操作的时候\",{\"1\":{\"217\":1}}],[\"子线程运行\",{\"1\":{\"897\":1}}],[\"子句中\",{\"1\":{\"813\":1}}],[\"子句的\",{\"1\":{\"813\":1}}],[\"子句的顺序并不重要\",{\"1\":{\"813\":1}}],[\"子句\",{\"1\":{\"807\":2}}],[\"子业务\",{\"1\":{\"722\":1}}],[\"子业务分区\",{\"0\":{\"722\":1}}],[\"子网掩码等\",{\"1\":{\"246\":1}}],[\"子类\",{\"1\":{\"33\":1}}],[\"八\",{\"0\":{\"527\":1},\"1\":{\"217\":1}}],[\"七\",{\"0\":{\"526\":1},\"1\":{\"217\":1}}],[\"物理存储\",{\"1\":{\"813\":1}}],[\"物理内存为4gb\",{\"1\":{\"217\":1}}],[\"物理地址对程序不可见\",{\"1\":{\"217\":1}}],[\"物理地址\",{\"1\":{\"217\":1}}],[\"六\",{\"0\":{\"521\":1},\"1\":{\"217\":1,\"730\":1}}],[\"涉及到数据库访问操作\",{\"1\":{\"243\":1}}],[\"涉及到间接寻址\",{\"1\":{\"217\":1}}],[\"涉及的两种系统调用\",{\"1\":{\"217\":1}}],[\"非二进制安全\",{\"1\":{\"873\":1}}],[\"非唯一索引\",{\"1\":{\"820\":2}}],[\"非叶子节点\",{\"1\":{\"813\":2}}],[\"非真实数据部分所占字节\",{\"1\":{\"770\":1}}],[\"非常快\",{\"1\":{\"956\":1}}],[\"非常安全\",{\"1\":{\"952\":1}}],[\"非常慢\",{\"1\":{\"952\":1}}],[\"非常类似\",{\"1\":{\"770\":1}}],[\"非常像\",{\"1\":{\"770\":1}}],[\"非常重要\",{\"1\":{\"644\":1}}],[\"非终端处理\",{\"1\":{\"578\":1}}],[\"非检查型异常\",{\"1\":{\"538\":2}}],[\"非空接口在运行时由以下结构表示\",{\"1\":{\"306\":1}}],[\"非空接口结构\",{\"0\":{\"306\":1}}],[\"非空接口\",{\"0\":{\"304\":1}}],[\"非阻塞模式\",{\"1\":{\"265\":1}}],[\"非阻塞i\",{\"1\":{\"226\":1}}],[\"非阻塞io\",{\"1\":{\"226\":1}}],[\"非对称加密\",{\"1\":{\"249\":1}}],[\"非活跃页\",{\"1\":{\"217\":1}}],[\"非幂等性接口的危害场景\",{\"1\":{\"23\":1}}],[\"自动解析并绑定到结构体中\",{\"1\":{\"1038\":1}}],[\"自动事务\",{\"0\":{\"1014\":1}}],[\"自动生成表结构\",{\"0\":{\"982\":1}}],[\"自动地在后台fork一个子进程\",{\"1\":{\"952\":1}}],[\"自动快照时\",{\"1\":{\"952\":1}}],[\"自动关闭资源\",{\"1\":{\"541\":1}}],[\"自然是再上一层的抽象\",{\"1\":{\"942\":1}}],[\"自然是dict\",{\"1\":{\"940\":1}}],[\"自然会索引失效\",{\"1\":{\"813\":1}}],[\"自然没法走索引\",{\"1\":{\"813\":2}}],[\"自然就不需要考虑\",{\"1\":{\"820\":1}}],[\"自然就不存在父类子类一说\",{\"1\":{\"461\":1}}],[\"自然就知道要释放多大的内存\",{\"1\":{\"217\":1}}],[\"自带的引擎是\",{\"1\":{\"810\":1}}],[\"自适应哈希索引\",{\"1\":{\"810\":1}}],[\"自增锁还是要等语句结束后才被释放\",{\"1\":{\"820\":1}}],[\"自增锁在申请之后就马上释放\",{\"1\":{\"820\":1}}],[\"自增\",{\"1\":{\"530\":1}}],[\"自增完成后\",{\"1\":{\"264\":1}}],[\"自定义列名\",{\"1\":{\"983\":1}}],[\"自定义日志配置\",{\"1\":{\"980\":1}}],[\"自定义日志包通过\",{\"1\":{\"957\":1}}],[\"自定义日志包提供了默认的\",{\"1\":{\"957\":1}}],[\"自定义servlet类\",{\"1\":{\"667\":1}}],[\"自定义运行时异常\",{\"1\":{\"545\":1}}],[\"自定义检查型异常\",{\"1\":{\"545\":1}}],[\"自定义异常\",{\"0\":{\"544\":1}}],[\"自定义方法的位置\",{\"0\":{\"461\":1}}],[\"自定义方法\",{\"1\":{\"460\":1}}],[\"自定义精度\",{\"1\":{\"33\":1}}],[\"自己的缓存\",{\"1\":{\"753\":1}}],[\"自己加密的自己也反解不出来\",{\"1\":{\"249\":1}}],[\"自己发明新的方法\",{\"1\":{\"249\":1}}],[\"自身套接字\",{\"1\":{\"226\":1}}],[\"共\",{\"1\":{\"900\":1,\"944\":1}}],[\"共加了两个锁\",{\"1\":{\"820\":2}}],[\"共有三个阶段\",{\"1\":{\"817\":1}}],[\"共有三个文件\",{\"1\":{\"770\":1}}],[\"共享和排他的间隙锁是没有区别的\",{\"1\":{\"820\":1}}],[\"共享锁\",{\"1\":{\"820\":2}}],[\"共享表锁\",{\"1\":{\"820\":1}}],[\"共享外网访问\",{\"1\":{\"246\":1}}],[\"共享内存等\",{\"1\":{\"217\":1}}],[\"共同完成\",{\"1\":{\"764\":1,\"810\":1}}],[\"共同目标\",{\"1\":{\"249\":1}}],[\"共同\",{\"1\":{\"217\":1}}],[\"源代码定义\",{\"0\":{\"351\":1}}],[\"源码日志\",{\"1\":{\"936\":1}}],[\"源码\",{\"1\":{\"817\":1,\"957\":1}}],[\"源码走读\",{\"0\":{\"528\":1}}],[\"源码学习\",{\"1\":{\"508\":1}}],[\"源码如下\",{\"1\":{\"264\":1}}],[\"源码分析\",{\"1\":{\"263\":1,\"903\":1}}],[\"源码里默认定义了一个阈值\",{\"1\":{\"217\":1}}],[\"源ip响应\",{\"1\":{\"243\":1}}],[\"源ip地址\",{\"1\":{\"237\":1,\"243\":1}}],[\"源端口号\",{\"1\":{\"237\":1}}],[\"源端口\",{\"1\":{\"237\":2}}],[\"源\",{\"1\":{\"237\":2}}],[\"源指针会被置空\",{\"1\":{\"33\":1}}],[\"两台业务服务器在同一时间发出两条请求\",{\"1\":{\"930\":1}}],[\"两份日志之间的逻辑不一致\",{\"1\":{\"810\":1}}],[\"两大作用\",{\"1\":{\"810\":1}}],[\"两位拳击手就可以直接开打\",{\"1\":{\"764\":1,\"810\":1}}],[\"两位拳击手\",{\"1\":{\"764\":1,\"810\":1}}],[\"两阶段提交是以\",{\"1\":{\"810\":1}}],[\"两阶段提交虽然能够保证\",{\"1\":{\"810\":1}}],[\"两阶段提交虽然能够保证单事务两个日志的内容一致\",{\"1\":{\"766\":1}}],[\"两阶段提交虽然保证了两个日志文件的数据一致性\",{\"1\":{\"766\":1,\"810\":1}}],[\"两阶段提交有什么问题\",{\"0\":{\"766\":1},\"1\":{\"810\":1}}],[\"两阶段提交把单个事务的提交拆分成了\",{\"1\":{\"764\":1,\"810\":1}}],[\"两阶段提交其实是分布式事务一致性协议\",{\"1\":{\"764\":1,\"810\":1}}],[\"两阶段提交的过程是怎样的\",{\"1\":{\"810\":1}}],[\"两阶段提交的过程\",{\"0\":{\"765\":1}}],[\"两阶段提交的概念\",{\"0\":{\"764\":1}}],[\"两阶段提交的提出\",{\"0\":{\"763\":1}}],[\"两阶段提交\",{\"0\":{\"762\":1},\"1\":{\"763\":1,\"810\":4}}],[\"两阶段\",{\"1\":{\"727\":1}}],[\"两者有很多不同的配置\",{\"1\":{\"957\":1}}],[\"两者输出的字段内容也略有差异\",{\"1\":{\"957\":1}}],[\"两者在实现思路上是一样的\",{\"1\":{\"957\":1}}],[\"两者在\",{\"1\":{\"813\":1}}],[\"两者结构相似\",{\"1\":{\"249\":1}}],[\"两者的目标都是实现网络设备之间的互操作性和通信\",{\"1\":{\"249\":1}}],[\"两者都采用了分层的概念\",{\"1\":{\"249\":1}}],[\"两种事务开启命令\",{\"1\":{\"785\":1}}],[\"两种协议\",{\"1\":{\"249\":1}}],[\"两种系统调用的设计目的\",{\"1\":{\"217\":1}}],[\"两种系统调用的异同\",{\"1\":{\"217\":1}}],[\"两种系统调用的阈值\",{\"1\":{\"217\":1}}],[\"两个构造函数源码\",{\"1\":{\"957\":1}}],[\"两个构造函数外\",{\"1\":{\"957\":1}}],[\"两个哈希表\",{\"1\":{\"942\":1}}],[\"两个终端均显示如下\",{\"1\":{\"924\":1}}],[\"两个客户端订阅\",{\"1\":{\"924\":1}}],[\"两个字段差就是预留空间的大小\",{\"1\":{\"873\":1}}],[\"两个事务的加锁过程\",{\"1\":{\"820\":1}}],[\"两个事务是可以同时持有的\",{\"1\":{\"820\":1}}],[\"两个事务都陷入了等待状态\",{\"1\":{\"820\":1}}],[\"两个日志的内容一致\",{\"1\":{\"810\":1}}],[\"两个日志的过程中\",{\"1\":{\"810\":1}}],[\"两个日志的提交顺序一致\",{\"1\":{\"766\":1,\"810\":1}}],[\"两个都是紧凑的行格式\",{\"1\":{\"770\":1}}],[\"两个\",{\"0\":{\"517\":1},\"1\":{\"512\":1,\"820\":1}}],[\"两个数值\",{\"1\":{\"374\":1}}],[\"两个命令是等价的\",{\"1\":{\"136\":1}}],[\"两个容器的进程可以通过\",{\"1\":{\"125\":1}}],[\"两个容器除了网络方面\",{\"1\":{\"125\":1}}],[\"两个难点\",{\"1\":{\"79\":1}}],[\"两个函数参数不同\",{\"1\":{\"33\":1}}],[\"两个函数参数相同\",{\"1\":{\"33\":1}}],[\"偷\",{\"1\":{\"217\":1}}],[\"获得db类型实例\",{\"1\":{\"976\":1}}],[\"获得了redlock\",{\"1\":{\"918\":1,\"921\":1}}],[\"获得一个与物理网络相同的ip地址\",{\"1\":{\"246\":1}}],[\"获得新的内存空间\",{\"1\":{\"217\":1}}],[\"获取表单参数的方法\",{\"1\":{\"1037\":1}}],[\"获取参数\",{\"1\":{\"1021\":1}}],[\"获取参数map\",{\"1\":{\"670\":1}}],[\"获取查询的返回的记录数\",{\"1\":{\"992\":1}}],[\"获取对应的数据\",{\"1\":{\"888\":1}}],[\"获取各属性值\",{\"1\":{\"873\":1}}],[\"获取主键值\",{\"1\":{\"817\":2}}],[\"获取权限\",{\"1\":{\"817\":1}}],[\"获取队列中的事务组\",{\"1\":{\"810\":1}}],[\"获取数据的时候会优先查询缓存\",{\"1\":{\"730\":1}}],[\"获取上传的文件部分\",{\"1\":{\"693\":1}}],[\"获取上下文路径\",{\"1\":{\"672\":1}}],[\"获取requestdispatcher\",{\"1\":{\"681\":1}}],[\"获取二进制输出流\",{\"1\":{\"677\":1}}],[\"获取字符长度的时间复杂度是\",{\"1\":{\"873\":1}}],[\"获取字符输出流\",{\"1\":{\"677\":1}}],[\"获取字段值\",{\"1\":{\"557\":1}}],[\"获取会话\",{\"1\":{\"673\":1}}],[\"获取会话和cookie\",{\"0\":{\"673\":1}}],[\"获取单个请求头\",{\"1\":{\"671\":1}}],[\"获取单个参数值\",{\"1\":{\"670\":1}}],[\"获取同名参数的多个值\",{\"1\":{\"670\":1}}],[\"获取输出流\",{\"1\":{\"652\":1}}],[\"获取新值\",{\"1\":{\"633\":1,\"634\":1,\"635\":1}}],[\"获取的是旧值\",{\"1\":{\"633\":1,\"634\":1,\"635\":1}}],[\"获取请求uri\",{\"1\":{\"672\":1}}],[\"获取请求url\",{\"1\":{\"672\":1}}],[\"获取请求路径\",{\"0\":{\"672\":1}}],[\"获取请求头\",{\"0\":{\"671\":1}}],[\"获取请求参数\",{\"0\":{\"670\":1,\"1034\":1}}],[\"获取请求开始时间\",{\"1\":{\"626\":1}}],[\"获取请求对象\",{\"1\":{\"626\":2}}],[\"获取请求的uri\",{\"1\":{\"598\":1}}],[\"获取当前会话\",{\"1\":{\"598\":1,\"625\":2}}],[\"获取servlet路径\",{\"1\":{\"672\":1}}],[\"获取servletcontext对象\",{\"1\":{\"624\":2}}],[\"获取servlet上下文\",{\"1\":{\"590\":1}}],[\"获取sockadd结构体长度\",{\"1\":{\"226\":1}}],[\"获取初始化参数\",{\"1\":{\"590\":1}}],[\"获取方法的修饰符\",{\"1\":{\"558\":1}}],[\"获取特定方法\",{\"1\":{\"558\":1}}],[\"获取特定字段\",{\"1\":{\"557\":1}}],[\"获取特定构造函数\",{\"1\":{\"556\":1}}],[\"获取所有cookie\",{\"1\":{\"673\":1}}],[\"获取所有请求头名称\",{\"1\":{\"671\":1}}],[\"获取所有参数名\",{\"1\":{\"670\":1}}],[\"获取所有方法\",{\"1\":{\"558\":1}}],[\"获取所有公共方法\",{\"1\":{\"558\":1}}],[\"获取所有公共构造函数\",{\"1\":{\"556\":1}}],[\"获取所有字段\",{\"1\":{\"557\":1}}],[\"获取公共字段\",{\"1\":{\"557\":1}}],[\"获取实现的接口\",{\"1\":{\"555\":1}}],[\"获取class对象\",{\"0\":{\"553\":1},\"1\":{\"556\":1,\"557\":1,\"558\":1}}],[\"获取和设置对象字段的值\",{\"1\":{\"551\":1}}],[\"获取任何类的信息\",{\"1\":{\"551\":1}}],[\"获取\",{\"1\":{\"529\":2}}],[\"获取到\",{\"1\":{\"523\":1}}],[\"获取到了才有资格进行请求处理\",{\"1\":{\"23\":1}}],[\"获取结果\",{\"1\":{\"505\":1}}],[\"获取锁之后gc了\",{\"1\":{\"918\":1,\"921\":1}}],[\"获取锁和释放锁的过程中\",{\"1\":{\"917\":1,\"921\":1}}],[\"获取锁\",{\"1\":{\"381\":1}}],[\"获取资源的元信息\",{\"1\":{\"249\":1}}],[\"获取资源\",{\"1\":{\"249\":1}}],[\"标志是否结束\",{\"1\":{\"879\":1}}],[\"标志这是\",{\"1\":{\"879\":1}}],[\"标志位\",{\"1\":{\"229\":1}}],[\"标识\",{\"1\":{\"770\":1,\"810\":1}}],[\"标识此条数据是否被删除\",{\"1\":{\"770\":1}}],[\"标识符\",{\"1\":{\"433\":1}}],[\"标识符大小写\",{\"0\":{\"433\":1}}],[\"标头的帮助下\",{\"1\":{\"249\":1}}],[\"标头的概念\",{\"1\":{\"249\":1}}],[\"标签\",{\"1\":{\"249\":1}}],[\"标准库一样开箱即用\",{\"1\":{\"957\":1}}],[\"标准库风格的\",{\"1\":{\"957\":1}}],[\"标准库\",{\"1\":{\"957\":1}}],[\"标准库的\",{\"1\":{\"217\":1}}],[\"标准\",{\"1\":{\"906\":1}}],[\"标准的跳表的限制\",{\"1\":{\"885\":1}}],[\"标准化的协议\",{\"1\":{\"249\":1}}],[\"标准化时间\",{\"1\":{\"249\":1}}],[\"标量值类型\",{\"1\":{\"229\":1}}],[\"标记是哪个分类\",{\"1\":{\"873\":1}}],[\"标记为\",{\"1\":{\"770\":1}}],[\"标记为可读或可写\",{\"1\":{\"226\":1}}],[\"标记该页为脏页\",{\"1\":{\"753\":1}}],[\"标记该页是否存在等\",{\"1\":{\"217\":1}}],[\"标记\",{\"1\":{\"516\":1}}],[\"标记资源所在位置\",{\"1\":{\"249\":1}}],[\"标记还可以多次使用来绑定多个端口\",{\"1\":{\"117\":1}}],[\"标记来指定\",{\"1\":{\"117\":1}}],[\"标记来将\",{\"1\":{\"110\":1}}],[\"标记时\",{\"1\":{\"117\":1}}],[\"标记也可以从主机挂载单个文件到容器中\",{\"1\":{\"115\":1}}],[\"标记可以指定挂载一个本地主机的目录到容器中去\",{\"1\":{\"113\":1}}],[\"快照触发间隔比较难确定\",{\"1\":{\"952\":1}}],[\"快照读语句\",{\"1\":{\"794\":1}}],[\"快照读\",{\"1\":{\"743\":1,\"783\":1}}],[\"快的\",{\"1\":{\"888\":1}}],[\"快\",{\"1\":{\"813\":1,\"956\":1}}],[\"快表等\",{\"1\":{\"217\":1}}],[\"快速返回长度\",{\"1\":{\"873\":1}}],[\"快速排序\",{\"1\":{\"813\":1}}],[\"快速掌握java\",{\"1\":{\"576\":1,\"612\":1,\"644\":1}}],[\"快速上手篇\",{\"1\":{\"432\":1}}],[\"快速统计每个关键字被搜索的次数\",{\"1\":{\"79\":1}}],[\"快速\",{\"1\":{\"20\":1}}],[\"转过来之后是81\",{\"1\":{\"770\":1}}],[\"转发\",{\"1\":{\"682\":1}}],[\"转发与重定向的区别\",{\"1\":{\"682\":1}}],[\"转发请求\",{\"1\":{\"681\":1}}],[\"转换的过程是使用了函数\",{\"1\":{\"813\":1}}],[\"转换成\",{\"1\":{\"813\":2,\"873\":1}}],[\"转换成一个可以比较的整数\",{\"1\":{\"460\":1}}],[\"转换为十进制是18\",{\"1\":{\"770\":1}}],[\"转换为http请求以获取更多信息\",{\"1\":{\"584\":1}}],[\"转换为大写\",{\"1\":{\"499\":1}}],[\"转换为小写\",{\"1\":{\"499\":1}}],[\"转换原理\",{\"0\":{\"357\":1}}],[\"转移\",{\"1\":{\"381\":1}}],[\"转移到其他可运行的线程上\",{\"1\":{\"378\":1}}],[\"转移一个unique\",{\"1\":{\"33\":1}}],[\"转化为字符串被用于临时场景\",{\"1\":{\"360\":1}}],[\"转化是否一定发生内存拷贝\",{\"0\":{\"360\":1}}],[\"转义使用的是\",{\"1\":{\"249\":2}}],[\"转址旁路缓存\",{\"1\":{\"217\":1}}],[\"芯片中\",{\"1\":{\"217\":1}}],[\"整数\",{\"1\":{\"873\":1}}],[\"整数型\",{\"1\":{\"440\":1}}],[\"整合了写和更新操作\",{\"1\":{\"531\":1}}],[\"整个项目启动的入口文件\",{\"1\":{\"962\":1}}],[\"整个集群还是可用的\",{\"1\":{\"917\":1,\"921\":1}}],[\"整个数据库就处于只读状态了\",{\"1\":{\"820\":1}}],[\"整个数据库中\",{\"1\":{\"813\":1}}],[\"整个数据库还有哪些其他活着的事务\",{\"1\":{\"744\":1}}],[\"整个\",{\"1\":{\"520\":1,\"867\":1,\"873\":1}}],[\"整个循环都是用这一个\",{\"1\":{\"453\":1}}],[\"整个程序的执行仅限于程序中的某一部分\",{\"1\":{\"217\":1}}],[\"整体\",{\"1\":{\"879\":1}}],[\"整体看成无序的就行\",{\"1\":{\"870\":1}}],[\"整体结构\",{\"0\":{\"325\":1},\"1\":{\"879\":1}}],[\"整体架构优化\",{\"1\":{\"807\":1}}],[\"整体架构\",{\"0\":{\"156\":1}}],[\"整体架构采用\",{\"1\":{\"100\":1}}],[\"整体思路\",{\"1\":{\"20\":1}}],[\"程序对数据库进行一次检查\",{\"1\":{\"882\":1}}],[\"程序会顺带迁移当前\",{\"1\":{\"864\":1}}],[\"程序控制\",{\"1\":{\"568\":1}}],[\"程序将终止\",{\"1\":{\"479\":1}}],[\"程序接着运行\",{\"1\":{\"479\":1}}],[\"程序不会在panic出中断\",{\"1\":{\"478\":1}}],[\"程序运行过程发生的\",{\"1\":{\"478\":1}}],[\"程序员看不到这些底层的细节\",{\"1\":{\"378\":1}}],[\"程序添加到上述目录中\",{\"1\":{\"223\":1}}],[\"程序\",{\"1\":{\"223\":1}}],[\"程序是有局部性的\",{\"1\":{\"217\":1}}],[\"程序段\",{\"1\":{\"36\":1}}],[\"程序段2\",{\"1\":{\"36\":1}}],[\"程序段1\",{\"1\":{\"36\":1}}],[\"个采样里面活性最低的与池中活性最低的比较\",{\"1\":{\"906\":1}}],[\"个数据\",{\"1\":{\"879\":1}}],[\"个数据包需要\",{\"1\":{\"249\":1}}],[\"个数据包\",{\"1\":{\"249\":1}}],[\"个有序文件再合并成一个有序的大文件\",{\"1\":{\"813\":1}}],[\"个事务的\",{\"1\":{\"810\":1}}],[\"个事务一次性一起刷盘的时间成本则近似于\",{\"1\":{\"810\":1}}],[\"个事务依次排队刷盘的时间成本是\",{\"1\":{\"810\":1}}],[\"个事务后才\",{\"1\":{\"760\":1,\"810\":2}}],[\"个从库\",{\"1\":{\"810\":1}}],[\"个线程同时工作\",{\"1\":{\"807\":1}}],[\"个变长字段\",{\"1\":{\"770\":1}}],[\"个比较重要的\",{\"1\":{\"770\":1}}],[\"个字段\",{\"1\":{\"807\":1}}],[\"个字段值都是\",{\"1\":{\"770\":2}}],[\"个字节的\",{\"1\":{\"879\":2}}],[\"个字节的指针来指向溢出页\",{\"1\":{\"770\":1}}],[\"个字节中\",{\"1\":{\"879\":1}}],[\"个字节放到一块\",{\"1\":{\"75\":1}}],[\"个字节\",{\"1\":{\"75\":3,\"770\":3,\"813\":1}}],[\"个页会被划为一个区\",{\"1\":{\"770\":1}}],[\"个页表项\",{\"1\":{\"217\":1}}],[\"个阶段\",{\"1\":{\"764\":1,\"810\":2}}],[\"个阶段的消息不丢失\",{\"1\":{\"708\":1}}],[\"个重做日志文件组\",{\"1\":{\"757\":1,\"810\":1}}],[\"个例子\",{\"1\":{\"477\":1}}],[\"个问题\",{\"0\":{\"473\":1}}],[\"个消息即可完成\",{\"1\":{\"249\":1}}],[\"个\",{\"1\":{\"249\":3,\"367\":1,\"374\":1,\"757\":1,\"770\":1,\"807\":1,\"810\":2,\"817\":1,\"864\":2,\"867\":1,\"870\":1,\"876\":1,\"879\":2,\"906\":5,\"927\":1,\"943\":1,\"944\":1}}],[\"个实现\",{\"1\":{\"226\":1}}],[\"个二级页表\",{\"1\":{\"217\":1}}],[\"个进程的话\",{\"1\":{\"217\":1}}],[\"位保存上次访问的时间戳\",{\"1\":{\"903\":1}}],[\"位操作系统中\",{\"1\":{\"900\":2}}],[\"位拿出来\",{\"1\":{\"879\":1}}],[\"位移运算符\",{\"0\":{\"569\":1}}],[\"位清除\",{\"1\":{\"446\":1}}],[\"位运算符是对内存中的二进制数进行按位运算\",{\"1\":{\"444\":1}}],[\"位运算符\",{\"0\":{\"444\":1},\"1\":{\"442\":1}}],[\"位\",{\"1\":{\"249\":1,\"770\":1,\"903\":2}}],[\"位的序列号\",{\"1\":{\"237\":1}}],[\"位的操作系统\",{\"1\":{\"217\":3}}],[\"位的环境下\",{\"1\":{\"217\":1}}],[\"位和\",{\"1\":{\"217\":1}}],[\"位系统为例\",{\"1\":{\"217\":1}}],[\"位存储访问计数\",{\"1\":{\"903\":1}}],[\"位存储\",{\"1\":{\"20\":1}}],[\"恢复数据的\",{\"1\":{\"952\":1}}],[\"恢复数据库\",{\"0\":{\"855\":1}}],[\"恢复出来的库\",{\"1\":{\"810\":1}}],[\"恢复正常运行\",{\"1\":{\"810\":1}}],[\"恢复事务\",{\"1\":{\"810\":1}}],[\"恢复后调用当数结束\",{\"1\":{\"479\":1}}],[\"恢复进程的运行\",{\"1\":{\"217\":1}}],[\"恢复消费\",{\"1\":{\"165\":2}}],[\"页空隙等问题\",{\"1\":{\"770\":1}}],[\"页的类型\",{\"1\":{\"770\":1}}],[\"页的修改也都会记录到\",{\"1\":{\"745\":1,\"810\":1}}],[\"页是记录什么\",{\"1\":{\"810\":1}}],[\"页是记录什么的\",{\"1\":{\"748\":1}}],[\"页是\",{\"1\":{\"770\":1}}],[\"页头\",{\"1\":{\"748\":1}}],[\"页目录类似于字典的目录\",{\"1\":{\"748\":1}}],[\"页目录\",{\"1\":{\"748\":1,\"810\":1}}],[\"页都是靠这个机制保证持久化的\",{\"1\":{\"745\":1,\"810\":1}}],[\"页\",{\"1\":{\"745\":1,\"748\":1,\"770\":4,\"810\":4}}],[\"页面后\",{\"1\":{\"753\":1,\"810\":3}}],[\"页面\",{\"1\":{\"249\":1,\"753\":2,\"810\":5}}],[\"页交换\",{\"1\":{\"217\":1}}],[\"页内位移三部分组成\",{\"1\":{\"217\":1}}],[\"页内偏移\",{\"1\":{\"217\":1}}],[\"页表是存储在内存里的\",{\"1\":{\"217\":1}}],[\"页表包含物理页每页所在物理内存的基地址\",{\"1\":{\"217\":1}}],[\"页表里的页表项中除了物理地址之外\",{\"1\":{\"217\":1}}],[\"页号作为页表的索引\",{\"1\":{\"217\":1}}],[\"页号\",{\"1\":{\"217\":1}}],[\"交互\",{\"1\":{\"962\":1}}],[\"交互是以记录为单位的\",{\"1\":{\"817\":1}}],[\"交互式进入\",{\"1\":{\"141\":1}}],[\"交易操作必须严格按照时间顺序执行\",{\"1\":{\"719\":1}}],[\"交给存储引擎层去处理了\",{\"1\":{\"817\":1}}],[\"交给存储引擎\",{\"1\":{\"817\":1}}],[\"交给\",{\"1\":{\"381\":1}}],[\"交出\",{\"1\":{\"265\":1}}],[\"交换空间通常是一个专用的磁盘分区或文件\",{\"1\":{\"217\":1}}],[\"交换空间\",{\"1\":{\"217\":1}}],[\"交换的是一个占内存空间很大的程序\",{\"1\":{\"217\":1}}],[\"段一般分为数据段\",{\"1\":{\"770\":1}}],[\"段是由多个区\",{\"1\":{\"770\":1}}],[\"段\",{\"1\":{\"217\":1,\"770\":1}}],[\"段页式地址变换中要得到物理地址须经过三次内存访问\",{\"1\":{\"217\":1}}],[\"段页式内存管理实现的方式\",{\"1\":{\"217\":1}}],[\"段页式内存管理\",{\"1\":{\"217\":1}}],[\"段内页号\",{\"1\":{\"217\":1}}],[\"段内偏移量\",{\"1\":{\"217\":2}}],[\"段的界限和特权等级等\",{\"1\":{\"217\":1}}],[\"段表里面保存的是这个段的基地址\",{\"1\":{\"217\":1}}],[\"段选择因子里面最重要的是段号\",{\"1\":{\"217\":1}}],[\"段选择因子\",{\"1\":{\"217\":2}}],[\"➕\",{\"1\":{\"217\":2}}],[\"区\",{\"1\":{\"770\":2}}],[\"区是动态调整的吗\",{\"1\":{\"217\":1}}],[\"区域\",{\"1\":{\"217\":1}}],[\"区别如下\",{\"1\":{\"810\":1}}],[\"区别在哪\",{\"1\":{\"810\":1}}],[\"区别在于对应不同大小的字符串\",{\"1\":{\"873\":1}}],[\"区别在于创建\",{\"1\":{\"743\":1,\"784\":1}}],[\"区别在于未受变动的消费者可以继续消费主题\",{\"1\":{\"165\":1}}],[\"区别于c++\",{\"1\":{\"454\":1}}],[\"区别\",{\"1\":{\"249\":1,\"747\":1}}],[\"区别巨大\",{\"1\":{\"33\":1}}],[\"区别指针类型\",{\"1\":{\"33\":1}}],[\"单表操作\",{\"0\":{\"984\":1}}],[\"单数表名\",{\"1\":{\"979\":1}}],[\"单位\",{\"1\":{\"1037\":1}}],[\"单位为每秒\",{\"1\":{\"957\":1}}],[\"单位是字符\",{\"1\":{\"770\":1}}],[\"单位是经过路由数\",{\"1\":{\"237\":1}}],[\"单位是时间\",{\"1\":{\"237\":1}}],[\"单机支持每秒几万的写入\",{\"1\":{\"927\":1}}],[\"单机数据库如何在高并发场景下健步如飞\",{\"1\":{\"807\":1}}],[\"单单从分布式锁本身出发\",{\"1\":{\"918\":1,\"921\":1}}],[\"单点redis的所有手段\",{\"1\":{\"917\":1,\"921\":1}}],[\"单点查询\",{\"1\":{\"813\":1}}],[\"单纯的加锁操作\",{\"1\":{\"897\":1}}],[\"单线程还是多线程\",{\"1\":{\"891\":1}}],[\"单线程模型\",{\"2\":{\"890\":1}}],[\"单线程也有了较大的并发度\",{\"1\":{\"888\":1}}],[\"单线程也能做到高性能的原因\",{\"1\":{\"226\":1}}],[\"单线程\",{\"1\":{\"888\":2}}],[\"单线程为什么这么快\",{\"1\":{\"888\":1}}],[\"单列建立索引\",{\"1\":{\"813\":1}}],[\"单列查询\",{\"1\":{\"813\":1}}],[\"单列索引查询暴露的性能问题\",{\"1\":{\"813\":1}}],[\"单列索引\",{\"1\":{\"813\":2}}],[\"单事务\",{\"1\":{\"810\":1}}],[\"单独开启\",{\"1\":{\"952\":1}}],[\"单独执行一个更新语句的时候\",{\"1\":{\"810\":1}}],[\"单独使用\",{\"1\":{\"123\":1}}],[\"单库\",{\"1\":{\"807\":2}}],[\"单字段的情况下\",{\"1\":{\"770\":1}}],[\"单个节点数据的丢失\",{\"1\":{\"917\":1,\"921\":1}}],[\"单个数据库的性能扛不住高并发流量\",{\"1\":{\"727\":1}}],[\"单个url模式\",{\"1\":{\"586\":1,\"654\":1}}],[\"单张数据表太大\",{\"1\":{\"727\":1}}],[\"单一职责原则\",{\"1\":{\"605\":1}}],[\"单变量声明\",{\"0\":{\"436\":1}}],[\"单词间需要使用空格分割\",{\"1\":{\"829\":1}}],[\"单词只有一个\",{\"1\":{\"249\":1}}],[\"单词都必须是大写的形式\",{\"1\":{\"249\":1}}],[\"单行协议\",{\"1\":{\"249\":1}}],[\"单页表的实现方式\",{\"1\":{\"217\":1}}],[\"单片机没有操作系统\",{\"1\":{\"217\":1}}],[\"单片机的\",{\"1\":{\"217\":1}}],[\"前者是后者的进阶版\",{\"1\":{\"879\":1}}],[\"前一节点的长度大于等于\",{\"1\":{\"879\":1}}],[\"前后端分离的时代\",{\"1\":{\"1031\":1}}],[\"前后执行相同的\",{\"1\":{\"820\":2}}],[\"前后两次读的数据可能会出现不一致\",{\"1\":{\"743\":1,\"810\":1}}],[\"前的条件列是索引列\",{\"1\":{\"813\":1}}],[\"前置知识\",{\"1\":{\"813\":1}}],[\"前置条件\",{\"1\":{\"813\":1}}],[\"前缀和日志包含的内容\",{\"1\":{\"980\":1}}],[\"前缀索引能够更加节省存储空间\",{\"1\":{\"813\":1}}],[\"前缀索引陷阱\",{\"1\":{\"813\":1}}],[\"前缀索引\",{\"1\":{\"813\":1}}],[\"前缀索引可以通过使用字段值的前几个字符来减少索引大小并提升查询效率\",{\"1\":{\"807\":1}}],[\"前缀压缩\",{\"1\":{\"807\":1}}],[\"前级索引和索引选择性\",{\"1\":{\"807\":1}}],[\"前面的内容\",{\"1\":{\"915\":1,\"921\":1}}],[\"前面也提到\",{\"1\":{\"820\":1}}],[\"前面\",{\"1\":{\"813\":1}}],[\"前面我创建表的时候\",{\"1\":{\"770\":1}}],[\"前面说过\",{\"1\":{\"223\":1}}],[\"前\",{\"1\":{\"744\":1,\"789\":1,\"841\":1}}],[\"前提没有打开死锁检测\",{\"1\":{\"820\":1}}],[\"前提\",{\"1\":{\"217\":1}}],[\"前端请求不一定可以走通的情况\",{\"1\":{\"1037\":1}}],[\"前端构造a标签\",{\"1\":{\"1032\":1}}],[\"前端在传递来的json数据中可能会使用字符串类型的数字\",{\"1\":{\"491\":1}}],[\"前端表单在提交时遇到网络波动\",{\"1\":{\"23\":1}}],[\"前端的表单重复提交\",{\"1\":{\"23\":1}}],[\"前端防重\",{\"1\":{\"23\":2}}],[\"前端\",{\"0\":{\"16\":1}}],[\"跳表决定每一个节点\",{\"1\":{\"885\":1}}],[\"跳表单个节点有几层\",{\"1\":{\"885\":1}}],[\"跳表结构体\",{\"1\":{\"885\":1}}],[\"跳表是用来支持有序集合的\",{\"1\":{\"885\":1}}],[\"跳表是有序集合\",{\"1\":{\"885\":1}}],[\"跳表的结构\",{\"1\":{\"885\":1}}],[\"跳表在链表基础上\",{\"1\":{\"885\":1}}],[\"跳表本质还是链表\",{\"1\":{\"885\":1}}],[\"跳表\",{\"1\":{\"813\":1,\"885\":1,\"888\":1},\"2\":{\"887\":1}}],[\"跳转限制\",{\"1\":{\"682\":1}}],[\"跳转到支付页面\",{\"1\":{\"23\":1}}],[\"跳出函数\",{\"1\":{\"479\":1}}],[\"跳出条件选择\",{\"1\":{\"450\":1}}],[\"跳到第20行\",{\"1\":{\"214\":1}}],[\"跳到文末\",{\"1\":{\"214\":1}}],[\"示例代码如下\",{\"1\":{\"490\":1}}],[\"示例代码\",{\"0\":{\"410\":1},\"1\":{\"452\":1}}],[\"示例\",{\"1\":{\"211\":2,\"496\":1,\"497\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"656\":1,\"826\":1}}],[\"按ascii码\",{\"1\":{\"813\":1}}],[\"按数据结构分类\",{\"1\":{\"813\":1}}],[\"按组的方式\",{\"1\":{\"810\":1}}],[\"按严重性排序\",{\"1\":{\"776\":1}}],[\"按\",{\"1\":{\"770\":1,\"813\":4}}],[\"按用户id\",{\"1\":{\"723\":1}}],[\"按用户名查找\",{\"1\":{\"211\":1}}],[\"按照\",{\"1\":{\"823\":1}}],[\"按照顺序一页一页写肯定比写一个字都要找到对应页写快得多\",{\"1\":{\"810\":1}}],[\"按照监听对象和事件类型可以分为以下几类\",{\"1\":{\"618\":1}}],[\"按照所需顺序定义<filter\",{\"1\":{\"608\":1}}],[\"按照<filter\",{\"1\":{\"595\":1}}],[\"按字典序排序\",{\"1\":{\"876\":1}}],[\"按字典顺序比较两个字符串\",{\"1\":{\"496\":1}}],[\"按字母顺序\",{\"1\":{\"596\":1}}],[\"按分隔符分割\",{\"1\":{\"502\":1}}],[\"按空白字符分割\",{\"1\":{\"502\":1}}],[\"按存在时间\",{\"1\":{\"249\":1}}],[\"按在客户端中的存储位置\",{\"1\":{\"249\":1}}],[\"按顺序地以及错误检测和修正的方式传输\",{\"1\":{\"249\":1}}],[\"按文件大小查找\",{\"1\":{\"211\":1}}],[\"按名字查找\",{\"1\":{\"211\":1}}],[\"按钮禁用\",{\"1\":{\"23\":1}}],[\"路由不太明了\",{\"1\":{\"1020\":1}}],[\"路由等信息\",{\"1\":{\"126\":1}}],[\"路飞\",{\"1\":{\"820\":1}}],[\"路径参数\",{\"0\":{\"1040\":1}}],[\"路径匹配中的\",{\"1\":{\"657\":1}}],[\"路径匹配\",{\"1\":{\"587\":1,\"655\":1,\"656\":1}}],[\"路径\",{\"1\":{\"211\":1,\"249\":1}}],[\"软链接目录+文件名\",{\"1\":{\"209\":1}}],[\"原生sql\",{\"1\":{\"1012\":1}}],[\"原生sql执行\",{\"0\":{\"1011\":1}}],[\"原生无状态的http协议\",{\"1\":{\"249\":1}}],[\"原本\",{\"1\":{\"879\":1,\"903\":1}}],[\"原本每个\",{\"1\":{\"879\":1}}],[\"原本是以\",{\"1\":{\"780\":1}}],[\"原本是局部指针变量\",{\"1\":{\"410\":1}}],[\"原来的定时器就随重启消失了\",{\"1\":{\"882\":1}}],[\"原来的路由基本上是全乱了\",{\"1\":{\"723\":1}}],[\"原来\",{\"1\":{\"867\":1}}],[\"原则不能太短\",{\"1\":{\"952\":1}}],[\"原则\",{\"1\":{\"813\":1}}],[\"原子性问题\",{\"1\":{\"911\":1,\"921\":1}}],[\"原子性\",{\"1\":{\"774\":1,\"810\":1}}],[\"原子操作\",{\"1\":{\"714\":1}}],[\"原数据\",{\"1\":{\"763\":1}}],[\"原理分类\",{\"1\":{\"804\":1}}],[\"原理\",{\"1\":{\"229\":1,\"535\":1,\"549\":1},\"2\":{\"806\":1}}],[\"原理及其广泛的应用场景\",{\"1\":{\"68\":1}}],[\"原因考虑阈值\",{\"1\":{\"873\":1}}],[\"原因就是在唯一索引等值查询并且查询记录存在的场景下\",{\"1\":{\"820\":1}}],[\"原因有两个\",{\"1\":{\"810\":1}}],[\"原因是redis宕机了也就无法处理缓存请求\",{\"1\":{\"930\":1}}],[\"原因是buf是一个环形数组\",{\"1\":{\"264\":1}}],[\"原因是\",{\"1\":{\"217\":1,\"813\":1}}],[\"原因\",{\"1\":{\"217\":1,\"511\":1,\"709\":1}}],[\"原文件或目录\",{\"1\":{\"209\":1}}],[\"旧客户端执行释放操作\",{\"1\":{\"913\":1,\"921\":1}}],[\"旧客户端准备释放锁\",{\"1\":{\"913\":1,\"921\":1}}],[\"旧客户端删除前检查锁\",{\"1\":{\"913\":1,\"921\":1}}],[\"旧值作为一条\",{\"1\":{\"748\":1}}],[\"旧值\",{\"1\":{\"633\":1,\"634\":1,\"635\":2}}],[\"旧\",{\"0\":{\"379\":1}}],[\"旧路径\",{\"1\":{\"209\":1}}],[\"旧文件名\",{\"1\":{\"209\":1}}],[\"选用\",{\"1\":{\"807\":1}}],[\"选出新的主机\",{\"1\":{\"730\":1}}],[\"选择了很多高效的数据结构\",{\"1\":{\"888\":1}}],[\"选择相应的操作来启动\",{\"1\":{\"836\":1}}],[\"选择查询成本最小的执行计划\",{\"1\":{\"817\":1}}],[\"选择最小数据类型\",{\"1\":{\"807\":1}}],[\"选择合适的索引列顺序\",{\"1\":{\"807\":1}}],[\"选择性高的索引有助于更快地定位记录\",{\"1\":{\"807\":1}}],[\"选择性是衡量索引效果的一个重要指标\",{\"1\":{\"807\":1}}],[\"选择成本最低的计划\",{\"1\":{\"734\":1}}],[\"选择执行计划\",{\"1\":{\"734\":1}}],[\"选择一个合适的哈希函数来计算每个客户的哈希值\",{\"1\":{\"723\":1}}],[\"选择的消费语义不同\",{\"1\":{\"705\":1}}],[\"选项模式\",{\"1\":{\"957\":1}}],[\"选项仅在新用户不存在时有条件地创建新用户\",{\"1\":{\"838\":1}}],[\"选项来创建\",{\"1\":{\"229\":1}}],[\"选项\",{\"1\":{\"209\":2,\"211\":1,\"249\":1,\"957\":1}}],[\"选举\",{\"1\":{\"181\":2}}],[\"更为灵活\",{\"1\":{\"957\":1}}],[\"更利于人类阅读\",{\"1\":{\"957\":1}}],[\"更安全一点\",{\"1\":{\"927\":1}}],[\"更好用的方案是加上一个验证码验证\",{\"1\":{\"927\":1}}],[\"更通用的过期命令\",{\"1\":{\"882\":1}}],[\"更快这个问题\",{\"1\":{\"810\":1}}],[\"更深的理解\",{\"1\":{\"469\":1}}],[\"更具扩展性\",{\"1\":{\"249\":1}}],[\"更易管理的部分\",{\"1\":{\"249\":1}}],[\"更改用户密码\",{\"1\":{\"207\":1}}],[\"更新年龄\",{\"1\":{\"998\":1}}],[\"更新指定字段\",{\"0\":{\"998\":1}}],[\"更新指的是更新已有数据\",{\"1\":{\"512\":1}}],[\"更新记录\",{\"0\":{\"996\":1}}],[\"更新mysql之后\",{\"1\":{\"930\":2}}],[\"更新mysql即可\",{\"1\":{\"930\":2}}],[\"更新一次\",{\"1\":{\"906\":1}}],[\"更新表中数据\",{\"1\":{\"829\":1}}],[\"更新存储引擎中的数据\",{\"1\":{\"810\":2}}],[\"更新多少行数据就会产生多少条记录\",{\"1\":{\"810\":1}}],[\"更新为旧值\",{\"1\":{\"810\":1}}],[\"更新语句的流程会涉及到\",{\"1\":{\"810\":1}}],[\"更新语句也是同样会走一遍\",{\"1\":{\"810\":1}}],[\"更新数据\",{\"1\":{\"730\":1,\"761\":1,\"879\":1}}],[\"更新本地存储的数据\",{\"1\":{\"730\":1,\"761\":1}}],[\"更新了\",{\"1\":{\"529\":1}}],[\"更新的操作流量\",{\"1\":{\"518\":1}}],[\"更新元素\",{\"1\":{\"514\":1}}],[\"更新\",{\"1\":{\"512\":1,\"526\":1,\"531\":1,\"737\":2,\"741\":1,\"793\":1,\"810\":3,\"820\":1,\"873\":1,\"903\":1,\"930\":1}}],[\"更新进程页表\",{\"1\":{\"217\":1}}],[\"更新前查询到\",{\"1\":{\"23\":1}}],[\"更新操作先放在存储服务内存中\",{\"1\":{\"930\":1}}],[\"更新操作比较麻烦\",{\"1\":{\"930\":1}}],[\"更新操作\",{\"1\":{\"23\":2}}],[\"添加记录\",{\"0\":{\"985\":1}}],[\"添加proto文件\",{\"1\":{\"969\":1}}],[\"添加公共字段\",{\"1\":{\"957\":1}}],[\"添加\",{\"1\":{\"820\":3,\"944\":1}}],[\"添加商品\",{\"1\":{\"638\":1}}],[\"添加依赖\",{\"0\":{\"583\":1,\"623\":1,\"651\":1}}],[\"添加或修改http头信息\",{\"1\":{\"579\":1}}],[\"添加元素\",{\"1\":{\"514\":1}}],[\"添加string\",{\"1\":{\"491\":2}}],[\"添加导入搜索路径\",{\"1\":{\"392\":1}}],[\"添加在文件证书上\",{\"1\":{\"240\":1,\"249\":1}}],[\"添加用户并指定home目录\",{\"1\":{\"207\":1}}],[\"添加用户\",{\"1\":{\"207\":1}}],[\"添加用户后会自动创建和用户同名的home目录\",{\"1\":{\"207\":1}}],[\"添加到epfd中\",{\"1\":{\"226\":1}}],[\"添加到\",{\"1\":{\"123\":1}}],[\"注释\",{\"1\":{\"983\":1}}],[\"注册钩子函数\",{\"1\":{\"957\":1}}],[\"注入攻击\",{\"1\":{\"243\":1,\"807\":1}}],[\"注入防御\",{\"1\":{\"243\":1}}],[\"注销\",{\"1\":{\"615\":1}}],[\"注销当前登录用户\",{\"1\":{\"205\":1}}],[\"注销和切换\",{\"0\":{\"205\":1}}],[\"注意这是接口函数不是命令\",{\"1\":{\"817\":1}}],[\"注意这里\",{\"1\":{\"488\":1}}],[\"注意下面的过程针对的是\",{\"1\":{\"810\":1}}],[\"注意写入到\",{\"1\":{\"810\":2}}],[\"注意每张表的主键要设置好\",{\"1\":{\"807\":1}}],[\"注意表格字段定义是char\",{\"1\":{\"770\":1}}],[\"注意是一行的总长度\",{\"1\":{\"770\":1}}],[\"注意并不意味着写入到了磁盘\",{\"1\":{\"756\":1}}],[\"注意看加密算法\",{\"1\":{\"249\":1}}],[\"注意大小写\",{\"1\":{\"117\":1}}],[\"注意对指针的操作\",{\"1\":{\"33\":1}}],[\"注意\",{\"0\":{\"438\":1},\"1\":{\"33\":1,\"177\":1,\"226\":1,\"249\":1,\"330\":1,\"346\":1,\"441\":1,\"478\":2,\"532\":1,\"591\":1,\"662\":1,\"689\":1,\"770\":1,\"810\":1,\"820\":4,\"836\":1,\"867\":1,\"873\":1,\"879\":2,\"930\":1,\"1037\":1}}],[\"注意事项\",{\"0\":{\"657\":1},\"1\":{\"23\":1,\"497\":1,\"817\":2}}],[\"立即执行对键的删除操作\",{\"1\":{\"882\":1}}],[\"立即重启计算机\",{\"1\":{\"204\":1}}],[\"立即重启\",{\"1\":{\"204\":1}}],[\"立即关机\",{\"1\":{\"204\":1}}],[\"现象就是\",{\"1\":{\"820\":2}}],[\"现代处理器架构一般允许\",{\"1\":{\"220\":1}}],[\"现代系统中shutdown\",{\"1\":{\"204\":1}}],[\"现在假设有5个redis主节点\",{\"1\":{\"917\":1,\"921\":1}}],[\"现在单个节点存一个\",{\"1\":{\"867\":1}}],[\"现在即使有复制命令在执行\",{\"1\":{\"864\":1}}],[\"现在有下面这条查询语句\",{\"1\":{\"817\":1}}],[\"现在最常用的存储引擎是\",{\"1\":{\"817\":1}}],[\"现在我们知道事务在提交的时候\",{\"1\":{\"810\":1}}],[\"现在我需要调整价格\",{\"1\":{\"23\":1}}],[\"现在平台升级后要求改为\",{\"1\":{\"780\":1}}],[\"现在不足\",{\"1\":{\"770\":1}}],[\"现在\",{\"1\":{\"770\":1,\"820\":3}}],[\"现在基本没人用了\",{\"1\":{\"770\":1}}],[\"现在来模拟一下读\",{\"1\":{\"524\":1}}],[\"现在该目录最主要的作用是存储日志\",{\"1\":{\"223\":1}}],[\"现在的操作系统已经很聪明了\",{\"1\":{\"223\":1}}],[\"现在使用\",{\"1\":{\"113\":1}}],[\"现在可以免费用\",{\"1\":{\"12\":1}}],[\"危险选项\",{\"1\":{\"202\":1}}],[\"忽略errrecordnotfound\",{\"1\":{\"980\":1}}],[\"忽略符号位\",{\"1\":{\"569\":1}}],[\"忽略大小写比较两个字符串\",{\"1\":{\"496\":1}}],[\"忽略该字段\",{\"1\":{\"489\":1}}],[\"忽略嵌套结构体空值字段\",{\"0\":{\"489\":1}}],[\"忽略空值字段\",{\"0\":{\"487\":1}}],[\"忽略某个字段\",{\"0\":{\"486\":1}}],[\"忽略不存在的文件\",{\"1\":{\"202\":1}}],[\"忽视\",{\"1\":{\"36\":1}}],[\"仅用于统计\",{\"1\":{\"944\":1}}],[\"仅是以\",{\"1\":{\"936\":1}}],[\"仅靠记录锁也能避免幻读的问题\",{\"1\":{\"820\":1}}],[\"仅仅存放索引\",{\"1\":{\"813\":1}}],[\"仅仅依靠返回值不同来区分的函数\",{\"1\":{\"33\":1}}],[\"仅使用\",{\"1\":{\"655\":1}}],[\"仅添加omitempty是不够的\",{\"1\":{\"489\":1}}],[\"仅主机\",{\"1\":{\"246\":1}}],[\"仅列出目录本身\",{\"1\":{\"201\":1}}],[\"先给张三\",{\"1\":{\"1014\":1,\"1015\":1}}],[\"先挖个坑\",{\"1\":{\"957\":1}}],[\"先看看\",{\"1\":{\"952\":1}}],[\"先看事务\",{\"1\":{\"820\":1}}],[\"先使用ht\",{\"1\":{\"942\":1}}],[\"先查询数据是否在缓存上\",{\"1\":{\"930\":1}}],[\"先将库存名额预加载到\",{\"1\":{\"927\":1}}],[\"先将程序划分为多个有逻辑意义的段\",{\"1\":{\"217\":1}}],[\"先定位到第一个比\",{\"1\":{\"885\":1}}],[\"先为新\",{\"1\":{\"864\":1}}],[\"先为hchan结构和分配内存\",{\"1\":{\"263\":1}}],[\"先插入\",{\"1\":{\"820\":1}}],[\"先插入了两个记录\",{\"1\":{\"820\":1}}],[\"先会加上表级别的意向独占锁\",{\"1\":{\"820\":1}}],[\"先表上加上意向独占锁\",{\"1\":{\"820\":1}}],[\"先在表上加上意向共享锁\",{\"1\":{\"820\":1}}],[\"先要看看数据库中的长事务\",{\"1\":{\"820\":1}}],[\"先启用了事务\",{\"1\":{\"820\":1}}],[\"先不执行回表操作\",{\"1\":{\"817\":1}}],[\"先不展开\",{\"1\":{\"469\":1}}],[\"先去查缓存\",{\"1\":{\"817\":1}}],[\"先执行\",{\"1\":{\"794\":1,\"823\":1}}],[\"先创建一个表格\",{\"1\":{\"770\":1}}],[\"先创建的\",{\"1\":{\"373\":1}}],[\"先把日志写到\",{\"1\":{\"760\":1,\"810\":1}}],[\"先写入到\",{\"1\":{\"810\":1}}],[\"先写\",{\"1\":{\"757\":1}}],[\"先记录相应操作的\",{\"1\":{\"748\":1}}],[\"先了解隐式事务\",{\"1\":{\"739\":1}}],[\"先删后写的场景优化\",{\"1\":{\"524\":1}}],[\"先说结论\",{\"1\":{\"524\":1}}],[\"先\",{\"1\":{\"446\":1,\"820\":1}}],[\"先调度\",{\"1\":{\"374\":1}}],[\"先解释一下为什么选\",{\"1\":{\"374\":1}}],[\"先被调度执行\",{\"1\":{\"373\":1}}],[\"先用epoll\",{\"1\":{\"226\":1}}],[\"先宏定义长度\",{\"1\":{\"226\":1}}],[\"先放在malloc的缓冲区\",{\"1\":{\"217\":1}}],[\"先找到进程的pid\",{\"1\":{\"196\":1}}],[\"先测试x是否被宏定义过\",{\"1\":{\"36\":1}}],[\"动态参数模式\",{\"1\":{\"1036\":1}}],[\"动态参数\",{\"0\":{\"1036\":1}}],[\"动态代理\",{\"0\":{\"559\":1}}],[\"动态类型逃逸\",{\"0\":{\"414\":1}}],[\"动态类型和动态值\",{\"0\":{\"303\":1}}],[\"动态显示系统进程\",{\"1\":{\"195\":1}}],[\"动态维护一个与自己基本保持同步的isr列表\",{\"1\":{\"182\":1}}],[\"组提交的效果\",{\"1\":{\"810\":1}}],[\"组提交吗\",{\"1\":{\"810\":1}}],[\"组提交\",{\"1\":{\"760\":1,\"810\":5}}],[\"组成的\",{\"1\":{\"770\":2}}],[\"组成\",{\"1\":{\"757\":1,\"770\":1}}],[\"组成员列表\",{\"1\":{\"190\":1}}],[\"组合\",{\"1\":{\"462\":1}}],[\"组合实现继承\",{\"0\":{\"462\":1}}],[\"组名\",{\"1\":{\"190\":1,\"208\":2}}],[\"组\",{\"1\":{\"190\":1}}],[\"组id\",{\"1\":{\"190\":2}}],[\"组消费的情况\",{\"1\":{\"164\":1}}],[\"仿真提供的\",{\"1\":{\"190\":1}}],[\"了端口\",{\"1\":{\"888\":1}}],[\"了解一个主要参数\",{\"1\":{\"756\":1}}],[\"了解编译器的工作原理有助于编写高效的go代码\",{\"1\":{\"400\":1}}],[\"了一块内存\",{\"1\":{\"217\":1}}],[\"了\",{\"1\":{\"190\":1,\"374\":1,\"446\":1,\"770\":4,\"810\":1}}],[\"项目地址在这里\",{\"1\":{\"957\":1}}],[\"项目规模大\",{\"1\":{\"813\":1}}],[\"项目对\",{\"1\":{\"190\":1}}],[\"项目管理\",{\"0\":{\"9\":1}}],[\"曾是第七版\",{\"1\":{\"190\":1}}],[\"历史最为悠久\",{\"1\":{\"190\":1}}],[\"历史\",{\"1\":{\"190\":1}}],[\"纵观\",{\"1\":{\"190\":1}}],[\"坚决不能让那些osr竞选leader\",{\"1\":{\"183\":1}}],[\"成本越大\",{\"1\":{\"1056\":1}}],[\"成本最小\",{\"1\":{\"813\":1}}],[\"成本估算\",{\"1\":{\"734\":1,\"804\":1}}],[\"成员变量如果没有被赋初始值\",{\"1\":{\"571\":1}}],[\"成员变量是对象的一部分\",{\"1\":{\"571\":1}}],[\"成员变量是属于类的\",{\"1\":{\"571\":1}}],[\"成员变量和局部变量都能被final所修饰\",{\"1\":{\"571\":1}}],[\"成员变量可以被public\",{\"1\":{\"571\":1}}],[\"成员变量与局部变量\",{\"0\":{\"571\":1}}],[\"成员函数\",{\"1\":{\"33\":1}}],[\"成功删除了几行\",{\"1\":{\"873\":1}}],[\"成功复制数据后\",{\"1\":{\"710\":1}}],[\"成功\",{\"1\":{\"240\":1,\"249\":1,\"1021\":1}}],[\"成为了\",{\"1\":{\"817\":1}}],[\"成为默认存储引擎\",{\"1\":{\"813\":1}}],[\"成为\",{\"1\":{\"183\":1,\"879\":1}}],[\"否则会导致大量的缓存占用内存资源\",{\"1\":{\"930\":1}}],[\"否则会出现\",{\"1\":{\"509\":1}}],[\"否则继续往下执行\",{\"1\":{\"817\":1}}],[\"否则跳过该记录\",{\"1\":{\"817\":2}}],[\"否则发送到客户端\",{\"1\":{\"817\":1}}],[\"否则1字节\",{\"1\":{\"770\":1}}],[\"否则一次读取\",{\"1\":{\"770\":1}}],[\"否则再去磁盘中读取\",{\"1\":{\"747\":1,\"810\":1}}],[\"否则则认为证书不可信\",{\"1\":{\"240\":1,\"249\":1}}],[\"否则\",{\"1\":{\"181\":1,\"656\":3,\"1015\":1}}],[\"否则只有处于\",{\"1\":{\"181\":1}}],[\"否则不存在\",{\"1\":{\"20\":1}}],[\"集群结构\",{\"1\":{\"810\":1}}],[\"集群的主从复制过程梳理成\",{\"1\":{\"810\":1}}],[\"集群的哨兵模式可以自动将从库升级为主库\",{\"1\":{\"730\":1}}],[\"集群\",{\"1\":{\"249\":1}}],[\"集合给内核\",{\"1\":{\"226\":1}}],[\"集合从用户态拷贝到内核态\",{\"1\":{\"226\":2}}],[\"集合\",{\"1\":{\"181\":3,\"226\":3}}],[\"集中处理\",{\"1\":{\"175\":1}}],[\"副节点是透明的\",{\"1\":{\"180\":1}}],[\"副本间的同步机制\",{\"0\":{\"184\":1,\"185\":1}}],[\"副本集合关系图\",{\"1\":{\"181\":1}}],[\"副本集合是动态变化的\",{\"1\":{\"181\":1}}],[\"副本之间的数据差异超过了一定的阈值\",{\"1\":{\"181\":1}}],[\"副本之间的数据差异不超过一定的阈值\",{\"1\":{\"181\":1}}],[\"副本不同步的副本集合\",{\"1\":{\"181\":1}}],[\"副本的最长时间间隔\",{\"1\":{\"181\":1}}],[\"副本的概念\",{\"0\":{\"170\":1}}],[\"副本能够落后\",{\"1\":{\"181\":1}}],[\"副本中的所有数据\",{\"1\":{\"181\":2}}],[\"副本保持同步\",{\"1\":{\"181\":1}}],[\"副本保持同步的副本集合\",{\"1\":{\"181\":1}}],[\"副本管理机制\",{\"0\":{\"181\":1}}],[\"副本创建示意图\",{\"1\":{\"177\":1}}],[\"副本个数和分区数\",{\"1\":{\"177\":1}}],[\"副本所在的\",{\"1\":{\"176\":1}}],[\"副本只能存储在\",{\"0\":{\"175\":1}}],[\"副本和\",{\"0\":{\"174\":1},\"1\":{\"181\":1}}],[\"副本\",{\"0\":{\"174\":1},\"1\":{\"172\":1,\"177\":2,\"181\":3}}],[\"去重查询\",{\"0\":{\"1009\":1}}],[\"去恢复数据\",{\"1\":{\"952\":1}}],[\"去竞争同一项资源\",{\"1\":{\"909\":1,\"921\":1}}],[\"去定位到某条具体的记录\",{\"1\":{\"810\":1}}],[\"去读取对应长度的数据\",{\"1\":{\"770\":1}}],[\"去读\",{\"1\":{\"730\":1,\"761\":1,\"810\":1}}],[\"去\",{\"1\":{\"524\":1,\"810\":1}}],[\"去处理\",{\"1\":{\"516\":1}}],[\"去完成对变量的操作\",{\"1\":{\"512\":1}}],[\"去除不必要的或重复的索引\",{\"1\":{\"807\":1}}],[\"去除前缀\",{\"1\":{\"500\":1}}],[\"去除空白字符\",{\"1\":{\"500\":1}}],[\"去除两端指定字符集\",{\"1\":{\"500\":1}}],[\"去负责读写请求\",{\"1\":{\"180\":1}}],[\"去掉调试信息\",{\"1\":{\"88\":1}}],[\"总是等于\",{\"1\":{\"864\":1}}],[\"总是取出全部列\",{\"1\":{\"807\":1}}],[\"总的来说\",{\"1\":{\"813\":1}}],[\"总的效率来说会高很多\",{\"1\":{\"23\":1}}],[\"总之知道表中的记录存储在\",{\"1\":{\"770\":1}}],[\"总结来说\",{\"1\":{\"734\":1}}],[\"总结\",{\"0\":{\"400\":1,\"417\":1,\"430\":1},\"1\":{\"180\":1,\"484\":1,\"810\":1,\"817\":2,\"864\":2,\"879\":1,\"930\":2,\"949\":1,\"957\":1}}],[\"写完后\",{\"1\":{\"952\":1}}],[\"写完后准备读\",{\"1\":{\"226\":1}}],[\"写操作可以用不同方式完成\",{\"1\":{\"930\":1}}],[\"写操作的流程\",{\"1\":{\"930\":1}}],[\"写操作到来\",{\"1\":{\"525\":1}}],[\"写穿透模式\",{\"1\":{\"930\":1}}],[\"写磁盘之前就可能失败\",{\"1\":{\"927\":1}}],[\"写磁盘成功\",{\"1\":{\"765\":1,\"810\":1}}],[\"写写互斥的\",{\"1\":{\"820\":1}}],[\"写锁等待\",{\"1\":{\"820\":1}}],[\"写锁获取优先级高于读锁\",{\"1\":{\"820\":1}}],[\"写锁\",{\"1\":{\"820\":6}}],[\"写成了\",{\"1\":{\"817\":1}}],[\"写成功了\",{\"1\":{\"810\":1}}],[\"写成功为事务提交成功的标识\",{\"1\":{\"810\":1}}],[\"写满一个文件\",{\"1\":{\"759\":1,\"810\":1}}],[\"写到操作系统的\",{\"1\":{\"810\":1}}],[\"写到末尾就又回到开头\",{\"1\":{\"757\":1,\"810\":1}}],[\"写到\",{\"1\":{\"756\":1,\"760\":1,\"810\":3}}],[\"写到暂存日志中\",{\"1\":{\"730\":1,\"761\":1,\"810\":1}}],[\"写两个操作\",{\"1\":{\"524\":1}}],[\"写请求是要通过加锁到\",{\"1\":{\"519\":1}}],[\"写指的是新增数据\",{\"1\":{\"512\":1}}],[\"写\",{\"0\":{\"531\":1},\"1\":{\"511\":1,\"512\":1,\"524\":1,\"867\":1,\"870\":1,\"876\":1}}],[\"写入细节\",{\"1\":{\"952\":1}}],[\"写入策略\",{\"1\":{\"952\":1}}],[\"写入流程\",{\"1\":{\"952\":1}}],[\"写入新的aof文件\",{\"1\":{\"949\":1}}],[\"写入就加载了缓存\",{\"1\":{\"930\":1}}],[\"写入数据时维护索引需要额外的时间开销\",{\"1\":{\"813\":1}}],[\"写入数据时\",{\"1\":{\"813\":1}}],[\"写入数据需要先找到写入位置\",{\"1\":{\"810\":1}}],[\"写入方式不同\",{\"1\":{\"810\":1}}],[\"写入性能\",{\"1\":{\"810\":1}}],[\"写入磁盘\",{\"1\":{\"810\":1}}],[\"写入磁盘的性能\",{\"1\":{\"810\":1}}],[\"写入磁盘的开销更小\",{\"1\":{\"810\":1}}],[\"写入文件\",{\"1\":{\"767\":1,\"810\":1}}],[\"写入到\",{\"1\":{\"765\":2,\"810\":3}}],[\"写入到交换空间\",{\"1\":{\"217\":1}}],[\"写入binlog文件的过程还可以继续拆分\",{\"1\":{\"760\":1}}],[\"写入速度较慢\",{\"1\":{\"754\":1}}],[\"写入等操作\",{\"1\":{\"734\":1}}],[\"写入字符串\",{\"1\":{\"505\":1}}],[\"写入时结果如下\",{\"1\":{\"263\":1}}],[\"写入\",{\"1\":{\"229\":1,\"730\":2,\"748\":1,\"761\":2,\"810\":3,\"952\":1}}],[\"写入后退出\",{\"1\":{\"214\":1}}],[\"写入之后leader和folower之间会进行同步\",{\"1\":{\"180\":1}}],[\"写入机制\",{\"0\":{\"180\":1}}],[\"写文件路径时\",{\"1\":{\"10\":1}}],[\"虽然速度足够快\",{\"1\":{\"957\":1}}],[\"虽然可以\",{\"1\":{\"952\":1}}],[\"虽然不如传统消息队列可靠\",{\"1\":{\"927\":1}}],[\"虽然多了一次扣减\",{\"1\":{\"927\":1}}],[\"虽然链表结构简单清晰\",{\"1\":{\"885\":1}}],[\"虽然实际很少遇到\",{\"1\":{\"879\":1}}],[\"虽然相同范围的间隙锁是多个事务相互兼容的\",{\"1\":{\"820\":2}}],[\"虽然都不了索引\",{\"1\":{\"813\":1}}],[\"虽然\",{\"1\":{\"813\":1,\"817\":1,\"879\":1,\"952\":1}}],[\"虽然每个线程有自己\",{\"1\":{\"810\":1}}],[\"虽然参数\",{\"1\":{\"810\":1}}],[\"虽然参数传递仍然是按值传递\",{\"1\":{\"456\":1}}],[\"虽然没有输入\",{\"1\":{\"810\":1}}],[\"虽然是\",{\"1\":{\"792\":1}}],[\"虽然脏页数据没有持久化\",{\"1\":{\"752\":1,\"810\":1}}],[\"虽然它会减少复制操作\",{\"1\":{\"417\":1}}],[\"虽然一个\",{\"1\":{\"378\":1}}],[\"虽然形式多样\",{\"1\":{\"249\":1}}],[\"虽然数据的多个副本可以分布在不同的\",{\"1\":{\"176\":1}}],[\"虽然容器的本质是主机上运行的一个进程\",{\"1\":{\"98\":1}}],[\"容量\",{\"1\":{\"813\":1}}],[\"容量增大后\",{\"0\":{\"413\":1}}],[\"容易导致程序性能抖动\",{\"1\":{\"527\":1}}],[\"容灾能力\",{\"1\":{\"909\":1,\"921\":1}}],[\"容灾\",{\"1\":{\"176\":1}}],[\"容器调用destroy\",{\"1\":{\"662\":1}}],[\"容器调用service\",{\"1\":{\"662\":1}}],[\"容器调用servlet的service\",{\"1\":{\"661\":1}}],[\"容器调用init\",{\"1\":{\"662\":1}}],[\"容器加载servlet类并创建实例\",{\"1\":{\"662\":1}}],[\"容器将响应发送回客户端\",{\"1\":{\"661\":1}}],[\"容器将不会获得一个独立的\",{\"1\":{\"124\":1}}],[\"容器将不会虚拟出自己的网卡\",{\"1\":{\"122\":1}}],[\"容器创建请求和响应对象\",{\"1\":{\"661\":1}}],[\"容器可能会将不活跃的会话序列化到磁盘以释放内存\",{\"1\":{\"638\":1}}],[\"容器会\",{\"1\":{\"661\":1}}],[\"容器会按照以下优先级选择\",{\"1\":{\"656\":1}}],[\"容器会调用相应的listener进行处理\",{\"1\":{\"614\":1}}],[\"容器会共享一个网络环境\",{\"1\":{\"125\":1}}],[\"容器管理\",{\"2\":{\"152\":1}}],[\"容器内路径\",{\"1\":{\"150\":1}}],[\"容器内部的服务端口也可以使用宿主机的端口\",{\"1\":{\"124\":1}}],[\"容器启动后\",{\"1\":{\"145\":1}}],[\"容器使用后台运行\",{\"1\":{\"145\":1}}],[\"容器id\",{\"1\":{\"142\":2,\"143\":4,\"146\":1,\"147\":1,\"148\":1,\"149\":2,\"150\":1}}],[\"容器不停止\",{\"1\":{\"141\":1}}],[\"容器直接停止\",{\"1\":{\"141\":1}}],[\"容器名字\",{\"1\":{\"139\":1}}],[\"容器命令\",{\"0\":{\"138\":1}}],[\"容器操作及实用技巧\",{\"1\":{\"130\":1}}],[\"容器架构\",{\"2\":{\"128\":1}}],[\"容器技术\",{\"2\":{\"127\":1,\"151\":1}}],[\"容器无网卡\",{\"1\":{\"126\":1}}],[\"容器之间也可以相互通信\",{\"1\":{\"123\":1}}],[\"容器的时候\",{\"1\":{\"123\":1}}],[\"容器的默认的网络模式\",{\"1\":{\"123\":1}}],[\"容器具备\",{\"1\":{\"122\":1}}],[\"容器和另外一个容器共享\",{\"1\":{\"122\":1}}],[\"容器和宿主机共享\",{\"1\":{\"122\":1}}],[\"容器端口\",{\"1\":{\"121\":1,\"139\":4}}],[\"容器网桥docker0\",{\"1\":{\"121\":1}}],[\"容器互联\",{\"0\":{\"119\":1}}],[\"容器有自己的\",{\"1\":{\"126\":1}}],[\"容器有自己独立的命名空间隔离和资源限制\",{\"1\":{\"98\":1}}],[\"容器有独立的\",{\"1\":{\"122\":1}}],[\"容器有初建\",{\"1\":{\"98\":1}}],[\"容器是镜像的运行实体\",{\"1\":{\"98\":1}}],[\"容器\",{\"0\":{\"96\":1},\"1\":{\"104\":1}}],[\"宕机算雪崩吗\",{\"1\":{\"930\":1}}],[\"宕机\",{\"1\":{\"176\":1}}],[\"避免使用\",{\"1\":{\"956\":1}}],[\"避免因为过期失效而被击穿\",{\"1\":{\"930\":1}}],[\"避免每次从磁盘中存取数据\",{\"1\":{\"930\":1}}],[\"避免每次从内存中存取数据\",{\"1\":{\"930\":1}}],[\"避免产生更多的无效扣减\",{\"1\":{\"927\":1}}],[\"避免少卖\",{\"1\":{\"927\":2}}],[\"避免锁因为异常永远不被释放\",{\"1\":{\"909\":1,\"921\":1}}],[\"避免\",{\"1\":{\"813\":1}}],[\"避免隐式转换\",{\"1\":{\"807\":1}}],[\"避免数据类型转换\",{\"1\":{\"807\":1}}],[\"避免频繁创建\",{\"1\":{\"807\":1}}],[\"避免额外排序开销\",{\"1\":{\"807\":1}}],[\"避免访问集中的单个数据库或者单张数据表\",{\"1\":{\"727\":1}}],[\"避免在servlet中使用实例变量存储请求特定的数据\",{\"1\":{\"662\":1,\"689\":1}}],[\"避免硬编码\",{\"1\":{\"605\":1}}],[\"避免创建\",{\"1\":{\"605\":1}}],[\"避免重复操作\",{\"1\":{\"603\":1}}],[\"避免加锁访问\",{\"1\":{\"531\":1}}],[\"避免了加锁访问\",{\"1\":{\"524\":1}}],[\"避免了在多个节点之间进行额外的网络通信\",{\"1\":{\"175\":1}}],[\"避免遗漏资源回收\",{\"1\":{\"474\":1}}],[\"避免返回大型结构体\",{\"0\":{\"429\":1}}],[\"避免变量大小不能确定的时候\",{\"1\":{\"416\":1}}],[\"避免逃逸\",{\"0\":{\"416\":1}}],[\"避免堆分配的开销\",{\"1\":{\"292\":1}}],[\"避免传输\",{\"1\":{\"249\":1}}],[\"避免野指针比较简单\",{\"1\":{\"33\":1}}],[\"简介\",{\"0\":{\"512\":1,\"697\":1},\"1\":{\"952\":2}}],[\"简化了spring应用的初始搭建和开发过程\",{\"1\":{\"700\":1}}],[\"简化了数据一致性管理\",{\"1\":{\"175\":1}}],[\"简化版\",{\"1\":{\"374\":1}}],[\"简单视角理解\",{\"1\":{\"941\":1}}],[\"简单流程\",{\"1\":{\"927\":1}}],[\"简单动态字符串\",{\"1\":{\"873\":1}}],[\"简单总结一下\",{\"1\":{\"817\":1}}],[\"简单了解过\",{\"1\":{\"730\":1}}],[\"简单实现\",{\"0\":{\"717\":1}}],[\"简单类名\",{\"1\":{\"555\":1}}],[\"简单的字符串对象\",{\"1\":{\"882\":1}}],[\"简单的遍历可能更快\",{\"1\":{\"497\":1}}],[\"简单的示例\",{\"1\":{\"458\":1}}],[\"简单交互流程\",{\"1\":{\"249\":1}}],[\"简单交互过程\",{\"1\":{\"249\":1}}],[\"简单来说范围\",{\"1\":{\"873\":1}}],[\"简单来说\",{\"1\":{\"181\":1,\"748\":1,\"941\":1}}],[\"简单来说就是多备份情况下数据丢失风险变小\",{\"1\":{\"176\":1}}],[\"简而言之\",{\"1\":{\"23\":1,\"525\":1,\"751\":1,\"879\":1}}],[\"负载过高\",{\"1\":{\"957\":1}}],[\"负载因子大于\",{\"1\":{\"864\":1}}],[\"负载因子大于等于\",{\"1\":{\"864\":1}}],[\"负载因子表示目前\",{\"1\":{\"864\":1}}],[\"负载均衡就可\",{\"1\":{\"927\":1}}],[\"负载均衡算法\",{\"1\":{\"240\":1}}],[\"负载均衡算法有很多\",{\"1\":{\"77\":1}}],[\"负载均衡\",{\"0\":{\"77\":1},\"1\":{\"249\":1}}],[\"负责具体的存储数据\",{\"1\":{\"813\":1}}],[\"负责\",{\"1\":{\"813\":1}}],[\"负责检测可读队列\",{\"1\":{\"226\":1}}],[\"负责把\",{\"1\":{\"226\":1}}],[\"负责接收生产者的消息并处理读写请求\",{\"1\":{\"180\":1}}],[\"负责处理所有的读写请求\",{\"1\":{\"174\":1}}],[\"负责处理读写请求的分区主节点\",{\"1\":{\"173\":1}}],[\"帮助您高效管理数据库系统\",{\"1\":{\"832\":1}}],[\"帮助您高效地进行系统管理和日常操作\",{\"1\":{\"193\":1}}],[\"帮助开发者了解编译过程\",{\"1\":{\"390\":1}}],[\"帮助开发基于\",{\"1\":{\"229\":1}}],[\"帮助读者深入理解kafka的容灾能力\",{\"1\":{\"168\":1}}],[\"帮助命令\",{\"0\":{\"132\":1},\"1\":{\"132\":1}}],[\"由这个存储服务先写入mysql\",{\"1\":{\"930\":1}}],[\"由这两个字段综合决定\",{\"1\":{\"903\":1}}],[\"由它来访问数据库和缓存\",{\"1\":{\"930\":1}}],[\"由业务需求决定\",{\"1\":{\"900\":1}}],[\"由绿色事务组的\",{\"1\":{\"810\":1}}],[\"由有\",{\"1\":{\"810\":1}}],[\"由参数\",{\"1\":{\"810\":1}}],[\"由段\",{\"1\":{\"770\":1}}],[\"由后台线程将缓存在\",{\"1\":{\"751\":1,\"810\":1}}],[\"由producer依据确认机制的反馈来实现\",{\"1\":{\"709\":1}}],[\"由kafka\",{\"1\":{\"709\":1}}],[\"由一对反引号包裹起来\",{\"1\":{\"484\":1}}],[\"由上至下代表优先级由高到低\",{\"1\":{\"445\":1}}],[\"由服务端生成并发放给客户端\",{\"1\":{\"249\":1}}],[\"由浏览器维护\",{\"1\":{\"249\":1}}],[\"由客户端来进行\",{\"1\":{\"237\":1}}],[\"由内核中的\",{\"1\":{\"226\":1}}],[\"由\",{\"1\":{\"190\":1,\"711\":1,\"757\":1,\"817\":1,\"882\":1}}],[\"由消费者组协调器\",{\"1\":{\"165\":1}}],[\"由消费者这边指定\",{\"1\":{\"164\":1}}],[\"由于email是指针类型\",{\"1\":{\"993\":1}}],[\"由于我们传递的是一个指针\",{\"1\":{\"985\":1}}],[\"由于缓存是不命中时被动写的\",{\"1\":{\"930\":1}}],[\"由于加锁是一半以上同意就成功\",{\"1\":{\"917\":1,\"921\":1}}],[\"由于向5个redis发送请求\",{\"1\":{\"917\":1,\"921\":1}}],[\"由于业务流程比较长\",{\"1\":{\"912\":1,\"921\":1}}],[\"由于意外崩溃而导致未能主动解锁\",{\"1\":{\"909\":1,\"921\":1}}],[\"由于事务\",{\"1\":{\"820\":1}}],[\"由于对\",{\"1\":{\"820\":1}}],[\"由于主键具有唯一性\",{\"1\":{\"820\":1}}],[\"由于在对记录加独占锁前\",{\"1\":{\"820\":1}}],[\"由于在引擎层就过滤掉大量的数据\",{\"1\":{\"813\":1}}],[\"由于全文索引对每个字段值都会做分词\",{\"1\":{\"813\":1}}],[\"由于全文索引是基于分词实现的\",{\"1\":{\"813\":1}}],[\"由于存在冗余的节点\",{\"1\":{\"813\":1}}],[\"由于线程数远超核心数\",{\"1\":{\"807\":1}}],[\"由于没有提前分配存储空间\",{\"1\":{\"770\":1}}],[\"由于没有收到ack一直维护这些连接队列\",{\"1\":{\"243\":1}}],[\"由于是先申请了一片连续的内存空间但没写入具体数据\",{\"1\":{\"748\":1}}],[\"由于网络波动\",{\"1\":{\"712\":1}}],[\"由于网络或其他什么原因导致\",{\"1\":{\"23\":1}}],[\"由于变量的值不能在编译器确定\",{\"1\":{\"415\":1}}],[\"由于指针传递会逃逸\",{\"1\":{\"409\":1}}],[\"由于\",{\"1\":{\"249\":2,\"374\":1,\"479\":2,\"730\":1,\"763\":2,\"770\":1,\"810\":4,\"879\":1}}],[\"由于每一层都是独立的\",{\"1\":{\"249\":1}}],[\"由于每个进程都有自己的页表\",{\"1\":{\"217\":1}}],[\"由于tcp四元组确定一条连接\",{\"1\":{\"237\":1}}],[\"由于与网络有关\",{\"1\":{\"237\":1}}],[\"由于所有\",{\"1\":{\"229\":1}}],[\"由于物理内存不够\",{\"1\":{\"217\":1}}],[\"由于读写请求直接由leader节点处理\",{\"1\":{\"175\":1}}],[\"由于使用的是毫秒级时间戳\",{\"1\":{\"92\":1}}],[\"由于第一次请求所加的分布式锁已经过期所以第二次请求仍然能够加锁成功\",{\"1\":{\"23\":1}}],[\"由于重试机制或者网络不稳定\",{\"1\":{\"23\":1}}],[\"符号分隔\",{\"1\":{\"838\":1}}],[\"符号扩展为表上的所有列\",{\"1\":{\"817\":1}}],[\"符号\",{\"1\":{\"817\":1}}],[\"符号表示变量的地址\",{\"1\":{\"30\":1}}],[\"符合最左匹配吗\",{\"1\":{\"813\":1}}],[\"符合条件二\",{\"1\":{\"770\":1}}],[\"符合这种场景的业务\",{\"1\":{\"723\":1}}],[\"符合队列的先入先出特性\",{\"1\":{\"161\":1}}],[\"消除了大量歧义内容并引入了多项改进\",{\"1\":{\"249\":1}}],[\"消费之后希望按投递的顺序记录进某个文件或数据库\",{\"1\":{\"723\":1}}],[\"消费阶段示意图\",{\"1\":{\"711\":1}}],[\"消费阶段\",{\"0\":{\"711\":1},\"1\":{\"708\":1,\"713\":1}}],[\"消费消息的语义\",{\"0\":{\"704\":1}}],[\"消费是主动拉取\",{\"0\":{\"162\":1}}],[\"消费顺序即生产顺序\",{\"1\":{\"161\":1}}],[\"消费形式示意图\",{\"1\":{\"161\":1}}],[\"消费形式\",{\"0\":{\"161\":1}}],[\"消费信息\",{\"1\":{\"160\":1}}],[\"消费者去消息后\",{\"1\":{\"924\":1}}],[\"消费者无法知道\",{\"1\":{\"924\":1}}],[\"消费者在消费消息的时候出现异常或者错误\",{\"1\":{\"706\":1}}],[\"消费者处理\",{\"1\":{\"706\":1}}],[\"消费者收到新的分配后\",{\"1\":{\"165\":1}}],[\"消费者会暂停对消息的消费\",{\"1\":{\"165\":1}}],[\"消费者离开\",{\"1\":{\"165\":1}}],[\"消费者代码就得跟着升级\",{\"1\":{\"164\":1}}],[\"消费者可以被指派多个分片\",{\"1\":{\"164\":1}}],[\"消费者组的分配策略\",{\"0\":{\"165\":1}}],[\"消费者组的意思是将多个消费者组织在一起工作\",{\"1\":{\"164\":1}}],[\"消费者组示意图\",{\"1\":{\"164\":1}}],[\"消费者组\",{\"0\":{\"164\":1}}],[\"消费者消费消息之后会提交它在某个partition对应的offset\",{\"1\":{\"163\":1}}],[\"消费者拉取的频率\",{\"1\":{\"162\":1}}],[\"消费者通过订阅topic\",{\"1\":{\"160\":1}}],[\"消费者\",{\"1\":{\"156\":1}}],[\"消息还得想办法放回去\",{\"1\":{\"924\":1}}],[\"消息就退出队列了\",{\"1\":{\"924\":1}}],[\"消息分发\",{\"1\":{\"924\":1}}],[\"消息中间件做削峰填谷\",{\"1\":{\"807\":1}}],[\"消息服务分为\",{\"1\":{\"722\":1}}],[\"消息服务一个分区\",{\"1\":{\"722\":1}}],[\"消息服务等\",{\"1\":{\"722\":1}}],[\"消息有序场景示意图\",{\"1\":{\"719\":1}}],[\"消息准确消费示意图\",{\"1\":{\"717\":1}}],[\"消息不重复\",{\"1\":{\"717\":1}}],[\"消息不丢失\",{\"1\":{\"717\":1}}],[\"消息不会丢失\",{\"1\":{\"705\":2}}],[\"消息丢失环节示意图\",{\"1\":{\"708\":1}}],[\"消息在什么环节可能发生丢失\",{\"0\":{\"708\":1}}],[\"消息可能会丢失\",{\"1\":{\"705\":1}}],[\"消息可靠性\",{\"1\":{\"703\":1}}],[\"消息顺序性等重要主题\",{\"1\":{\"703\":1}}],[\"消息\",{\"1\":{\"249\":1}}],[\"消息传给服务端\",{\"1\":{\"249\":1}}],[\"消息里含有数字证书\",{\"1\":{\"249\":1}}],[\"消息里面有\",{\"1\":{\"249\":1}}],[\"消息正文\",{\"1\":{\"249\":1}}],[\"消息队列可以实现高性能\",{\"1\":{\"924\":1}}],[\"消息队列一般用于异步流程\",{\"1\":{\"924\":1}}],[\"消息队列组件一般实现的都是至少一次语义\",{\"1\":{\"706\":1}}],[\"消息队列\",{\"1\":{\"924\":1},\"2\":{\"166\":1,\"186\":1,\"725\":1,\"726\":1,\"926\":1}}],[\"消息偏移\",{\"0\":{\"163\":1}}],[\"消息摘要算法\",{\"1\":{\"73\":1}}],[\"消息重复消费\",{\"1\":{\"23\":1}}],[\"生命周期\",{\"0\":{\"662\":1}}],[\"生命周期以及常见问题\",{\"1\":{\"644\":1}}],[\"生命周期以及常见应用场景\",{\"1\":{\"576\":1,\"612\":1}}],[\"生命周期管理\",{\"1\":{\"614\":1}}],[\"生命周期是程序存活时间\",{\"1\":{\"439\":1}}],[\"生存时间\",{\"1\":{\"571\":1}}],[\"生产环境\",{\"1\":{\"957\":1}}],[\"生产订阅模式\",{\"1\":{\"924\":1}}],[\"生产阶段\",{\"0\":{\"709\":1},\"1\":{\"708\":1,\"713\":1}}],[\"生产\",{\"1\":{\"229\":1}}],[\"生产者重试发送\",{\"1\":{\"713\":1}}],[\"生产者将消息发送到特定的主题中\",{\"1\":{\"157\":1}}],[\"生产者\",{\"1\":{\"156\":1}}],[\"生成service代码\",{\"1\":{\"969\":1}}],[\"生成proto代码\",{\"1\":{\"969\":1}}],[\"生成所有proto源码\",{\"1\":{\"965\":1}}],[\"生成执行计划\",{\"1\":{\"813\":1}}],[\"生成最终的结果集\",{\"1\":{\"734\":1}}],[\"生成动态内容\",{\"1\":{\"647\":1}}],[\"生成token流\",{\"1\":{\"395\":1}}],[\"生成机器码\",{\"1\":{\"394\":1}}],[\"生成一个解析树\",{\"1\":{\"734\":1}}],[\"生成一个\",{\"1\":{\"472\":1,\"784\":1}}],[\"生成一个新的随机数\",{\"1\":{\"249\":1}}],[\"生成一对匹配的\",{\"1\":{\"249\":1}}],[\"生成服务端随机数\",{\"1\":{\"249\":1}}],[\"生成密钥\",{\"1\":{\"249\":1}}],[\"生成\",{\"1\":{\"240\":1,\"249\":2}}],[\"生成的结果里面\",{\"1\":{\"820\":1}}],[\"生成的日志\",{\"1\":{\"737\":1}}],[\"生成的客户端随机数\",{\"1\":{\"249\":1}}],[\"生成的\",{\"1\":{\"229\":1,\"753\":1,\"810\":1,\"820\":2}}],[\"生成的id可以根据需要进行进一步编码和转换\",{\"1\":{\"92\":1}}],[\"生成的id是一个64位的整数\",{\"1\":{\"92\":1}}],[\"生成各种编程语言的代码\",{\"1\":{\"229\":1}}],[\"jianghushin\",{\"1\":{\"957\":1}}],[\"jianghushinian\",{\"1\":{\"957\":11}}],[\"jpeg\",{\"1\":{\"708\":1}}],[\"jpg\",{\"1\":{\"598\":1,\"1037\":2}}],[\"jcp\",{\"1\":{\"658\":3}}],[\"jdbc\",{\"1\":{\"640\":1}}],[\"jdk\",{\"0\":{\"565\":1},\"1\":{\"565\":1,\"581\":1,\"617\":1,\"649\":1}}],[\"jetty或undertow\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"jre\",{\"0\":{\"565\":1},\"1\":{\"565\":2}}],[\"jvm可以理解的代码就叫做字节码\",{\"1\":{\"566\":1}}],[\"jvm\",{\"0\":{\"565\":1},\"1\":{\"565\":1}}],[\"j++\",{\"1\":{\"515\":3}}],[\"j\",{\"1\":{\"515\":10,\"770\":5}}],[\"join\",{\"1\":{\"503\":2,\"734\":1,\"823\":1,\"829\":1}}],[\"john\",{\"1\":{\"462\":1,\"556\":1,\"559\":1,\"637\":2}}],[\"jay\",{\"1\":{\"763\":3,\"810\":3}}],[\"james的私钥\",{\"1\":{\"249\":1}}],[\"james的公钥\",{\"1\":{\"249\":1}}],[\"james用自己的私钥解密\",{\"1\":{\"249\":1}}],[\"james\",{\"1\":{\"249\":4}}],[\"java填坑笔记\",{\"1\":{\"933\":1}}],[\"javaee\",{\"1\":{\"658\":3},\"2\":{\"611\":1,\"643\":1,\"695\":1}}],[\"javax\",{\"1\":{\"584\":3,\"624\":4,\"625\":4,\"626\":5,\"633\":3,\"634\":3,\"635\":4,\"637\":2,\"638\":2,\"652\":5}}],[\"java程序从代码到运行的过程\",{\"1\":{\"566\":1}}],[\"java语言通过字节码的方式\",{\"1\":{\"566\":1}}],[\"java语言特性\",{\"0\":{\"563\":1}}],[\"java核心类库\",{\"1\":{\"565\":1}}],[\"java工具\",{\"1\":{\"565\":1}}],[\"java的特点\",{\"0\":{\"564\":1}}],[\"java的异常处理机制提供了一种结构化和受控的方式来处理程序中的错误\",{\"1\":{\"536\":1}}],[\"java基础\",{\"0\":{\"562\":1}}],[\"java反射机制\",{\"0\":{\"549\":1}}],[\"java异常层次结构\",{\"1\":{\"538\":1}}],[\"java异常机制\",{\"0\":{\"535\":1}}],[\"java中的异常主要分为三类\",{\"1\":{\"538\":1}}],[\"java\",{\"0\":{\"154\":1},\"1\":{\"541\":1,\"553\":1,\"559\":3,\"584\":1,\"618\":1,\"625\":1,\"637\":1,\"638\":1,\"644\":1,\"652\":3},\"2\":{\"547\":1,\"560\":1,\"574\":1,\"610\":1,\"642\":1,\"694\":1,\"701\":1}}],[\"jsessionid=\",{\"1\":{\"692\":1}}],[\"js\",{\"1\":{\"598\":1}}],[\"jsp的扩展名匹配\",{\"1\":{\"656\":1}}],[\"jsp的精确匹配\",{\"1\":{\"656\":1}}],[\"jsp结尾的请求\",{\"1\":{\"587\":1}}],[\"jsp\",{\"1\":{\"587\":1,\"598\":2,\"656\":1}}],[\"jsp页面或html文件\",{\"1\":{\"578\":1}}],[\"js计算更不行\",{\"1\":{\"249\":1}}],[\"jsonstr1\",{\"1\":{\"491\":3}}],[\"json包的用法\",{\"1\":{\"482\":1}}],[\"json包的使用\",{\"0\":{\"482\":1}}],[\"json可以很清晰的描述\",{\"1\":{\"229\":1}}],[\"json\",{\"0\":{\"483\":1,\"1029\":1,\"1042\":1},\"1\":{\"3\":2,\"229\":1,\"249\":1,\"483\":6,\"487\":4,\"489\":2,\"490\":2,\"491\":2,\"873\":1,\"957\":17,\"962\":2,\"993\":1,\"1021\":2,\"1028\":1,\"1029\":1,\"1039\":1,\"1040\":1,\"1041\":2}}],[\"jul\",{\"1\":{\"249\":2}}],[\"jwt\",{\"1\":{\"240\":1,\"249\":2}}],[\"强\",{\"1\":{\"810\":1}}],[\"强一致性\",{\"1\":{\"727\":1}}],[\"强类型语言\",{\"1\":{\"564\":1}}],[\"强缓存是利用下面这两个\",{\"1\":{\"249\":1}}],[\"强制缓存\",{\"1\":{\"249\":1}}],[\"强制转换\",{\"1\":{\"226\":1}}],[\"强制覆盖复制\",{\"1\":{\"209\":1}}],[\"强制删除不提醒\",{\"1\":{\"209\":1}}],[\"强制删除\",{\"1\":{\"202\":1}}],[\"强制停止当前容器\",{\"1\":{\"143\":1}}],[\"强调是指针\",{\"1\":{\"33\":1}}],[\"强调是一个指向数组的指针\",{\"1\":{\"33\":1}}],[\"强调数组概念\",{\"1\":{\"33\":1}}],[\"列对象保存的所有字符串对象长度小于\",{\"1\":{\"867\":1}}],[\"列明等小写\",{\"1\":{\"829\":1}}],[\"列无法使用到联合索引\",{\"1\":{\"817\":1}}],[\"列作为聚簇索引的索引键\",{\"1\":{\"813\":1}}],[\"列\",{\"1\":{\"770\":1,\"820\":1,\"841\":1,\"842\":1}}],[\"列是\",{\"1\":{\"770\":2}}],[\"列的值是\",{\"1\":{\"770\":1}}],[\"列的值为\",{\"1\":{\"770\":2}}],[\"列不是变长字段\",{\"1\":{\"770\":1}}],[\"列和\",{\"1\":{\"770\":1}}],[\"列表\",{\"1\":{\"957\":1}}],[\"列表对象保存的所有字符串对象长度小于\",{\"1\":{\"876\":1}}],[\"列表对象元素个数少于\",{\"1\":{\"867\":1,\"876\":1}}],[\"列表中\",{\"1\":{\"744\":3,\"789\":3}}],[\"列表标签说明\",{\"1\":{\"134\":1}}],[\"列出用户\",{\"0\":{\"842\":1}}],[\"列出可对资源实行的方法\",{\"1\":{\"249\":1}}],[\"列出目录及文件名\",{\"1\":{\"201\":1}}],[\"列出当前正在运行的容器+历史运行过的容器\",{\"1\":{\"140\":1}}],[\"列出当前正在运行的容器\",{\"1\":{\"140\":1}}],[\"列出所有运行的容器\",{\"0\":{\"140\":1}}],[\"小林coding\",{\"1\":{\"936\":1}}],[\"小林的图文解释的很好\",{\"1\":{\"879\":1}}],[\"小林图解也有提到\",{\"1\":{\"748\":1}}],[\"小数据量时遍历访问性能好\",{\"1\":{\"879\":1}}],[\"小于等于\",{\"1\":{\"820\":2,\"873\":1}}],[\"小于\",{\"1\":{\"820\":2,\"864\":1,\"873\":1}}],[\"小于或者小于等于\",{\"1\":{\"820\":1}}],[\"小时\",{\"1\":{\"817\":1,\"903\":1}}],[\"小明\",{\"1\":{\"483\":3,\"487\":2,\"488\":1,\"489\":5,\"490\":2}}],[\"小写字母p\",{\"1\":{\"139\":1}}],[\"小顶堆\",{\"1\":{\"51\":1}}],[\"可读性降低的aof\",{\"1\":{\"949\":1}}],[\"可配置多个\",{\"1\":{\"957\":2}}],[\"可配置\",{\"1\":{\"943\":1}}],[\"可配置性\",{\"1\":{\"578\":1}}],[\"可用\",{\"1\":{\"924\":3}}],[\"可用尝试引入\",{\"1\":{\"813\":1}}],[\"可取的值有\",{\"1\":{\"810\":1}}],[\"可见\",{\"1\":{\"744\":2,\"789\":2}}],[\"可重复读的隔离级别\",{\"1\":{\"820\":1}}],[\"可重复读的工作原理\",{\"0\":{\"791\":1}}],[\"可重复读是否完全解决幻读\",{\"0\":{\"792\":1}}],[\"可重复读与幻读问题\",{\"0\":{\"790\":1}}],[\"可重复读隔离级别下\",{\"1\":{\"820\":1}}],[\"可重复读隔离级别的事务\",{\"1\":{\"820\":1}}],[\"可重复读隔离级别是\",{\"1\":{\"791\":1}}],[\"可重复读隔离级别\",{\"1\":{\"743\":1}}],[\"可重复读\",{\"1\":{\"743\":1,\"782\":1,\"784\":2,\"810\":2,\"820\":2}}],[\"可靠\",{\"1\":{\"710\":1}}],[\"可靠性强\",{\"1\":{\"930\":1}}],[\"可靠性还是很大差距\",{\"1\":{\"924\":1}}],[\"可靠性探索\",{\"0\":{\"918\":1},\"1\":{\"921\":1}}],[\"可靠性会向etcd靠近\",{\"1\":{\"917\":1,\"921\":1}}],[\"可靠性的保证\",{\"0\":{\"915\":1},\"1\":{\"921\":1}}],[\"可靠性\",{\"1\":{\"249\":1,\"710\":1,\"909\":1,\"921\":1}}],[\"可跳转到任意url\",{\"1\":{\"682\":1}}],[\"可共享request域\",{\"1\":{\"682\":1}}],[\"可多次执行\",{\"1\":{\"662\":1}}],[\"可扩展性\",{\"1\":{\"646\":1}}],[\"可在任何支持java的平台上运行\",{\"1\":{\"646\":1}}],[\"可维护性考虑\",{\"0\":{\"605\":1}}],[\"可选\",{\"0\":{\"588\":1,\"627\":1,\"658\":1},\"1\":{\"734\":1}}],[\"可选参数\",{\"1\":{\"139\":1}}],[\"可被分解成以下3步\",{\"1\":{\"477\":1}}],[\"可变参数会被当作一个切片\",{\"1\":{\"458\":1}}],[\"可变参数原理\",{\"1\":{\"458\":1}}],[\"可变参数使用省略号\",{\"1\":{\"458\":1}}],[\"可变参数\",{\"0\":{\"458\":1},\"1\":{\"458\":1}}],[\"可认为是一个计数器\",{\"1\":{\"442\":1}}],[\"可分为非持久cookie和持久cookie\",{\"1\":{\"249\":1}}],[\"可分为内存cookie和硬盘cookie\",{\"1\":{\"249\":1}}],[\"可能采用相同的编码方式\",{\"1\":{\"938\":1}}],[\"可能db就挂掉了\",{\"1\":{\"930\":1}}],[\"可能已经没有库存了\",{\"1\":{\"927\":1}}],[\"可能都是一个出口ip\",{\"1\":{\"927\":1}}],[\"可能锁获取的时候还是自己的\",{\"1\":{\"913\":1,\"921\":1}}],[\"可能服务\",{\"1\":{\"912\":1,\"921\":1}}],[\"可能发生在两个地方\",{\"1\":{\"888\":1}}],[\"可能存在几十个竞争者\",{\"1\":{\"912\":1,\"921\":1}}],[\"可能存在的问题\",{\"1\":{\"888\":1}}],[\"可能存储更多的数据\",{\"1\":{\"770\":1}}],[\"可能导致和数据源差距过大\",{\"1\":{\"882\":1}}],[\"可能导致消息重复发送\",{\"1\":{\"706\":1}}],[\"可能要对多个用户赋予相同的权限\",{\"1\":{\"850\":1}}],[\"可能原因\",{\"1\":{\"813\":1}}],[\"可能涉及复杂的树的变形\",{\"1\":{\"813\":1}}],[\"可能在非叶子节点就能找到索引\",{\"1\":{\"813\":1}}],[\"可能非常慢\",{\"1\":{\"807\":1}}],[\"可能需要优化\",{\"1\":{\"807\":1}}],[\"可能是重建定时器\",{\"1\":{\"882\":1}}],[\"可能是因为索引返回的行比实际需要的行多\",{\"1\":{\"807\":1}}],[\"可能是无法识别这个请求方法\",{\"1\":{\"240\":1}}],[\"可能出现同时处理多个事务的情况\",{\"1\":{\"776\":1}}],[\"可能出现半成功的状态\",{\"1\":{\"763\":1,\"810\":1}}],[\"可能离得非常远\",{\"1\":{\"770\":1}}],[\"可能有不同的服务\",{\"1\":{\"722\":1}}],[\"可能的原因\",{\"1\":{\"607\":1,\"608\":1,\"609\":1}}],[\"可能破坏封装性\",{\"1\":{\"552\":1}}],[\"可能抛出异常的代码\",{\"1\":{\"540\":1}}],[\"可能len>字符个数\",{\"1\":{\"353\":1}}],[\"可能会少了很多数据\",{\"1\":{\"952\":1}}],[\"可能会丢失相对比较多的数据\",{\"1\":{\"952\":1}}],[\"可能会影响命令处理性能\",{\"1\":{\"882\":1}}],[\"可能会发生意想不到的事情\",{\"1\":{\"820\":1}}],[\"可能会导致后续大量entry\",{\"1\":{\"879\":1}}],[\"可能会导致树的复杂变化\",{\"1\":{\"813\":1}}],[\"可能会导致支付消息先到而下单消息后到\",{\"1\":{\"719\":1}}],[\"可能会导致数据不一致或崩溃\",{\"1\":{\"520\":1}}],[\"可能会导致不必要的内存复制\",{\"1\":{\"428\":1}}],[\"可能会使用到堆\",{\"1\":{\"409\":1}}],[\"可能会有序列号绕回导致数据完整性破坏\",{\"1\":{\"237\":1}}],[\"可能会出现消息丢失的问题\",{\"1\":{\"183\":1}}],[\"可执行文件采用\",{\"1\":{\"220\":1}}],[\"可以放多个\",{\"1\":{\"982\":1}}],[\"可以自己设置\",{\"1\":{\"980\":1}}],[\"可以自动转换成\",{\"1\":{\"867\":1}}],[\"可以查看源码\",{\"1\":{\"957\":1}}],[\"可以参考这里\",{\"1\":{\"957\":1}}],[\"可以参考官方示例\",{\"1\":{\"957\":1}}],[\"可以参考上面的防重处理思路\",{\"1\":{\"715\":1}}],[\"可以只开启\",{\"1\":{\"952\":1}}],[\"可以只针对该用户做限制\",{\"1\":{\"927\":1}}],[\"可以同时开启\",{\"1\":{\"952\":1}}],[\"可以增加个删除逻辑\",{\"1\":{\"930\":1}}],[\"可以加一个睡眠然后循环重试\",{\"1\":{\"930\":2}}],[\"可以用来告诉我们\",{\"1\":{\"930\":1}}],[\"可以用开源的\",{\"1\":{\"730\":1}}],[\"可以考虑走wal路线\",{\"1\":{\"927\":1}}],[\"可以考虑开启\",{\"1\":{\"237\":1}}],[\"可以先入先出\",{\"1\":{\"924\":1}}],[\"可以先对数据进行分片\",{\"1\":{\"79\":1}}],[\"可以尝试多机部署\",{\"1\":{\"917\":1,\"921\":1}}],[\"可以灵活自动切换\",{\"1\":{\"916\":1,\"921\":1}}],[\"可以发现\",{\"1\":{\"912\":1,\"921\":1,\"946\":1,\"957\":1}}],[\"可以选择更新多个字段\",{\"1\":{\"998\":1}}],[\"可以选择临时调度\",{\"1\":{\"927\":1}}],[\"可以选择时\",{\"1\":{\"900\":1}}],[\"可以选择前缀索引\",{\"1\":{\"813\":1}}],[\"可以设置过期键\",{\"1\":{\"894\":1}}],[\"可以重复\",{\"1\":{\"885\":1}}],[\"可以对所有数据对象设置过期时间\",{\"1\":{\"882\":1}}],[\"可以很方便清除缓存以便后续再次加载进去\",{\"1\":{\"882\":1}}],[\"可以从\",{\"1\":{\"879\":1}}],[\"可以跳到前一个节点的开头位置\",{\"1\":{\"879\":1}}],[\"可以\",{\"1\":{\"879\":1}}],[\"可以快速定位到数据所在\",{\"1\":{\"876\":1}}],[\"可以叫\",{\"1\":{\"876\":1}}],[\"可以预留空间\",{\"1\":{\"873\":1}}],[\"可以处理文本数据\",{\"1\":{\"873\":1}}],[\"可以插入成功\",{\"1\":{\"820\":1}}],[\"可以执行\",{\"1\":{\"820\":1}}],[\"可以确认是\",{\"1\":{\"820\":1}}],[\"可以确保数据表中的数据唯一性\",{\"1\":{\"813\":1}}],[\"可以不指定主键的值\",{\"1\":{\"820\":1}}],[\"可以不需要等到将缓存在\",{\"1\":{\"752\":1,\"810\":1}}],[\"可以分为\",{\"1\":{\"820\":1}}],[\"可以带来十分明显的性能提升\",{\"1\":{\"813\":1}}],[\"可以做到索引扫描\",{\"1\":{\"813\":1}}],[\"可以进行索引下推\",{\"1\":{\"813\":1}}],[\"可以走索引\",{\"1\":{\"813\":1}}],[\"可以这么简单理解\",{\"1\":{\"813\":1}}],[\"可以理解成目录\",{\"1\":{\"864\":1}}],[\"可以理解成对主键索引表\",{\"1\":{\"813\":1}}],[\"可以理解为\",{\"1\":{\"930\":1}}],[\"可以理解为记录当前事务id创建时\",{\"1\":{\"744\":1}}],[\"可以理解为动态数组\",{\"1\":{\"337\":1}}],[\"可以理解为读取或者下载数据\",{\"1\":{\"249\":1}}],[\"可以理解为c\",{\"1\":{\"229\":1}}],[\"可以理解为机器或者节点吧\",{\"1\":{\"157\":1}}],[\"可以尽早的处理下一组事务\",{\"1\":{\"810\":1}}],[\"可以知道\",{\"1\":{\"810\":2}}],[\"可以知道该记录是被哪个事务修改的\",{\"1\":{\"742\":1,\"810\":1}}],[\"可以称为逻辑日志\",{\"1\":{\"810\":1}}],[\"可以比喻为你有一个本子\",{\"1\":{\"810\":1}}],[\"可以提升索引扫描的效率\",{\"1\":{\"807\":1}}],[\"可以提供很多有用的特性\",{\"1\":{\"106\":1}}],[\"可以得出一个结论\",{\"1\":{\"770\":1}}],[\"可以看的出来\",{\"1\":{\"810\":1}}],[\"可以看出来\",{\"1\":{\"810\":1}}],[\"可以看到不同的数据对象\",{\"1\":{\"938\":1}}],[\"可以看到三个元素都挨在一起\",{\"1\":{\"867\":1}}],[\"可以看到这条记录是没有加任何锁的\",{\"1\":{\"820\":1}}],[\"可以看到\",{\"1\":{\"770\":4,\"810\":3,\"813\":2,\"817\":2,\"820\":5,\"864\":1,\"867\":1,\"930\":1,\"957\":1}}],[\"可以看作是\",{\"1\":{\"249\":1}}],[\"可以缓存的数据类型\",{\"1\":{\"748\":1}}],[\"可以利用\",{\"1\":{\"740\":1,\"810\":2}}],[\"可以剔除原有主机\",{\"1\":{\"730\":1}}],[\"可以强制读主库\",{\"1\":{\"730\":1}}],[\"可以访问java\",{\"1\":{\"646\":1}}],[\"可以获取更多信息\",{\"1\":{\"626\":2,\"635\":3}}],[\"可以监听属性的添加\",{\"1\":{\"614\":1}}],[\"可以监听web组件的创建和销毁\",{\"1\":{\"614\":1}}],[\"可以拦截进入web应用的请求和离开web应用的响应\",{\"1\":{\"578\":1}}],[\"可以再去查一次啊\",{\"1\":{\"918\":1,\"921\":1}}],[\"可以再次通过\",{\"1\":{\"524\":1}}],[\"可以再里面操作\",{\"1\":{\"149\":1}}],[\"可以为\",{\"1\":{\"518\":1}}],[\"可以避免创建临时字符串\",{\"1\":{\"502\":1}}],[\"可以像下面这样定义结构体\",{\"0\":{\"488\":1}}],[\"可以按如下方式在tag中添加\",{\"1\":{\"486\":1}}],[\"可以总结为以下\",{\"1\":{\"479\":1}}],[\"可以实现多态的效果\",{\"1\":{\"463\":1}}],[\"可以实现类似继承的效果\",{\"1\":{\"462\":1}}],[\"可以直接通过make命令生成\",{\"1\":{\"969\":1}}],[\"可以直接从叶子节点中删除\",{\"1\":{\"813\":1}}],[\"可以直接利用索引顺序进行排序\",{\"1\":{\"807\":1}}],[\"可以直接调用内部结构体\",{\"1\":{\"462\":1}}],[\"可以直接把文件或目录从资源管理器\",{\"1\":{\"249\":1}}],[\"可以存在不同的源文件\",{\"1\":{\"461\":1}}],[\"可以改变形参的值\",{\"1\":{\"454\":1}}],[\"可以省略\",{\"1\":{\"440\":1}}],[\"可以减少心智成本\",{\"1\":{\"930\":1}}],[\"可以减少随机写入的频率和次数\",{\"1\":{\"754\":1}}],[\"可以减少gc压力\",{\"1\":{\"405\":1}}],[\"可以减少遍历的次数\",{\"1\":{\"226\":1}}],[\"可以控制编译过程中的优化行为\",{\"1\":{\"397\":1}}],[\"可以将任意类型的数据赋值给一个空接口\",{\"1\":{\"300\":1}}],[\"可以高效实现协程的阻塞和唤醒及多路复用\",{\"1\":{\"254\":1}}],[\"可以防止明文被篡改\",{\"1\":{\"249\":1}}],[\"可以让对方也发对方的公钥过来\",{\"1\":{\"249\":1}}],[\"可以是数字\",{\"1\":{\"989\":1}}],[\"可以是字符串\",{\"1\":{\"989\":1}}],[\"可以是字符串或数字\",{\"1\":{\"873\":1}}],[\"可以是ip或者域名\",{\"1\":{\"976\":1}}],[\"可以是所有对象\",{\"1\":{\"846\":1}}],[\"可以是普通字段查询也可以是获取聚合函数的查询结果\",{\"1\":{\"823\":1}}],[\"可以是任意类型\",{\"1\":{\"460\":1}}],[\"可以是文本\",{\"1\":{\"249\":1}}],[\"可以是图片\",{\"1\":{\"249\":1}}],[\"可以认为cookie只是实现session机制的一种方法途径而已\",{\"1\":{\"249\":1}}],[\"可以认为是消息的中转站\",{\"1\":{\"156\":1}}],[\"可以多次删除同一个资源\",{\"1\":{\"249\":1}}],[\"可以根据\",{\"1\":{\"810\":1}}],[\"可以根据实际需求\",{\"1\":{\"249\":1}}],[\"可以根据机器的网络地址或其他唯一标识来生成机器id\",{\"1\":{\"92\":1}}],[\"可以任意添加请求动作\",{\"1\":{\"249\":1}}],[\"可以任意排列不影响语义\",{\"1\":{\"249\":1}}],[\"可以传递多个go\",{\"1\":{\"229\":1}}],[\"可以向\",{\"1\":{\"229\":1}}],[\"可以嵌套使用\",{\"1\":{\"229\":1}}],[\"可以表示不在\",{\"1\":{\"229\":1}}],[\"可以怎么表示呢\",{\"1\":{\"229\":1}}],[\"可以保存所有待检测的\",{\"1\":{\"226\":1}}],[\"可以立即开始做其他事情\",{\"1\":{\"226\":1}}],[\"可以到\",{\"1\":{\"223\":2}}],[\"可以正常使用8gb内存\",{\"1\":{\"217\":1}}],[\"可以被索引下推\",{\"1\":{\"813\":1}}],[\"可以被用来转换任何类型的指针\",{\"1\":{\"460\":1}}],[\"可以被划分为多个分区\",{\"1\":{\"172\":1}}],[\"可以被独立地读写\",{\"1\":{\"157\":1}}],[\"可以被多次改变\",{\"1\":{\"33\":1}}],[\"可以把字符串转化为字节数组\",{\"1\":{\"356\":1}}],[\"可以把这个脚本\",{\"1\":{\"223\":1}}],[\"可以把\",{\"1\":{\"156\":1}}],[\"可以指定显示几条\",{\"1\":{\"140\":1}}],[\"可以说对性能的影响最小\",{\"1\":{\"952\":1}}],[\"可以说是专门为解决原子问题而生\",{\"1\":{\"927\":1}}],[\"可以说是让原本的\",{\"1\":{\"524\":1}}],[\"可以说这是\",{\"1\":{\"810\":1}}],[\"可以说\",{\"1\":{\"103\":1}}],[\"可以使代码更清晰\",{\"1\":{\"427\":1}}],[\"可以使用select选择要更新的字段\",{\"1\":{\"998\":1}}],[\"可以使用判断\",{\"1\":{\"992\":1}}],[\"可以使用文件开头是否为\",{\"1\":{\"949\":1}}],[\"可以使用订阅binlog的模式来更新\",{\"1\":{\"930\":1}}],[\"可以使用的场景非常多\",{\"1\":{\"867\":1}}],[\"可以使用\",{\"1\":{\"841\":1,\"870\":1,\"957\":1}}],[\"可以使用以下命令来启动和停止mysql服务器\",{\"1\":{\"835\":1}}],[\"可以使用下面这两个方式\",{\"1\":{\"820\":3}}],[\"可以使用下面这条命令\",{\"1\":{\"820\":1}}],[\"可以使用下面的命令\",{\"1\":{\"820\":1}}],[\"可以使用前缀压缩来节省索引空间\",{\"1\":{\"807\":1}}],[\"可以使用hex\",{\"1\":{\"770\":1}}],[\"可以使用fallthrough\",{\"1\":{\"450\":1}}],[\"可以使用连字符\",{\"1\":{\"249\":1}}],[\"可以使用标准里的\",{\"1\":{\"249\":1}}],[\"可以使用分布式锁\",{\"1\":{\"23\":1}}],[\"可以使局部变量在函数调用结束后仍然保留其值\",{\"1\":{\"33\":1}}],[\"可以使全局变量具有内部链接性\",{\"1\":{\"33\":1}}],[\"可以创建指向常量的指针或引用\",{\"1\":{\"33\":1}}],[\"可以定义不可更改的常量\",{\"1\":{\"33\":1}}],[\"可以有效节约内存空间\",{\"1\":{\"867\":1}}],[\"可以有实现\",{\"1\":{\"33\":1}}],[\"可以有多级指针\",{\"1\":{\"33\":1}}],[\"可以完成链式操作\",{\"1\":{\"30\":1}}],[\"可以结合业务场景\",{\"1\":{\"23\":1}}],[\"可以通过以下命令创建新项目\",{\"1\":{\"961\":1}}],[\"可以通过消息队列实现\",{\"1\":{\"927\":1}}],[\"可以通过配置项修改proto\",{\"1\":{\"873\":1}}],[\"可以通过配置参数\",{\"1\":{\"183\":1}}],[\"可以通过设置下面这两个参数来实现\",{\"1\":{\"810\":1}}],[\"可以通过注解或xml配置应用于特定的url模式\",{\"1\":{\"578\":1}}],[\"可以通过类名直接访问\",{\"1\":{\"573\":1}}],[\"可以通过go\",{\"1\":{\"229\":1}}],[\"可以通过端口映射\",{\"1\":{\"121\":1}}],[\"可以通过ulimit\",{\"1\":{\"33\":1}}],[\"可以通过\",{\"1\":{\"23\":1,\"585\":1,\"755\":1,\"810\":1}}],[\"可以在访问db之后\",{\"1\":{\"930\":1}}],[\"可以在存储引擎层进行索引遍历过程中\",{\"1\":{\"813\":1}}],[\"可以在事务没提交之前持久化到磁盘\",{\"1\":{\"810\":1}}],[\"可以在主数据库发生宕机时\",{\"1\":{\"730\":1}}],[\"可以在servlet处理前后执行操作\",{\"1\":{\"683\":1}}],[\"可以在这里进行一些初始化工作\",{\"1\":{\"638\":1}}],[\"可以在这里进行一些清理工作\",{\"1\":{\"638\":1}}],[\"可以在这里进行其他初始化操作\",{\"1\":{\"590\":1}}],[\"可以在这里设置会话属性\",{\"1\":{\"625\":1}}],[\"可以在web\",{\"1\":{\"588\":1,\"627\":1,\"658\":1}}],[\"可以在对应字段添加omitempty\",{\"1\":{\"487\":1}}],[\"可以在运行的时候通过反射的机制读取出来\",{\"1\":{\"484\":1}}],[\"可以在并不真正需要资源的场合\",{\"1\":{\"249\":1}}],[\"可以在应用层设计一个逻辑\",{\"1\":{\"237\":1}}],[\"可以在命令行上指定\",{\"1\":{\"229\":1}}],[\"可以在\",{\"1\":{\"229\":1}}],[\"可以在容器之间共享和重用\",{\"1\":{\"106\":1}}],[\"可以在函数参数和返回值前加上const\",{\"1\":{\"33\":1}}],[\"可以在订单表中设置订单号\",{\"1\":{\"23\":1}}],[\"可以在vsc的设置里面搜索\",{\"1\":{\"3\":1}}],[\"$2a$14$ael8nw7uf\",{\"1\":{\"1059\":1}}],[\"$gobin\",{\"1\":{\"229\":2}}],[\"$path\",{\"1\":{\"209\":1}}],[\"$\",{\"1\":{\"137\":1,\"142\":1,\"391\":7}}],[\"kratos版本升级\",{\"1\":{\"970\":1}}],[\"kratos项目初始化运行\",{\"0\":{\"963\":1}}],[\"kratos项目结构\",{\"0\":{\"961\":1}}],[\"kratos\",{\"0\":{\"967\":1},\"1\":{\"961\":1,\"964\":1,\"966\":1,\"968\":4,\"969\":4,\"970\":3},\"2\":{\"972\":1}}],[\"kratos使用kratos\",{\"1\":{\"961\":1}}],[\"kratos微服务框架详解\",{\"0\":{\"960\":1}}],[\"kryiea\",{\"1\":{\"137\":3,\"141\":1,\"145\":1,\"147\":1,\"410\":1,\"447\":1,\"735\":1,\"763\":3}}],[\"k\",{\"1\":{\"453\":2,\"516\":1,\"523\":4,\"527\":1,\"529\":3,\"531\":2,\"532\":2,\"864\":5,\"873\":1,\"891\":1,\"894\":2,\"940\":1,\"943\":1,\"944\":1,\"945\":3}}],[\"kv\",{\"1\":{\"249\":1,\"531\":1}}],[\"keep\",{\"1\":{\"237\":3,\"249\":4}}],[\"keepalive\",{\"1\":{\"237\":1}}],[\"keylist\",{\"1\":{\"1035\":2}}],[\"key=124\",{\"1\":{\"1035\":1}}],[\"key=123\",{\"1\":{\"1035\":1}}],[\"key=xxx\",{\"1\":{\"1035\":1}}],[\"key=value\",{\"1\":{\"249\":2}}],[\"keys\",{\"1\":{\"944\":3,\"957\":1}}],[\"key1\",{\"1\":{\"514\":5}}],[\"key2\",{\"1\":{\"484\":1,\"514\":2}}],[\"key这个索引对应的数组的\",{\"1\":{\"20\":1}}],[\"key\",{\"1\":{\"20\":2,\"249\":5,\"452\":2,\"512\":1,\"514\":2,\"515\":14,\"516\":1,\"519\":1,\"523\":1,\"524\":8,\"525\":3,\"529\":6,\"531\":12,\"532\":1,\"714\":1,\"770\":3,\"783\":3,\"795\":1,\"807\":2,\"813\":4,\"817\":4,\"820\":58,\"873\":7,\"882\":7,\"888\":1,\"894\":3,\"900\":2,\"903\":1,\"906\":15,\"910\":1,\"911\":1,\"921\":1,\"930\":1,\"937\":2,\"939\":1,\"941\":1,\"944\":2,\"946\":2,\"957\":5,\"983\":1,\"1035\":1}}],[\"kb\",{\"1\":{\"217\":2,\"378\":3}}],[\"ksh\",{\"1\":{\"190\":1}}],[\"korn\",{\"1\":{\"190\":2}}],[\"kafka消费者通过提交每个分区的偏移量来跟踪已经消费的消息\",{\"1\":{\"711\":1}}],[\"kafka提供了偏移量管理功能\",{\"1\":{\"711\":1}}],[\"kafka的消息确认机制依赖存储阶段\",{\"1\":{\"710\":1}}],[\"kafka这种消息队列\",{\"1\":{\"710\":1}}],[\"kafka本身是没有什么机制能保证生产一定成功的\",{\"1\":{\"709\":1}}],[\"kafka支持并发消费\",{\"1\":{\"706\":1}}],[\"kafka中的每个主题\",{\"1\":{\"172\":1}}],[\"kafka需要重新分配这些分区\",{\"1\":{\"165\":1}}],[\"kafka需要重新分配分区\",{\"1\":{\"165\":1}}],[\"kafka不会自动管理分区和消费者之间的关系\",{\"1\":{\"164\":1}}],[\"kafka是需要消费者主动去broker拉取消息回来消费的\",{\"1\":{\"162\":1}}],[\"kafka整体架构图\",{\"1\":{\"156\":1}}],[\"kafka\",{\"0\":{\"155\":1,\"168\":1,\"169\":1,\"170\":1,\"176\":1,\"188\":1,\"703\":1},\"1\":{\"156\":1,\"164\":1,\"169\":1,\"176\":3,\"177\":1,\"180\":1,\"181\":1,\"706\":2,\"708\":1,\"924\":2},\"2\":{\"167\":1,\"187\":1,\"726\":1}}],[\"kill\",{\"1\":{\"143\":1,\"217\":1,\"817\":2,\"820\":1}}],[\"搜索的字符串\",{\"1\":{\"211\":1}}],[\"搜索查找命令\",{\"0\":{\"211\":1}}],[\"搜索镜像\",{\"0\":{\"135\":1}}],[\"搜索一张图是否存在\",{\"1\":{\"75\":1}}],[\"需自行添加网卡\",{\"1\":{\"126\":1}}],[\"需要根据程序的特点来决定\",{\"1\":{\"957\":1}}],[\"需要进行\",{\"1\":{\"945\":1}}],[\"需要进一步操作\",{\"1\":{\"249\":1}}],[\"需要优化为\",{\"1\":{\"927\":1}}],[\"需要持久化\",{\"1\":{\"924\":1}}],[\"需要消费组\",{\"1\":{\"924\":1}}],[\"需要ack\",{\"1\":{\"924\":1}}],[\"需要向每个redis发送解锁命令\",{\"1\":{\"917\":1,\"921\":1}}],[\"需要人工参与\",{\"1\":{\"916\":1,\"921\":1}}],[\"需要有一定程度的异常处理能力\",{\"1\":{\"909\":1,\"921\":1}}],[\"需要有额外的确认机制才可以\",{\"1\":{\"709\":1}}],[\"需要放入\",{\"1\":{\"906\":1}}],[\"需要主动开启\",{\"1\":{\"897\":1}}],[\"需要加锁来实现\",{\"1\":{\"891\":1}}],[\"需要比较随机才能在各个场景表现出较为平均的性能\",{\"1\":{\"885\":1}}],[\"需要走\",{\"1\":{\"885\":1}}],[\"需要一定时间后\",{\"1\":{\"882\":1}}],[\"需要一种不记录\",{\"1\":{\"879\":1}}],[\"需要一个构造函数\",{\"1\":{\"33\":1}}],[\"需要字节从\",{\"1\":{\"879\":1}}],[\"需要支持\",{\"1\":{\"879\":1}}],[\"需要更新\",{\"1\":{\"879\":1}}],[\"需要遍历这个压缩列表\",{\"1\":{\"879\":1}}],[\"需要遍历一次链表\",{\"1\":{\"864\":1}}],[\"需要获取尾巴节点\",{\"1\":{\"879\":1}}],[\"需要为整个\",{\"1\":{\"867\":1}}],[\"需要为每台机器分配一个唯一的机器id\",{\"1\":{\"92\":1}}],[\"需要等待其它事务释放间隙锁之后\",{\"1\":{\"820\":1}}],[\"需要额外维护索引结构\",{\"1\":{\"813\":1}}],[\"需要额外的空间存储索引数据\",{\"1\":{\"813\":1}}],[\"需要先对表加上\",{\"1\":{\"820\":1}}],[\"需要先在表级别加上一个\",{\"1\":{\"820\":2}}],[\"需要先回表所有数据\",{\"1\":{\"813\":1}}],[\"需要先找到一块大小合适的内存\",{\"1\":{\"405\":1}}],[\"需要回表\",{\"1\":{\"813\":1}}],[\"需要查两个\",{\"1\":{\"813\":1}}],[\"需要将\",{\"1\":{\"810\":1}}],[\"需要将被更新的列的旧值记下来\",{\"1\":{\"753\":1}}],[\"需要的\",{\"1\":{\"810\":1}}],[\"需要的计算时间也越长\",{\"1\":{\"74\":1}}],[\"需要记录对应的\",{\"1\":{\"810\":3}}],[\"需要记录对应\",{\"1\":{\"810\":1}}],[\"需要记录的内容也是不同的\",{\"1\":{\"810\":1}}],[\"需要去测试\",{\"1\":{\"807\":1}}],[\"需要去重\",{\"1\":{\"20\":1}}],[\"需要用多少字节表示\",{\"1\":{\"770\":1}}],[\"需要用新的url重新发送请求获取资源\",{\"1\":{\"240\":1}}],[\"需要减去请求时间\",{\"1\":{\"917\":1,\"918\":1,\"921\":2}}],[\"需要减去\",{\"1\":{\"770\":3}}],[\"需要判断插入位置是否已被其他事务加了间隙锁\",{\"1\":{\"820\":1}}],[\"需要判断\",{\"1\":{\"744\":1,\"789\":1}}],[\"需要了解一条记录在innodb引擎中的存储格式\",{\"1\":{\"742\":1}}],[\"需要按照时间顺序处理\",{\"1\":{\"719\":1}}],[\"需要严格保证消息处理一次且仅一次\",{\"1\":{\"705\":1}}],[\"需要通过类的实例对象去访问\",{\"1\":{\"573\":1}}],[\"需要通过创建子进程或者线程的方式来实现\",{\"1\":{\"226\":1}}],[\"需要保证数据的强一致性\",{\"1\":{\"952\":1}}],[\"需要保证自己的数据是全量的\",{\"1\":{\"519\":1}}],[\"需要保留调用函数的现场\",{\"1\":{\"36\":1}}],[\"需要配合互斥锁使用\",{\"1\":{\"516\":1}}],[\"需要改为具名嵌套或定义字段tag\",{\"1\":{\"489\":1}}],[\"需要思考的\",{\"0\":{\"473\":1}}],[\"需要把被更新的列的旧值记下来\",{\"1\":{\"748\":1,\"810\":4}}],[\"需要把\",{\"1\":{\"381\":1,\"525\":1}}],[\"需要重新遍历得到\",{\"1\":{\"879\":1}}],[\"需要重新分配大小为\",{\"1\":{\"879\":1}}],[\"需要重新分配空间\",{\"1\":{\"873\":1}}],[\"需要重新分配该消费者负责的分区给其他消费者\",{\"1\":{\"165\":1}}],[\"需要重新请求\",{\"1\":{\"249\":1}}],[\"需要注意线程安全\",{\"1\":{\"689\":1}}],[\"需要注意uri编码转义与\",{\"1\":{\"249\":1}}],[\"需要注意的是\",{\"1\":{\"223\":1,\"734\":1,\"813\":1,\"820\":2}}],[\"需要在物理网络中配置相应的网络设置\",{\"1\":{\"246\":1}}],[\"需要dns解析\",{\"1\":{\"243\":1}}],[\"需要打开allow\",{\"1\":{\"229\":1}}],[\"需要监听的socket放到ep中\",{\"1\":{\"226\":1}}],[\"需要手动管理\",{\"1\":{\"217\":1}}],[\"需要手动指定消费者要消费的分区\",{\"1\":{\"164\":1}}],[\"需要\",{\"1\":{\"217\":1,\"249\":1}}],[\"需要返回函数内局部变量的内存的时候用指针\",{\"1\":{\"33\":1}}],[\"需要检查类型\",{\"1\":{\"33\":1}}],[\"需要找到号码\",{\"1\":{\"20\":1}}],[\"需要多大的数组\",{\"1\":{\"20\":1}}],[\"需要较大的内存成本\",{\"1\":{\"20\":1}}],[\"高并发\",{\"2\":{\"929\":1,\"935\":1}}],[\"高拓展的架构\",{\"1\":{\"924\":1}}],[\"高度变为\",{\"1\":{\"813\":1}}],[\"高\",{\"1\":{\"810\":1,\"903\":2}}],[\"高级查询\",{\"0\":{\"1000\":1}}],[\"高级特性\",{\"2\":{\"548\":1,\"561\":1}}],[\"高级加密标准\",{\"1\":{\"73\":1}}],[\"高位\",{\"1\":{\"330\":1}}],[\"高效的底层数据结构\",{\"1\":{\"888\":1}}],[\"高效的多\",{\"1\":{\"810\":1}}],[\"高效的字符串构建\",{\"0\":{\"504\":1}}],[\"高效解决了select和poll的缺点\",{\"1\":{\"226\":1}}],[\"高效快速通信\",{\"1\":{\"125\":1}}],[\"高地址\",{\"1\":{\"217\":1,\"423\":1}}],[\"高权限到低权限无需密码\",{\"1\":{\"205\":1}}],[\"高可用套件\",{\"1\":{\"730\":1}}],[\"高可用性\",{\"1\":{\"176\":1}}],[\"高可用架构及数据同步原理\",{\"1\":{\"168\":1}}],[\"高可用\",{\"0\":{\"168\":1},\"1\":{\"924\":1},\"2\":{\"187\":1,\"729\":1,\"732\":1}}],[\"另外无论什么方法\",{\"1\":{\"1056\":1}}],[\"另外一个事务要插入订单\",{\"1\":{\"820\":1}}],[\"另外一个接口也可以收到相同的数据包\",{\"1\":{\"123\":1}}],[\"另外\",{\"1\":{\"249\":1,\"770\":1,\"817\":1,\"820\":2,\"917\":1,\"921\":1,\"957\":2}}],[\"另一种方式就是合并几个写操作成为一个批量操作\",{\"1\":{\"930\":1}}],[\"另一个事务就可以继续执行了\",{\"1\":{\"820\":1}}],[\"另一个拥有该间隙区间内的插入意向锁\",{\"1\":{\"820\":2}}],[\"另一个是能防止序列号回绕\",{\"1\":{\"237\":1}}],[\"另一次是\",{\"1\":{\"766\":1,\"810\":1}}],[\"另一方接收到fin报文\",{\"1\":{\"237\":1}}],[\"另一端在本地并被挂载到\",{\"1\":{\"123\":1}}],[\"文档\",{\"1\":{\"957\":1}}],[\"文档崩溃了\",{\"1\":{\"223\":1}}],[\"文可以发往\",{\"1\":{\"123\":1}}],[\"文件路径\",{\"1\":{\"1032\":1}}],[\"文件路径为\",{\"1\":{\"1032\":1}}],[\"文件下载示例\",{\"1\":{\"1032\":1}}],[\"文件下载\",{\"1\":{\"1032\":4}}],[\"文件而没有\",{\"1\":{\"952\":1}}],[\"文件替换旧的\",{\"1\":{\"952\":1}}],[\"文件存在哪里\",{\"1\":{\"952\":1}}],[\"文件来重建数据集\",{\"1\":{\"949\":1}}],[\"文件后\",{\"1\":{\"810\":1}}],[\"文件保存的是全量的日志\",{\"1\":{\"810\":1}}],[\"文件里擦除\",{\"1\":{\"810\":1}}],[\"文件是循环写\",{\"1\":{\"810\":1}}],[\"文件是记录了所有数据库表结构变更和表数据修改的日志\",{\"1\":{\"759\":1,\"810\":1}}],[\"文件恢复数据\",{\"1\":{\"810\":1,\"952\":1}}],[\"文件恢复数据吗\",{\"1\":{\"810\":1}}],[\"文件恢复\",{\"1\":{\"810\":2}}],[\"文件过大\",{\"1\":{\"810\":1}}],[\"文件过大怎么办\",{\"1\":{\"757\":1}}],[\"文件格式不同\",{\"1\":{\"810\":1}}],[\"文件满了\",{\"1\":{\"810\":1}}],[\"文件组成\",{\"1\":{\"810\":1}}],[\"文件做\",{\"1\":{\"767\":1,\"810\":1}}],[\"文件也被写满时\",{\"1\":{\"757\":1,\"810\":1}}],[\"文件被写满的时候\",{\"1\":{\"757\":1,\"810\":1}}],[\"文件写满了怎么办\",{\"1\":{\"810\":1}}],[\"文件写满了\",{\"1\":{\"757\":1}}],[\"文件尾等\",{\"1\":{\"748\":1}}],[\"文件头\",{\"1\":{\"748\":1}}],[\"文件上传示例\",{\"1\":{\"1037\":1}}],[\"文件上传成功\",{\"1\":{\"693\":1}}],[\"文件上传问题\",{\"0\":{\"693\":1}}],[\"文件句柄的资源释放\",{\"1\":{\"474\":1}}],[\"文件结构\",{\"0\":{\"434\":1}}],[\"文件以外其他类型文档的能力\",{\"1\":{\"249\":1}}],[\"文件将被发回\",{\"1\":{\"249\":1}}],[\"文件可以传送\",{\"1\":{\"249\":1}}],[\"文件断点续传\",{\"1\":{\"240\":1}}],[\"文件描述符和内存资源\",{\"1\":{\"237\":1}}],[\"文件描述符\",{\"1\":{\"237\":1}}],[\"文件需要导入包含生成的\",{\"1\":{\"229\":1}}],[\"文件时必须生成哪些导入语句\",{\"1\":{\"229\":1}}],[\"文件导入另一个\",{\"1\":{\"229\":1}}],[\"文件有重复条目\",{\"1\":{\"229\":1}}],[\"文件到其\",{\"1\":{\"229\":1}}],[\"文件本身和命令行提供\",{\"1\":{\"229\":1}}],[\"文件本身集中标识\",{\"1\":{\"229\":1}}],[\"文件的刷盘\",{\"1\":{\"751\":1}}],[\"文件的\",{\"1\":{\"229\":3}}],[\"文件的库\",{\"1\":{\"223\":1}}],[\"文件传递依赖的文件\",{\"1\":{\"229\":1}}],[\"文件输入创建一个源文件\",{\"1\":{\"229\":1}}],[\"文件生成\",{\"1\":{\"229\":1}}],[\"文件添加一个可选package说明符\",{\"1\":{\"229\":1}}],[\"文件映射内存加速与内核空间的消息传递\",{\"1\":{\"226\":1}}],[\"文件映射段\",{\"1\":{\"217\":1}}],[\"文件服务的资源可以存放在这里\",{\"1\":{\"223\":1}}],[\"文件夹名与包名\",{\"1\":{\"434\":1}}],[\"文件夹访问设备内容\",{\"1\":{\"223\":1}}],[\"文件夹存储了一部分应用程序的配置\",{\"1\":{\"223\":1}}],[\"文件夹存储应用缓存数据\",{\"1\":{\"223\":1}}],[\"文件夹在系统重启之后会自动被清空\",{\"1\":{\"223\":1}}],[\"文件夹里又有很多文件\",{\"1\":{\"223\":1}}],[\"文件夹是系统自动挂载设备的地方\",{\"1\":{\"223\":1}}],[\"文件夹\",{\"1\":{\"223\":4}}],[\"文件系统\",{\"1\":{\"220\":1,\"223\":1,\"817\":1},\"2\":{\"225\":1}}],[\"文件名与包名\",{\"1\":{\"434\":1}}],[\"文件名\",{\"1\":{\"209\":3,\"770\":2,\"1032\":1}}],[\"文件名+后缀\",{\"1\":{\"209\":1}}],[\"文件名生成\",{\"1\":{\"190\":1}}],[\"文件目录操作指令\",{\"0\":{\"209\":1}}],[\"文件操作工具和文本编辑器等\",{\"1\":{\"220\":1}}],[\"文件操作\",{\"0\":{\"202\":1}}],[\"文件用于存储系统上所有用户组的信息\",{\"1\":{\"190\":1}}],[\"文件中的package说明符之间没有关联\",{\"1\":{\"229\":1}}],[\"文件中的一行示例\",{\"1\":{\"190\":2}}],[\"文件中指定的\",{\"1\":{\"229\":1}}],[\"文件中声明它\",{\"1\":{\"229\":2}}],[\"文件中定义\",{\"1\":{\"229\":1}}],[\"文件中\",{\"1\":{\"190\":2,\"753\":1,\"760\":2,\"810\":2,\"957\":1}}],[\"文件包含\",{\"1\":{\"36\":1}}],[\"文件\",{\"1\":{\"20\":1,\"229\":4,\"751\":1,\"756\":1,\"757\":4,\"759\":1,\"760\":1,\"770\":2,\"810\":17,\"854\":1,\"949\":1,\"952\":4,\"957\":1}}],[\"附加到\",{\"1\":{\"123\":1}}],[\"技术的另外一个优点\",{\"1\":{\"810\":1}}],[\"技术的特性可以保证无论哪一个\",{\"1\":{\"123\":1}}],[\"技术指的是\",{\"1\":{\"810\":1}}],[\"技术\",{\"1\":{\"123\":1,\"751\":1,\"810\":4}}],[\"提前锁定了\",{\"1\":{\"897\":1}}],[\"提交了事务\",{\"1\":{\"820\":1}}],[\"提交\",{\"1\":{\"810\":1}}],[\"提交阶段\",{\"1\":{\"764\":1,\"810\":1}}],[\"提交事务时也会刷盘\",{\"1\":{\"745\":1,\"810\":1}}],[\"提交事务\",{\"1\":{\"730\":1,\"761\":1,\"810\":2,\"1014\":1,\"1015\":2}}],[\"提交的动作可以是自动周期性进行\",{\"1\":{\"163\":1}}],[\"提升一致性\",{\"1\":{\"930\":1}}],[\"提升语句的执行性能\",{\"1\":{\"810\":1}}],[\"提升\",{\"1\":{\"462\":1,\"810\":1}}],[\"提倡通过通信来实现内存共享\",{\"1\":{\"254\":1}}],[\"提供给用户控制的参数都有几百个\",{\"1\":{\"807\":1}}],[\"提供一个静态方法\",{\"1\":{\"625\":1,\"641\":2}}],[\"提供一种与语言\",{\"1\":{\"229\":1}}],[\"提供的方法\",{\"0\":{\"274\":1}}],[\"提供\",{\"1\":{\"229\":1}}],[\"提供了四种方式输出日志\",{\"1\":{\"957\":1}}],[\"提供了更人性化的接口\",{\"1\":{\"957\":1}}],[\"提供了更容易的并发\",{\"1\":{\"378\":1}}],[\"提供了一个简易的开发方式\",{\"1\":{\"697\":1}}],[\"提供了设置响应信息的方法\",{\"1\":{\"674\":1}}],[\"提供了访问请求信息的方法\",{\"1\":{\"669\":1}}],[\"提供了基本实现\",{\"1\":{\"665\":1}}],[\"提供了\",{\"1\":{\"229\":1,\"770\":1,\"854\":1}}],[\"提供了与\",{\"1\":{\"190\":1}}],[\"提示用户下载该文件\",{\"1\":{\"1032\":1}}],[\"提示\",{\"1\":{\"123\":2,\"158\":1,\"159\":1,\"178\":1,\"184\":1,\"185\":1,\"367\":1,\"373\":1,\"374\":1,\"576\":1,\"583\":1,\"595\":1,\"612\":1,\"623\":1,\"644\":1,\"651\":1,\"721\":1,\"724\":1,\"957\":1}}],[\"提高日志级别\",{\"1\":{\"957\":1}}],[\"提高性能节省网络带宽\",{\"1\":{\"930\":1}}],[\"提高扩展能力\",{\"1\":{\"927\":1}}],[\"提高查询的效率\",{\"1\":{\"817\":1}}],[\"提高查询性能\",{\"1\":{\"807\":1}}],[\"提高索引命中率\",{\"1\":{\"807\":1}}],[\"提高事务处理速度\",{\"1\":{\"807\":1}}],[\"提高了系统整体性能\",{\"1\":{\"820\":1}}],[\"提高了数据库整体吞吐量\",{\"1\":{\"813\":1}}],[\"提高了写入磁盘的阈值\",{\"1\":{\"755\":1}}],[\"提高了程序的灵活性和扩展性\",{\"1\":{\"552\":1}}],[\"提高了性能\",{\"1\":{\"175\":1}}],[\"提高效率\",{\"1\":{\"409\":1}}],[\"提高整个网络的安全性\",{\"1\":{\"249\":1}}],[\"提高传输效率\",{\"1\":{\"240\":1}}],[\"提高程序运行速度\",{\"1\":{\"405\":1}}],[\"提高程序并发性和响应时间\",{\"1\":{\"226\":1}}],[\"提高程序的运行效率\",{\"1\":{\"36\":1}}],[\"提高处理速度\",{\"1\":{\"79\":1}}],[\"提高运行效率\",{\"1\":{\"36\":1}}],[\"表单数据等\",{\"1\":{\"1038\":1}}],[\"表单\",{\"1\":{\"1037\":1}}],[\"表单参数\",{\"0\":{\"1037\":1,\"1041\":1}}],[\"表现为👇\",{\"1\":{\"939\":1}}],[\"表明数据对象的底层编码方式\",{\"1\":{\"938\":1}}],[\"表明是哪种\",{\"1\":{\"938\":1}}],[\"表明有事务想在某个区间插入新记录\",{\"1\":{\"820\":1}}],[\"表渐进式扩容\",{\"1\":{\"864\":1}}],[\"表列级别\",{\"1\":{\"847\":1}}],[\"表等\",{\"1\":{\"846\":1}}],[\"表里现在已经有了\",{\"1\":{\"820\":1}}],[\"表里的主键通常都会设置成自增的\",{\"1\":{\"820\":1}}],[\"表里有这三条记录\",{\"1\":{\"770\":1}}],[\"表级别的独占锁\",{\"1\":{\"820\":1}}],[\"表级别的共享锁\",{\"1\":{\"820\":1}}],[\"表级锁类型\",{\"1\":{\"820\":1}}],[\"表级锁\",{\"1\":{\"820\":2}}],[\"表级锁和行锁\",{\"1\":{\"820\":1}}],[\"表锁和行锁是满足读读共享\",{\"1\":{\"820\":1}}],[\"表锁除了会限制别的线程的读写外\",{\"1\":{\"820\":1}}],[\"表锁\",{\"1\":{\"820\":5}}],[\"表就有主键索引\",{\"1\":{\"817\":1}}],[\"表不存在或者字段不存在\",{\"1\":{\"817\":1}}],[\"表\",{\"1\":{\"813\":2,\"820\":1,\"864\":2}}],[\"表达式计算的情况多种多样\",{\"1\":{\"813\":1}}],[\"表达性强\",{\"1\":{\"449\":1}}],[\"表只对\",{\"1\":{\"813\":1}}],[\"表结构\",{\"1\":{\"807\":2}}],[\"表的更新只会记录这两个\",{\"1\":{\"820\":1}}],[\"表的主外键或连表字段\",{\"1\":{\"813\":1}}],[\"表的数据都是存放在聚集索引的叶子节点\",{\"1\":{\"813\":1}}],[\"表的扫描方式\",{\"1\":{\"807\":1}}],[\"表的这三条记录作为例子\",{\"1\":{\"770\":1}}],[\"表中的\",{\"1\":{\"820\":2}}],[\"表中的某些列可能会存储\",{\"1\":{\"770\":1}}],[\"表中最后一个记录的\",{\"1\":{\"820\":1}}],[\"表中有一个范围\",{\"1\":{\"820\":2}}],[\"表中主键\",{\"1\":{\"820\":1}}],[\"表中哪个字段建立一个索引能带来最大的性能收益\",{\"1\":{\"813\":1}}],[\"表中字段根据业务选择合适的数据类型\",{\"1\":{\"807\":1}}],[\"表中\",{\"1\":{\"770\":1,\"820\":2}}],[\"表空间中的\",{\"1\":{\"810\":2}}],[\"表空间是由各个段\",{\"1\":{\"770\":1}}],[\"表空间\",{\"1\":{\"770\":1}}],[\"表空间文件的结构\",{\"1\":{\"770\":1}}],[\"表数据既可以存在共享表空间文件\",{\"1\":{\"770\":1}}],[\"表名前缀\",{\"1\":{\"979\":1}}],[\"表名是蛇形复数\",{\"1\":{\"979\":1}}],[\"表名的首字母大写\",{\"1\":{\"829\":1}}],[\"表名等等\",{\"1\":{\"810\":1}}],[\"表名字\",{\"1\":{\"770\":1}}],[\"表名\",{\"1\":{\"763\":1,\"817\":1}}],[\"表扫描的方式\",{\"1\":{\"734\":1}}],[\"表配置与宿主机通信\",{\"1\":{\"122\":1}}],[\"表示这是一个二进制文件流\",{\"1\":{\"1032\":1}}],[\"表示这个数据是由哪个事务生成的\",{\"1\":{\"770\":1}}],[\"表示这个版本的记录是在创建\",{\"1\":{\"744\":2,\"789\":2}}],[\"表示这个变量是所有对象共享的\",{\"1\":{\"33\":1}}],[\"表示只有一个主线程\",{\"1\":{\"897\":1}}],[\"表示每间隔interval\",{\"1\":{\"952\":1}}],[\"表示每个节点都可能是多层结构\",{\"1\":{\"885\":1}}],[\"表示每次事务提交时\",{\"1\":{\"810\":5}}],[\"表示每次提交事务都\",{\"1\":{\"760\":1,\"810\":2}}],[\"表示每次提交事务都会将\",{\"1\":{\"810\":1}}],[\"表示每次提交事务都会\",{\"1\":{\"760\":1,\"810\":1}}],[\"表示每次提交事务都只\",{\"1\":{\"760\":1,\"810\":1}}],[\"表示上一个节点的数据长度\",{\"1\":{\"879\":1}}],[\"表示压缩列表的数据节点\",{\"1\":{\"879\":1}}],[\"表示有多少个数据节点\",{\"1\":{\"879\":1}}],[\"表示该字段是否存在\",{\"1\":{\"1037\":1}}],[\"表示该\",{\"1\":{\"879\":1}}],[\"表示该成员函数不会修改该类的任何成员变量\",{\"1\":{\"33\":1}}],[\"表示一共分配了多少内存\",{\"1\":{\"873\":1}}],[\"表示用了多少\",{\"1\":{\"873\":1}}],[\"表示设置成功\",{\"1\":{\"873\":1}}],[\"表示存在\",{\"1\":{\"873\":1}}],[\"表示已经使用的节点数量\",{\"1\":{\"864\":1}}],[\"表示已经加载\",{\"1\":{\"531\":1}}],[\"表示开启这个逻辑\",{\"1\":{\"820\":1}}],[\"表示行级锁\",{\"1\":{\"820\":3}}],[\"表示如果队列中的事务数达到\",{\"1\":{\"810\":1}}],[\"表示在等待\",{\"1\":{\"810\":1}}],[\"表示在生成当前readview时\",{\"1\":{\"787\":2}}],[\"表示在生成当前\",{\"1\":{\"744\":2}}],[\"表示事务在写入binlog之前崩溃\",{\"1\":{\"810\":1}}],[\"表示事务已经成功写入所有必要的日志\",{\"1\":{\"810\":1}}],[\"表示mysql服务器将存储引擎返回的行进行了额外的过滤\",{\"1\":{\"807\":1}}],[\"表示mysql决定如何查找表中的行的方法\",{\"1\":{\"807\":1}}],[\"表示查询只使用了索引中的信息\",{\"1\":{\"807\":1}}],[\"表示查找成功\",{\"1\":{\"529\":1}}],[\"表示没有使用索引\",{\"1\":{\"807\":1}}],[\"表示没有加载任何值\",{\"1\":{\"531\":1}}],[\"表示生成该版本记录的活跃事务已经被提交\",{\"1\":{\"744\":1,\"789\":1}}],[\"表示生成该版本记录的活跃事务依然活跃着\",{\"1\":{\"744\":1,\"789\":1}}],[\"表示生成id的时间\",{\"1\":{\"92\":1}}],[\"表示严重问题\",{\"1\":{\"538\":1}}],[\"表示加载了新值\",{\"1\":{\"531\":2}}],[\"表示硬删除\",{\"1\":{\"525\":1}}],[\"表示硬删除状态\",{\"1\":{\"523\":1}}],[\"表示当前要擦除的位置\",{\"1\":{\"810\":1}}],[\"表示当前记录的类型\",{\"1\":{\"770\":1}}],[\"表示当前\",{\"1\":{\"524\":1}}],[\"表示软删除状态\",{\"1\":{\"523\":1}}],[\"表示接受任何类型的参数\",{\"1\":{\"467\":1}}],[\"表示word这个字符串所占的字节数\",{\"1\":{\"353\":1}}],[\"表示断言失败\",{\"1\":{\"307\":1}}],[\"表示要完成请求\",{\"1\":{\"249\":1}}],[\"表示成功处理了请求的状态代码\",{\"1\":{\"249\":1}}],[\"表示成功状态\",{\"1\":{\"249\":1}}],[\"表示临时响应并需要请求者继续执行操作的状态代码\",{\"1\":{\"249\":1}}],[\"表示目前是协议处理的中间状态\",{\"1\":{\"249\":1}}],[\"表示对资源附加的额外要求\",{\"1\":{\"249\":1}}],[\"表示资源所在的主机名\",{\"1\":{\"249\":1}}],[\"表示资源应该使用哪种协议来访问\",{\"1\":{\"249\":1}}],[\"表示资源请求成功\",{\"1\":{\"240\":1}}],[\"表示的是\",{\"1\":{\"249\":1,\"820\":1}}],[\"表示网关服务器正常\",{\"1\":{\"240\":1}}],[\"表示\",{\"1\":{\"240\":4,\"458\":2,\"810\":1,\"864\":2,\"879\":1,\"957\":1}}],[\"表示文件描述符集合\",{\"1\":{\"226\":1}}],[\"表示数组的指针\",{\"1\":{\"33\":1}}],[\"表示指针的数组\",{\"1\":{\"33\":1}}],[\"虚拟化\",{\"2\":{\"247\":1}}],[\"虚拟局域网\",{\"1\":{\"246\":1}}],[\"虚拟机\",{\"2\":{\"248\":1}}],[\"虚拟机的网络行为与物理机无异\",{\"1\":{\"246\":1}}],[\"虚拟机可以与物理网络中的其他设备进行双向通信\",{\"1\":{\"246\":1}}],[\"虚拟机可以通过宿主机访问外部网络\",{\"1\":{\"246\":1}}],[\"虚拟机将获得一个与物理网络相同的ip地址\",{\"1\":{\"246\":1}}],[\"虚拟机直接连接到物理网络\",{\"1\":{\"246\":2}}],[\"虚拟机ip是虚有的\",{\"1\":{\"246\":1}}],[\"虚拟机无法直接被外部网络访问\",{\"1\":{\"246\":1}}],[\"虚拟机与外部网络之间有一定的隔离\",{\"1\":{\"246\":1}}],[\"虚拟机使用一个虚拟的私有ip地址\",{\"1\":{\"246\":1}}],[\"虚拟机通过宿主机的ip地址和网络连接来访问外部网络\",{\"1\":{\"246\":1}}],[\"虚拟机通过虚拟网络地址转换\",{\"1\":{\"246\":1}}],[\"虚拟机网络模式\",{\"1\":{\"246\":3}}],[\"虚拟机网络模式详解\",{\"0\":{\"246\":1}}],[\"虚拟地址到物理地址的映射是操作系统负责的\",{\"1\":{\"217\":1}}],[\"虚拟地址空间如何划分\",{\"1\":{\"217\":1}}],[\"虚拟地址空间共有\",{\"1\":{\"217\":1}}],[\"虚拟地址分为两部分\",{\"1\":{\"217\":1}}],[\"虚拟地址中的段内偏移量应该位于\",{\"1\":{\"217\":1}}],[\"虚拟地址和物理地址如何映射\",{\"1\":{\"217\":1}}],[\"虚拟内存的实现方式\",{\"1\":{\"217\":1}}],[\"虚拟内存可以使得进程对运行内存超过物理内存大小\",{\"1\":{\"217\":1}}],[\"虚拟内存有什么作用\",{\"1\":{\"217\":1}}],[\"虚拟内存\",{\"1\":{\"217\":1},\"2\":{\"219\":1}}],[\"虚拟网桥\",{\"1\":{\"122\":1}}],[\"虚函数\",{\"1\":{\"33\":1}}],[\"虚函数和纯虚函数\",{\"1\":{\"33\":1}}],[\"此方案和业务完全解耦\",{\"1\":{\"930\":1}}],[\"此次的事务\",{\"1\":{\"820\":2}}],[\"此后该用户在此连接的任何操作都会基于连接时保存的权限进行逻辑判断\",{\"1\":{\"817\":1}}],[\"此攻击以多个随机的源主机地址向目的主机发送syn包\",{\"1\":{\"243\":1}}],[\"此攻击在短时间内向目的主机发送大量的ping的echo报文\",{\"1\":{\"243\":1}}],[\"此外\",{\"1\":{\"229\":1,\"957\":1}}],[\"此模式对于将生成的文件直接输出到\",{\"1\":{\"229\":1}}],[\"此模式下容器只有\",{\"1\":{\"126\":1}}],[\"此模式会为每一个容器分配\",{\"1\":{\"122\":1}}],[\"此时是不会用\",{\"1\":{\"952\":1}}],[\"此时是不能插入记录的\",{\"1\":{\"820\":1}}],[\"此时不用再重试\",{\"1\":{\"927\":1}}],[\"此时a和b拿到了相同的执行权限\",{\"1\":{\"918\":1,\"921\":1}}],[\"此时可能虽然加锁成功\",{\"1\":{\"918\":1,\"921\":1}}],[\"此时客户端就可以发起连接请求\",{\"1\":{\"888\":1}}],[\"此时客户端再次发起请求\",{\"1\":{\"23\":1}}],[\"此时再进行删除\",{\"1\":{\"882\":1}}],[\"此时真实的\",{\"1\":{\"879\":1}}],[\"此时将\",{\"1\":{\"864\":1}}],[\"此时还没有实际的锁结构\",{\"1\":{\"820\":1}}],[\"此时对应的唯一二级索引记录被\",{\"1\":{\"820\":1}}],[\"此时有个事务\",{\"1\":{\"820\":1}}],[\"此时有两种可能\",{\"1\":{\"23\":1}}],[\"此时插入就会失败\",{\"1\":{\"820\":1}}],[\"此时也不能插入记录\",{\"1\":{\"820\":1}}],[\"此时也发生了幻读现象\",{\"1\":{\"794\":1}}],[\"此时会生成一个插入意向锁\",{\"1\":{\"820\":2}}],[\"此时事务\",{\"1\":{\"820\":5}}],[\"此时事务b来了\",{\"1\":{\"780\":1}}],[\"此时由于线程\",{\"1\":{\"820\":1}}],[\"此时并不会阻塞\",{\"1\":{\"820\":1}}],[\"此时就先对该表加上\",{\"1\":{\"820\":1}}],[\"此时需要自行写存储过程\",{\"1\":{\"813\":1}}],[\"此时后面到来的事务都是\",{\"1\":{\"810\":1}}],[\"此时后台已经完成扣款\",{\"1\":{\"23\":1}}],[\"此时的aof文件\",{\"1\":{\"949\":1}}],[\"此时的\",{\"1\":{\"810\":1}}],[\"此时记录的\",{\"1\":{\"810\":2}}],[\"此时表中是没有该记录的\",{\"1\":{\"793\":1}}],[\"此时该状态并不需要持久化到磁盘\",{\"1\":{\"765\":1,\"810\":1}}],[\"此时这些缓存页都是空闲的\",{\"1\":{\"748\":1,\"810\":1}}],[\"此时调用在内存中还不存在的非静态成员\",{\"1\":{\"573\":1}}],[\"此时\",{\"1\":{\"488\":1,\"516\":1,\"810\":1,\"820\":2,\"913\":1,\"921\":1}}],[\"此时默认会绑定本地所有接口上的所有地址\",{\"1\":{\"117\":1}}],[\"此时开始争抢锁\",{\"1\":{\"23\":1}}],[\"此时幂等性失效\",{\"1\":{\"23\":1}}],[\"此时第二次请求仍然能加锁成功\",{\"1\":{\"23\":1}}],[\"此时服务端可能会向客户端返回执行失败\",{\"1\":{\"23\":1}}],[\"默认监听并在\",{\"1\":{\"1040\":1}}],[\"默认载入\",{\"1\":{\"966\":1}}],[\"默认如下\",{\"1\":{\"952\":1}}],[\"默认配置\",{\"1\":{\"952\":1}}],[\"默认就是混合持久化\",{\"1\":{\"949\":1}}],[\"默认就开启\",{\"1\":{\"820\":1}}],[\"默认两种缓存\",{\"1\":{\"930\":1}}],[\"默认每\",{\"1\":{\"906\":1}}],[\"默认每个页的大小为\",{\"1\":{\"770\":1}}],[\"默认为\",{\"1\":{\"957\":1}}],[\"默认为小写\",{\"1\":{\"957\":1}}],[\"默认为1\",{\"1\":{\"813\":1}}],[\"默认为0\",{\"1\":{\"813\":4}}],[\"默认为20\",{\"1\":{\"813\":1}}],[\"默认会根据主键查询\",{\"1\":{\"989\":1}}],[\"默认会使用主键作为聚簇索引的索引键\",{\"1\":{\"813\":1}}],[\"默认会一直存在\",{\"1\":{\"106\":1}}],[\"默认模型\",{\"1\":{\"810\":1}}],[\"默认模式\",{\"1\":{\"122\":1}}],[\"默认格式\",{\"1\":{\"810\":1}}],[\"默认隔离级别\",{\"1\":{\"792\":1,\"820\":2}}],[\"默认行格式可以通过innodb\",{\"1\":{\"770\":1}}],[\"默认使用id作为主键\",{\"1\":{\"982\":1}}],[\"默认使用\",{\"1\":{\"770\":1}}],[\"默认大小\",{\"1\":{\"755\":1,\"810\":1}}],[\"默认开启\",{\"1\":{\"739\":1,\"813\":1}}],[\"默认的同步模式\",{\"1\":{\"730\":1,\"761\":1}}],[\"默认\",{\"0\":{\"783\":1},\"1\":{\"710\":1,\"906\":1,\"957\":3,\"979\":1}}],[\"默认servlet\",{\"1\":{\"655\":1,\"656\":1}}],[\"默认值时\",{\"1\":{\"820\":1}}],[\"默认值是\",{\"1\":{\"817\":1}}],[\"默认值为0\",{\"1\":{\"813\":1}}],[\"默认值为1\",{\"1\":{\"813\":1}}],[\"默认值为\",{\"1\":{\"810\":1}}],[\"默认值\",{\"1\":{\"571\":1}}],[\"默认值不能设置为null\",{\"1\":{\"229\":1}}],[\"默认有break\",{\"1\":{\"450\":1}}],[\"默认长连接\",{\"1\":{\"240\":1}}],[\"默认短链接\",{\"1\":{\"240\":1}}],[\"默认关闭的原因\",{\"1\":{\"237\":1}}],[\"默认是选择\",{\"1\":{\"944\":1}}],[\"默认是有\",{\"1\":{\"944\":1}}],[\"默认是注释的\",{\"1\":{\"900\":1}}],[\"默认是开启\",{\"1\":{\"810\":1}}],[\"默认是\",{\"1\":{\"229\":1,\"900\":1,\"1027\":1}}],[\"默认是10s\",{\"1\":{\"182\":1}}],[\"默认最大值为\",{\"1\":{\"226\":1}}],[\"默认情况下\",{\"1\":{\"176\":1,\"757\":1,\"810\":1}}],[\"创建记录\",{\"1\":{\"985\":1}}],[\"创建项目\",{\"0\":{\"964\":1}}],[\"创建自定义的配置对象\",{\"1\":{\"957\":1}}],[\"创建自定义异常\",{\"0\":{\"545\":1}}],[\"创建角色\",{\"1\":{\"851\":1,\"852\":1}}],[\"创建用户\",{\"0\":{\"838\":1}}],[\"创建windows服务\",{\"1\":{\"836\":1}}],[\"创建数据库或者表等对象\",{\"1\":{\"829\":1}}],[\"创建数据库连接池或其他资源\",{\"1\":{\"624\":1}}],[\"创建联合索引\",{\"1\":{\"826\":2}}],[\"创建联合索引时\",{\"1\":{\"813\":1}}],[\"创建唯一索引\",{\"1\":{\"826\":1}}],[\"创建索引\",{\"1\":{\"826\":1}}],[\"创建内存临时表的成本\",{\"1\":{\"813\":1}}],[\"创建磁盘临时表的成本\",{\"1\":{\"813\":1}}],[\"创建成功了\",{\"1\":{\"770\":1}}],[\"创建失败了\",{\"1\":{\"770\":1}}],[\"创建新会话\",{\"1\":{\"692\":1}}],[\"创建阶段\",{\"1\":{\"630\":1}}],[\"创建httpsessionlistener\",{\"0\":{\"625\":1}}],[\"创建servlet实例\",{\"1\":{\"661\":1}}],[\"创建servlet类\",{\"0\":{\"652\":1}}],[\"创建servletrequestlistener\",{\"0\":{\"626\":1}}],[\"创建servletcontextlistener\",{\"0\":{\"624\":1}}],[\"创建socket服务端\",{\"1\":{\"226\":1}}],[\"创建第一个servlet\",{\"0\":{\"650\":1}}],[\"创建第一个listener\",{\"0\":{\"622\":1}}],[\"创建第一个filter\",{\"0\":{\"582\":1}}],[\"创建filter类\",{\"0\":{\"584\":1}}],[\"创建代理\",{\"1\":{\"559\":1}}],[\"创建实例\",{\"1\":{\"557\":1,\"558\":1}}],[\"创建这个结构体或数组的一个完整副本\",{\"1\":{\"457\":1}}],[\"创建变量的一个新副本\",{\"1\":{\"455\":1}}],[\"创建了\",{\"1\":{\"381\":1}}],[\"创建\",{\"1\":{\"373\":1,\"381\":1,\"813\":6,\"873\":1}}],[\"创建子进程的时候\",{\"1\":{\"217\":1}}],[\"创建软链接\",{\"1\":{\"209\":1}}],[\"创建一个user结构体实例\",{\"1\":{\"1039\":1,\"1041\":1}}],[\"创建一个定时器\",{\"1\":{\"882\":1}}],[\"创建一个锁定的用户\",{\"1\":{\"843\":1}}],[\"创建一个带有varchar字段的表格\",{\"1\":{\"770\":1}}],[\"创建一个新的只读缓存\",{\"1\":{\"530\":1}}],[\"创建一个新的目录\",{\"1\":{\"201\":1}}],[\"创建一个虚拟的局域网\",{\"1\":{\"246\":1}}],[\"创建一个\",{\"1\":{\"226\":1}}],[\"创建一个tcp客户端的流程\",{\"1\":{\"226\":1}}],[\"创建一个tcp服务端的流程\",{\"1\":{\"226\":1}}],[\"创建一个空文件\",{\"1\":{\"209\":1}}],[\"创建一个数据卷\",{\"0\":{\"107\":1}}],[\"创建的日志对象输出格式为\",{\"1\":{\"957\":2}}],[\"创建的主要逻辑位于switch中\",{\"1\":{\"263\":1}}],[\"创建的\",{\"1\":{\"123\":1}}],[\"创建的容器不会创建自己的网卡\",{\"1\":{\"122\":1}}],[\"宿主机ip\",{\"1\":{\"121\":1}}],[\"访问redis超时\",{\"1\":{\"927\":1}}],[\"访问redis错误\",{\"1\":{\"927\":1}}],[\"访问的热度一直在变\",{\"1\":{\"903\":1}}],[\"访问计数的\",{\"1\":{\"903\":1}}],[\"访问url\",{\"1\":{\"659\":1}}],[\"访问后端资源\",{\"1\":{\"647\":1}}],[\"访问时间\",{\"1\":{\"579\":1}}],[\"访问控制\",{\"1\":{\"568\":1}}],[\"访问步骤\",{\"1\":{\"331\":1}}],[\"访问外网\",{\"1\":{\"246\":1}}],[\"访问域名就会被重定向到恶意网站的服务器上\",{\"1\":{\"243\":1}}],[\"访问内存会有很明显的重复访问的倾向性\",{\"1\":{\"217\":1}}],[\"访问容器\",{\"1\":{\"121\":1}}],[\"访问容器的时候就通过\",{\"1\":{\"121\":1}}],[\"访问到容器\",{\"1\":{\"121\":1}}],[\"qqh\",{\"1\":{\"985\":1,\"991\":1,\"995\":1,\"1001\":2}}],[\"qq\",{\"1\":{\"985\":1,\"1001\":2,\"1005\":1}}],[\"qq号码\",{\"1\":{\"20\":1}}],[\"qq号码一定要存吗\",{\"1\":{\"20\":1}}],[\"qq号码无符号整数\",{\"1\":{\"20\":1}}],[\"qp\",{\"1\":{\"265\":3}}],[\"qps高的时候\",{\"1\":{\"237\":1}}],[\"qcount\",{\"1\":{\"265\":4}}],[\"queue\",{\"1\":{\"374\":1}}],[\"queryarray\",{\"1\":{\"1035\":1}}],[\"query\",{\"1\":{\"249\":4,\"770\":8,\"817\":4,\"820\":4,\"1035\":1}}],[\"quicklist\",{\"1\":{\"867\":3}}],[\"quic\",{\"1\":{\"249\":4}}],[\"q=0\",{\"1\":{\"249\":4}}],[\"q|xargs\",{\"1\":{\"142\":1}}],[\"q\",{\"1\":{\"140\":1,\"214\":1,\"249\":1}}],[\"qdisc\",{\"1\":{\"121\":1}}],[\"网页异常排查\",{\"1\":{\"249\":1}}],[\"网卡设备通信\",{\"1\":{\"125\":1}}],[\"网桥\",{\"1\":{\"123\":1}}],[\"网桥上\",{\"1\":{\"123\":1}}],[\"网桥以及\",{\"1\":{\"122\":1}}],[\"网桥是宿主机虚拟出来的\",{\"1\":{\"121\":1}}],[\"网桥是每个容器的默认网络网关\",{\"1\":{\"121\":1}}],[\"网桥的网段分配给容器一个\",{\"1\":{\"121\":1}}],[\"网络错误\",{\"1\":{\"1030\":1}}],[\"网络延迟\",{\"1\":{\"706\":1,\"918\":1,\"921\":1}}],[\"网络问题\",{\"1\":{\"706\":1}}],[\"网络连接\",{\"1\":{\"474\":1}}],[\"网络架构\",{\"2\":{\"251\":1}}],[\"网络基础\",{\"2\":{\"250\":1}}],[\"网络代理\",{\"1\":{\"249\":1}}],[\"网络传输场景\",{\"1\":{\"249\":1}}],[\"网络传输文件的时候往往会分片成一个个文件块\",{\"1\":{\"76\":1}}],[\"网络层之间加入了\",{\"1\":{\"249\":1}}],[\"网络层对应的协议包括ipx和ip\",{\"1\":{\"249\":1}}],[\"网络层处理数据包在网络中的路由\",{\"1\":{\"249\":1}}],[\"网络层\",{\"1\":{\"249\":2}}],[\"网络层攻击\",{\"1\":{\"243\":1}}],[\"网络可以逐步发展和扩展\",{\"1\":{\"249\":1}}],[\"网络体系结构\",{\"1\":{\"249\":1}}],[\"网络配置\",{\"1\":{\"246\":1},\"2\":{\"248\":1}}],[\"网络隔离\",{\"1\":{\"246\":2}}],[\"网络攻击\",{\"1\":{\"243\":1}}],[\"网络安全\",{\"1\":{\"243\":1},\"2\":{\"244\":1,\"245\":1}}],[\"网络切换不需要重新建立连接\",{\"1\":{\"240\":1}}],[\"网络协议\",{\"2\":{\"238\":1,\"239\":1,\"241\":1,\"251\":1}}],[\"网络地址\",{\"1\":{\"226\":1}}],[\"网络编程\",{\"1\":{\"226\":1},\"2\":{\"227\":1,\"228\":1}}],[\"网络设备等\",{\"1\":{\"223\":1}}],[\"网络的隔离性不好\",{\"1\":{\"124\":1}}],[\"网络的联通性\",{\"1\":{\"123\":1}}],[\"网络\",{\"0\":{\"124\":1},\"1\":{\"119\":1,\"891\":1}}],[\"网络类型用于\",{\"1\":{\"119\":1}}],[\"网络类型\",{\"1\":{\"119\":1}}],[\"网络模式没有改善容器与宿主机以外世界通信的情况\",{\"1\":{\"125\":1}}],[\"网络模式是\",{\"1\":{\"125\":1}}],[\"网络模式\",{\"0\":{\"116\":1,\"120\":1,\"125\":1},\"1\":{\"122\":1,\"125\":1},\"2\":{\"248\":1}}],[\"网络等信息\",{\"1\":{\"98\":1}}],[\"还不了解\",{\"1\":{\"917\":1,\"921\":1}}],[\"还小时\",{\"1\":{\"906\":1}}],[\"还提供了\",{\"1\":{\"957\":1}}],[\"还提供了查交集\",{\"1\":{\"870\":1}}],[\"还提供了另外两种策略\",{\"1\":{\"810\":1}}],[\"还可以预加载数据到缓存\",{\"1\":{\"930\":1}}],[\"还可以做成集群\",{\"1\":{\"927\":1}}],[\"还可以方便限频\",{\"1\":{\"927\":1}}],[\"还可以保存二进制数据\",{\"1\":{\"873\":1}}],[\"还可以创建多个角色\",{\"1\":{\"850\":1}}],[\"还可以使用反引号\",{\"1\":{\"838\":1}}],[\"还可以使用\",{\"1\":{\"117\":1}}],[\"还做一个很重要的事情\",{\"1\":{\"820\":2}}],[\"还给行记录两边的空隙也加上了间隙锁\",{\"1\":{\"820\":1}}],[\"还包括了\",{\"1\":{\"810\":1}}],[\"还要单独搭建一个同步服务\",{\"1\":{\"930\":1}}],[\"还要先更新数据库\",{\"1\":{\"930\":1}}],[\"还要依赖数据库的优化器\",{\"1\":{\"813\":1}}],[\"还要有\",{\"1\":{\"810\":1}}],[\"还要看数据库表的字符集\",{\"1\":{\"770\":1}}],[\"还要复制底层数组\",{\"1\":{\"346\":1}}],[\"还是能被猜测出来的\",{\"1\":{\"1056\":1}}],[\"还是可能通过彩虹表的方式破译\",{\"1\":{\"1051\":1}}],[\"还是需要用完整的消息中间件\",{\"1\":{\"924\":1}}],[\"还是需要和业务的配合\",{\"1\":{\"918\":1,\"921\":1}}],[\"还是比较繁重的事务\",{\"1\":{\"924\":1}}],[\"还是用\",{\"1\":{\"897\":1}}],[\"还是记录锁\",{\"1\":{\"820\":1}}],[\"还是间隙锁\",{\"1\":{\"820\":1}}],[\"还是轻量级的锁\",{\"1\":{\"820\":1}}],[\"还是外部文件排序\",{\"1\":{\"813\":1}}],[\"还是时刻\",{\"1\":{\"810\":1}}],[\"还是\",{\"1\":{\"810\":1,\"820\":1,\"952\":1,\"957\":1}}],[\"还是在内存中\",{\"1\":{\"810\":1}}],[\"还是内存回收\",{\"1\":{\"807\":1}}],[\"还是不行\",{\"1\":{\"770\":1}}],[\"还是以\",{\"1\":{\"770\":1}}],[\"还是将限制逻辑加入到redis中\",{\"1\":{\"927\":1}}],[\"还是将\",{\"1\":{\"756\":1}}],[\"还是选择缓存起来呢\",{\"1\":{\"747\":1,\"810\":1}}],[\"还没来得及重新产生\",{\"1\":{\"930\":1}}],[\"还没来得及落盘的脏页数据就会丢失\",{\"1\":{\"751\":1,\"810\":1}}],[\"还没提交的时候\",{\"1\":{\"820\":1}}],[\"还没提交事务的\",{\"1\":{\"810\":1}}],[\"还没提交事务\",{\"1\":{\"744\":1,\"789\":1}}],[\"还没被使用的时候\",{\"1\":{\"817\":1}}],[\"还没有刷盘\",{\"1\":{\"810\":1}}],[\"还没有来得及写入\",{\"1\":{\"763\":2,\"810\":2}}],[\"还没持久化到磁盘的数据就会丢失\",{\"1\":{\"810\":1}}],[\"还没写入\",{\"1\":{\"810\":1}}],[\"还没写入磁盘\",{\"1\":{\"810\":1}}],[\"还没写\",{\"1\":{\"763\":1,\"810\":1}}],[\"还需要在更新mysql时\",{\"1\":{\"930\":1}}],[\"还需要加一个锁来保证提交的原子性\",{\"1\":{\"766\":1,\"810\":1}}],[\"还需要记录对应的\",{\"1\":{\"753\":1}}],[\"还需要完成最后的\",{\"1\":{\"751\":1}}],[\"还需要使用嵌套的结构体指针\",{\"1\":{\"489\":1}}],[\"还需要后续操作\",{\"1\":{\"249\":1}}],[\"还需进行\",{\"1\":{\"249\":1}}],[\"还会多一次服务间调用\",{\"1\":{\"930\":1}}],[\"还会更改\",{\"1\":{\"240\":1}}],[\"还会最终同步到broker11上的topic\",{\"1\":{\"177\":1}}],[\"还有三个隐藏字段\",{\"1\":{\"770\":1}}],[\"还有空间存元素\",{\"1\":{\"265\":1}}],[\"还有一些\",{\"1\":{\"374\":1}}],[\"还有一些其他额外信息\",{\"1\":{\"249\":1}}],[\"还有一些标记属性的比特\",{\"1\":{\"217\":1}}],[\"还有机会在\",{\"1\":{\"223\":1}}],[\"还开辟出一块新的空间用来存放新的值\",{\"1\":{\"33\":1}}],[\"例子来自小林图解\",{\"1\":{\"764\":1}}],[\"例子3\",{\"1\":{\"477\":1}}],[\"例子2\",{\"1\":{\"477\":1}}],[\"例子1\",{\"1\":{\"477\":1}}],[\"例子\",{\"1\":{\"117\":1,\"456\":1,\"465\":1,\"468\":1,\"478\":1,\"479\":1,\"813\":1,\"879\":1,\"952\":1}}],[\"例如bcrypt\",{\"1\":{\"1054\":1}}],[\"例如请求\",{\"1\":{\"1035\":1}}],[\"例如将\",{\"1\":{\"982\":1}}],[\"例如将子查询转换为连接\",{\"1\":{\"734\":1}}],[\"例如事务提交时\",{\"1\":{\"753\":1}}],[\"例如int和float类型零值是\",{\"1\":{\"487\":1}}],[\"例如以太网\",{\"1\":{\"249\":1}}],[\"例如我们定义了一个名为\",{\"1\":{\"229\":1}}],[\"例如用1表示name\",{\"1\":{\"229\":1}}],[\"例如从不可读变为可读\",{\"1\":{\"226\":1}}],[\"例如有数据可读\",{\"1\":{\"226\":1}}],[\"例如全名\",{\"1\":{\"190\":1}}],[\"例如转为字符串或使用其他格式存储和传输\",{\"1\":{\"92\":1}}],[\"例如在提交订单时\",{\"1\":{\"23\":1}}],[\"例如通过token机制\",{\"1\":{\"23\":1}}],[\"例如订单状态字段\",{\"1\":{\"23\":1}}],[\"例如\",{\"1\":{\"23\":2,\"123\":1,\"165\":1,\"229\":6,\"249\":2,\"719\":1,\"810\":1,\"817\":1,\"840\":1,\"879\":1}}],[\"外部客户端\",{\"1\":{\"817\":1}}],[\"外部文件排序\",{\"1\":{\"813\":1}}],[\"外部结构体就可以直接访问内部结构体的字段和方法\",{\"1\":{\"462\":1}}],[\"外部设备可以直接访问虚拟机\",{\"1\":{\"246\":1}}],[\"外部网络无法直接访问这些虚拟机\",{\"1\":{\"246\":1}}],[\"外部网络是无法寻址到的\",{\"1\":{\"121\":1}}],[\"外部内存碎片是很容易产生的\",{\"1\":{\"217\":1}}],[\"外部碎片\",{\"1\":{\"217\":1}}],[\"外部主机是不可见的\",{\"1\":{\"123\":1}}],[\"外部访问容器\",{\"0\":{\"117\":1}}],[\"外部排序\",{\"1\":{\"20\":1}}],[\"上启动服务\",{\"1\":{\"1040\":1}}],[\"上图是一个bcrypt哈希的示例图\",{\"1\":{\"1056\":1}}],[\"上图的意思\",{\"1\":{\"952\":1}}],[\"上图中\",{\"1\":{\"879\":1}}],[\"上下文切换成本\",{\"1\":{\"891\":1}}],[\"上下文切换\",{\"1\":{\"888\":1}}],[\"上下文信息\",{\"1\":{\"249\":1}}],[\"上一个\",{\"1\":{\"879\":1}}],[\"上一秒钟所有事务数据才可能丢失\",{\"1\":{\"810\":1}}],[\"上对应的数据\",{\"1\":{\"864\":1}}],[\"上加的是\",{\"1\":{\"820\":1}}],[\"上的所有变化并以二进制形式保存在磁盘上\",{\"1\":{\"810\":1}}],[\"上的数据\",{\"1\":{\"810\":1}}],[\"上面有提到\",{\"1\":{\"930\":1}}],[\"上面出名的消息队列\",{\"1\":{\"924\":1}}],[\"上面这两条语句必须在一个事务中\",{\"1\":{\"820\":1}}],[\"上面这种\",{\"1\":{\"810\":1}}],[\"上面提到的\",{\"1\":{\"748\":1,\"927\":1}}],[\"上面是自动提交\",{\"1\":{\"711\":1}}],[\"上面的转账示例也可以这样写\",{\"1\":{\"1015\":1}}],[\"上面的案例是针对唯一二级索引重复而插入失败的场景\",{\"1\":{\"820\":1}}],[\"上面的\",{\"1\":{\"810\":1}}],[\"上面的两个过程一起完成这个enrty\",{\"1\":{\"531\":1}}],[\"上面的命令加载主机的\",{\"1\":{\"113\":1}}],[\"上解决\",{\"1\":{\"512\":1}}],[\"上执行\",{\"1\":{\"381\":1}}],[\"上应用最为广泛的\",{\"1\":{\"190\":1}}],[\"上\",{\"1\":{\"172\":1,\"176\":1,\"190\":1,\"249\":1,\"836\":1,\"864\":1}}],[\"上已经使用的端口就不能再用了\",{\"1\":{\"124\":1}}],[\"上浮到合适位置\",{\"1\":{\"52\":1}}],[\"上浮操作\",{\"1\":{\"52\":1}}],[\"目的为了防止事务执行的过程中\",{\"1\":{\"820\":1}}],[\"目的是为了解决可重复读隔离级别下幻读的现象\",{\"1\":{\"820\":1}}],[\"目的是为了组合更多事务的\",{\"1\":{\"810\":1}}],[\"目的是为了将明文公布给别人\",{\"1\":{\"249\":1}}],[\"目的是避免有其他\",{\"1\":{\"529\":1}}],[\"目的是用于快速判断类型是否相等\",{\"1\":{\"307\":1}}],[\"目的是告诉客户端\",{\"1\":{\"249\":1}}],[\"目的主机就为这些源主机建立大量的连接队列\",{\"1\":{\"243\":1}}],[\"目的主机的路径\",{\"1\":{\"150\":1}}],[\"目的端口号\",{\"1\":{\"237\":1}}],[\"目的端口和协议\",{\"1\":{\"237\":2}}],[\"目的ip地址\",{\"1\":{\"237\":1}}],[\"目的ip+目的port\",{\"1\":{\"237\":1}}],[\"目的\",{\"1\":{\"237\":2,\"879\":1}}],[\"目标第几页\",{\"1\":{\"1008\":1}}],[\"目标资源\",{\"1\":{\"596\":1}}],[\"目标文档\",{\"1\":{\"209\":1}}],[\"目标路径\",{\"1\":{\"209\":2}}],[\"目录结构\",{\"0\":{\"962\":1}}],[\"目录下再使用\",{\"1\":{\"854\":1}}],[\"目录下寻找\",{\"1\":{\"223\":1}}],[\"目录配置到环境变量\",{\"1\":{\"854\":1}}],[\"目录里面创建一个以\",{\"1\":{\"770\":1}}],[\"目录占用的磁盘空间会越来越大\",{\"1\":{\"223\":1}}],[\"目录中读取输入文件\",{\"1\":{\"229\":1}}],[\"目录中\",{\"1\":{\"223\":1}}],[\"目录中又含有\",{\"1\":{\"223\":1}}],[\"目录中的信息也许会帮上忙\",{\"1\":{\"223\":1}}],[\"目录了\",{\"1\":{\"223\":1}}],[\"目录进行操作\",{\"1\":{\"223\":1}}],[\"目录的信息就会丢失\",{\"1\":{\"223\":1}}],[\"目录操作\",{\"0\":{\"201\":1}}],[\"目录和文件操作命令\",{\"0\":{\"200\":1}}],[\"目录新建文件\",{\"1\":{\"113\":1}}],[\"目录到容器的\",{\"1\":{\"113\":1}}],[\"目录挂载\",{\"0\":{\"112\":1}}],[\"目录\",{\"1\":{\"110\":1,\"113\":1,\"223\":4,\"229\":1,\"770\":1}}],[\"目前支持\",{\"1\":{\"957\":1}}],[\"目前\",{\"1\":{\"99\":1,\"249\":1}}],[\"目前首选\",{\"1\":{\"12\":1}}],[\"目前使用ing\",{\"1\":{\"5\":1}}],[\"到备库执行的时候\",{\"1\":{\"820\":1}}],[\"到主键索引读取数据行\",{\"1\":{\"813\":1}}],[\"到磁盘\",{\"1\":{\"810\":1}}],[\"到底是要调哪个位置\",{\"1\":{\"807\":1}}],[\"到底取哪个值\",{\"1\":{\"249\":1}}],[\"到文件系统的\",{\"1\":{\"765\":1,\"810\":1}}],[\"到这里\",{\"1\":{\"751\":1}}],[\"到这就说明要阻塞等待了\",{\"1\":{\"265\":1}}],[\"到表中就好了\",{\"1\":{\"741\":1,\"810\":1}}],[\"到处运行\",{\"1\":{\"564\":1}}],[\"到了\",{\"1\":{\"479\":1}}],[\"到\",{\"1\":{\"223\":1,\"374\":2,\"520\":1,\"529\":2,\"864\":1,\"962\":1}}],[\"到容器的\",{\"1\":{\"110\":1}}],[\"到二进制数组中查找对应索引位置的值\",{\"1\":{\"20\":1}}],[\"下时间精度是\",{\"1\":{\"903\":1}}],[\"下一秒又来了\",{\"1\":{\"952\":1}}],[\"下一个\",{\"1\":{\"879\":1}}],[\"下一条记录的位置\",{\"1\":{\"770\":1}}],[\"下推到了哪里\",{\"1\":{\"817\":1}}],[\"下推\",{\"1\":{\"817\":1}}],[\"下个事务才可以继续进行\",{\"1\":{\"810\":1}}],[\"下图中有时刻\",{\"1\":{\"810\":1}}],[\"下动态函数的问题\",{\"1\":{\"810\":1}}],[\"下单\",{\"1\":{\"719\":1}}],[\"下面才能用\",{\"1\":{\"1031\":1}}],[\"下面才能用这个文件名\",{\"1\":{\"1031\":1}}],[\"下面维护了微服务使用的proto文件以及根据它们所生成的go文件\",{\"1\":{\"962\":1}}],[\"下面举个\",{\"1\":{\"820\":2}}],[\"下面事务\",{\"1\":{\"820\":1}}],[\"下面的更准确\",{\"1\":{\"885\":1}}],[\"下面的查询语句会不会走索引\",{\"1\":{\"813\":1}}],[\"下面的代码都是在锁内的\",{\"1\":{\"265\":1}}],[\"下面通过一个实验来看看\",{\"1\":{\"770\":1}}],[\"下面是一个有趣的切片扩容示例\",{\"1\":{\"344\":1}}],[\"下面是一个非空接口赋值的例子\",{\"1\":{\"310\":1}}],[\"下面是chanrecv源码\",{\"1\":{\"265\":1}}],[\"下面做一些资源的清理\",{\"1\":{\"265\":1}}],[\"下面唯一要做的就是给阻塞做准备\",{\"1\":{\"265\":1}}],[\"下面我们找两个数来试一下这个算法\",{\"1\":{\"249\":1}}],[\"下面创建一个名为\",{\"1\":{\"110\":1}}],[\"下次会自动跳转\",{\"1\":{\"240\":1}}],[\"下次再有申请的时候可以直接使用\",{\"1\":{\"217\":1}}],[\"下次消费是从它的下一条消息开始消费\",{\"1\":{\"163\":1}}],[\"下载一个\",{\"1\":{\"138\":1}}],[\"下载镜像\",{\"0\":{\"136\":1},\"1\":{\"136\":1}}],[\"下\",{\"1\":{\"123\":1,\"217\":1,\"1031\":1}}],[\"下沉到合适位置\",{\"1\":{\"52\":1}}],[\"下沉操作\",{\"1\":{\"52\":1}}],[\"中被抽象为redisobject\",{\"1\":{\"937\":1}}],[\"中进行快速\",{\"1\":{\"955\":1}}],[\"中进行扣减\",{\"1\":{\"927\":1}}],[\"中进一步实现精确一次消费是非常困难的\",{\"1\":{\"706\":1}}],[\"中随机采样\",{\"1\":{\"906\":1}}],[\"中创建对象\",{\"1\":{\"897\":1}}],[\"中指向\",{\"1\":{\"894\":1}}],[\"中指向下一个记录的指针\",{\"1\":{\"770\":1}}],[\"中只会使用\",{\"1\":{\"873\":1}}],[\"中以键值对形式存在就是\",{\"1\":{\"870\":1}}],[\"中包含空格或\",{\"1\":{\"838\":1}}],[\"中包含创建新协程的时候\",{\"1\":{\"381\":1}}],[\"中插入数据的场景\",{\"1\":{\"820\":1}}],[\"中插入数据\",{\"1\":{\"820\":1}}],[\"中插入了一条记录\",{\"1\":{\"820\":1}}],[\"中插入了\",{\"1\":{\"820\":1}}],[\"中会有更多层的抽象\",{\"1\":{\"941\":1}}],[\"中会出现\",{\"1\":{\"873\":1}}],[\"中会发生\",{\"1\":{\"820\":1}}],[\"中会把记录中的内容都记下来\",{\"1\":{\"810\":1}}],[\"中已经有了事务记录\",{\"1\":{\"810\":1}}],[\"中查找到与\",{\"1\":{\"810\":2}}],[\"中继日志\",{\"1\":{\"810\":1}}],[\"中继日志然后回放\",{\"1\":{\"730\":1,\"761\":1}}],[\"中过滤数据\",{\"1\":{\"807\":1}}],[\"中磁盘和内存交互的基本单位是页\",{\"1\":{\"770\":1}}],[\"中存储了表的行数据和索引数据\",{\"1\":{\"770\":1}}],[\"中每一张表的数据都存放在一个独立的\",{\"1\":{\"770\":1}}],[\"中建立一张表都会生成一个\",{\"1\":{\"770\":1}}],[\"中就够了\",{\"1\":{\"765\":1,\"810\":1}}],[\"中就存放着对应的配置\",{\"1\":{\"223\":1}}],[\"中记录的写入量大于\",{\"1\":{\"756\":1,\"810\":1}}],[\"中完成数据页的更新\",{\"1\":{\"753\":1}}],[\"中数据所在的页\",{\"1\":{\"747\":1,\"810\":1}}],[\"中有两种编码形式\",{\"1\":{\"879\":1}}],[\"中有当前内部\",{\"1\":{\"810\":1}}],[\"中有\",{\"1\":{\"745\":1,\"810\":1}}],[\"中断\",{\"1\":{\"706\":1}}],[\"中文乱码问题\",{\"0\":{\"686\":1}}],[\"中更新\",{\"1\":{\"531\":1}}],[\"中都没有\",{\"1\":{\"529\":1}}],[\"中没有该组事务的记录\",{\"1\":{\"810\":1}}],[\"中没有当前内部\",{\"1\":{\"810\":1}}],[\"中没有\",{\"1\":{\"529\":2}}],[\"中获取\",{\"1\":{\"529\":1}}],[\"中是没有这个\",{\"1\":{\"525\":1}}],[\"中将\",{\"1\":{\"524\":1}}],[\"中加锁写\",{\"1\":{\"524\":1}}],[\"中操作\",{\"1\":{\"524\":1}}],[\"中操作的\",{\"1\":{\"519\":1}}],[\"中无锁完成写\",{\"1\":{\"524\":1}}],[\"中复制一份逻辑上存在\",{\"1\":{\"519\":1}}],[\"中相同的\",{\"1\":{\"512\":1}}],[\"中处理\",{\"1\":{\"512\":1}}],[\"中找到了\",{\"1\":{\"479\":1}}],[\"中发现了一个\",{\"1\":{\"479\":1}}],[\"中参数是地址\",{\"1\":{\"476\":1}}],[\"中向切片追加元素时\",{\"1\":{\"453\":1}}],[\"中最终所有的元素都是一个地址\",{\"1\":{\"453\":1}}],[\"中间节点也会随之增加\",{\"1\":{\"813\":1}}],[\"中间节点\",{\"1\":{\"813\":1}}],[\"中间再穿插写入binlog\",{\"1\":{\"810\":1}}],[\"中间再穿插写入\",{\"1\":{\"765\":1}}],[\"中间用英文逗号分隔\",{\"1\":{\"488\":1}}],[\"中间代码生成\",{\"1\":{\"389\":1,\"400\":1}}],[\"中间层的差异\",{\"1\":{\"249\":1}}],[\"中从\",{\"1\":{\"374\":1}}],[\"中设置了\",{\"1\":{\"373\":1}}],[\"中拷贝出来的\",{\"1\":{\"307\":1}}],[\"中几乎所有的数据结构都可以抽象成\",{\"1\":{\"302\":1}}],[\"中顺序和阻塞的约束\",{\"1\":{\"249\":1}}],[\"中安装一个\",{\"1\":{\"229\":1}}],[\"中定义任意的内置类型\",{\"1\":{\"229\":1}}],[\"中寻找残留的临时文件\",{\"1\":{\"223\":1}}],[\"中尝试寻找出错信息\",{\"1\":{\"223\":1}}],[\"中名称以\",{\"1\":{\"223\":1}}],[\"中手动配置桌面图标文件\",{\"1\":{\"223\":1}}],[\"中含有我通过包管理工具安装的应用程序\",{\"1\":{\"223\":1}}],[\"中一切都以文件形式储存\",{\"1\":{\"223\":1}}],[\"中一种较为特别的网络的模式\",{\"1\":{\"125\":1}}],[\"中看到了一大堆设备\",{\"1\":{\"223\":1}}],[\"中可执行文件的依赖\",{\"1\":{\"223\":1}}],[\"中可以挂载多个\",{\"1\":{\"110\":1}}],[\"中\",{\"1\":{\"223\":2,\"378\":1,\"384\":1,\"461\":1,\"464\":1,\"466\":1,\"518\":1,\"525\":1,\"531\":6,\"742\":1,\"747\":2,\"748\":1,\"751\":1,\"753\":1,\"756\":1,\"763\":1,\"770\":11,\"810\":10,\"813\":1,\"820\":1,\"841\":1,\"854\":1,\"873\":1,\"885\":1,\"946\":1,\"952\":1}}],[\"中常见的许多特性\",{\"1\":{\"190\":1}}],[\"中的角色可以让你简化授权的过程\",{\"1\":{\"850\":1}}],[\"中的普通筛选或聚合函数的筛选\",{\"1\":{\"823\":1}}],[\"中的某个数值\",{\"1\":{\"810\":1}}],[\"中的脏页刷新到磁盘中\",{\"1\":{\"810\":1}}],[\"中的脏页丢失而设计的\",{\"1\":{\"810\":1}}],[\"中的历史数据将数据恢复到事务开始之前的状态\",{\"1\":{\"810\":1}}],[\"中的原子性\",{\"1\":{\"810\":1}}],[\"中的信息之所以要逆序存放\",{\"1\":{\"770\":1}}],[\"中的缓存页\",{\"1\":{\"748\":1}}],[\"中的页就叫做缓存页\",{\"1\":{\"748\":1,\"810\":1}}],[\"中的数据从主库传输到从库上\",{\"1\":{\"810\":1}}],[\"中的数据页\",{\"1\":{\"751\":1}}],[\"中的数据\",{\"1\":{\"747\":1,\"810\":1}}],[\"中的字段没有值时\",{\"1\":{\"487\":1}}],[\"中的协程后\",{\"1\":{\"374\":1}}],[\"中的连接都会默认启用长连接\",{\"1\":{\"249\":1}}],[\"中的class\",{\"1\":{\"229\":1}}],[\"中的类\",{\"1\":{\"229\":1}}],[\"中的副本不能被选举为新的\",{\"1\":{\"181\":1}}],[\"中的副本才有可能被选举为新的\",{\"1\":{\"181\":1}}],[\"中的副本与\",{\"1\":{\"181\":2}}],[\"中的\",{\"1\":{\"124\":1,\"307\":2,\"744\":4,\"748\":1,\"752\":1,\"753\":2,\"789\":2,\"793\":1,\"810\":10,\"817\":2,\"820\":3,\"879\":1,\"894\":1,\"946\":1}}],[\"中的一种\",{\"1\":{\"36\":1}}],[\"进\",{\"1\":{\"906\":1}}],[\"进一步节省查询需要的时间\",{\"1\":{\"813\":1}}],[\"进而吸引用户\",{\"1\":{\"927\":1}}],[\"进而不会导致索引失效\",{\"1\":{\"813\":1}}],[\"进而导致性能下降\",{\"1\":{\"770\":2}}],[\"进而提升写\",{\"1\":{\"755\":1,\"810\":1}}],[\"进化\",{\"1\":{\"249\":1}}],[\"进入多线程模式后\",{\"1\":{\"897\":1}}],[\"进入服务管理页面\",{\"1\":{\"836\":1}}],[\"进入阻塞状态\",{\"1\":{\"820\":1}}],[\"进入\",{\"1\":{\"237\":1}}],[\"进入系统内核空间分配物理内存\",{\"1\":{\"217\":1}}],[\"进入容器正在执行的终端\",{\"1\":{\"149\":1}}],[\"进入容器后开启一个新的终端\",{\"1\":{\"149\":1}}],[\"进入容器查看内容\",{\"1\":{\"139\":1}}],[\"进入当前正在运行的容器\",{\"0\":{\"149\":1}}],[\"进程暂停\",{\"1\":{\"918\":1,\"921\":1}}],[\"进程中途挂了\",{\"1\":{\"810\":1}}],[\"进程的崩溃并不会丢失数据\",{\"1\":{\"810\":1}}],[\"进程的崩溃会导致上一秒钟所有事务数据的丢失\",{\"1\":{\"810\":1}}],[\"进程可以通过select\",{\"1\":{\"226\":1}}],[\"进程可以正常运行\",{\"1\":{\"217\":1}}],[\"进程调度\",{\"1\":{\"220\":1}}],[\"进程会被操作系统杀掉\",{\"1\":{\"217\":1}}],[\"进程也没有办法访问其他进程的页表\",{\"1\":{\"217\":1}}],[\"进程列表等还是隔离的\",{\"1\":{\"125\":1}}],[\"进程\",{\"1\":{\"104\":1}}],[\"进行automigrate\",{\"1\":{\"982\":1}}],[\"进行合并\",{\"1\":{\"952\":1}}],[\"进行一个粗略判断\",{\"1\":{\"918\":1,\"921\":1}}],[\"进行一些操作\",{\"1\":{\"882\":1}}],[\"进行了一些优化\",{\"1\":{\"906\":1}}],[\"进行回收\",{\"1\":{\"882\":1}}],[\"进行分离为\",{\"1\":{\"873\":1}}],[\"进行分布式事务处理时\",{\"1\":{\"810\":1}}],[\"进行查询\",{\"1\":{\"817\":2}}],[\"进行条件判断\",{\"1\":{\"813\":1}}],[\"进行排序\",{\"1\":{\"813\":1}}],[\"进行组提交\",{\"1\":{\"810\":1}}],[\"进行存放的\",{\"1\":{\"770\":1}}],[\"进行持久化的时机\",{\"1\":{\"952\":1}}],[\"进行持久化\",{\"1\":{\"763\":1}}],[\"进行对比\",{\"1\":{\"744\":1}}],[\"进行哈希取模操作\",{\"1\":{\"727\":1}}],[\"进行任意类型的转换\",{\"1\":{\"460\":1}}],[\"进行解密\",{\"1\":{\"249\":1}}],[\"进行通信时所必须用到的协议群的统称\",{\"1\":{\"249\":1}}],[\"进行窗口内数据的一系列更新\",{\"1\":{\"88\":2}}],[\"进行预处理\",{\"1\":{\"36\":1}}],[\"垫片\",{\"1\":{\"104\":1}}],[\"镜\",{\"1\":{\"104\":1}}],[\"镜像保存始终是数据库行之有效的解决方案\",{\"1\":{\"952\":1}}],[\"镜像来测试学习\",{\"1\":{\"138\":1}}],[\"镜像id\",{\"1\":{\"137\":4}}],[\"镜像名\",{\"1\":{\"136\":1,\"145\":1}}],[\"镜像的大小\",{\"1\":{\"134\":1}}],[\"镜像的创建时间\",{\"1\":{\"134\":1}}],[\"镜像的id\",{\"1\":{\"134\":1}}],[\"镜像的标签\",{\"1\":{\"134\":1}}],[\"镜像的仓库源\",{\"1\":{\"134\":1}}],[\"镜像命令\",{\"0\":{\"133\":1}}],[\"镜像创建并启动容器\",{\"1\":{\"104\":1}}],[\"镜像仓库分为公共镜像仓库和私有镜像仓库\",{\"1\":{\"99\":1}}],[\"镜像是静态的只读文件\",{\"1\":{\"98\":1}}],[\"镜像\",{\"0\":{\"96\":1},\"1\":{\"99\":1}}],[\"秒杀系统\",{\"2\":{\"929\":1}}],[\"秒杀活动一开始\",{\"1\":{\"927\":1}}],[\"秒杀通常指因为某种活动瞬时产生巨大流量的场景\",{\"1\":{\"927\":1}}],[\"秒杀\",{\"1\":{\"927\":1}}],[\"秒\",{\"1\":{\"104\":1,\"691\":1,\"756\":1,\"810\":2,\"820\":1,\"952\":1}}],[\"启用后\",{\"1\":{\"237\":2}}],[\"启用工作台列表的平滑滚动效果\",{\"1\":{\"3\":1}}],[\"启动时默认开启\",{\"1\":{\"943\":1}}],[\"启动mysql\",{\"1\":{\"836\":1}}],[\"启动mysql服务器\",{\"1\":{\"835\":1}}],[\"启动事务时生成一个\",{\"1\":{\"791\":1}}],[\"启动事务时\",{\"1\":{\"784\":1}}],[\"启动完成的时候\",{\"1\":{\"748\":1}}],[\"启动多个并发删除操作\",{\"1\":{\"515\":1}}],[\"启动多个并发读操作\",{\"1\":{\"515\":1}}],[\"启动多个并发写操作\",{\"1\":{\"515\":1}}],[\"启动\",{\"0\":{\"834\":1},\"1\":{\"367\":1}}],[\"启动容器\",{\"1\":{\"143\":1,\"659\":1}}],[\"启动容器使用\",{\"1\":{\"124\":1}}],[\"启动和停止容器的操作\",{\"0\":{\"143\":1}}],[\"启动的时候\",{\"1\":{\"104\":1,\"748\":1,\"810\":1}}],[\"启动一个web服务\",{\"1\":{\"1021\":1}}],[\"启动一个容器时会根据\",{\"1\":{\"121\":1}}],[\"启动一个挂载数据卷的容器\",{\"0\":{\"110\":1}}],[\"启动一个\",{\"0\":{\"1021\":1},\"1\":{\"104\":1,\"515\":1}}],[\"启动并管理\",{\"1\":{\"103\":1}}],[\"⬇️辅助理解\",{\"1\":{\"737\":1}}],[\"⬇️\",{\"1\":{\"103\":1}}],[\"图解redis\",{\"1\":{\"936\":1}}],[\"图上的某些节点不是只有一层\",{\"1\":{\"885\":1}}],[\"图上有\",{\"1\":{\"103\":1}}],[\"图中\",{\"1\":{\"820\":1}}],[\"图中顺时针\",{\"1\":{\"810\":1}}],[\"图中蓝色部分\",{\"1\":{\"810\":1}}],[\"图中的红色部分\",{\"1\":{\"810\":1}}],[\"图中的\",{\"1\":{\"810\":3}}],[\"图示\",{\"1\":{\"751\":1,\"757\":1}}],[\"图片下载失败\",{\"1\":{\"829\":21,\"891\":1}}],[\"图片失败\",{\"1\":{\"829\":1}}],[\"图片\",{\"1\":{\"249\":1}}],[\"图形用户界面\",{\"1\":{\"220\":1}}],[\"图标包\",{\"0\":{\"6\":1}}],[\"与慢速哈希\",{\"1\":{\"1054\":1}}],[\"与不同日志库的速度对比\",{\"1\":{\"956\":1}}],[\"与此同时\",{\"1\":{\"864\":1}}],[\"与客户端进行\",{\"1\":{\"817\":1}}],[\"与主库的值不一致性\",{\"1\":{\"810\":2}}],[\"与主库的值不一致\",{\"1\":{\"763\":2}}],[\"与传统的cgi\",{\"1\":{\"646\":1}}],[\"与servlet和filter相比\",{\"1\":{\"614\":1}}],[\"与servlet类似\",{\"1\":{\"585\":1}}],[\"与servlet相比\",{\"1\":{\"578\":1}}],[\"与json\",{\"0\":{\"483\":1}}],[\"与空接口的\",{\"1\":{\"307\":1}}],[\"与外部网络通信\",{\"1\":{\"246\":1}}],[\"与管道符\",{\"1\":{\"211\":1}}],[\"与宿主机在同一个网络中\",{\"1\":{\"124\":1}}],[\"与\",{\"0\":{\"509\":1,\"753\":1},\"1\":{\"102\":1,\"104\":1,\"249\":3,\"473\":1,\"744\":1,\"753\":1,\"770\":1,\"957\":2,\"962\":1}}],[\"与原变量实际是同一个东西\",{\"1\":{\"33\":1}}],[\"种淘汰方式\",{\"1\":{\"900\":1}}],[\"种策略\",{\"1\":{\"900\":1}}],[\"种情况\",{\"1\":{\"873\":1}}],[\"种类\",{\"1\":{\"829\":1,\"873\":1}}],[\"种存储方式\",{\"1\":{\"813\":1}}],[\"种格式类型\",{\"1\":{\"810\":1}}],[\"种行格式\",{\"1\":{\"770\":1}}],[\"种\",{\"1\":{\"101\":1,\"873\":1,\"930\":1,\"952\":1}}],[\"模运算是不能反解的\",{\"1\":{\"249\":1}}],[\"模型定义\",{\"0\":{\"981\":1}}],[\"模型下\",{\"1\":{\"374\":1}}],[\"模型所导致的\",{\"1\":{\"249\":1}}],[\"模型联系和区别\",{\"1\":{\"249\":1}}],[\"模型\",{\"0\":{\"384\":1},\"1\":{\"249\":2,\"888\":1}}],[\"模型是\",{\"1\":{\"249\":1}}],[\"模型是理论是理论网络模型\",{\"1\":{\"249\":1}}],[\"模块化\",{\"1\":{\"249\":1}}],[\"模块非常有用\",{\"1\":{\"229\":1}}],[\"模拟数据库查询\",{\"1\":{\"546\":1}}],[\"模拟\",{\"0\":{\"510\":1}}],[\"模拟一下\",{\"1\":{\"373\":1}}],[\"模拟随机的源端口地址向随机的目的端口发送大量的udp包\",{\"1\":{\"243\":1}}],[\"模拟指针行为的同时还提供自动垃圾回收机制\",{\"1\":{\"33\":1}}],[\"模式中\",{\"1\":{\"906\":1}}],[\"模式和\",{\"1\":{\"810\":1}}],[\"模式可以在容器创建时通过\",{\"1\":{\"126\":1}}],[\"模式的容器可以直接使用宿主机的\",{\"1\":{\"124\":1}}],[\"模式相当于\",{\"1\":{\"124\":1}}],[\"模式\",{\"0\":{\"123\":1,\"126\":1},\"1\":{\"100\":1,\"122\":5,\"124\":2,\"126\":1,\"810\":2,\"927\":1}}],[\"停止或重启动\",{\"1\":{\"836\":1}}],[\"停止mysql服务器\",{\"0\":{\"834\":1},\"1\":{\"835\":1}}],[\"停止查询\",{\"1\":{\"817\":1}}],[\"停止当前正在运行的容器\",{\"1\":{\"143\":1}}],[\"停止\",{\"1\":{\"98\":1}}],[\"仓库中看到\",{\"1\":{\"956\":1,\"957\":1}}],[\"仓库中只用一句话来概括\",{\"1\":{\"955\":1}}],[\"仓库\",{\"0\":{\"96\":1}}],[\"便于维护\",{\"1\":{\"657\":1}}],[\"便于问题排查\",{\"1\":{\"605\":1}}],[\"便于数据的分片和分布式系统的处理\",{\"1\":{\"92\":1}}],[\"便于组织\",{\"1\":{\"36\":1}}],[\"被访问时\",{\"1\":{\"906\":2}}],[\"被调用\",{\"1\":{\"897\":1}}],[\"被阻塞\",{\"1\":{\"820\":1}}],[\"被拆开的时候\",{\"1\":{\"810\":1}}],[\"被修改\",{\"1\":{\"810\":1}}],[\"被final修饰的成员变量也必须显式地赋值\",{\"1\":{\"571\":1}}],[\"被删除了\",{\"1\":{\"524\":1}}],[\"被\",{\"1\":{\"512\":1,\"820\":1,\"879\":1}}],[\"被捕获了\",{\"1\":{\"479\":1}}],[\"被返回了引用\",{\"1\":{\"410\":1}}],[\"被追加到了\",{\"1\":{\"249\":1}}],[\"被分为五类\",{\"1\":{\"249\":1}}],[\"被借用到了\",{\"1\":{\"249\":1}}],[\"被污染的个人计算机等\",{\"1\":{\"243\":1}}],[\"被动触发\",{\"1\":{\"614\":1}}],[\"被动关闭连接\",{\"1\":{\"237\":1}}],[\"被动方由于没有收到ack响应\",{\"1\":{\"237\":1}}],[\"被后面相同四元组的连接错误的接收\",{\"1\":{\"237\":1}}],[\"被添加到了该用户的\",{\"1\":{\"223\":1}}],[\"被划分成多个部分\",{\"1\":{\"92\":1}}],[\"被定义为\",{\"1\":{\"36\":1}}],[\"机器人27号\",{\"1\":{\"990\":3}}],[\"机器人\",{\"1\":{\"986\":1}}],[\"机器id和序列号\",{\"1\":{\"92\":1}}],[\"机器id和序列号组合成一个64位的二进制数\",{\"1\":{\"92\":1}}],[\"机器id\",{\"1\":{\"92\":1}}],[\"机构\",{\"1\":{\"249\":1}}],[\"机制的弊端\",{\"1\":{\"249\":1}}],[\"机制工作原理\",{\"1\":{\"217\":1}}],[\"机制\",{\"0\":{\"740\":1,\"744\":1,\"752\":1,\"786\":1},\"1\":{\"217\":1,\"767\":1,\"810\":1,\"924\":1,\"956\":1}}],[\"机制来防止重复提交\",{\"1\":{\"23\":1}}],[\"缩容不会进行\",{\"1\":{\"864\":1}}],[\"缩容\",{\"1\":{\"864\":1}}],[\"缩小窗口\",{\"1\":{\"88\":1}}],[\"缩进着色\",{\"1\":{\"8\":1}}],[\"增删更新\",{\"1\":{\"952\":1}}],[\"增删改\",{\"1\":{\"810\":4}}],[\"增删改一般时间复杂度是\",{\"1\":{\"226\":1}}],[\"增\",{\"1\":{\"813\":1}}],[\"增大它的大小可以让\",{\"1\":{\"755\":1,\"810\":1}}],[\"增大窗口\",{\"1\":{\"88\":1}}],[\"增减节点会对原有的路由分布会造成冲击\",{\"1\":{\"723\":1}}],[\"增长方向不同\",{\"1\":{\"217\":1}}],[\"增加一条记录\",{\"1\":{\"985\":1}}],[\"增加一个\",{\"1\":{\"957\":1}}],[\"增加一个大于\",{\"1\":{\"879\":1}}],[\"增加一个判断条件来计算哪种情况会使窗口需要缩小\",{\"1\":{\"88\":1}}],[\"增加渐进式重试\",{\"1\":{\"927\":1}}],[\"增加回退指针\",{\"1\":{\"885\":1}}],[\"增加了删除逻辑\",{\"1\":{\"930\":1}}],[\"增加了\",{\"1\":{\"879\":1}}],[\"增加了一层安全性\",{\"1\":{\"246\":1}}],[\"增加空余空间\",{\"1\":{\"873\":1}}],[\"增加长度字段\",{\"1\":{\"873\":1}}],[\"增加字符数量时\",{\"1\":{\"807\":1}}],[\"增加管线化技术\",{\"1\":{\"249\":1}}],[\"增加\",{\"1\":{\"226\":1}}],[\"增加读的并发度\",{\"1\":{\"176\":1}}],[\"增加新的分区\",{\"1\":{\"165\":1}}],[\"我基于\",{\"1\":{\"957\":1}}],[\"我是一个key\",{\"1\":{\"939\":2}}],[\"我是协程\",{\"1\":{\"367\":1,\"369\":10,\"370\":256,\"371\":258}}],[\"我补充一点\",{\"1\":{\"820\":1}}],[\"我对\",{\"1\":{\"817\":1}}],[\"我下面这条查询语句\",{\"1\":{\"817\":1}}],[\"我在两阶段提交的不同时刻\",{\"1\":{\"810\":1}}],[\"我上面这个例子是针对字符集为\",{\"1\":{\"770\":1}}],[\"我这里有一个名为\",{\"1\":{\"770\":1}}],[\"我这里算好的是\",{\"1\":{\"249\":1}}],[\"我已经把该给你的东西都给你了\",{\"1\":{\"249\":1}}],[\"我就不展开了\",{\"1\":{\"249\":1}}],[\"我的用户名是\",{\"1\":{\"223\":1}}],[\"我想记录窗口中的元素和\",{\"1\":{\"88\":1}}],[\"我想记录窗口中元素出现的次数\",{\"1\":{\"88\":1}}],[\"我们去掉了\",{\"1\":{\"962\":1}}],[\"我们可能会把\",{\"1\":{\"962\":1}}],[\"我们可以执行\",{\"1\":{\"820\":2}}],[\"我们可以看到\",{\"1\":{\"817\":1}}],[\"我们可以利用一个字段的前n个字符创建索引\",{\"1\":{\"813\":1}}],[\"我们可以从执行计划中的\",{\"1\":{\"813\":1}}],[\"我们可以从图片的二进制码串开头取\",{\"1\":{\"75\":1}}],[\"我们可以将该值设置为\",{\"1\":{\"810\":1}}],[\"我们可以及时在数据库表看到\",{\"1\":{\"810\":1}}],[\"我们可以了解sql语句是如何被优化器执行的\",{\"1\":{\"807\":1}}],[\"我们可以通过\",{\"1\":{\"820\":1}}],[\"我们可以通过将参数\",{\"1\":{\"817\":1}}],[\"我们可以通过控制以下参数\",{\"1\":{\"810\":1}}],[\"我们可以通过这个日志回滚到事务之前的数据\",{\"1\":{\"739\":1,\"810\":1}}],[\"我们可以通过给结构体字段添加tag来指定json序列化生成的字段名\",{\"1\":{\"485\":1}}],[\"我们可以调用\",{\"1\":{\"458\":1}}],[\"我们可以知道\",{\"1\":{\"374\":1}}],[\"我们可以快速定位到问题发生在哪一层\",{\"1\":{\"249\":1}}],[\"我们可以把它换出到物理内存之外\",{\"1\":{\"217\":1}}],[\"我们可以关注消费端partition\",{\"1\":{\"165\":1}}],[\"我们可以借用前面数据分片的思想\",{\"1\":{\"81\":1}}],[\"我们使用wire来维护依赖注入\",{\"1\":{\"962\":1}}],[\"我们使用gorm操作数据库的话\",{\"1\":{\"488\":1}}],[\"我们并不需要极致的性能\",{\"1\":{\"957\":1}}],[\"我们再来对比下\",{\"1\":{\"957\":1}}],[\"我们来看下\",{\"1\":{\"957\":1}}],[\"我们只需要保证redis库存+kafka消耗的最终一致性\",{\"1\":{\"927\":1}}],[\"我们看下访问redis扣减库存时各种异常情况\",{\"1\":{\"927\":1}}],[\"我们看看看看这三条记录的行格式中的\",{\"1\":{\"770\":1}}],[\"我们抢购场景最核心的\",{\"1\":{\"927\":1}}],[\"我们希望还能更进一步\",{\"1\":{\"927\":1}}],[\"我们要尽量挡住黄牛的魔爪\",{\"1\":{\"927\":1}}],[\"我们要先知道每个变长字段的\",{\"1\":{\"770\":1}}],[\"我们就可以用setnx实现加锁的目的\",{\"1\":{\"910\":1,\"921\":1}}],[\"我们就需要将数据分布在多台机器上\",{\"1\":{\"81\":1}}],[\"我们也可以从\",{\"1\":{\"820\":1}}],[\"我们是要考虑\",{\"1\":{\"820\":2}}],[\"我们常说的索引数据结构\",{\"1\":{\"817\":1}}],[\"我们知道可以使用\",{\"1\":{\"957\":1}}],[\"我们知道\",{\"1\":{\"810\":1,\"957\":1}}],[\"我们在执行执行一条\",{\"1\":{\"810\":1}}],[\"我们在算\",{\"1\":{\"770\":1}}],[\"我们先来测试看看\",{\"1\":{\"770\":1}}],[\"我们先创建这样一张表\",{\"1\":{\"770\":1}}],[\"我们这里字段类型是\",{\"1\":{\"770\":1}}],[\"我们定义一个\",{\"1\":{\"770\":1}}],[\"我们执行\",{\"1\":{\"770\":1,\"820\":2}}],[\"我们把三条记录的\",{\"1\":{\"770\":1}}],[\"我们进入\",{\"1\":{\"770\":1}}],[\"我们每创建一个\",{\"1\":{\"770\":1}}],[\"我们每换一个页面可能就得重新登录一次\",{\"1\":{\"249\":1}}],[\"我们还通过\",{\"1\":{\"957\":1}}],[\"我们还可以按客户来分区\",{\"1\":{\"723\":1}}],[\"我们还需要一个引用计数的指针设定对象的值\",{\"1\":{\"33\":1}}],[\"我们用公钥随便加密一个5试试\",{\"1\":{\"249\":1}}],[\"我们选7\",{\"1\":{\"249\":1}}],[\"我们假设每个报文时间加\",{\"1\":{\"237\":1}}],[\"我们需要一个超时来兜底\",{\"1\":{\"911\":1,\"921\":1}}],[\"我们需要注意创建时的顺序问题\",{\"1\":{\"813\":1}}],[\"我们需要json序列化user\",{\"1\":{\"490\":1}}],[\"我们需要确保\",{\"1\":{\"229\":1}}],[\"我们需要在同一个客户端上\",{\"1\":{\"77\":1}}],[\"我们说一些隐藏的比较重要的文件夹\",{\"1\":{\"223\":1}}],[\"我们不需要显示的使用\",{\"1\":{\"820\":1}}],[\"我们不应该乱动这里的文件\",{\"1\":{\"223\":1}}],[\"我们不能单纯地用图片的元信息\",{\"1\":{\"75\":1}}],[\"我们最少只能分配一个页\",{\"1\":{\"217\":1}}],[\"我们叫页\",{\"1\":{\"217\":1}}],[\"我们有了镜像才可以创建容器\",{\"1\":{\"138\":1}}],[\"我们有海量的数据需要缓存\",{\"1\":{\"81\":1}}],[\"滑动窗口\",{\"2\":{\"90\":1}}],[\"滑动窗口算法框架\",{\"0\":{\"87\":1},\"1\":{\"88\":1}}],[\"滑动窗口算法详解\",{\"0\":{\"85\":1}}],[\"滑动窗口是一种常见的双指针技术\",{\"1\":{\"86\":1}}],[\"滑动窗口基本概念\",{\"0\":{\"86\":1}}],[\"哈希大小\",{\"1\":{\"864\":1}}],[\"哈希结构的致命问题在于无序\",{\"1\":{\"813\":1}}],[\"哈希索引陷阱\",{\"1\":{\"813\":1}}],[\"哈希索引\",{\"1\":{\"803\":1,\"813\":1}}],[\"哈希槽示意图\",{\"1\":{\"723\":1}}],[\"哈希表来组织所有的\",{\"1\":{\"945\":1}}],[\"哈希表重置下标\",{\"1\":{\"942\":1}}],[\"哈希表的类型\",{\"1\":{\"942\":1}}],[\"哈希表大小的掩码表示\",{\"1\":{\"864\":1}}],[\"哈希表\",{\"1\":{\"942\":1},\"2\":{\"335\":1,\"866\":1}}],[\"哈希冲突如何解决\",{\"0\":{\"945\":1}}],[\"哈希冲突是指不同的键计算出相同的哈希值\",{\"1\":{\"320\":1}}],[\"哈希冲突\",{\"0\":{\"320\":1}}],[\"哈希\",{\"1\":{\"302\":1},\"2\":{\"84\":1}}],[\"哈希算法因哈希值长度有限而无法避免冲突\",{\"1\":{\"74\":1}}],[\"哈希算法有很多\",{\"1\":{\"72\":1}}],[\"哈希算法应用\",{\"0\":{\"71\":1}}],[\"哈希算法基础\",{\"0\":{\"69\":1}}],[\"哈希算法详解\",{\"0\":{\"68\":1}}],[\"特别标识\",{\"1\":{\"879\":1}}],[\"特别适用于节点动态变化的场景\",{\"1\":{\"82\":1}}],[\"特性\",{\"1\":{\"682\":1,\"810\":1,\"911\":1,\"921\":1}}],[\"特殊监听器\",{\"0\":{\"636\":1}}],[\"特殊运算符\",{\"0\":{\"446\":1}}],[\"特殊场景\",{\"1\":{\"265\":1}}],[\"特点是高效地插入和查询\",{\"1\":{\"930\":1}}],[\"特点是函数名相同\",{\"1\":{\"33\":1}}],[\"特点\",{\"1\":{\"246\":3,\"813\":2}}],[\"该功能可以用于确定哪些密码需要更新\",{\"1\":{\"1058\":1}}],[\"该服务所有不对外暴露的代码\",{\"1\":{\"962\":1}}],[\"该配置的字段会以结构化的形式打印在每条日志输出中\",{\"1\":{\"957\":1}}],[\"该数据库的键空间\",{\"1\":{\"944\":1}}],[\"该字段的值可能会重复\",{\"1\":{\"826\":1}}],[\"该记录还是隐式锁\",{\"1\":{\"820\":1}}],[\"该记录的索引\",{\"1\":{\"820\":1}}],[\"该记录的索引的\",{\"1\":{\"820\":2}}],[\"该记录的索引中的\",{\"1\":{\"820\":1}}],[\"该锁只用于并发插入操作\",{\"1\":{\"820\":1}}],[\"该规范定义了两个或更多的数据库资源管理器如何在全局事务中协同工作的标准\",{\"1\":{\"810\":1}}],[\"该文件是用来保存每个表的元数据信息的\",{\"1\":{\"770\":1}}],[\"该\",{\"1\":{\"770\":1,\"943\":1}}],[\"该内存叫\",{\"1\":{\"760\":1,\"810\":1}}],[\"该页的内存数据和磁盘上的数据已经不一致\",{\"1\":{\"747\":1,\"810\":1}}],[\"该用户就路由到\",{\"1\":{\"723\":1}}],[\"该层剩下的代码才会恢复执行\",{\"1\":{\"479\":1}}],[\"该panic会一直向外层传递\",{\"1\":{\"479\":1}}],[\"该结构体有两个域\",{\"1\":{\"441\":1}}],[\"该线程的其他协程也可以被\",{\"1\":{\"378\":1}}],[\"该问题以\",{\"1\":{\"373\":1}}],[\"该指针占用8个字节\",{\"1\":{\"325\":1}}],[\"该指针指向的函数具有int类型参数\",{\"1\":{\"33\":1}}],[\"该类型不能赋值给该接口\",{\"1\":{\"307\":1}}],[\"该类型的hash值\",{\"1\":{\"307\":1}}],[\"该类型的内容暂不支持下载\",{\"1\":{\"240\":1}}],[\"该状态会持续\",{\"1\":{\"237\":1}}],[\"该状态出现在主动断开方\",{\"1\":{\"237\":1}}],[\"该模式的缺点\",{\"1\":{\"930\":1}}],[\"该模式下在事务提交时不会主动触发写入磁盘的操作\",{\"1\":{\"756\":1,\"810\":1}}],[\"该模式下的容器只有宿主机可以直接访问\",{\"1\":{\"123\":1}}],[\"该模式关闭了容器的网络功能\",{\"1\":{\"122\":1}}],[\"该如何决定将哪个数据放到哪个机器上呢\",{\"1\":{\"81\":1}}],[\"次级ttl\",{\"1\":{\"900\":1}}],[\"次方幂则为\",{\"1\":{\"864\":1}}],[\"次方幂\",{\"1\":{\"864\":2}}],[\"次刷盘操作\",{\"1\":{\"810\":1}}],[\"次调度了用户定义的\",{\"1\":{\"374\":1}}],[\"次里面\",{\"1\":{\"374\":1}}],[\"次就去全局队列中偷一个协程\",{\"1\":{\"374\":1}}],[\"次本地队列\",{\"1\":{\"374\":1}}],[\"次\",{\"1\":{\"79\":1,\"813\":1}}],[\"次数更新到低8位\",{\"1\":{\"903\":1}}],[\"次数更少\",{\"1\":{\"813\":1}}],[\"次数会很高\",{\"1\":{\"810\":1}}],[\"次数高\",{\"1\":{\"766\":1,\"810\":1}}],[\"次数\",{\"1\":{\"20\":1}}],[\"时不在需要\",{\"1\":{\"957\":1}}],[\"时钟漂移\",{\"1\":{\"918\":1,\"921\":1}}],[\"时机\",{\"1\":{\"924\":1}}],[\"时机都是存储了\",{\"1\":{\"894\":1}}],[\"时机复杂度找到\",{\"1\":{\"876\":1}}],[\"时加上\",{\"1\":{\"820\":1}}],[\"时刻\",{\"1\":{\"794\":3}}],[\"时传递的标志集\",{\"1\":{\"229\":1}}],[\"时在命令行上声明它\",{\"1\":{\"229\":1}}],[\"时也称之为监管态\",{\"1\":{\"220\":1}}],[\"时\",{\"1\":{\"79\":1,\"104\":1,\"165\":1,\"229\":1,\"511\":2,\"744\":2,\"755\":1,\"810\":6,\"817\":1,\"820\":7,\"867\":1,\"888\":2,\"957\":1}}],[\"时间太短容易造成缓存频繁失效\",{\"1\":{\"930\":1}}],[\"时间消耗都很小\",{\"1\":{\"930\":1}}],[\"时间复杂度是\",{\"1\":{\"879\":1}}],[\"时间复杂度上找到\",{\"1\":{\"864\":1}}],[\"时间复杂度为\",{\"1\":{\"226\":1}}],[\"时间复杂度为o\",{\"1\":{\"86\":1}}],[\"时间\",{\"1\":{\"817\":1}}],[\"时间日期命令\",{\"0\":{\"210\":1}}],[\"时间戳取模\",{\"1\":{\"906\":1}}],[\"时间戳\",{\"1\":{\"92\":2}}],[\"时间久\",{\"1\":{\"79\":1}}],[\"时间内查找到某个qq\",{\"1\":{\"20\":1}}],[\"第2条中文记录\",{\"1\":{\"770\":1}}],[\"第4步的细节参考\",{\"1\":{\"751\":1}}],[\"第四步记录用户购买数\",{\"1\":{\"927\":1}}],[\"第四步\",{\"1\":{\"817\":1}}],[\"第四次握手\",{\"1\":{\"249\":1}}],[\"第四挥手ack报文没有被被动方接收到\",{\"1\":{\"237\":1}}],[\"第七步说明下\",{\"1\":{\"249\":1}}],[\"第三方日志库\",{\"1\":{\"957\":1}}],[\"第三方库\",{\"1\":{\"957\":1}}],[\"第三种\",{\"1\":{\"927\":1}}],[\"第三步扣减库存\",{\"1\":{\"927\":1}}],[\"第三步\",{\"1\":{\"817\":1,\"903\":1,\"952\":1}}],[\"第三条记录\",{\"1\":{\"770\":2}}],[\"第三次声明\",{\"1\":{\"442\":1}}],[\"第三次握手\",{\"1\":{\"249\":1}}],[\"第三次将物理页号与页内位移组合\",{\"1\":{\"217\":1}}],[\"第三\",{\"1\":{\"217\":1}}],[\"第二种\",{\"1\":{\"927\":1}}],[\"第二是多种淘汰策略\",{\"1\":{\"900\":1}}],[\"第二件事\",{\"1\":{\"817\":1}}],[\"第二条记录\",{\"1\":{\"770\":3}}],[\"第二个才是实际路径\",{\"1\":{\"1033\":1}}],[\"第二个事务就会\",{\"1\":{\"820\":1}}],[\"第二个filter\",{\"1\":{\"596\":1}}],[\"第二个参数代表通道中的元素大小\",{\"1\":{\"263\":1}}],[\"第二个是如果只用一台机器来处理这么巨大的数据\",{\"1\":{\"79\":1}}],[\"第二次声明\",{\"1\":{\"442\":1}}],[\"第二次握手\",{\"1\":{\"249\":1}}],[\"第二次访问页表\",{\"1\":{\"217\":1}}],[\"第二步查询用户已购买个数\",{\"1\":{\"927\":1}}],[\"第二步扣减库存\",{\"1\":{\"927\":1}}],[\"第二步\",{\"1\":{\"249\":1,\"817\":1,\"903\":1,\"927\":1,\"952\":1}}],[\"第二\",{\"1\":{\"217\":1}}],[\"第一种\",{\"1\":{\"927\":1}}],[\"第一件事\",{\"1\":{\"817\":1}}],[\"第一列数据相同时才会按照第二列排序\",{\"1\":{\"813\":1}}],[\"第一条记录所有列都有值\",{\"1\":{\"770\":1}}],[\"第一条记录\",{\"1\":{\"770\":2}}],[\"第一个参数是别名\",{\"1\":{\"1033\":1}}],[\"第一个事务插入的记录\",{\"1\":{\"820\":1}}],[\"第一个事务会成为\",{\"1\":{\"810\":1}}],[\"第一个字节的\",{\"1\":{\"879\":1}}],[\"第一个字\",{\"1\":{\"813\":1}}],[\"第一个进入队列的事务会成为\",{\"1\":{\"810\":1}}],[\"第一个filter\",{\"1\":{\"596\":1}}],[\"第一个返回值为正常返回值\",{\"1\":{\"425\":1}}],[\"第一个代表创建的channel的类型\",{\"1\":{\"263\":1}}],[\"第一个是文件大\",{\"1\":{\"79\":1}}],[\"第一步查询库存\",{\"1\":{\"927\":2}}],[\"第一步\",{\"1\":{\"249\":1,\"817\":2,\"903\":1,\"927\":1,\"952\":1}}],[\"第一行\",{\"1\":{\"229\":1}}],[\"第一\",{\"1\":{\"217\":1}}],[\"第一次随机选取的\",{\"1\":{\"906\":1}}],[\"第一次执行普通的\",{\"1\":{\"793\":1}}],[\"第一次声明\",{\"1\":{\"442\":2}}],[\"第一次握手\",{\"1\":{\"249\":1}}],[\"第一次访问段表\",{\"1\":{\"217\":1}}],[\"第一次请求已经执行完毕并且释放了锁\",{\"1\":{\"23\":1}}],[\"第一次请求先到达服务端\",{\"1\":{\"23\":1}}],[\"第一次申请的token\",{\"1\":{\"23\":1}}],[\"关系表达式或逻辑表达式\",{\"1\":{\"451\":1}}],[\"关系运算符\",{\"1\":{\"442\":1}}],[\"关注aof可读性的情况实际比较少\",{\"1\":{\"949\":1}}],[\"关注这三个结构体\",{\"1\":{\"516\":1}}],[\"关注\",{\"1\":{\"226\":1}}],[\"关闭日志的debug输出\",{\"0\":{\"1027\":1}}],[\"关闭小写转换\",{\"1\":{\"979\":1}}],[\"关闭数据库连接池\",{\"1\":{\"640\":1}}],[\"关闭\",{\"1\":{\"612\":1,\"1015\":1}}],[\"关闭连接等\",{\"1\":{\"592\":1}}],[\"关闭连接是\",{\"1\":{\"249\":1}}],[\"关闭socket\",{\"1\":{\"226\":1}}],[\"关闭套接字\",{\"1\":{\"226\":1}}],[\"关闭客户端socket\",{\"1\":{\"226\":1}}],[\"关闭和重启系统前应先运行sync命令\",{\"1\":{\"204\":1}}],[\"关键是备份期间\",{\"1\":{\"820\":1}}],[\"关键因素之一\",{\"1\":{\"810\":1}}],[\"关键点6\",{\"1\":{\"760\":1}}],[\"关键点5\",{\"1\":{\"760\":1}}],[\"关键点4\",{\"1\":{\"760\":1}}],[\"关键点3\",{\"1\":{\"760\":1}}],[\"关键点2\",{\"1\":{\"760\":1}}],[\"关键点1\",{\"1\":{\"760\":1}}],[\"关键字后指定用户的密码\",{\"1\":{\"838\":1}}],[\"关键字后指定帐户名称\",{\"1\":{\"838\":1}}],[\"关键字大写\",{\"1\":{\"829\":1}}],[\"关键字不区分大小写\",{\"1\":{\"829\":1}}],[\"关键字时会发生什么\",{\"1\":{\"473\":1}}],[\"关键字出现时将被重置为\",{\"1\":{\"442\":1}}],[\"关键字\",{\"0\":{\"568\":1},\"1\":{\"214\":1,\"568\":1,\"952\":1}}],[\"关键词\",{\"0\":{\"79\":1}}],[\"关机\",{\"1\":{\"204\":1}}],[\"关机重启命令\",{\"0\":{\"204\":1}}],[\"关于定制开发的日志包设计思路这里就不讲解了\",{\"1\":{\"957\":1}}],[\"关于\",{\"0\":{\"0\":1},\"1\":{\"512\":1,\"957\":1}}],[\"地址不要写\",{\"1\":{\"1026\":1}}],[\"地址的服务器上\",{\"1\":{\"249\":1}}],[\"地址的设置等\",{\"1\":{\"226\":1}}],[\"地址栏就会显示出对应的\",{\"1\":{\"249\":1}}],[\"地址或者域名的形式\",{\"1\":{\"249\":1}}],[\"地址或者会话\",{\"1\":{\"77\":1}}],[\"地址空间通常分为两部分\",{\"1\":{\"217\":1}}],[\"地址结构就由段号\",{\"1\":{\"217\":1}}],[\"地址与外界通信\",{\"1\":{\"124\":1}}],[\"地址\",{\"1\":{\"121\":1,\"122\":1,\"836\":1}}],[\"地址一样\",{\"1\":{\"30\":1}}],[\"完全依赖过期时间\",{\"1\":{\"930\":1}}],[\"完全可靠是不可能的\",{\"1\":{\"918\":1,\"921\":1}}],[\"完全取代\",{\"1\":{\"879\":1}}],[\"完全匹配请求路径\",{\"1\":{\"587\":1,\"655\":1}}],[\"完全二叉树\",{\"0\":{\"61\":1}}],[\"完之后\",{\"1\":{\"525\":1}}],[\"完成的\",{\"1\":{\"817\":1}}],[\"完成最后的引擎提交\",{\"1\":{\"810\":2}}],[\"完成了\",{\"1\":{\"810\":1}}],[\"完成了更新操作\",{\"1\":{\"524\":1}}],[\"完成刷盘\",{\"1\":{\"810\":1}}],[\"完成后通知队内其他事务操作结束\",{\"1\":{\"810\":1}}],[\"完成后\",{\"1\":{\"737\":1,\"810\":1}}],[\"完成\",{\"1\":{\"515\":1,\"817\":1}}],[\"完成映射的工作\",{\"1\":{\"217\":1}}],[\"完整的具体加载流程\",{\"1\":{\"949\":1}}],[\"完整的软件包\",{\"1\":{\"220\":1}}],[\"完整配置\",{\"1\":{\"586\":1,\"654\":1}}],[\"完整\",{\"1\":{\"76\":1}}],[\"正如\",{\"1\":{\"867\":1}}],[\"正如c语言中所讲\",{\"1\":{\"36\":1}}],[\"正式执行\",{\"1\":{\"817\":1}}],[\"正好向用户表中插入了一条\",{\"1\":{\"780\":1}}],[\"正常关闭是不会丢失数据的\",{\"1\":{\"952\":1}}],[\"正常关闭程序\",{\"1\":{\"952\":1}}],[\"正常关闭时\",{\"1\":{\"756\":1,\"810\":1}}],[\"正常业务错误\",{\"1\":{\"927\":1}}],[\"正常情况下\",{\"1\":{\"807\":1}}],[\"正常的\",{\"1\":{\"523\":1}}],[\"正常值\",{\"1\":{\"523\":1}}],[\"正在等着别人接收\",{\"1\":{\"265\":1}}],[\"正向代理\",{\"1\":{\"240\":2,\"249\":1}}],[\"正确的列顺序可以最大化索引的效率\",{\"1\":{\"807\":1}}],[\"正确示例\",{\"1\":{\"689\":1}}],[\"正确\",{\"1\":{\"76\":1}}],[\"等封装\",{\"1\":{\"962\":1}}],[\"等包级别的开放函数\",{\"1\":{\"957\":1}}],[\"等价于\",{\"1\":{\"1026\":1}}],[\"等价于sql语句中的where\",{\"1\":{\"1001\":1}}],[\"等价\",{\"1\":{\"957\":1}}],[\"等其他日志库来的方便\",{\"1\":{\"957\":1}}],[\"等0点一到就是海量的请求\",{\"1\":{\"927\":1}}],[\"等达到这个时间\",{\"1\":{\"882\":1}}],[\"等特殊字符\",{\"1\":{\"838\":1}}],[\"等号与值之间有空格\",{\"1\":{\"836\":1}}],[\"等值查询\",{\"1\":{\"820\":2}}],[\"等插入语句执行完成后\",{\"1\":{\"820\":1}}],[\"等到客户端在发起下一个请求的时候\",{\"1\":{\"817\":1}}],[\"等多个存储引擎\",{\"1\":{\"817\":1}}],[\"等搜索引擎\",{\"1\":{\"813\":1}}],[\"等之类的\",{\"1\":{\"813\":1}}],[\"等之后事务提交的时候\",{\"1\":{\"737\":1,\"759\":1,\"810\":1}}],[\"等引擎\",{\"1\":{\"813\":1}}],[\"等擦除完旧记录腾出了空间\",{\"1\":{\"810\":1}}],[\"等语句\",{\"1\":{\"783\":1,\"820\":1}}],[\"等变长字段也是这么实现的\",{\"1\":{\"770\":1}}],[\"等方法实现\",{\"1\":{\"957\":1}}],[\"等方法\",{\"1\":{\"661\":1}}],[\"等用户登录后再添加到在线用户列表\",{\"1\":{\"641\":1}}],[\"等已有头\",{\"1\":{\"249\":1}}],[\"等待下一次事件到来之前\",{\"1\":{\"952\":1}}],[\"等待下次访问再加载回来\",{\"1\":{\"930\":1}}],[\"等待缓存过期失效\",{\"1\":{\"930\":1}}],[\"等待leader节点的确认\",{\"1\":{\"710\":1}}],[\"等待所有\",{\"1\":{\"515\":1}}],[\"等待部分写操作完成\",{\"1\":{\"515\":1}}],[\"等待条件满足之后\",{\"1\":{\"265\":1}}],[\"等待被唤醒\",{\"1\":{\"264\":1}}],[\"等待数据\",{\"1\":{\"226\":1}}],[\"等待接收客户端连接\",{\"1\":{\"226\":1}}],[\"等待客户端链接\",{\"1\":{\"226\":1}}],[\"等\",{\"1\":{\"122\":3,\"249\":1,\"723\":1,\"734\":1,\"846\":2}}],[\"等所有文件快下载完成后\",{\"1\":{\"76\":1}}],[\"等第二次请求达到服务端的时候\",{\"1\":{\"23\":1}}],[\"从请求中获取文件头\",{\"1\":{\"1037\":1}}],[\"从post请求中获取表单字段\",{\"1\":{\"1037\":2}}],[\"从节点崩溃就算主节点正常关闭也会丢失数据\",{\"1\":{\"952\":1}}],[\"从节点会基于\",{\"1\":{\"807\":1}}],[\"从解耦层面来看\",{\"1\":{\"930\":1}}],[\"从缓存取不到的数据\",{\"1\":{\"930\":1}}],[\"从数据库查询\",{\"1\":{\"930\":1}}],[\"从服务角度来看\",{\"1\":{\"930\":1}}],[\"从有过期时间的\",{\"1\":{\"906\":1}}],[\"从所有\",{\"1\":{\"906\":1}}],[\"从套接字中读取请求\",{\"1\":{\"888\":1}}],[\"从投入产生来看\",{\"1\":{\"888\":1}}],[\"从后往前依次查找\",{\"1\":{\"879\":1}}],[\"从后往前依次查找每一个字节\",{\"1\":{\"879\":1}}],[\"从静默状态\",{\"1\":{\"864\":1}}],[\"从上图可以看到\",{\"1\":{\"820\":2}}],[\"从上面了解到\",{\"1\":{\"940\":1}}],[\"从上面的过程\",{\"1\":{\"810\":1}}],[\"从上面的实验可以看出\",{\"1\":{\"770\":1}}],[\"从上面这个过程\",{\"1\":{\"810\":1}}],[\"从上面内容可以看出\",{\"1\":{\"770\":1}}],[\"从上面可以知道\",{\"1\":{\"519\":1}}],[\"从存储引擎读取记录\",{\"1\":{\"817\":1}}],[\"从mysql整体架构而言\",{\"1\":{\"813\":1}}],[\"从内存读取一个页的成本\",{\"1\":{\"813\":1}}],[\"从执行计划的结果看\",{\"1\":{\"813\":1}}],[\"从图中你能看到\",{\"1\":{\"813\":1}}],[\"从图中可看出\",{\"1\":{\"810\":1}}],[\"从千万的数据里查询一条数据\",{\"1\":{\"813\":1}}],[\"从业务设计层面减少大量数据返回的情况\",{\"1\":{\"807\":1}}],[\"从char和varchar的存储结构对比\",{\"1\":{\"770\":1}}],[\"从输出中可以看到大量重复的e6\",{\"1\":{\"770\":1}}],[\"从报错信息就可以知道一行数据的最大字节数是\",{\"1\":{\"770\":1}}],[\"从这里开始\",{\"1\":{\"1015\":1}}],[\"从这里可以知道\",{\"1\":{\"770\":2}}],[\"从这个实验可以得知\",{\"1\":{\"820\":1}}],[\"从这个队列里取出来唤醒\",{\"1\":{\"265\":1}}],[\"从下图可以看到\",{\"1\":{\"820\":2}}],[\"从下图你可以看到\",{\"1\":{\"249\":1}}],[\"从下往上看\",{\"1\":{\"770\":1}}],[\"从头开始写\",{\"1\":{\"757\":1,\"810\":1}}],[\"从理解\",{\"1\":{\"733\":1}}],[\"从库的自增值就是什么\",{\"1\":{\"820\":1}}],[\"从库的这一行\",{\"1\":{\"763\":1,\"810\":1}}],[\"从库上\",{\"1\":{\"820\":1}}],[\"从库连接上来的\",{\"1\":{\"810\":1}}],[\"从库连接到主库后\",{\"1\":{\"730\":1,\"761\":1}}],[\"从库是不是越多越好\",{\"1\":{\"810\":1}}],[\"从库会创建一个用于回放\",{\"1\":{\"810\":1}}],[\"从库会创建一个专门的\",{\"1\":{\"810\":1}}],[\"从库执行了这条更新语句\",{\"1\":{\"763\":1,\"810\":1}}],[\"从库启动一个\",{\"1\":{\"730\":1,\"761\":1}}],[\"从库\",{\"1\":{\"730\":1,\"820\":1}}],[\"从在线用户列表中移除\",{\"1\":{\"641\":1}}],[\"从磁盘读取一个页的成本\",{\"1\":{\"813\":1}}],[\"从磁盘活化\",{\"1\":{\"638\":1}}],[\"从磁盘反序列化\",{\"1\":{\"638\":1}}],[\"从变量是否有默认值来看\",{\"1\":{\"571\":1}}],[\"从变量在内存中的生存时间上看\",{\"1\":{\"571\":1}}],[\"从变量在内存中的存储方式来看\",{\"1\":{\"571\":1}}],[\"从汇编代码可以看出\",{\"1\":{\"423\":1}}],[\"从客户端的密码套件列表选择了一个合适的密码套件\",{\"1\":{\"249\":1}}],[\"从密码套件列表中选择一个密码套件\",{\"1\":{\"249\":1}}],[\"从低地址开始向上增长\",{\"1\":{\"217\":2}}],[\"从高地址往低地址增长\",{\"1\":{\"217\":1}}],[\"从leader副本复制数据\",{\"1\":{\"174\":1,\"180\":1}}],[\"从\",{\"1\":{\"173\":1,\"767\":1,\"770\":3,\"810\":2,\"813\":1,\"817\":1,\"876\":1,\"879\":1}}],[\"从容器内拷贝文件到主机\",{\"0\":{\"150\":1}}],[\"从最后再取\",{\"1\":{\"75\":1}}],[\"从中间取\",{\"1\":{\"75\":1}}],[\"从而可以在不需要任何其他信息的情况下对其进行验证\",{\"1\":{\"1056\":1}}],[\"从而可以找到剩余数据所在的页\",{\"1\":{\"770\":1}}],[\"从而增加破译的难度\",{\"1\":{\"1051\":1}}],[\"从而避免幻读现象\",{\"1\":{\"820\":1}}],[\"从而降低磁盘\",{\"1\":{\"810\":1}}],[\"从而提升了性能\",{\"1\":{\"813\":1}}],[\"从而提升效率\",{\"1\":{\"810\":1}}],[\"从而提高写入速度\",{\"1\":{\"754\":1}}],[\"从而提高读写操作的性能和一致性\",{\"1\":{\"743\":1}}],[\"从而影响并发性能\",{\"1\":{\"807\":1}}],[\"从而减少了锁的数量\",{\"1\":{\"820\":1}}],[\"从而减少了延迟\",{\"1\":{\"175\":1}}],[\"从而减少回表次数\",{\"1\":{\"813\":1}}],[\"从而减少\",{\"1\":{\"810\":1}}],[\"从而减少磁盘\",{\"1\":{\"767\":1,\"810\":1}}],[\"从而保证插入数据时\",{\"1\":{\"820\":1}}],[\"从而保证多事务的情况下\",{\"1\":{\"766\":1,\"810\":1}}],[\"从而保证消息的有序性\",{\"1\":{\"723\":1}}],[\"从而控制并发事务访问同一个记录时的行为\",{\"1\":{\"743\":1,\"810\":1}}],[\"从而引发逻辑错误\",{\"1\":{\"719\":1}}],[\"从而在某些情况下掩盖数据竞争的问题\",{\"1\":{\"511\":1}}],[\"从而在销毁时对同一内存进行多次释放\",{\"1\":{\"33\":1}}],[\"从而改变\",{\"1\":{\"511\":1}}],[\"从而实现类似于继承中方法的覆盖\",{\"1\":{\"464\":1}}],[\"从而造成内存泄漏\",{\"1\":{\"33\":1}}],[\"从而形成环的情况\",{\"1\":{\"33\":1}}],[\"从而确保幂等性操作\",{\"1\":{\"23\":1}}],[\"且数据有可能变化\",{\"1\":{\"930\":1}}],[\"且过期时间设置较长\",{\"1\":{\"930\":1}}],[\"且元素数量不超过\",{\"1\":{\"870\":1}}],[\"且元素包含指针类型\",{\"1\":{\"263\":1}}],[\"且\",{\"1\":{\"864\":1}}],[\"且锁类型为\",{\"1\":{\"820\":1}}],[\"且功能相同\",{\"1\":{\"820\":1}}],[\"且是默认使用\",{\"1\":{\"817\":1}}],[\"且位置发生了变更\",{\"1\":{\"813\":1}}],[\"且按顺序\",{\"1\":{\"448\":1}}],[\"且应用广泛\",{\"1\":{\"190\":1}}],[\"且实际开发中要权衡加密算法的破解难度和计算时间来选择合适算法\",{\"1\":{\"74\":1}}],[\"且会有碎片\",{\"1\":{\"33\":1}}],[\"越来越多数据无法在\",{\"1\":{\"864\":1}}],[\"越难破解的加密算法\",{\"1\":{\"74\":1}}],[\"越复杂\",{\"1\":{\"74\":1}}],[\"鸽巢原理\",{\"0\":{\"74\":1}}],[\"很明显\",{\"1\":{\"952\":1}}],[\"很少有真正需要去人肉读aof数据的情况\",{\"1\":{\"949\":1}}],[\"很容易造成大量的恶意请求\",{\"1\":{\"927\":1}}],[\"很显然这条查询语句是覆盖索引\",{\"1\":{\"817\":1}}],[\"很好\",{\"1\":{\"813\":1}}],[\"很好理解\",{\"1\":{\"156\":1}}],[\"很高的现象\",{\"1\":{\"810\":1}}],[\"很高\",{\"1\":{\"810\":1}}],[\"很难追踪\",{\"1\":{\"243\":1}}],[\"很难逆推原始数据\",{\"1\":{\"72\":1}}],[\"很多时候是被低估了\",{\"1\":{\"927\":1}}],[\"很多时会很大\",{\"1\":{\"226\":2}}],[\"很多业务请求量都达到了一个曾经难以现象的高度\",{\"1\":{\"897\":1}}],[\"很多次没有挡住请求\",{\"1\":{\"518\":1}}],[\"很多场景会用到这个转化\",{\"1\":{\"360\":1}}],[\"很多情况下\",{\"1\":{\"249\":1}}],[\"很多http\",{\"1\":{\"23\":1}}],[\"树快速定位到这条记录后\",{\"1\":{\"817\":1}}],[\"树结构定位到\",{\"1\":{\"817\":1}}],[\"树这样的索引结构中进行\",{\"1\":{\"813\":1}}],[\"树会自平衡\",{\"1\":{\"813\":1}}],[\"树没有冗余节点\",{\"1\":{\"813\":1}}],[\"树则不同\",{\"1\":{\"813\":1}}],[\"树在删除根节点的时候\",{\"1\":{\"813\":1}}],[\"树根节点的过程\",{\"1\":{\"813\":2}}],[\"树形结构变化很小\",{\"1\":{\"813\":1}}],[\"树有大量的冗余节点\",{\"1\":{\"813\":1}}],[\"树更加矮胖\",{\"1\":{\"813\":1}}],[\"树单个索引查询最快是\",{\"1\":{\"813\":1}}],[\"树矮\",{\"1\":{\"813\":1}}],[\"树索引\",{\"1\":{\"813\":1,\"817\":1}}],[\"树的成本会比查询二级索引的\",{\"1\":{\"817\":1}}],[\"树的叶子节点的数据存储的是主键值\",{\"1\":{\"817\":1}}],[\"树的叶子节点的区的集合\",{\"1\":{\"770\":1}}],[\"树的插入也是一样\",{\"1\":{\"813\":1}}],[\"树的插入和删除效率高\",{\"1\":{\"813\":1}}],[\"树的查询波动大\",{\"1\":{\"813\":1}}],[\"树的非叶子节点的区的集合\",{\"1\":{\"770\":1}}],[\"树中每一层都是通过双向链表连接起来的\",{\"1\":{\"770\":1}}],[\"树来组织数据的\",{\"1\":{\"770\":2}}],[\"树\",{\"1\":{\"770\":1,\"813\":3},\"2\":{\"67\":1}}],[\"左边界\",{\"1\":{\"820\":1}}],[\"左右模糊匹配会导致索引失效\",{\"1\":{\"813\":1}}],[\"左右模糊匹配\",{\"1\":{\"813\":1}}],[\"左右两边都是独立索引才能走索引\",{\"1\":{\"813\":1}}],[\"左子树所有节点的值小于根节点\",{\"1\":{\"62\":1}}],[\"左小右大\",{\"1\":{\"62\":1}}],[\"优势\",{\"1\":{\"813\":1}}],[\"优雅处理字符串格式的数字\",{\"0\":{\"491\":1}}],[\"优雅解决资源回收问题\",{\"1\":{\"474\":1}}],[\"优缺点\",{\"1\":{\"226\":1}}],[\"优化阶段\",{\"1\":{\"817\":1}}],[\"优化mysql架构提高可用性\",{\"1\":{\"807\":1}}],[\"优化机制\",{\"0\":{\"804\":1}}],[\"优化查询\",{\"1\":{\"734\":1}}],[\"优化器基于查询成本的考虑\",{\"1\":{\"817\":1}}],[\"优化器主要负责将\",{\"1\":{\"817\":1}}],[\"优化器阶段\",{\"1\":{\"817\":1}}],[\"优化器认为从磁盘读取的开销是内存开销的\",{\"1\":{\"813\":1}}],[\"优化器决定了具体的索引选择\",{\"1\":{\"813\":1}}],[\"优化器\",{\"1\":{\"813\":1,\"817\":2}}],[\"优化器会基于查询成本的考虑\",{\"1\":{\"817\":1}}],[\"优化器会帮我们调整字段的查询顺序\",{\"1\":{\"813\":1}}],[\"优化器会生成多个执行计划\",{\"1\":{\"734\":1}}],[\"优化器确定执行计划\",{\"1\":{\"810\":1}}],[\"优化器可能会对解析树进行重写\",{\"1\":{\"734\":1}}],[\"优化的先删后写场景和无锁完成删操作\",{\"1\":{\"526\":1}}],[\"优化选项\",{\"0\":{\"397\":1}}],[\"优化\",{\"0\":{\"185\":1},\"1\":{\"807\":4,\"813\":3,\"879\":1}}],[\"优先淘汰活跃最低\",{\"1\":{\"903\":1}}],[\"优先使用哪个\",{\"1\":{\"813\":1}}],[\"优先保持当前的分配状态\",{\"1\":{\"165\":1}}],[\"优先队列\",{\"2\":{\"57\":1}}],[\"优点是空间\",{\"1\":{\"930\":1}}],[\"优点在于节约了内存\",{\"1\":{\"906\":1}}],[\"优点\",{\"1\":{\"36\":1,\"552\":1,\"813\":1,\"930\":4}}],[\"麻烦\",{\"0\":{\"54\":1},\"1\":{\"813\":1}}],[\"麻烦死了\",{\"1\":{\"30\":1}}],[\"再请求这个接口唤起浏览器下载\",{\"1\":{\"1032\":1}}],[\"再给李四+100\",{\"1\":{\"1014\":1,\"1015\":1}}],[\"再用新aof文件替换原来的aof文件\",{\"1\":{\"952\":1}}],[\"再用会话密钥\",{\"1\":{\"249\":1}}],[\"再将重写缓冲区的内容追加到新的aof文件\",{\"1\":{\"949\":1}}],[\"再将缓存在\",{\"1\":{\"810\":1}}],[\"再更新到redis\",{\"1\":{\"930\":1}}],[\"再从mysql拉取缓存\",{\"1\":{\"930\":1}}],[\"再同步写入redis\",{\"1\":{\"930\":1}}],[\"再详细一点\",{\"1\":{\"897\":1}}],[\"再封装了一层\",{\"1\":{\"864\":1}}],[\"再判断该记录的\",{\"1\":{\"817\":1}}],[\"再返还给\",{\"1\":{\"813\":1}}],[\"再返回给主库\",{\"1\":{\"810\":1}}],[\"再去删除缓存\",{\"1\":{\"930\":1}}],[\"再去通知对应的事件\",{\"1\":{\"888\":1}}],[\"再去聚集索引\",{\"1\":{\"813\":1}}],[\"再去取出这个地址的值\",{\"1\":{\"217\":1}}],[\"再看\",{\"1\":{\"810\":1}}],[\"再看到左边的页目录\",{\"1\":{\"748\":1}}],[\"再提交事务\",{\"1\":{\"810\":1}}],[\"再执行第\",{\"1\":{\"930\":1}}],[\"再执行修改\",{\"1\":{\"873\":1}}],[\"再执行\",{\"1\":{\"794\":1}}],[\"再执行上述的omitemptydemo\",{\"1\":{\"488\":1}}],[\"再使用普通\",{\"1\":{\"793\":1}}],[\"再向producer发送确认\",{\"1\":{\"710\":1}}],[\"再\",{\"1\":{\"446\":1,\"897\":1}}],[\"再回想八股\",{\"1\":{\"374\":1}}],[\"再把根据我们要的的数据进行\",{\"1\":{\"823\":1}}],[\"再把\",{\"1\":{\"374\":1,\"760\":1,\"810\":2}}],[\"再转化回字符串\",{\"1\":{\"356\":1}}],[\"再存连续的8个value\",{\"1\":{\"330\":1}}],[\"再为buf数组元素分配内存\",{\"1\":{\"263\":1}}],[\"再读取就会阻塞\",{\"1\":{\"256\":1}}],[\"再写入新的数据就会阻塞\",{\"1\":{\"256\":1}}],[\"再试试私钥加密\",{\"1\":{\"249\":1}}],[\"再划分固定大小的页\",{\"1\":{\"217\":1}}],[\"再平衡过程\",{\"1\":{\"165\":1}}],[\"再平衡策略\",{\"0\":{\"165\":1}}],[\"再通过delete解锁\",{\"1\":{\"910\":1,\"921\":1}}],[\"再通过页里的\",{\"1\":{\"810\":1}}],[\"再通过页的页目录去定位到某条具体的记录\",{\"1\":{\"748\":1}}],[\"再通过\",{\"1\":{\"226\":1,\"810\":1}}],[\"再通过特定的机制将每台机器统计出来的结果进行合并汇总\",{\"1\":{\"79\":1}}],[\"再通过swim\",{\"1\":{\"52\":1}}],[\"再次使用hexdump命令查看文件中的数据\",{\"1\":{\"770\":1}}],[\"再次用hexdump命令查看\",{\"1\":{\"770\":1}}],[\"再次尝试从\",{\"1\":{\"529\":1}}],[\"再次向服务端发送请求\",{\"1\":{\"23\":1}}],[\"再次点击支付按钮\",{\"1\":{\"23\":1}}],[\"插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录\",{\"1\":{\"820\":1}}],[\"插入新记录的事务会给已存在的主键值重复的聚簇索引记录\",{\"1\":{\"820\":2}}],[\"插入新元素\",{\"1\":{\"52\":1}}],[\"插入操作就会发生\",{\"1\":{\"820\":1}}],[\"插入意向锁的生成时机\",{\"1\":{\"820\":1}}],[\"插入意向锁是一种特殊的间隙锁\",{\"1\":{\"820\":1}}],[\"插入意向锁是什么\",{\"1\":{\"820\":1}}],[\"插入意向锁如果不在间隙锁区间内则是可以的\",{\"1\":{\"820\":2}}],[\"插入意向锁与间隙锁的另一个非常重要的差别是\",{\"1\":{\"820\":2}}],[\"插入意向锁确实是一种特殊的间隙锁\",{\"1\":{\"820\":2}}],[\"插入意向锁名字虽然有意向锁\",{\"1\":{\"820\":2}}],[\"插入意向锁\",{\"1\":{\"820\":6}}],[\"插入两条记录\",{\"1\":{\"820\":1}}],[\"插入了一条\",{\"1\":{\"820\":1}}],[\"插入了一个与\",{\"1\":{\"820\":1}}],[\"插入了一个记录\",{\"1\":{\"820\":1}}],[\"插入了\",{\"1\":{\"820\":2}}],[\"插入数据会导致很多内存复制\",{\"1\":{\"867\":1}}],[\"插入数据\",{\"1\":{\"813\":1}}],[\"插入可能存在节点的分裂\",{\"1\":{\"813\":1}}],[\"插入缓存\",{\"1\":{\"810\":1}}],[\"插入的\",{\"1\":{\"820\":1}}],[\"插入的纪录了\",{\"1\":{\"793\":1}}],[\"插入的第1条中文\",{\"1\":{\"770\":1}}],[\"插入一条记录\",{\"1\":{\"820\":1}}],[\"插入一条\",{\"1\":{\"793\":1}}],[\"插入2条中文\",{\"1\":{\"770\":1}}],[\"插入\",{\"1\":{\"741\":1,\"810\":2,\"813\":2,\"885\":1}}],[\"插件式存储引擎\",{\"1\":{\"817\":1}}],[\"插件\",{\"0\":{\"1\":1,\"2\":1},\"2\":{\"15\":1,\"481\":1}}],[\"能查询到的记录才能删除\",{\"1\":{\"996\":1}}],[\"能解决大部分场景\",{\"1\":{\"903\":1}}],[\"能存多少数据\",{\"1\":{\"900\":1}}],[\"能存放千万到上亿的排序数据\",{\"1\":{\"813\":1}}],[\"能并发处理大量的客户端请求\",{\"1\":{\"888\":1}}],[\"能达到每秒数万级别的处理能力\",{\"1\":{\"888\":1}}],[\"能节约内存\",{\"1\":{\"879\":1}}],[\"能加快处理性能\",{\"1\":{\"867\":1}}],[\"能加快排序时间\",{\"1\":{\"813\":1}}],[\"能保证全局\",{\"1\":{\"813\":1}}],[\"能与其他索引比较拼音大小\",{\"1\":{\"813\":1}}],[\"能索引\",{\"1\":{\"813\":2}}],[\"能走索引\",{\"1\":{\"813\":2}}],[\"能走索索引\",{\"1\":{\"813\":1}}],[\"能在联合索引\",{\"1\":{\"813\":1}}],[\"能在非叶子节点中直接获取数据\",{\"1\":{\"813\":1}}],[\"能在重启后根据\",{\"1\":{\"752\":1}}],[\"能使用\",{\"1\":{\"810\":1}}],[\"能力\",{\"1\":{\"810\":1}}],[\"能力的\",{\"1\":{\"810\":1}}],[\"能将\",{\"1\":{\"763\":1,\"810\":1}}],[\"能提高数据库的写性能\",{\"1\":{\"754\":1}}],[\"能直接在\",{\"1\":{\"524\":1}}],[\"能不能\",{\"1\":{\"520\":1}}],[\"能不能通过定义一种消息格式\",{\"1\":{\"229\":1}}],[\"能通过\",{\"1\":{\"519\":1}}],[\"能够减少我们编写的代码量\",{\"1\":{\"957\":1}}],[\"能够保证\",{\"1\":{\"810\":1}}],[\"能够保证数据的一致性和完整性\",{\"1\":{\"773\":1}}],[\"能够工作\",{\"1\":{\"373\":1}}],[\"能够使不同域名配置在同一个\",{\"1\":{\"249\":1}}],[\"能被正确的关闭\",{\"1\":{\"237\":1}}],[\"能打开的fd的上限远大于1024\",{\"1\":{\"226\":1}}],[\"能动态排序的数据结构主要有两种\",{\"1\":{\"50\":1}}],[\"能切换多种主题\",{\"1\":{\"5\":1}}],[\"染色法\",{\"2\":{\"48\":1}}],[\"lvl\",{\"1\":{\"957\":3}}],[\"llc\",{\"1\":{\"930\":1}}],[\"llen\",{\"1\":{\"867\":1}}],[\"lua\",{\"0\":{\"913\":1},\"1\":{\"913\":1,\"921\":2}}],[\"ldt\",{\"1\":{\"903\":1}}],[\"lfu内存淘汰算法详解\",{\"0\":{\"903\":1}}],[\"lfu\",{\"1\":{\"900\":3,\"903\":7,\"940\":2},\"2\":{\"905\":1}}],[\"lft\",{\"1\":{\"121\":2}}],[\"lrulock\",{\"1\":{\"906\":2}}],[\"lru内存淘汰算法详解\",{\"0\":{\"906\":1}}],[\"lru\",{\"1\":{\"900\":3,\"903\":4,\"906\":19,\"940\":6},\"2\":{\"908\":1}}],[\"lrange\",{\"1\":{\"867\":1}}],[\"lrem\",{\"1\":{\"867\":1}}],[\"lpop\",{\"1\":{\"867\":1,\"924\":2}}],[\"lpush\",{\"1\":{\"867\":1}}],[\"layout项目中对proto文件进行了版本划分\",{\"1\":{\"969\":1}}],[\"layout作为项目模板\",{\"1\":{\"961\":1}}],[\"later\",{\"1\":{\"944\":1}}],[\"latest\",{\"1\":{\"136\":1,\"229\":1,\"968\":1}}],[\"lang\",{\"1\":{\"553\":1,\"559\":3}}],[\"language\",{\"1\":{\"249\":2}}],[\"last\",{\"1\":{\"249\":2,\"903\":1,\"988\":1}}],[\"ln\",{\"1\":{\"209\":2}}],[\"lstdflags\",{\"1\":{\"980\":1}}],[\"lsof\",{\"1\":{\"197\":1}}],[\"ls\",{\"1\":{\"108\":1,\"201\":1,\"211\":1,\"770\":1}}],[\"lost\",{\"1\":{\"817\":1}}],[\"longtext\",{\"1\":{\"979\":2}}],[\"long\",{\"1\":{\"584\":2,\"600\":3,\"626\":4,\"637\":1,\"638\":1,\"944\":3}}],[\"loc=local\",{\"1\":{\"976\":1}}],[\"locked\",{\"1\":{\"843\":3}}],[\"locks\",{\"1\":{\"820\":9}}],[\"lock\",{\"1\":{\"265\":7,\"374\":2,\"529\":1,\"531\":1,\"532\":1,\"783\":3,\"820\":79,\"843\":2,\"897\":1}}],[\"locator\",{\"1\":{\"249\":1}}],[\"localstate\",{\"1\":{\"689\":1}}],[\"local\",{\"1\":{\"223\":8}}],[\"localhost\",{\"1\":{\"125\":1,\"659\":1,\"839\":1,\"840\":4,\"1021\":1}}],[\"locahost\",{\"1\":{\"177\":1}}],[\"loadhtmlfiles\",{\"1\":{\"1031\":1}}],[\"loadhtmlglob\",{\"1\":{\"1031\":1}}],[\"loadonstartup\",{\"1\":{\"654\":1}}],[\"loaded\",{\"1\":{\"531\":4,\"966\":1}}],[\"loadreadonly\",{\"1\":{\"529\":2,\"531\":2,\"532\":2}}],[\"load\",{\"0\":{\"529\":1},\"1\":{\"265\":1,\"514\":1,\"515\":1,\"529\":4,\"531\":1,\"532\":1,\"1031\":1}}],[\"loaduint\",{\"1\":{\"265\":1}}],[\"lookaside\",{\"1\":{\"217\":2}}],[\"lo\",{\"1\":{\"125\":1,\"126\":1}}],[\"logframework\",{\"0\":{\"1082\":1}}],[\"logfile1\",{\"1\":{\"757\":3,\"810\":3}}],[\"logfile0\",{\"1\":{\"757\":4,\"810\":4}}],[\"logfilter\",{\"1\":{\"683\":1}}],[\"logmode\",{\"1\":{\"980\":1}}],[\"logrus\",{\"1\":{\"956\":1,\"957\":3}}],[\"log这种wal技术了\",{\"1\":{\"927\":1}}],[\"logistic\",{\"1\":{\"903\":1}}],[\"login\",{\"1\":{\"587\":2,\"598\":3}}],[\"logc\",{\"1\":{\"903\":1}}],[\"log中标记为prepare状态的事务\",{\"1\":{\"810\":1}}],[\"log文件\",{\"1\":{\"810\":2}}],[\"log文件意味着写入到了操作系统的文件缓存\",{\"1\":{\"756\":1}}],[\"logger\",{\"1\":{\"600\":5,\"957\":54,\"980\":8,\"988\":1}}],[\"logging\",{\"1\":{\"751\":1,\"810\":1}}],[\"loggingfilter<\",{\"1\":{\"588\":1}}],[\"loggingfilter\",{\"1\":{\"584\":3,\"586\":1,\"590\":1,\"592\":1,\"596\":6}}],[\"logginghandler\",{\"1\":{\"559\":3}}],[\"loglevel\",{\"1\":{\"586\":1,\"590\":3,\"980\":1}}],[\"logn\",{\"1\":{\"226\":1}}],[\"logout\",{\"1\":{\"205\":1}}],[\"logs\",{\"1\":{\"146\":1,\"817\":1}}],[\"log\",{\"1\":{\"104\":1,\"223\":3,\"730\":1,\"751\":3,\"752\":1,\"753\":4,\"754\":1,\"755\":8,\"756\":17,\"757\":1,\"761\":1,\"763\":5,\"765\":6,\"766\":1,\"775\":2,\"802\":2,\"810\":214,\"927\":1,\"957\":51,\"980\":2,\"988\":1},\"2\":{\"769\":2,\"812\":2}}],[\"lowercaselevelencoder\",{\"1\":{\"957\":2}}],[\"low\",{\"1\":{\"46\":5}}],[\"l\",{\"1\":{\"104\":1,\"201\":1,\"392\":1,\"398\":1,\"957\":1}}],[\"lisi\",{\"1\":{\"1014\":5,\"1015\":5}}],[\"listpack\",{\"1\":{\"867\":1,\"879\":8}}],[\"list类型详解\",{\"0\":{\"867\":1}}],[\"list<product>\",{\"1\":{\"638\":1}}],[\"listenandserve\",{\"1\":{\"1021\":1}}],[\"listening\",{\"1\":{\"966\":2}}],[\"listener生命周期\",{\"0\":{\"628\":1}}],[\"listener>\",{\"1\":{\"627\":3}}],[\"listener的分类\",{\"0\":{\"618\":1}}],[\"listener的作用\",{\"0\":{\"615\":1}}],[\"listener快速入门\",{\"0\":{\"616\":1}}],[\"listener在web应用中主要用于以下场景\",{\"1\":{\"615\":1}}],[\"listener具有以下特点\",{\"1\":{\"614\":1}}],[\"listener\",{\"0\":{\"684\":1},\"1\":{\"614\":1,\"624\":1,\"625\":1,\"626\":1,\"627\":6,\"633\":1,\"634\":1,\"635\":1,\"637\":1,\"638\":1},\"2\":{\"643\":1}}],[\"listener概述\",{\"0\":{\"613\":1}}],[\"listener是java\",{\"1\":{\"612\":1}}],[\"listener监听器的核心概念\",{\"1\":{\"612\":1}}],[\"listener学习笔记\",{\"0\":{\"612\":1}}],[\"listenfd\",{\"1\":{\"226\":5}}],[\"listen\",{\"1\":{\"226\":2,\"888\":1}}],[\"list\",{\"1\":{\"3\":1,\"201\":1,\"226\":1,\"265\":1,\"465\":6,\"655\":1,\"867\":5,\"876\":1,\"879\":5,\"897\":1,\"924\":4,\"937\":1,\"944\":1},\"2\":{\"869\":1}}],[\"license\",{\"1\":{\"962\":1}}],[\"limit\",{\"1\":{\"829\":1,\"988\":3,\"990\":1,\"1008\":5}}],[\"like\",{\"1\":{\"770\":2,\"807\":2,\"813\":7,\"817\":2,\"829\":1,\"1001\":3,\"1005\":1}}],[\"lifecycleservlet\",{\"1\":{\"662\":1}}],[\"lived\",{\"1\":{\"249\":1}}],[\"lineending\",{\"1\":{\"957\":3}}],[\"line\",{\"1\":{\"541\":3,\"542\":3,\"770\":1}}],[\"linda\",{\"1\":{\"249\":3}}],[\"linkedlist\",{\"1\":{\"867\":7,\"879\":1}}],[\"link\",{\"1\":{\"121\":1}}],[\"linux系统\",{\"0\":{\"835\":1}}],[\"linux一般可以开启的端口为\",{\"1\":{\"237\":1}}],[\"linux默认64\",{\"1\":{\"237\":1}}],[\"linux默认\",{\"1\":{\"237\":1}}],[\"linux的五种io模型\",{\"1\":{\"226\":1}}],[\"linux网络编程详解\",{\"0\":{\"226\":1}}],[\"linux不按后缀识别文件类型\",{\"1\":{\"223\":1}}],[\"linux文件系统详解\",{\"0\":{\"223\":1}}],[\"linux内核态与用户态\",{\"0\":{\"220\":1}}],[\"linux内存管理详解\",{\"0\":{\"217\":1}}],[\"linux下\",{\"1\":{\"217\":1}}],[\"linux常用命令详解\",{\"0\":{\"193\":1}}],[\"linux\",{\"0\":{\"189\":1,\"190\":1},\"1\":{\"104\":2,\"121\":1,\"138\":1,\"190\":2,\"217\":6,\"220\":1,\"223\":8,\"226\":2,\"249\":1},\"2\":{\"191\":1,\"192\":1,\"212\":1,\"213\":1,\"215\":1,\"216\":1,\"218\":1,\"219\":1,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"227\":1,\"228\":1}}],[\"libwww\",{\"1\":{\"249\":2}}],[\"lib64\",{\"1\":{\"223\":1}}],[\"lib32\",{\"1\":{\"223\":1}}],[\"lib是\",{\"1\":{\"223\":1}}],[\"library\",{\"0\":{\"1068\":1},\"1\":{\"136\":1,\"223\":1}}],[\"lib\",{\"1\":{\"104\":1,\"223\":2,\"770\":5}}],[\"leaf\",{\"1\":{\"727\":1}}],[\"least\",{\"1\":{\"705\":1,\"940\":1}}],[\"leader领导所在队列的所有事务\",{\"1\":{\"810\":1}}],[\"leader会根据acks参数决定是否回发确认以及何时回发确认\",{\"1\":{\"710\":1}}],[\"leader节点会等待所有同步副本\",{\"1\":{\"710\":1}}],[\"leader节点接收到消息后\",{\"1\":{\"710\":1}}],[\"leader节点处理消息\",{\"1\":{\"710\":1}}],[\"leader节点负责处理所有的写请求和读请求\",{\"1\":{\"175\":1}}],[\"leader副本存储在被选为该分区leader的节点上\",{\"1\":{\"174\":1}}],[\"leader副本\",{\"1\":{\"173\":1,\"174\":1}}],[\"leader副本必须在leader节点中\",{\"1\":{\"170\":1}}],[\"leader副本是唯一可以自主向分区写入数据的副本\",{\"1\":{\"170\":1}}],[\"leader是指kafka集群中的一个分区副本\",{\"1\":{\"170\":1}}],[\"leader\",{\"0\":{\"173\":1,\"174\":1,\"175\":2,\"183\":1},\"1\":{\"170\":1,\"173\":1,\"176\":2,\"177\":2,\"180\":1,\"181\":11,\"183\":2,\"810\":3}}],[\"less是按需加载\",{\"1\":{\"209\":1}}],[\"levelenablerfunc\",{\"1\":{\"957\":4}}],[\"levelenabler\",{\"1\":{\"957\":2}}],[\"levelkey\",{\"1\":{\"957\":4}}],[\"level\",{\"1\":{\"104\":1,\"847\":1,\"885\":1,\"957\":33}}],[\"left++\",{\"1\":{\"88\":1}}],[\"left\",{\"1\":{\"88\":4}}],[\"len字段存储的是实际的字节数\",{\"1\":{\"353\":1}}],[\"length\",{\"1\":{\"249\":1,\"415\":4,\"556\":1,\"693\":1}}],[\"len>0\",{\"1\":{\"226\":2}}],[\"len\",{\"1\":{\"46\":2,\"88\":1,\"226\":6,\"338\":1,\"344\":3,\"353\":1,\"374\":4,\"441\":2,\"530\":1,\"873\":11,\"879\":7}}],[\"闭区间简洁模板\",{\"0\":{\"46\":1}}],[\"寻找循环排序数组中的最小值\",{\"1\":{\"44\":1}}],[\"寻找循环排序数组的最小值\",{\"0\":{\"44\":1}}],[\"应当遵循最左前缀原则\",{\"1\":{\"813\":1}}],[\"应使用jakarta\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"应使用copy函数\",{\"1\":{\"346\":1}}],[\"应注意返回值的数量和类型\",{\"1\":{\"430\":1}}],[\"应该回滚\",{\"1\":{\"810\":1}}],[\"应该提交\",{\"1\":{\"810\":1}}],[\"应该遵循数据库三范式\",{\"1\":{\"807\":1}}],[\"应该配置为多少呢\",{\"1\":{\"807\":1}}],[\"应该尽量避免使用接口类型\",{\"1\":{\"416\":1}}],[\"应该调用lock\",{\"1\":{\"33\":1}}],[\"应答\",{\"1\":{\"249\":4}}],[\"应用服务不再和缓存直接交互\",{\"1\":{\"930\":1}}],[\"应用服务收到查询请求后\",{\"1\":{\"930\":1}}],[\"应用服务把缓存当作数据库的旁路\",{\"1\":{\"930\":1}}],[\"应用关闭\",{\"1\":{\"684\":1}}],[\"应用关闭时执行的清理操作\",{\"1\":{\"624\":1}}],[\"应用启动\",{\"1\":{\"684\":1}}],[\"应用启动时执行的初始化操作\",{\"1\":{\"624\":1}}],[\"应用资源已释放\",{\"1\":{\"624\":1}}],[\"应用清理\",{\"1\":{\"615\":1}}],[\"应用初始化和资源管理\",{\"0\":{\"640\":1}}],[\"应用初始化完成\",{\"1\":{\"624\":1}}],[\"应用初始化\",{\"1\":{\"615\":1}}],[\"应用层在tcp\",{\"1\":{\"249\":1}}],[\"应用层协议定义了应用程序如何通过网络进行通信和数据交换\",{\"1\":{\"249\":1}}],[\"应用层是最接近用户的层\",{\"1\":{\"249\":1}}],[\"应用层攻击\",{\"1\":{\"243\":1}}],[\"应用层\",{\"1\":{\"240\":1,\"249\":2},\"2\":{\"242\":1}}],[\"应用层的http保活机制和传输层的tcp保活机制\",{\"1\":{\"237\":1}}],[\"应用程序只有一个单独的访问源\",{\"1\":{\"930\":1}}],[\"应用程序需要维护两个数据存储\",{\"1\":{\"930\":1}}],[\"应用程序发起i\",{\"1\":{\"226\":1}}],[\"应用程序就可以对其进行处理\",{\"1\":{\"226\":1}}],[\"应用程序就会被阻塞\",{\"1\":{\"226\":1}}],[\"应用程序可以在接收到信号时读取数据\",{\"1\":{\"226\":1}}],[\"应用程序可以向操作系统注册一个信号处理函数当数据准备好时\",{\"1\":{\"226\":1}}],[\"应用程序可以同时监控多个i\",{\"1\":{\"226\":1}}],[\"应用程序可以继续执行其他操作\",{\"1\":{\"226\":1}}],[\"应用程序不能做其他事情\",{\"1\":{\"226\":1}}],[\"应用场景\",{\"0\":{\"42\":1},\"1\":{\"873\":1}}],[\"本质是记录操作日志\",{\"1\":{\"952\":1}}],[\"本质就是数据快照\",{\"1\":{\"952\":1}}],[\"本质就是监听各种事件\",{\"1\":{\"888\":1}}],[\"本质上不重复是手段\",{\"1\":{\"712\":1}}],[\"本身的限制是可以存\",{\"1\":{\"879\":1}}],[\"本身占据的字节\",{\"1\":{\"879\":1}}],[\"本身存在一个连锁更新的问题\",{\"1\":{\"867\":1}}],[\"本阶段完成的工作\",{\"1\":{\"817\":2}}],[\"本次的例子加的是\",{\"1\":{\"820\":1}}],[\"本次查询没有其他条件\",{\"1\":{\"817\":1}}],[\"本次案例中\",{\"1\":{\"770\":2}}],[\"本次打招呼完毕\",{\"1\":{\"249\":1}}],[\"本文将介绍\",{\"1\":{\"973\":1}}],[\"本文将深入介绍这些常用函数\",{\"1\":{\"494\":1}}],[\"本文讲解了\",{\"1\":{\"957\":1}}],[\"本文不对\",{\"1\":{\"936\":1}}],[\"本文对mysql的核心原理进行分类介绍\",{\"1\":{\"799\":1}}],[\"本文总结了kafka在实际应用中的关键问题及解决方案\",{\"1\":{\"703\":1}}],[\"本文详细介绍mysql数据库的管理\",{\"1\":{\"832\":1}}],[\"本文详细介绍mysql的逻辑架构及sql语句的执行流程\",{\"1\":{\"816\":1}}],[\"本文详细介绍事务的acid特性\",{\"1\":{\"773\":1}}],[\"本文详细介绍java反射机制的基本概念\",{\"1\":{\"549\":1}}],[\"本文详细介绍java异常机制的基本概念\",{\"1\":{\"535\":1}}],[\"本文详细介绍gmp模型的基本概念及其在go语言运行时中的作用\",{\"1\":{\"377\":1}}],[\"本文详细介绍go语言中bcrypt加密的原理及实现方法\",{\"1\":{\"1046\":1}}],[\"本文详细介绍go语言中内存逃逸的场景及优化方法\",{\"1\":{\"403\":1}}],[\"本文详细介绍go语言gin框架的基础知识和使用方法\",{\"1\":{\"1018\":1}}],[\"本文详细介绍go语言kratos微服务框架的架构和使用方法\",{\"1\":{\"960\":1}}],[\"本文详细介绍go语言的基础语法和使用方法\",{\"1\":{\"432\":1}}],[\"本文详细介绍go语言多返回值的实现原理及其使用场景\",{\"1\":{\"419\":1}}],[\"本文详细介绍go语言编译器的工作原理和编译过程\",{\"1\":{\"387\":1}}],[\"本文详细介绍go语言字符串的实现原理和使用方法\",{\"1\":{\"349\":1}}],[\"本文详细介绍go语言切片\",{\"1\":{\"336\":1}}],[\"本文详细介绍go语言map的底层实现原理和使用方法\",{\"1\":{\"318\":1}}],[\"本文详细介绍go语言接口的底层实现原理和使用方法\",{\"1\":{\"297\":1}}],[\"本文详细介绍go语言defer机制的底层实现原理和执行过程\",{\"1\":{\"286\":1}}],[\"本文详细介绍go语言context的底层实现原理和使用方法\",{\"1\":{\"269\":1}}],[\"本文详细介绍go语言channel的底层实现原理和使用方法\",{\"1\":{\"253\":1}}],[\"本文详细介绍了java\",{\"1\":{\"576\":1,\"612\":1,\"644\":1}}],[\"本文详细介绍了linux系统中常用的命令及其用法\",{\"1\":{\"193\":1}}],[\"本文详细介绍了kafka的副本机制\",{\"1\":{\"168\":1}}],[\"本文详细介绍了kafka的整体架构设计\",{\"1\":{\"155\":1}}],[\"本文详细介绍滑动窗口算法的原理及实现方法\",{\"1\":{\"85\":1}}],[\"本文详细介绍哈希算法的定义\",{\"1\":{\"68\":1}}],[\"本文详细介绍二叉树的基本概念\",{\"1\":{\"58\":1}}],[\"本文详细介绍二叉堆的基本原理\",{\"1\":{\"49\":1}}],[\"本文详细介绍二分红蓝染色法的原理及应用场景\",{\"1\":{\"40\":1}}],[\"本来就有的协程要调度\",{\"1\":{\"374\":1}}],[\"本地的回环地址即可\",{\"1\":{\"1026\":1}}],[\"本地队列中的最后一个\",{\"1\":{\"374\":1}}],[\"本地队列的长度是\",{\"1\":{\"374\":1}}],[\"本地目录的路径必须是绝对路径\",{\"1\":{\"113\":1}}],[\"本例中\",{\"1\":{\"353\":1}}],[\"本系列包含redis相关的技术文档和学习笔记\",{\"1\":{\"252\":1}}],[\"本系列包含计算机网络相关的技术文档和学习笔记\",{\"1\":{\"236\":1}}],[\"本系列包含mysql相关的技术文档和学习笔记\",{\"1\":{\"235\":1}}],[\"本系列包含微服务相关的技术文档和学习笔记\",{\"1\":{\"232\":1}}],[\"本系列包含linux相关的技术文档和学习笔记\",{\"1\":{\"189\":1}}],[\"本系列包含kafka相关的技术文档和学习笔记\",{\"1\":{\"188\":1}}],[\"本系列包含java相关的技术文档和学习笔记\",{\"1\":{\"154\":1}}],[\"本系列包含go语言相关的技术文档和学习笔记\",{\"1\":{\"153\":1}}],[\"本系列包含docker相关的技术文档和学习笔记\",{\"1\":{\"129\":1}}],[\"本系列包含分布式系统相关的技术文档和学习笔记\",{\"1\":{\"91\":1}}],[\"本系列包含算法相关的技术文档和学习笔记\",{\"1\":{\"39\":1}}],[\"本系列包含c++相关的技术文档和学习笔记\",{\"1\":{\"29\":1}}],[\"本系列包含后端优化场景相关的技术文档和学习笔记\",{\"1\":{\"17\":1}}],[\"实践\",{\"1\":{\"952\":1}}],[\"实践应用经验\",{\"0\":{\"703\":1}}],[\"实例来支持\",{\"1\":{\"927\":1}}],[\"实例\",{\"1\":{\"854\":1}}],[\"实例变量\",{\"1\":{\"689\":1}}],[\"实时性不高的\",{\"1\":{\"807\":1}}],[\"实体\",{\"1\":{\"523\":1}}],[\"实在处理不了再去拿锁\",{\"1\":{\"512\":1}}],[\"实用性\",{\"1\":{\"249\":1}}],[\"实际触发\",{\"1\":{\"952\":1}}],[\"实际中\",{\"1\":{\"949\":1}}],[\"实际都是存储了\",{\"1\":{\"946\":1}}],[\"实际例子\",{\"0\":{\"939\":1}}],[\"实际调用的时候\",{\"1\":{\"927\":1}}],[\"实际的数据\",{\"1\":{\"879\":1}}],[\"实际平常使用的是一个\",{\"1\":{\"864\":1}}],[\"实际就是做一个双向链表\",{\"1\":{\"906\":1}}],[\"实际就是\",{\"1\":{\"864\":1}}],[\"实际执行了以下步骤\",{\"1\":{\"396\":1}}],[\"实际原来字符串没有变化\",{\"1\":{\"356\":1}}],[\"实际类型的指针\",{\"1\":{\"307\":1}}],[\"实际传输的数据\",{\"1\":{\"249\":1}}],[\"实际使用的具体实现只能在运行时确定\",{\"1\":{\"408\":1}}],[\"实际使用的\",{\"1\":{\"249\":1}}],[\"实际密码如果有的话存储在\",{\"1\":{\"190\":1}}],[\"实际密码存储在\",{\"1\":{\"190\":1}}],[\"实际上不是\",{\"1\":{\"949\":1}}],[\"实际上是一个数学用语\",{\"1\":{\"249\":1}}],[\"实际上\",{\"1\":{\"157\":1,\"810\":1,\"927\":1,\"952\":1}}],[\"实际上确切的说\",{\"1\":{\"36\":1}}],[\"实现一个文件上传功能\",{\"1\":{\"1037\":1}}],[\"实现一致性读\",{\"1\":{\"820\":1}}],[\"实现成本较低\",{\"1\":{\"930\":1}}],[\"实现是用的最多的一种\",{\"1\":{\"909\":1,\"921\":1}}],[\"实现高吞吐量\",{\"1\":{\"888\":1}}],[\"实现起来没有那么容易\",{\"1\":{\"882\":1}}],[\"实现从后往前的操作\",{\"1\":{\"879\":1}}],[\"实现事务的持久性\",{\"1\":{\"810\":1}}],[\"实现事务回滚\",{\"1\":{\"810\":1}}],[\"实现这一机制就是\",{\"1\":{\"810\":1}}],[\"实现单点登录\",{\"1\":{\"615\":1}}],[\"实现简单的页面缓存机制\",{\"1\":{\"579\":1}}],[\"实现类\",{\"1\":{\"559\":1,\"699\":1}}],[\"实现类型\",{\"0\":{\"273\":1}}],[\"实现了事务中的\",{\"1\":{\"810\":2}}],[\"实现了servlet接口\",{\"1\":{\"665\":1}}],[\"实现了\",{\"1\":{\"470\":2,\"962\":2}}],[\"实现接口\",{\"1\":{\"471\":1}}],[\"实现接口b的方法\",{\"1\":{\"466\":1}}],[\"实现接口a的方法\",{\"1\":{\"466\":1}}],[\"实现接口a和接口b\",{\"1\":{\"466\":1}}],[\"实现多个接口\",{\"0\":{\"466\":1}}],[\"实现多路复用的方式\",{\"1\":{\"226\":1}}],[\"实现可靠传输\",{\"1\":{\"249\":1}}],[\"实现\",{\"0\":{\"706\":1,\"743\":1},\"1\":{\"249\":1,\"470\":2,\"709\":1,\"810\":3,\"924\":1}}],[\"实现分配id\",{\"1\":{\"249\":1}}],[\"实现容器网络环境的隔离性\",{\"1\":{\"123\":1}}],[\"实现宿主机到\",{\"1\":{\"123\":1}}],[\"实现的一种延迟加锁机制\",{\"1\":{\"820\":1}}],[\"实现的接口\",{\"1\":{\"555\":1}}],[\"实现的\",{\"1\":{\"122\":1,\"810\":1,\"820\":2}}],[\"实现较为复杂\",{\"1\":{\"54\":1}}],[\"实现方法\",{\"0\":{\"45\":1}}],[\"实现方式\",{\"0\":{\"53\":1,\"63\":1},\"1\":{\"33\":2,\"226\":2,\"249\":1,\"910\":1,\"921\":1,\"1036\":1}}],[\"实现运行时多态\",{\"1\":{\"33\":1}}],[\"实现编译时多态\",{\"1\":{\"33\":1}}],[\"实现继承\",{\"1\":{\"33\":1}}],[\"实现流程\",{\"1\":{\"20\":1}}],[\"预计有\",{\"1\":{\"927\":1}}],[\"预处理阶段\",{\"1\":{\"817\":1}}],[\"预处理阶段进行的替换工作\",{\"1\":{\"36\":1}}],[\"预处理器阶段\",{\"1\":{\"817\":1}}],[\"预处理器会判断表和字段是否存在\",{\"1\":{\"810\":1}}],[\"预处理器进一步检查解析树的合法性\",{\"1\":{\"734\":1}}],[\"预处理器\",{\"1\":{\"734\":1,\"817\":1}}],[\"预分配内存\",{\"1\":{\"505\":1}}],[\"预编译\",{\"1\":{\"36\":1},\"2\":{\"38\":1}}],[\"包定制开发了自己的日志包\",{\"1\":{\"957\":1}}],[\"包内部出现错误的日志输出位置\",{\"1\":{\"957\":1}}],[\"包装请求对象\",{\"1\":{\"609\":1}}],[\"包相关\",{\"1\":{\"568\":1}}],[\"包中定义的一个特殊类型\",{\"1\":{\"460\":1}}],[\"包中的\",{\"0\":{\"460\":1},\"1\":{\"460\":1}}],[\"包允许你绕过\",{\"1\":{\"460\":1}}],[\"包名\",{\"1\":{\"391\":1,\"555\":1}}],[\"包\",{\"1\":{\"229\":1,\"957\":1}}],[\"包的完整导入路径的\",{\"1\":{\"229\":1}}],[\"包的导入路径\",{\"1\":{\"229\":1}}],[\"包的导入路径命名的目录中\",{\"1\":{\"229\":2}}],[\"包可以与\",{\"1\":{\"229\":1}}],[\"包可以被用做go包名称\",{\"1\":{\"229\":1}}],[\"包都会导致错误\",{\"1\":{\"229\":1}}],[\"包管理工具下载的软件也可能被存放在这里\",{\"1\":{\"223\":1}}],[\"包含两个\",{\"1\":{\"864\":1}}],[\"包含其他资源的输出\",{\"1\":{\"681\":1}}],[\"包含三个主要阶段\",{\"1\":{\"589\":1}}],[\"包含多个bucket数组\",{\"1\":{\"325\":1}}],[\"包含方法列表的接口就是非空接口\",{\"1\":{\"305\":1}}],[\"包含了\",{\"1\":{\"302\":1,\"810\":1}}],[\"包含了在其他\",{\"1\":{\"190\":1}}],[\"包含\",{\"1\":{\"223\":1,\"530\":1,\"962\":1}}],[\"包含文件的属性与权限等数据\",{\"1\":{\"201\":1}}],[\"包含头文件就是为了将声明或者源代码替换到当前\",{\"1\":{\"36\":1}}],[\"包含头文件\",{\"1\":{\"36\":1}}],[\"包括哈希函数\",{\"1\":{\"942\":1}}],[\"包括特殊字符\",{\"1\":{\"873\":1}}],[\"包括是否使用了索引\",{\"1\":{\"807\":1}}],[\"包括何时修改\",{\"1\":{\"753\":1}}],[\"包括表和列是否存在\",{\"1\":{\"734\":1}}],[\"包括消息语义\",{\"1\":{\"703\":1}}],[\"包括私有方法\",{\"1\":{\"558\":1}}],[\"包括私有字段\",{\"1\":{\"557\":1}}],[\"包括+运算符和fmt\",{\"1\":{\"362\":1}}],[\"包括从数组切片\",{\"1\":{\"340\":1}}],[\"包括客户端使用的\",{\"1\":{\"249\":1}}],[\"包括语言\",{\"1\":{\"249\":1}}],[\"包括那些被生成的\",{\"1\":{\"229\":1}}],[\"包括socket建立\",{\"1\":{\"226\":1}}],[\"包括硬件设备\",{\"1\":{\"223\":1}}],[\"包括二进制可执行代码\",{\"1\":{\"217\":1}}],[\"包括已初始化的静态常量和全局变量\",{\"1\":{\"217\":1}}],[\"包括未初始化的静态变量和全局变量\",{\"1\":{\"217\":1}}],[\"包括动态分配的内存\",{\"1\":{\"217\":1}}],[\"包括动态库\",{\"1\":{\"217\":1}}],[\"包括局部变量和函数调用的上下文等\",{\"1\":{\"217\":1}}],[\"包括代码段\",{\"1\":{\"217\":1}}],[\"包括隐藏文件\",{\"1\":{\"201\":1}}],[\"包括\",{\"1\":{\"181\":1,\"444\":1,\"801\":1,\"854\":1,\"937\":1}}],[\"包括生产者\",{\"1\":{\"155\":1}}],[\"包括镜像和容器的数量\",{\"1\":{\"132\":1}}],[\"包括以下情况\",{\"1\":{\"33\":1}}],[\"带select\",{\"1\":{\"998\":1}}],[\"带来了损耗\",{\"1\":{\"930\":1}}],[\"带来的优势越明显\",{\"1\":{\"813\":1}}],[\"带来的性能收益排序为④\",{\"1\":{\"807\":1}}],[\"带符号右移和左移\",{\"1\":{\"569\":1}}],[\"带参\",{\"1\":{\"36\":1}}],[\"带参宏和不带参宏\",{\"1\":{\"36\":1}}],[\"带个框好看点\",{\"1\":{\"13\":1}}],[\"又是被如何组织管理的呢\",{\"1\":{\"940\":1}}],[\"又同时去数据库去取数据\",{\"1\":{\"930\":1}}],[\"又要\",{\"1\":{\"879\":1}}],[\"又能阻止其他事务将新纪录插入到被保护记录前面的间隙中\",{\"1\":{\"820\":1}}],[\"又能减少系统开销\",{\"1\":{\"36\":1}}],[\"又不会出现数据一致性问题\",{\"1\":{\"820\":1}}],[\"又不是很优化\",{\"1\":{\"813\":1}}],[\"又不想修改user结构体\",{\"1\":{\"490\":1}}],[\"又没有唯一约束\",{\"1\":{\"770\":1}}],[\"又可以指向一个\",{\"1\":{\"374\":1}}],[\"又可以继续调用函数\",{\"1\":{\"30\":1}}],[\"又叫write\",{\"1\":{\"930\":1}}],[\"又叫\",{\"1\":{\"243\":1}}],[\"又假设这个报文段在网络上绕了远路并在时刻\",{\"1\":{\"237\":1}}],[\"又会申请文件映射区域的虚拟内存返回\",{\"1\":{\"217\":1}}],[\"复杂示例\",{\"1\":{\"983\":1}}],[\"复活\",{\"1\":{\"531\":1}}],[\"复数型\",{\"1\":{\"440\":1}}],[\"复用tcp连接能并发传输\",{\"1\":{\"240\":1}}],[\"复习\",{\"2\":{\"35\":1}}],[\"复制模块\",{\"1\":{\"891\":1}}],[\"复制命令\",{\"1\":{\"864\":1}}],[\"复制成功\",{\"1\":{\"810\":1}}],[\"复制到所有从库上\",{\"1\":{\"810\":1}}],[\"复制的过程就是将\",{\"1\":{\"810\":1}}],[\"复制大数据量的\",{\"1\":{\"520\":1}}],[\"复制是在栈上完成的操作\",{\"1\":{\"417\":1}}],[\"复制2行\",{\"1\":{\"214\":1}}],[\"复制文件\",{\"1\":{\"209\":1}}],[\"复制文件或目录\",{\"1\":{\"202\":1}}],[\"复制数据的分区从节点\",{\"1\":{\"173\":1}}],[\"复制构造函数\",{\"1\":{\"33\":1}}],[\"复制对象\",{\"1\":{\"33\":1}}],[\"语进行优化\",{\"1\":{\"807\":1}}],[\"语句和\",{\"1\":{\"854\":1}}],[\"语句来更改用户的密码\",{\"1\":{\"841\":1}}],[\"语句来尝试插入消息记录\",{\"1\":{\"714\":1}}],[\"语句创建了一个没有任何权限的新用户\",{\"1\":{\"838\":1}}],[\"语句要以\",{\"1\":{\"829\":1}}],[\"语句会发生阻塞\",{\"1\":{\"820\":1}}],[\"语句会被阻塞\",{\"1\":{\"820\":2}}],[\"语句在正常执行时是不会生成锁结构的\",{\"1\":{\"820\":1}}],[\"语句并不会相互影响\",{\"1\":{\"820\":1}}],[\"语句是怎么加行级锁的\",{\"1\":{\"820\":1}}],[\"语句是不会对记录加锁的\",{\"1\":{\"820\":3}}],[\"语句是利用\",{\"1\":{\"820\":1}}],[\"语句是否满足\",{\"1\":{\"817\":1}}],[\"语句是否自动提交事务\",{\"1\":{\"739\":1}}],[\"语句类型\",{\"1\":{\"817\":1}}],[\"语句语法不对\",{\"1\":{\"817\":1}}],[\"语句做解析\",{\"1\":{\"817\":1}}],[\"语句执行结束后才释放锁\",{\"1\":{\"820\":1}}],[\"语句执行的时候\",{\"1\":{\"810\":1}}],[\"语句执行过程中提到的缓存\",{\"1\":{\"747\":1}}],[\"语句混淆了\",{\"1\":{\"810\":1}}],[\"语句而已\",{\"1\":{\"810\":1}}],[\"语句重现\",{\"1\":{\"810\":1}}],[\"语句也是会使用事务的\",{\"1\":{\"810\":1}}],[\"语句也是同样会走一遍\",{\"1\":{\"735\":1}}],[\"语句后都持有范围为\",{\"1\":{\"820\":1}}],[\"语句后\",{\"1\":{\"810\":1,\"820\":1}}],[\"语句去查询这条记录时就可以看到这条记录了\",{\"1\":{\"793\":1}}],[\"语句时生成了一个\",{\"1\":{\"793\":1}}],[\"语句或者在自动提交的情况下\",{\"1\":{\"765\":1,\"810\":1}}],[\"语句的场景\",{\"1\":{\"820\":1}}],[\"语句的请求到来\",{\"1\":{\"820\":1}}],[\"语句的执行计划\",{\"1\":{\"817\":1}}],[\"语句的执行过程\",{\"0\":{\"734\":1,\"735\":1},\"1\":{\"810\":1,\"813\":1}}],[\"语句的第一个字段\",{\"1\":{\"817\":1}}],[\"语句的\",{\"1\":{\"810\":1,\"820\":1}}],[\"语句的时候\",{\"1\":{\"783\":1,\"810\":1}}],[\"语句的那一套流程\",{\"1\":{\"735\":1}}],[\"语句\",{\"1\":{\"735\":1,\"743\":1,\"783\":1,\"785\":1,\"807\":1,\"810\":7,\"813\":1,\"817\":5,\"820\":21,\"838\":1,\"854\":1}}],[\"语义分析\",{\"1\":{\"389\":1,\"400\":1}}],[\"语雀导入\",{\"1\":{\"249\":1}}],[\"语言希望\",{\"1\":{\"520\":1}}],[\"语言中最受欢迎的\",{\"1\":{\"973\":1}}],[\"语言中\",{\"1\":{\"458\":1,\"873\":1}}],[\"语言的指针是类型安全的\",{\"1\":{\"459\":1}}],[\"语言的\",{\"1\":{\"101\":1}}],[\"语言特性\",{\"2\":{\"32\":1,\"295\":1,\"431\":1,\"575\":1}}],[\"语法树\",{\"1\":{\"817\":1}}],[\"语法解析器会根据语法规则\",{\"1\":{\"817\":1}}],[\"语法形式\",{\"1\":{\"571\":1}}],[\"语法的特性符合\",{\"1\":{\"432\":1}}],[\"语法分析之后\",{\"1\":{\"817\":1}}],[\"语法分析\",{\"1\":{\"389\":1,\"400\":1,\"817\":2}}],[\"语法\",{\"1\":{\"229\":1,\"810\":1,\"817\":1,\"829\":1,\"846\":1,\"854\":1,\"873\":3,\"924\":2},\"2\":{\"35\":1}}],[\"告诉编译器不要优化这个变量\",{\"1\":{\"33\":1}}],[\"多机部署\",{\"0\":{\"917\":1},\"1\":{\"921\":1}}],[\"多级部署\",{\"1\":{\"915\":1,\"921\":1}}],[\"多级页表虽然解决了空间上的问题\",{\"1\":{\"217\":1}}],[\"多级页表的实现方式\",{\"1\":{\"217\":1}}],[\"多久淘汰\",{\"1\":{\"900\":1}}],[\"多线程\",{\"2\":{\"899\":1}}],[\"多线程模式下\",{\"1\":{\"897\":1}}],[\"多线程模型\",{\"1\":{\"897\":1}}],[\"多线程默认是关闭的\",{\"1\":{\"897\":1}}],[\"多线程设计思路\",{\"1\":{\"897\":1}}],[\"多线程化\",{\"1\":{\"897\":1}}],[\"多线程也不是将整个逻辑都多线程化\",{\"1\":{\"897\":1}}],[\"多线程是怎么回事\",{\"1\":{\"897\":1}}],[\"多线程带来额外的成本\",{\"1\":{\"891\":1}}],[\"多线程带来的复杂度远比现象的大\",{\"1\":{\"891\":1}}],[\"多线程引入的复杂度大\",{\"1\":{\"891\":1}}],[\"多线程共享\",{\"1\":{\"689\":1}}],[\"多事务\",{\"1\":{\"810\":1}}],[\"多表查询时一定要以小驱大\",{\"1\":{\"807\":1}}],[\"多表关联时返回全部列\",{\"1\":{\"807\":1}}],[\"多字节编码\",{\"1\":{\"770\":2}}],[\"多字段的情况下\",{\"1\":{\"770\":1}}],[\"多的数据就会存到另外的\",{\"1\":{\"770\":1}}],[\"多版本并发控制\",{\"1\":{\"743\":2,\"775\":1,\"786\":1,\"810\":3,\"820\":1}}],[\"多变量声明\",{\"0\":{\"437\":1}}],[\"多值返回\",{\"0\":{\"426\":1}}],[\"多返回值不会带来明显的性能开销\",{\"1\":{\"428\":1}}],[\"多返回值的性能考量\",{\"0\":{\"428\":1}}],[\"多返回值的实现\",{\"0\":{\"421\":1}}],[\"多返回值应用场景\",{\"0\":{\"424\":1}}],[\"多返回值实际上是通过一个匿名结构体实现的\",{\"1\":{\"422\":1}}],[\"多返回值简介\",{\"0\":{\"420\":1}}],[\"多了全局队列的参与\",{\"1\":{\"374\":1}}],[\"多种不同的实现方式在实际运用中显得有些混乱\",{\"1\":{\"249\":1}}],[\"多个标签之前用\",{\"1\":{\"983\":1}}],[\"多个简单查询\",{\"1\":{\"807\":1}}],[\"多个事务的\",{\"1\":{\"767\":1,\"810\":1}}],[\"多个事务按进入的顺序将\",{\"1\":{\"767\":1,\"810\":1}}],[\"多个消费者可以同时消费一个topic\",{\"1\":{\"706\":1}}],[\"多个filter的执行顺序不符合预期\",{\"1\":{\"608\":1}}],[\"多个filter可以组成一个过滤器链\",{\"1\":{\"578\":1}}],[\"多个url模式\",{\"1\":{\"586\":1,\"654\":1}}],[\"多个\",{\"1\":{\"249\":1}}],[\"多次查询某个条件下的记录数量\",{\"1\":{\"779\":1}}],[\"多次读取同一个数据\",{\"1\":{\"778\":1}}],[\"多次更新一个资源\",{\"1\":{\"249\":1}}],[\"多次提交数据会创建多个资源\",{\"1\":{\"249\":1}}],[\"多次请求只要verison被执行了一次\",{\"1\":{\"23\":1}}],[\"多是恶意的\",{\"1\":{\"243\":1}}],[\"多路复用让\",{\"1\":{\"888\":1}}],[\"多路复用有关系\",{\"1\":{\"226\":1}}],[\"多路复用系统调用接口从内核中获取有事件发生的\",{\"1\":{\"226\":1}}],[\"多路复用可以实现是多个i\",{\"1\":{\"226\":1}}],[\"多路复用就可以解决这个问题\",{\"1\":{\"226\":1}}],[\"多路复用\",{\"1\":{\"226\":1,\"888\":3}}],[\"多出来的\",{\"1\":{\"217\":1}}],[\"多进程的系统中页表可能会占用大量内存\",{\"1\":{\"217\":1}}],[\"多副本的写入机制\",{\"0\":{\"179\":1}}],[\"多态性通常通过继承和虚函数来实现\",{\"1\":{\"33\":1}}],[\"多态\",{\"1\":{\"33\":1,\"564\":1},\"2\":{\"317\":1}}],[\"封装业务状态码\",{\"0\":{\"1030\":1}}],[\"封装响应数据\",{\"1\":{\"1021\":1}}],[\"封装自己的\",{\"1\":{\"957\":1}}],[\"封装\",{\"1\":{\"33\":1}}],[\"才代表事务成功获取到了锁\",{\"1\":{\"820\":3}}],[\"才代表函数没有被实现\",{\"1\":{\"33\":1}}],[\"才去执行回表操作获取整个记录\",{\"1\":{\"817\":1}}],[\"才可以持久化到磁盘\",{\"1\":{\"810\":1}}],[\"才可进入加密报文传输\",{\"1\":{\"249\":1}}],[\"才是将数据持久化到磁盘的操作\",{\"1\":{\"810\":1}}],[\"才是事务真正启动的时机\",{\"1\":{\"785\":1}}],[\"才能获取到插入意向锁\",{\"1\":{\"820\":1}}],[\"才能完成持久化存储\",{\"1\":{\"751\":1}}],[\"才能将一个旧的智能指针赋值给另一个指针\",{\"1\":{\"33\":1}}],[\"才启动的事务生成的\",{\"1\":{\"744\":1,\"789\":1}}],[\"才返回客户端结果\",{\"1\":{\"730\":1,\"761\":1,\"810\":1}}],[\"才会放入池中\",{\"1\":{\"906\":1}}],[\"才会将隐式锁转换为显示锁\",{\"1\":{\"820\":1}}],[\"才会执行下一条\",{\"1\":{\"820\":1}}],[\"才会把\",{\"1\":{\"820\":1}}],[\"才会显示出所有的记录\",{\"1\":{\"817\":1}}],[\"才会收到这样的报错\",{\"1\":{\"817\":1}}],[\"才会有磁盘上的页被缓存到\",{\"1\":{\"810\":1}}],[\"才会分配到栈上\",{\"1\":{\"407\":1}}],[\"才会复制物理内存\",{\"1\":{\"217\":1}}],[\"才套用参数运行\",{\"1\":{\"243\":1}}],[\"纯虚函数\",{\"1\":{\"33\":1}}],[\"派生类中的函数屏蔽了基类中的同名函数\",{\"1\":{\"33\":1}}],[\"派生类中覆盖基类中的同名函数\",{\"1\":{\"33\":1}}],[\"父类\",{\"1\":{\"33\":1,\"555\":1}}],[\"重建缓存加互斥锁\",{\"1\":{\"930\":2}}],[\"重命名用户\",{\"0\":{\"840\":1}}],[\"重命名文件\",{\"1\":{\"209\":1}}],[\"重点结构\",{\"1\":{\"944\":1}}],[\"重点关注\",{\"1\":{\"894\":1,\"938\":1}}],[\"重点关注使用最广泛的\",{\"1\":{\"813\":1}}],[\"重点是客户端连接池的连接数\",{\"1\":{\"807\":1}}],[\"重点理解\",{\"1\":{\"770\":1}}],[\"重要的是要根据查询模式和列的选择性来选择索引列的顺序\",{\"1\":{\"807\":1}}],[\"重要组件\",{\"0\":{\"103\":1}}],[\"重启之后通过重放命令来恢复数据\",{\"1\":{\"952\":1}}],[\"重启\",{\"1\":{\"924\":1}}],[\"重启会进行回滚操作\",{\"1\":{\"810\":1}}],[\"重启就提交事务\",{\"1\":{\"810\":1}}],[\"重启后会按顺序扫描\",{\"1\":{\"810\":1}}],[\"重启后会通过\",{\"1\":{\"810\":2}}],[\"重启后之前已提交的记录都不会丢失\",{\"1\":{\"810\":1}}],[\"重启后\",{\"1\":{\"763\":1,\"810\":3}}],[\"重启容器\",{\"1\":{\"143\":1}}],[\"重做已经提交的修改\",{\"1\":{\"737\":1}}],[\"重做日志文件组是以\",{\"1\":{\"810\":1}}],[\"重做日志文件组\",{\"1\":{\"810\":1}}],[\"重做日志\",{\"0\":{\"750\":1,\"758\":1},\"1\":{\"737\":1,\"775\":1,\"802\":1,\"810\":2}}],[\"重试机制\",{\"1\":{\"709\":1}}],[\"重新赋值\",{\"1\":{\"989\":1}}],[\"重新启动时\",{\"1\":{\"949\":1}}],[\"重新启动后它仍然可以从最后一个提交的偏移量处继续消费\",{\"1\":{\"711\":1}}],[\"重新出现\",{\"1\":{\"237\":1}}],[\"重新分配内存\",{\"1\":{\"867\":1}}],[\"重新分配完成后\",{\"1\":{\"165\":1}}],[\"重新分配分区\",{\"1\":{\"165\":1}}],[\"重定向是客户端的跳转\",{\"1\":{\"682\":1}}],[\"重定向到另一个url\",{\"1\":{\"678\":1}}],[\"重定向到登录页面\",{\"1\":{\"598\":1}}],[\"重定向状态\",{\"1\":{\"249\":1}}],[\"重定向\",{\"0\":{\"678\":1,\"682\":1},\"1\":{\"190\":1,\"249\":1,\"682\":1}}],[\"重写animal的speal\",{\"1\":{\"464\":1}}],[\"重写就是重写函数体\",{\"1\":{\"33\":1}}],[\"重写\",{\"1\":{\"33\":4,\"952\":1}}],[\"重载和函数成员是否是虚函数无关\",{\"1\":{\"33\":1}}],[\"重载\",{\"1\":{\"33\":3}}],[\"重复查询相同数据\",{\"1\":{\"807\":1}}],[\"重复字符串\",{\"1\":{\"503\":1}}],[\"重复请求\",{\"1\":{\"23\":1}}],[\"重复执行多次结果不变\",{\"1\":{\"23\":1}}],[\"直达数据库\",{\"1\":{\"930\":1}}],[\"直到达到超时时间\",{\"1\":{\"924\":1}}],[\"直到进程结束\",{\"1\":{\"897\":1}}],[\"直到\",{\"1\":{\"879\":1}}],[\"直到会话结束\",{\"1\":{\"839\":1}}],[\"直到第一个事务提交后\",{\"1\":{\"820\":1}}],[\"直到事务\",{\"1\":{\"820\":1}}],[\"直到拥有间隙锁的那个事务提交为止\",{\"1\":{\"820\":1}}],[\"直到表结构变更完成\",{\"1\":{\"820\":1}}],[\"直到执行完\",{\"1\":{\"820\":1}}],[\"直到锁被释放\",{\"1\":{\"820\":1}}],[\"直到存储引擎把表中的所有记录读完\",{\"1\":{\"817\":3}}],[\"直到找到\",{\"1\":{\"813\":1}}],[\"直到交换成功或者entry被移除\",{\"1\":{\"531\":1}}],[\"直到某层被recover后\",{\"1\":{\"479\":1}}],[\"直到状态再次变化\",{\"1\":{\"226\":1}}],[\"直到数据准备好为止\",{\"1\":{\"226\":1}}],[\"直到偏移量是整数倍为止\",{\"1\":{\"33\":1}}],[\"直接保存二进制数据到磁盘\",{\"1\":{\"952\":1}}],[\"直接将结果写入redis\",{\"1\":{\"930\":1}}],[\"直接打到数据库\",{\"1\":{\"930\":1}}],[\"直接和缓存进行交互\",{\"1\":{\"930\":1}}],[\"直接假设5台机器都发生了时钟漂移\",{\"1\":{\"918\":1,\"921\":1}}],[\"直接用redis的setnx命令\",{\"1\":{\"910\":1,\"921\":1}}],[\"直接缓存整个\",{\"1\":{\"873\":1}}],[\"直接查该表是否有意向独占锁\",{\"1\":{\"820\":1}}],[\"直接查询主库\",{\"1\":{\"730\":1}}],[\"直接在二级索引就能查找到结果\",{\"1\":{\"817\":1}}],[\"直接过滤掉不满足条件的记录\",{\"1\":{\"813\":1}}],[\"直接调用\",{\"1\":{\"810\":2}}],[\"直接持久到磁盘\",{\"1\":{\"810\":1}}],[\"直接持久化到磁盘\",{\"1\":{\"756\":2,\"810\":3}}],[\"直接读取缓存中的记录\",{\"1\":{\"747\":1,\"810\":1}}],[\"直接切换引用可以避免这些性能问题\",{\"1\":{\"520\":1}}],[\"直接使用==运算符比compare函数更高效\",{\"1\":{\"496\":1}}],[\"直接使用索引获取原来的元素\",{\"1\":{\"453\":1}}],[\"直接使用绝对物理地址\",{\"1\":{\"217\":1}}],[\"直接按照\",{\"1\":{\"448\":1}}],[\"直接把它的元素给到我们这里就好了\",{\"1\":{\"265\":1}}],[\"直接从一个goroutine操作另一个goroutine的栈\",{\"1\":{\"264\":1}}],[\"直接发送\",{\"1\":{\"264\":2}}],[\"直接连接\",{\"1\":{\"246\":1}}],[\"直接通信\",{\"1\":{\"121\":1}}],[\"直接放在底层的最右节点\",{\"1\":{\"52\":1}}],[\"直接插入代码\",{\"1\":{\"33\":1}}],[\"直接代表引用类型\",{\"1\":{\"30\":1}}],[\"直接返回给用户即可\",{\"1\":{\"927\":1}}],[\"直接返回\",{\"1\":{\"23\":1,\"524\":1,\"879\":1}}],[\"直接返回重复请求信息\",{\"1\":{\"23\":1}}],[\"哪个索引的成本的成本越低\",{\"1\":{\"813\":1}}],[\"哪个好\",{\"1\":{\"33\":1}}],[\"哪些流程会拖沓\",{\"1\":{\"888\":1}}],[\"哪些记录可以被覆盖的过程\",{\"1\":{\"810\":1}}],[\"哪些记录可以被擦除\",{\"1\":{\"810\":1}}],[\"哪些接口需要幂等\",{\"1\":{\"23\":1}}],[\"新闻报道等\",{\"1\":{\"930\":1}}],[\"新客户端来获取到了这个锁\",{\"1\":{\"913\":1,\"921\":1}}],[\"新客户端加入\",{\"1\":{\"226\":1}}],[\"新算法会维护一个大小为\",{\"1\":{\"906\":1}}],[\"新版是\",{\"1\":{\"867\":1}}],[\"新数据实在链表上叠加的\",{\"1\":{\"864\":1}}],[\"新表大小为第一个大于等于原表\",{\"1\":{\"864\":2}}],[\"新值\",{\"1\":{\"633\":1,\"634\":1,\"635\":2}}],[\"新建\",{\"1\":{\"249\":1}}],[\"新建sockadd结构体接收客户端数据\",{\"1\":{\"226\":1}}],[\"新建容器并启动\",{\"0\":{\"139\":1}}],[\"新建容器网络\",{\"1\":{\"119\":1}}],[\"新路径\",{\"1\":{\"209\":1}}],[\"新文件名\",{\"1\":{\"209\":1}}],[\"新的\",{\"1\":{\"906\":1}}],[\"新的用户名\",{\"1\":{\"207\":1}}],[\"新的引用计数加1\",{\"1\":{\"33\":1}}],[\"新\",{\"0\":{\"183\":1,\"382\":1}}],[\"新消费者加入\",{\"1\":{\"165\":1}}],[\"新创建的容器不会创建自己的网卡\",{\"1\":{\"125\":1}}],[\"新增\",{\"1\":{\"519\":1,\"810\":2}}],[\"新增或提交数据\",{\"1\":{\"249\":1}}],[\"新增用户同时加入指定组\",{\"1\":{\"208\":1}}],[\"新增组\",{\"1\":{\"208\":1}}],[\"新增对象还需要一个构造函数\",{\"1\":{\"33\":1}}],[\"新增操作每次执行都会往db新增数据\",{\"1\":{\"23\":1}}],[\"新增操作\",{\"1\":{\"23\":1}}],[\"同步服务如果压力比较大\",{\"1\":{\"930\":1}}],[\"同步机制开销\",{\"1\":{\"891\":1}}],[\"同步机制的开销等等成本很高\",{\"1\":{\"888\":1}}],[\"同步到各从库\",{\"1\":{\"810\":1}}],[\"同步到所有从库\",{\"1\":{\"730\":1,\"761\":1}}],[\"同步复制\",{\"1\":{\"810\":1}}],[\"同步完成就返回客户端结果\",{\"1\":{\"730\":1,\"761\":1}}],[\"同步模式\",{\"1\":{\"730\":2,\"761\":1}}],[\"同步\",{\"1\":{\"381\":1,\"730\":1,\"761\":1,\"810\":1}}],[\"同步异步的区别\",{\"1\":{\"226\":1}}],[\"同步io模型\",{\"1\":{\"226\":1}}],[\"同一个锁\",{\"1\":{\"909\":1,\"921\":1}}],[\"同一个团队下\",{\"1\":{\"722\":1}}],[\"同一个结构体字段可以设置多个键值对tag\",{\"1\":{\"484\":1}}],[\"同一个文件夹下的文件只能有一个包名\",{\"1\":{\"434\":1}}],[\"同一个消费组中\",{\"1\":{\"164\":2}}],[\"同一消费者可以同一时间从同一主题的不同分片读取信息\",{\"1\":{\"161\":1}}],[\"同一事物变现出不同事物的能力\",{\"1\":{\"33\":1}}],[\"同时检查该字段是否存在\",{\"1\":{\"1037\":1}}],[\"同时协同各类\",{\"1\":{\"962\":1}}],[\"同时开启的情况下\",{\"1\":{\"952\":1}}],[\"同时满足这两个条件则重写\",{\"1\":{\"952\":1}}],[\"同时由于binlog存在statement\",{\"1\":{\"930\":1}}],[\"同时由于黄牛善于使用脚本\",{\"1\":{\"927\":1}}],[\"同时尝试操作redis\",{\"1\":{\"930\":1}}],[\"同时读缓存没读到数据\",{\"1\":{\"930\":1}}],[\"同时引入\",{\"1\":{\"891\":1}}],[\"同时拥有两个\",{\"1\":{\"864\":1}}],[\"同时使用\",{\"1\":{\"864\":1}}],[\"同时执行向表\",{\"1\":{\"820\":1}}],[\"同时主键\",{\"1\":{\"817\":1}}],[\"同时还受限于主库的网络带宽\",{\"1\":{\"810\":1}}],[\"同时性能方便比参数\",{\"1\":{\"810\":1}}],[\"同时标记为脏页\",{\"1\":{\"810\":3}}],[\"同时也不支持多人消费\",{\"1\":{\"924\":1}}],[\"同时也不存在之前的存储容量的木桶问题\",{\"1\":{\"807\":1}}],[\"同时也支持选择\",{\"1\":{\"813\":1}}],[\"同时也保证\",{\"1\":{\"123\":1}}],[\"同时在处理速度也会更快\",{\"1\":{\"807\":1}}],[\"同时将偏移索引的值设为\",{\"1\":{\"864\":1}}],[\"同时将\",{\"1\":{\"765\":1,\"810\":1}}],[\"同时将该页标记为脏页\",{\"1\":{\"751\":1}}],[\"同时又保留了解释型语言可移植的特点\",{\"1\":{\"566\":1}}],[\"同时unexpungelocked\",{\"1\":{\"531\":1}}],[\"同时指向\",{\"1\":{\"512\":1}}],[\"同时指定password字段为匿名结构体指针类型\",{\"1\":{\"490\":1}}],[\"同时递归处理导入的包\",{\"1\":{\"396\":1}}],[\"同时证明是自己发的\",{\"1\":{\"249\":1}}],[\"同时消费多个分片下\",{\"1\":{\"161\":1}}],[\"同时会创建了一对\",{\"1\":{\"123\":1}}],[\"同时\",{\"1\":{\"121\":1,\"163\":1,\"524\":1,\"820\":1,\"949\":1}}],[\"同时旧的引用计数减1\",{\"1\":{\"33\":1}}],[\"同理\",{\"1\":{\"51\":1}}],[\"同样也意味着如果密码库被盗\",{\"1\":{\"1056\":1}}],[\"同样通过先定义一个\",{\"1\":{\"957\":1}}],[\"同样可以显著减少sql查询的分组和排序的时间\",{\"1\":{\"813\":1}}],[\"同样需要按\",{\"1\":{\"810\":1}}],[\"同样需要按页来划分\",{\"1\":{\"748\":1}}],[\"同样的道理\",{\"1\":{\"770\":1}}],[\"同样\",{\"1\":{\"125\":1}}],[\"同样在子函数执行完后要恢复调用函数的现场\",{\"1\":{\"36\":1}}],[\"同样有上述的数据拷贝过程\",{\"1\":{\"33\":1}}],[\"同样有一个形参向函数所属的栈拷贝数据的过程\",{\"1\":{\"33\":1}}],[\"除此之外\",{\"1\":{\"810\":1}}],[\"除了在代码中指定配置参数\",{\"1\":{\"957\":1}}],[\"除了提供\",{\"1\":{\"957\":1}}],[\"除了\",{\"1\":{\"940\":1}}],[\"除了查库后加载这种模式\",{\"1\":{\"930\":1}}],[\"除了扣件库存\",{\"1\":{\"927\":1}}],[\"除了单引号\",{\"1\":{\"838\":1}}],[\"除了缓存\",{\"1\":{\"810\":1}}],[\"除了指针对象外\",{\"1\":{\"33\":1}}],[\"除去第1位后\",{\"1\":{\"770\":1}}],[\"除非你可以接受丢失几分钟级别的数据\",{\"1\":{\"952\":1}}],[\"除非你显式的提供一个option\",{\"1\":{\"229\":1}}],[\"除非主键发生了增删修改\",{\"1\":{\"813\":1}}],[\"除非用户手工清理或到了过期时间\",{\"1\":{\"249\":1}}],[\"除非这个字段本身的语义允许\",{\"1\":{\"249\":1}}],[\"除非两个文件在同一个包中\",{\"1\":{\"229\":1}}],[\"除非开启了\",{\"1\":{\"181\":2}}],[\"除非是局部变量的返回值\",{\"1\":{\"33\":1}}],[\"它提供了强大的对象关系映射功能\",{\"1\":{\"973\":1}}],[\"它提供了一种方式来暂时存储指针值\",{\"1\":{\"460\":1}}],[\"它所要做的是将领域对象重新拿出来\",{\"1\":{\"962\":1}}],[\"它能将一个或者多个数据库\",{\"1\":{\"854\":1}}],[\"它可能有很多使用者\",{\"1\":{\"850\":1}}],[\"它可以保证多个逻辑操作要不全部成功\",{\"1\":{\"764\":1,\"810\":1}}],[\"它可以监听web应用中的各种事件\",{\"1\":{\"612\":1}}],[\"它可以拦截和处理对web资源\",{\"1\":{\"578\":1}}],[\"它可以对请求和响应进行预处理和后处理\",{\"1\":{\"576\":1}}],[\"它可以是一个位置\",{\"1\":{\"249\":1}}],[\"它可以是leader的副本或者follower的副本的一种\",{\"1\":{\"170\":1}}],[\"它使用\",{\"1\":{\"846\":1}}],[\"它用来保存锁定的用户尝试连接到服务器的次数\",{\"1\":{\"843\":1}}],[\"它用于监听web应用中的各种事件\",{\"1\":{\"614\":1}}],[\"它用于表示一个无类型的指针或将一个\",{\"1\":{\"460\":1}}],[\"它删除了\",{\"1\":{\"841\":1}}],[\"它什么时候刷新到磁盘\",{\"1\":{\"810\":1}}],[\"它保证了事务的\",{\"1\":{\"810\":1}}],[\"它决定了表中数据的物理排序\",{\"1\":{\"807\":1}}],[\"它决定数据如何从源头到达目的地\",{\"1\":{\"249\":1}}],[\"它就可以被消费者至少消费一次\",{\"1\":{\"710\":1}}],[\"它就会被持久化存储到磁盘中\",{\"1\":{\"710\":1}}],[\"它就会对收到的这个关键词进行计数统计\",{\"1\":{\"79\":1}}],[\"它采用了特定的方式来进行配置\",{\"1\":{\"700\":1}}],[\"它重写了service\",{\"1\":{\"666\":1}}],[\"它简化了servlet的开发\",{\"1\":{\"665\":1}}],[\"它定义了哪些url请求会被特定的servlet处理\",{\"1\":{\"653\":1}}],[\"它定义了ip地址和数据包如何封装和处理\",{\"1\":{\"249\":1}}],[\"它随着对象的创建而存在\",{\"1\":{\"571\":1}}],[\"它不能直接处理用户请求生成响应\",{\"1\":{\"578\":1}}],[\"它不面向任何特定的处理器\",{\"1\":{\"566\":1}}],[\"它不一定是纯文本\",{\"1\":{\"249\":1}}],[\"它允许事务协调器\",{\"1\":{\"810\":1}}],[\"它允许在运行时创建一个实现了指定接口的代理类\",{\"1\":{\"559\":1}}],[\"它允许程序在运行时检查和操作类\",{\"1\":{\"550\":1}}],[\"它发生在程序运行期间\",{\"1\":{\"537\":1}}],[\"它本质是采用空间换时间的思想\",{\"1\":{\"512\":1}}],[\"它会从json数据中提取\",{\"1\":{\"1041\":1}}],[\"它会从表单数据中提取\",{\"1\":{\"1041\":1}}],[\"它会保存所有字段\",{\"1\":{\"997\":1}}],[\"它会检查redo\",{\"1\":{\"810\":1}}],[\"它会根据不同的情况自动使用\",{\"1\":{\"810\":1}}],[\"它会依次经过filter链中的每个filter\",{\"1\":{\"594\":1}}],[\"它会获取一个锁\",{\"1\":{\"511\":1}}],[\"它会自动记录smartpointer<t\",{\"1\":{\"33\":1}}],[\"它返回值的两倍\",{\"1\":{\"460\":1}}],[\"它非常轻量\",{\"1\":{\"378\":1}}],[\"它在哪里被使用了\",{\"1\":{\"354\":1}}],[\"它实际上只是一个int值\",{\"1\":{\"279\":1}}],[\"它底层的数据传输基于\",{\"1\":{\"249\":1}}],[\"它确保数据可以在系统之间可靠地\",{\"1\":{\"249\":1}}],[\"它为应用程序提供网络服务\",{\"1\":{\"249\":1}}],[\"它将网络通信划分为不同的层次\",{\"1\":{\"249\":1}}],[\"它将写入的数据都会同步到所有的folower副本中\",{\"1\":{\"170\":1}}],[\"它有两个好处\",{\"1\":{\"237\":1}}],[\"它有如下几种选择\",{\"1\":{\"165\":1}}],[\"它的默认值就是\",{\"1\":{\"770\":1}}],[\"它的副本作为leader副本\",{\"1\":{\"180\":1}}],[\"它的核心思想是在分布式环境下生成id\",{\"1\":{\"92\":1}}],[\"它只能从leader副本中复制数据\",{\"1\":{\"170\":1}}],[\"它负责处理该分区的所有读写请求\",{\"1\":{\"170\":1}}],[\"它负责响应和处理来自\",{\"1\":{\"102\":1}}],[\"它们持久化到磁盘的时机分别由下面这两个参数控制\",{\"1\":{\"810\":1}}],[\"它们也可以被正确地协调和管理\",{\"1\":{\"810\":1}}],[\"它们的区别在于\",{\"1\":{\"810\":1}}],[\"它们的区别在于创建\",{\"1\":{\"810\":1}}],[\"它们的行格式是这样的\",{\"1\":{\"770\":1}}],[\"它们的行格式都和\",{\"1\":{\"770\":1}}],[\"它们的快照读\",{\"1\":{\"743\":1,\"810\":1}}],[\"它们都用来表示资源在客户端缓存的有效期\",{\"1\":{\"249\":1}}],[\"它们负责订阅主题并消费其中的消息\",{\"1\":{\"156\":1}}],[\"它们将消息发送到特定的主题中\",{\"1\":{\"156\":1}}],[\"它绕过\",{\"1\":{\"106\":1}}],[\"它包含了容器运行时所需要的所有基础文件和配置信息\",{\"1\":{\"97\":1}}],[\"它是靠聚簇索引记录自带的\",{\"1\":{\"820\":1}}],[\"它是记录锁和间隙锁的组合\",{\"1\":{\"820\":1}}],[\"它是java\",{\"1\":{\"646\":1}}],[\"它是由实现该接口的对象自身负责监听其绑定到会话或从会话解除绑定的事件\",{\"1\":{\"637\":1}}],[\"它是对称密钥\",{\"1\":{\"249\":1}}],[\"它是对消息进行分类的一种方式\",{\"1\":{\"157\":1}}],[\"它是常见的开机引导程序\",{\"1\":{\"223\":1}}],[\"它是主题的物理存储单位\",{\"1\":{\"157\":1}}],[\"它是一种特殊的间隙锁\",{\"1\":{\"820\":2}}],[\"它是一种不影响对象生命周期的智能指针\",{\"1\":{\"33\":1}}],[\"它是一个无限循环函数\",{\"1\":{\"897\":1}}],[\"它是一个多路复用协议\",{\"1\":{\"249\":1}}],[\"它是一个只读的文件和文件夹组合\",{\"1\":{\"97\":1}}],[\"它是if\",{\"1\":{\"36\":1}}],[\"析构函数负责引用计数减少和释放内存\",{\"1\":{\"33\":1}}],[\"析构函数\",{\"1\":{\"33\":2}}],[\"弱指针用于专门解决shared\",{\"1\":{\"33\":1}}],[\"弱引用\",{\"1\":{\"33\":1}}],[\"环境准备\",{\"0\":{\"581\":1,\"617\":1,\"649\":1}}],[\"环境变量处理\",{\"1\":{\"190\":1}}],[\"环境变量\",{\"1\":{\"98\":1}}],[\"环引用是指使用多个智能指针share\",{\"1\":{\"33\":1}}],[\"环形引用会导致相互引用的内存无法释放\",{\"1\":{\"33\":1}}],[\"引起数据库压力过大甚至宕机\",{\"1\":{\"930\":1}}],[\"引起数据库压力瞬间增大\",{\"1\":{\"930\":1}}],[\"引多了多余的复杂度\",{\"1\":{\"882\":1}}],[\"引擎为了解决\",{\"1\":{\"820\":1}}],[\"引擎并不支持行级锁\",{\"1\":{\"820\":1}}],[\"引擎是支持行级锁的\",{\"1\":{\"820\":1}}],[\"引擎的表里对某些纪录加上\",{\"1\":{\"820\":1}}],[\"引擎的表里对某些记录加上\",{\"1\":{\"820\":1}}],[\"引擎的表使用表锁\",{\"1\":{\"820\":1}}],[\"引擎全扫描的接口\",{\"1\":{\"817\":2}}],[\"引擎索引查询的接口\",{\"1\":{\"817\":1}}],[\"引擎层\",{\"1\":{\"817\":1}}],[\"引擎一定会为表创建一个聚集索引\",{\"1\":{\"813\":1}}],[\"引擎\",{\"1\":{\"810\":1}}],[\"引擎就会先更新内存\",{\"1\":{\"810\":1}}],[\"引擎对一条记录进行操作\",{\"1\":{\"810\":1}}],[\"引擎对一条记录进行操作时\",{\"1\":{\"741\":1}}],[\"引擎会自己启动一个事务\",{\"1\":{\"810\":1}}],[\"引擎会在适当的时候\",{\"1\":{\"751\":1,\"810\":1}}],[\"引擎会先更新\",{\"1\":{\"751\":1}}],[\"引擎在执行一条增删改语句的时候\",{\"1\":{\"739\":1}}],[\"引入多线程要付出更大的时间复杂度\",{\"1\":{\"888\":1}}],[\"引入消息中间件解决写压力\",{\"1\":{\"807\":1}}],[\"引入中间件解决读压力\",{\"1\":{\"807\":1}}],[\"引入中间件减轻数据库压力\",{\"1\":{\"807\":1}}],[\"引入\",{\"0\":{\"913\":1},\"1\":{\"723\":1,\"879\":1,\"903\":1,\"921\":1}}],[\"引入内容协商机制\",{\"1\":{\"249\":1}}],[\"引入额外的缓存控制机制\",{\"1\":{\"249\":1}}],[\"引入了消息队列这种算比较重的组件\",{\"1\":{\"930\":1}}],[\"引入了跳表\",{\"1\":{\"885\":1}}],[\"引入了组提交机制后\",{\"1\":{\"767\":1,\"810\":1}}],[\"引入了组提交\",{\"1\":{\"767\":1}}],[\"引入了\",{\"1\":{\"249\":1,\"810\":1}}],[\"引入了weak\",{\"1\":{\"33\":1}}],[\"引入stream\",{\"1\":{\"240\":1}}],[\"引用计数\",{\"1\":{\"940\":1}}],[\"引用计数会减1\",{\"1\":{\"33\":1}}],[\"引用小林图解的一张图\",{\"1\":{\"734\":1}}],[\"引用的副本或指针的副本\",{\"1\":{\"456\":1}}],[\"引用类型如\",{\"1\":{\"456\":1}}],[\"引用类型和指针\",{\"0\":{\"456\":1}}],[\"引用一旦绑定到一个对象\",{\"1\":{\"33\":1}}],[\"引用必须在声明时初始化\",{\"1\":{\"33\":1}}],[\"引用必须初始化\",{\"1\":{\"30\":1}}],[\"引用传递\",{\"1\":{\"33\":1}}],[\"引用传递的区别和效率\",{\"1\":{\"33\":1}}],[\"引用原变量的别名\",{\"1\":{\"33\":1}}],[\"引用作为函数返回值类型\",{\"1\":{\"30\":1}}],[\"引用\",{\"1\":{\"30\":1,\"33\":2},\"2\":{\"32\":1}}],[\"每秒刷一次盘\",{\"1\":{\"952\":1}}],[\"每\",{\"1\":{\"952\":3}}],[\"每隔一段时间\",{\"1\":{\"882\":1}}],[\"每隔一秒一起持久化到磁盘\",{\"1\":{\"810\":1}}],[\"每插入一条新记录\",{\"1\":{\"820\":2}}],[\"每查询到一条二级索引记录\",{\"1\":{\"817\":1}}],[\"每条select查询语句流程主要可以分为下面这三个阶段\",{\"1\":{\"817\":1}}],[\"每条消息在kafka中会有partition\",{\"1\":{\"163\":1}}],[\"每种都考虑的话\",{\"1\":{\"813\":1}}],[\"每日定时统计一次\",{\"1\":{\"807\":1}}],[\"每行记录根据不同的行格式\",{\"1\":{\"770\":1}}],[\"每调度\",{\"1\":{\"374\":1}}],[\"每层负责一组特定的功能\",{\"1\":{\"249\":1}}],[\"每次请求都刷入aof\",{\"1\":{\"952\":1}}],[\"每次请求都是完全独立互不影响的\",{\"1\":{\"249\":1}}],[\"每次添加\",{\"1\":{\"945\":1}}],[\"每次运行读写命令都会调用processcommand函数\",{\"1\":{\"900\":1}}],[\"每次删除一部分过期\",{\"1\":{\"882\":1}}],[\"每次使用游标\",{\"1\":{\"870\":1}}],[\"每次迁移一个函数\",{\"1\":{\"864\":1}}],[\"每次对字典执行增删改查\",{\"1\":{\"864\":1}}],[\"每次对某条聚簇索引记录进行改动时\",{\"1\":{\"770\":1,\"788\":1}}],[\"每次事务提交时\",{\"1\":{\"756\":3}}],[\"每次事务提交时都将缓存在\",{\"1\":{\"756\":1,\"810\":1}}],[\"每次执行请求\",{\"1\":{\"952\":1}}],[\"每次执行\",{\"1\":{\"743\":1}}],[\"每次消费消息前\",{\"1\":{\"714\":1}}],[\"每次未命中时增加\",{\"1\":{\"530\":1}}],[\"每次迭代都共享一个底层变量\",{\"1\":{\"452\":1}}],[\"每次迭代都是一个新变量\",{\"1\":{\"452\":1}}],[\"每次发送请求前需要先与服务器建立连接\",{\"1\":{\"249\":1}}],[\"每次操作时都传入整个\",{\"1\":{\"226\":1}}],[\"每次需要遍历所有fd\",{\"1\":{\"226\":2}}],[\"每次需要把fd从用户态拷贝到内核态\",{\"1\":{\"226\":2}}],[\"每次调用\",{\"1\":{\"226\":2,\"511\":1}}],[\"每次1gb\",{\"1\":{\"217\":1}}],[\"每次写完代码都要借助工具把程序烧录进去\",{\"1\":{\"217\":1}}],[\"每次提交表单时附带一个唯一的token\",{\"1\":{\"23\":1}}],[\"每一份单独排序后存在这些临时文件中\",{\"1\":{\"813\":1}}],[\"每一种存储引擎支持的索引类型不一定相同\",{\"1\":{\"813\":1}}],[\"每一条修改数据的\",{\"1\":{\"810\":1}}],[\"每一个线程都有自己的binlog\",{\"1\":{\"760\":1}}],[\"每一个组内部都有一些数据记录\",{\"1\":{\"748\":1}}],[\"每一个epoll对象都有一个独立的eventpoll结构体\",{\"1\":{\"226\":1}}],[\"每一页的大小为\",{\"1\":{\"217\":1}}],[\"每一行代表一个用户组\",{\"1\":{\"190\":1}}],[\"每一行代表一个用户账户\",{\"1\":{\"190\":1}}],[\"每一层节点都是满的\",{\"1\":{\"60\":1}}],[\"每台机器都会从分配给自己的那部分日志数据中依次读取每个搜索关键词\",{\"1\":{\"79\":1}}],[\"每个密码加单独的盐进行哈希\",{\"1\":{\"1056\":1}}],[\"每个配置项说明如下\",{\"1\":{\"957\":1}}],[\"每个服务其实都应该缓存一些热点数据\",{\"1\":{\"930\":1}}],[\"每个字节第一个\",{\"1\":{\"879\":1}}],[\"每个字符在存储时都对应一个整数\",{\"1\":{\"352\":1}}],[\"每个系欸但即存索引又存记录\",{\"1\":{\"813\":1}}],[\"每个数据页默认大小16kb\",{\"1\":{\"813\":1}}],[\"每个数据库表的行格式都有\",{\"1\":{\"770\":2}}],[\"每个阶段的过程段的过程\",{\"1\":{\"810\":1}}],[\"每个阶段的过程\",{\"1\":{\"810\":1}}],[\"每个阶段有锁进行保护\",{\"1\":{\"810\":1}}],[\"每个阶段都有一个队列\",{\"1\":{\"810\":1}}],[\"每个阶段都由协调者\",{\"1\":{\"764\":1,\"810\":1}}],[\"每个\",{\"1\":{\"810\":1,\"944\":1}}],[\"每个语句执行前\",{\"1\":{\"784\":1}}],[\"每个事务各自执行\",{\"1\":{\"810\":1}}],[\"每个事务都会被分配一个唯一的标识符\",{\"1\":{\"810\":1}}],[\"每个事务都有一个完整的数据空间\",{\"1\":{\"774\":1}}],[\"每个事务提交都会进行两次\",{\"1\":{\"766\":1,\"810\":1}}],[\"每个区的大小为\",{\"1\":{\"770\":1}}],[\"每个步骤中都有许多细节和优化点\",{\"1\":{\"734\":1}}],[\"每个从库把\",{\"1\":{\"730\":1,\"761\":1,\"810\":1}}],[\"每个filter只负责一种功能\",{\"1\":{\"605\":1}}],[\"每个函数的栈空间都是独立的\",{\"1\":{\"405\":1}}],[\"每个进程的用户空间划分的情况\",{\"1\":{\"217\":1}}],[\"每个进程都有自己独立的虚拟地址空间\",{\"1\":{\"217\":1}}],[\"每个进程都是有自己的虚拟地址空间的\",{\"1\":{\"217\":1}}],[\"每个表二级页表中包含\",{\"1\":{\"217\":1}}],[\"每个partition都会由leader\",{\"1\":{\"182\":1}}],[\"每个副本都保存了分区的完整数据\",{\"1\":{\"170\":1}}],[\"每个分片只会分配给一个消费者\",{\"1\":{\"164\":1}}],[\"每个分区的副本包括一个leader副本和多个follower副本\",{\"1\":{\"172\":1}}],[\"每个分区的数据会被复制到多个节点上\",{\"1\":{\"172\":1}}],[\"每个分区内是一个有序的\",{\"1\":{\"172\":1}}],[\"每个分区都有多个副本\",{\"1\":{\"170\":1}}],[\"每个分区都是一个有序的\",{\"1\":{\"157\":1}}],[\"每个分区又可以有一至多个副本\",{\"1\":{\"157\":1}}],[\"每个节点负责一部分槽\",{\"1\":{\"723\":1}}],[\"每个节点通过指针指向左右子节点\",{\"1\":{\"64\":1}}],[\"每个节点下方的所有节点的值都比它大\",{\"1\":{\"51\":1}}],[\"每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍\",{\"1\":{\"33\":1}}],[\"每当产生一条\",{\"1\":{\"755\":1,\"810\":1}}],[\"每当执行一个事务就会产生这样的一条或者多条物理日志\",{\"1\":{\"752\":1,\"810\":1}}],[\"每当\",{\"1\":{\"741\":1,\"810\":1}}],[\"每当减少一个智能指针指向对象时\",{\"1\":{\"33\":1}}],[\"每当多一个指针指向该对象时\",{\"1\":{\"33\":1}}],[\"允许通过索引直接满足查询需求\",{\"1\":{\"813\":1}}],[\"允许多次读取\",{\"1\":{\"609\":1}}],[\"允许多个智能指针指向同一个对象\",{\"1\":{\"33\":1}}],[\"允许访问登录页面和静态资源\",{\"1\":{\"598\":1}}],[\"允许函数接受数量可变的参数\",{\"1\":{\"458\":1}}],[\"允许后空缺\",{\"1\":{\"448\":1}}],[\"允许在第一个应答被完全发送之前就发送第二个请求\",{\"1\":{\"249\":1}}],[\"允许传输元数据\",{\"1\":{\"249\":1}}],[\"允许报文在网络中丢失一次\",{\"1\":{\"237\":1}}],[\"允许为不同的枚举值赋予相同的标识符\",{\"1\":{\"229\":1}}],[\"允许\",{\"1\":{\"183\":1}}],[\"允许使用鼠标滚轮进行编辑器字体缩放\",{\"1\":{\"3\":1}}],[\"智能指针是一个数据类型\",{\"1\":{\"33\":1}}],[\"智能指针往往不能正常调用对象的析构函数\",{\"1\":{\"33\":1}}],[\"智能指针的循环引用\",{\"1\":{\"33\":1}}],[\"智能指针\",{\"1\":{\"33\":1}}],[\"当出现\",{\"1\":{\"957\":1}}],[\"当出现问题时\",{\"1\":{\"249\":1}}],[\"当程序重启或者服务崩溃\",{\"1\":{\"952\":1}}],[\"当线程拿到缓存发现缓存不存在就会尝试加锁\",{\"1\":{\"930\":1}}],[\"当线程查询缓存发现缓存不存在就会尝试加锁\",{\"1\":{\"930\":1}}],[\"当分布式锁获得返回包的时间过长\",{\"1\":{\"918\":1,\"921\":1}}],[\"当池子满了\",{\"1\":{\"906\":1}}],[\"当内存不足\",{\"1\":{\"906\":1}}],[\"当达到最大内存时\",{\"1\":{\"900\":1}}],[\"当事件发生\",{\"1\":{\"888\":1}}],[\"当事务需要加锁的时\",{\"1\":{\"820\":1}}],[\"当事务需要回滚时\",{\"1\":{\"740\":1}}],[\"当事务\",{\"1\":{\"820\":2}}],[\"当事务执行\",{\"1\":{\"820\":1}}],[\"当事务回滚时\",{\"1\":{\"810\":1}}],[\"当事务对数据库中的记录进行更新时\",{\"1\":{\"753\":1}}],[\"当列表个数或节点数据比较大会使用\",{\"1\":{\"867\":1}}],[\"当插入元素时候\",{\"1\":{\"867\":1}}],[\"当创建了一个新用户之后\",{\"1\":{\"846\":1}}],[\"当创建一个\",{\"1\":{\"123\":1}}],[\"当锁定的帐户尝试登录时\",{\"1\":{\"843\":1}}],[\"当检测到死锁后\",{\"1\":{\"820\":1}}],[\"当检查到有事件产生后\",{\"1\":{\"226\":1}}],[\"当条件值的记录在表中\",{\"1\":{\"820\":1}}],[\"当条件值的记录不在表中\",{\"1\":{\"820\":1}}],[\"当唯一索引进行范围查询时\",{\"1\":{\"820\":1}}],[\"当查询的记录不存在时\",{\"1\":{\"820\":1}}],[\"当查询的记录是\",{\"1\":{\"820\":2}}],[\"当查询条件中使用了某个列\",{\"1\":{\"813\":1}}],[\"当你发现执行计划里的\",{\"1\":{\"817\":1}}],[\"当你传递一个结构体或数组给函数时\",{\"1\":{\"457\":1}}],[\"当堆表的数据发生改变\",{\"1\":{\"813\":1}}],[\"当优化器分析出成本最小的执行计划后\",{\"1\":{\"810\":1}}],[\"当设置该\",{\"1\":{\"810\":3}}],[\"当索引包含所有需要查询的字段时\",{\"1\":{\"807\":1}}],[\"当再次去查询用户表时\",{\"1\":{\"780\":1}}],[\"当负责执行事务a的线程正在更改最后一条表数据时\",{\"1\":{\"780\":1}}],[\"当发生超时后\",{\"1\":{\"820\":1}}],[\"当发生行溢出时\",{\"1\":{\"770\":1}}],[\"当发起新连接的时候\",{\"1\":{\"237\":1}}],[\"当一条记录有\",{\"1\":{\"770\":1}}],[\"当一个竞争者在持有锁期间内\",{\"1\":{\"909\":1,\"921\":1}}],[\"当一个事务的等待时间超过该值后\",{\"1\":{\"820\":1}}],[\"当一个事务执行了下面这条语句\",{\"1\":{\"820\":1}}],[\"当一个事务对一条记录加了\",{\"1\":{\"820\":2}}],[\"当一个事务对某条聚簇索引记录进行改动时\",{\"1\":{\"788\":1}}],[\"当一个请求可能匹配多个servlet时\",{\"1\":{\"656\":1}}],[\"当一个请求到达web应用时\",{\"1\":{\"594\":1}}],[\"当一个函数发生panic后当前函数体的剩余代码不再执行\",{\"1\":{\"479\":1}}],[\"当一个消费者离开\",{\"1\":{\"165\":1}}],[\"当一个新的消费者加入消费者组时\",{\"1\":{\"165\":1}}],[\"当需要读一条记录的时候\",{\"1\":{\"770\":1}}],[\"当需要处理大量字符串分割操作时\",{\"1\":{\"502\":1}}],[\"当有客户端连接到来\",{\"1\":{\"897\":1}}],[\"当有\",{\"1\":{\"888\":1}}],[\"当有死锁发生时\",{\"1\":{\"820\":1}}],[\"当有线程对表结构进行变更\",{\"1\":{\"820\":1}}],[\"当有线程在执行\",{\"1\":{\"820\":1}}],[\"当有多个事务提交的时候\",{\"1\":{\"767\":1,\"810\":1}}],[\"当有一条记录需要更新的时候\",{\"1\":{\"751\":1,\"810\":1}}],[\"当客户端执行\",{\"1\":{\"765\":1,\"810\":1}}],[\"当客户端第一次请求session对象时候\",{\"1\":{\"249\":1}}],[\"当系统重启并恢复时\",{\"1\":{\"810\":1}}],[\"当系统崩溃时\",{\"1\":{\"752\":1,\"810\":1}}],[\"当系统的物理内存不足时\",{\"1\":{\"217\":1}}],[\"当修改数据时\",{\"1\":{\"747\":1,\"810\":1}}],[\"当读取数据时\",{\"1\":{\"747\":1,\"810\":1}}],[\"当节点增加或减少\",{\"1\":{\"723\":1}}],[\"当单个业务增长比较快\",{\"1\":{\"720\":1}}],[\"当会话退出后\",{\"1\":{\"820\":1}}],[\"当会话断开了\",{\"1\":{\"820\":1}}],[\"当会话活化时\",{\"1\":{\"638\":1}}],[\"当会话钝化时\",{\"1\":{\"638\":1}}],[\"当会话超时或被显式销毁时\",{\"1\":{\"630\":1}}],[\"当用户注销时\",{\"1\":{\"641\":1}}],[\"当用户登录成功时\",{\"1\":{\"641\":1}}],[\"当用户首次访问web应用并且需要创建会话时\",{\"1\":{\"630\":1}}],[\"当用户调用\",{\"1\":{\"226\":1}}],[\"当前时间更新到高16位\",{\"1\":{\"903\":1}}],[\"当前记录写到的位置\",{\"1\":{\"810\":1}}],[\"当前读语句\",{\"1\":{\"794\":1}}],[\"当前读\",{\"1\":{\"783\":1}}],[\"当前字符集一个字符的字节大小\",{\"1\":{\"770\":1}}],[\"当前行可用最大字节\",{\"1\":{\"770\":2}}],[\"当前在线用户数\",{\"1\":{\"641\":4}}],[\"当前活跃会话数\",{\"1\":{\"625\":2}}],[\"当前channel没有正在阻塞等待接受数据的goroutine\",{\"1\":{\"264\":1}}],[\"当前channel有正在阻塞等待接受数据的goroutine\",{\"1\":{\"264\":1}}],[\"当这些事件发生时\",{\"1\":{\"614\":1}}],[\"当这些页再次被访问时\",{\"1\":{\"217\":1}}],[\"当web应用关闭时\",{\"1\":{\"629\":1}}],[\"当web应用关闭或重新加载时\",{\"1\":{\"592\":1}}],[\"当web应用启动时\",{\"1\":{\"590\":1,\"629\":1}}],[\"当请求处理完成时\",{\"1\":{\"631\":1}}],[\"当请求到达web应用时\",{\"1\":{\"631\":1}}],[\"当请求到达web应用并匹配filter的url模式时\",{\"1\":{\"591\":1}}],[\"当请求访问\",{\"1\":{\"512\":1}}],[\"当b为0时抛出arithmeticexception\",{\"1\":{\"540\":1}}],[\"当方法中发生错误时\",{\"1\":{\"537\":1}}],[\"当写多的时候\",{\"1\":{\"527\":1}}],[\"当某一种类型实现了所有这些声明的方法\",{\"1\":{\"464\":1}}],[\"当某个订阅者订阅了某个频道\",{\"1\":{\"924\":1}}],[\"当某个\",{\"1\":{\"226\":1}}],[\"当我们需要查找当前元素的上一个元素\",{\"1\":{\"879\":1}}],[\"当我们要对\",{\"1\":{\"873\":1}}],[\"当我们查询一条记录时\",{\"1\":{\"810\":1}}],[\"当我们输入go\",{\"1\":{\"396\":1}}],[\"当我们对切片进行赋值操作时\",{\"1\":{\"342\":1}}],[\"当\",{\"1\":{\"374\":2,\"487\":1,\"516\":1,\"524\":1,\"527\":1,\"756\":1,\"757\":2,\"810\":6,\"820\":6,\"879\":1,\"897\":1,\"906\":1,\"930\":1}}],[\"当键值对不够8个时\",{\"1\":{\"330\":1}}],[\"当defer无法在栈上分配时\",{\"1\":{\"291\":1}}],[\"当channel没有可读的数据\",{\"1\":{\"256\":1}}],[\"当浏览器下次请求别的资源的时候\",{\"1\":{\"249\":1}}],[\"当服务器收到\",{\"1\":{\"249\":1}}],[\"当服务端要断开的时候\",{\"1\":{\"237\":1}}],[\"当数据越多时\",{\"1\":{\"813\":1}}],[\"当数据表的字段都定义成\",{\"1\":{\"770\":1}}],[\"当数据表没有变长字段的时候\",{\"1\":{\"770\":1}}],[\"当数据准备好时\",{\"1\":{\"226\":1}}],[\"当数据包发送到一个接口时\",{\"1\":{\"123\":1}}],[\"当任何一个i\",{\"1\":{\"226\":1}}],[\"当应用程序执行i\",{\"1\":{\"226\":1}}],[\"当然cache\",{\"1\":{\"930\":1}}],[\"当然这种模式可能会有时序性问题\",{\"1\":{\"930\":1}}],[\"当然其他线程对学生表进行写操作时也会被阻塞\",{\"1\":{\"820\":1}}],[\"当然是会影响插入性能的\",{\"1\":{\"813\":1}}],[\"当然是缓存起来好\",{\"1\":{\"747\":1,\"810\":1}}],[\"当然还会受到系统文件描述符限制\",{\"1\":{\"226\":1}}],[\"当然\",{\"1\":{\"223\":2,\"770\":1,\"820\":3,\"903\":1}}],[\"当然系统也提供了参数\",{\"1\":{\"217\":1}}],[\"当父\",{\"1\":{\"217\":1}}],[\"当进程访问的虚拟地址在页表中查不到时\",{\"1\":{\"217\":1}}],[\"当主节点挂了\",{\"1\":{\"916\":1,\"921\":1}}],[\"当主节点掉线后\",{\"1\":{\"180\":1}}],[\"当主题的分区数量发生变化时\",{\"1\":{\"165\":1}}],[\"当不使用消费者组时\",{\"1\":{\"164\":1}}],[\"当生产者向server传递了消息之后\",{\"1\":{\"156\":1}}],[\"当使用左\",{\"1\":{\"813\":1}}],[\"当使用xa事务\",{\"1\":{\"810\":1}}],[\"当使用go\",{\"1\":{\"229\":1}}],[\"当使用\",{\"1\":{\"117\":1}}],[\"当使用mq消息中间件时候\",{\"1\":{\"23\":1}}],[\"当执行插入\",{\"1\":{\"820\":1}}],[\"当执行下面的命令时\",{\"1\":{\"229\":1}}],[\"当执行\",{\"1\":{\"104\":1,\"217\":1}}],[\"当所有shared\",{\"1\":{\"33\":1}}],[\"当计数为0的时候会自动的释放动态分配的资源\",{\"1\":{\"33\":1}}],[\"当对象的name和传入对象的name指向相同的地址\",{\"1\":{\"33\":1}}],[\"拷贝\",{\"1\":{\"453\":1}}],[\"拷贝出来的\",{\"1\":{\"307\":1}}],[\"拷贝构造函数\",{\"1\":{\"33\":3}}],[\"拷贝的指针和原来的指针指向同一块地址\",{\"1\":{\"33\":1}}],[\"拷贝的是一个固定字节的地址变量\",{\"1\":{\"33\":1}}],[\"~75\",{\"1\":{\"807\":1}}],[\"~\",{\"1\":{\"33\":1,\"147\":1,\"770\":1}}],[\"~student\",{\"1\":{\"33\":6}}],[\"~myclass\",{\"1\":{\"33\":1}}],[\"即暴力攻击\",{\"1\":{\"1052\":1}}],[\"即文件名和行号\",{\"1\":{\"957\":1}}],[\"即可\",{\"1\":{\"957\":1}}],[\"即可以提交事务\",{\"1\":{\"810\":1}}],[\"即调用系统的flush函数\",{\"1\":{\"952\":1}}],[\"即把数据保存到可永久保存的存储设备中\",{\"1\":{\"952\":1}}],[\"即对象\",{\"1\":{\"937\":1}}],[\"即不同的\",{\"1\":{\"930\":1}}],[\"即不会对服务器上的资源造成实质的修改\",{\"1\":{\"249\":1}}],[\"即单独起这么一个服务\",{\"1\":{\"930\":1}}],[\"即一个模式消息\",{\"1\":{\"924\":1}}],[\"即一次将同组事务的\",{\"1\":{\"810\":1}}],[\"即记录每个\",{\"1\":{\"906\":1}}],[\"即全部\",{\"1\":{\"900\":1}}],[\"即当前地址\",{\"1\":{\"879\":1}}],[\"即负载率小于\",{\"1\":{\"864\":1}}],[\"即两个事务可以同时持有包含共同间隙的间隙锁\",{\"1\":{\"820\":1}}],[\"即两个事务可以同时持有包含共同间隙范围的间隙锁\",{\"1\":{\"820\":1}}],[\"即能保护该记录\",{\"1\":{\"820\":1}}],[\"即xid\",{\"1\":{\"810\":1}}],[\"即提高了数据库的整体吞吐量和并发能力\",{\"1\":{\"807\":1}}],[\"即便系统故障也不会丢失\",{\"1\":{\"774\":1}}],[\"即01\",{\"1\":{\"770\":1}}],[\"即每类业务自己一个分区\",{\"1\":{\"720\":1}}],[\"即扩展名为\",{\"1\":{\"566\":1}}],[\"即多个数据\",{\"1\":{\"867\":1}}],[\"即多线程访问同一资源需要加锁进行保证互斥\",{\"1\":{\"381\":1}}],[\"即多次\",{\"1\":{\"249\":1}}],[\"即包含开始索引但不包含结束索引\",{\"1\":{\"341\":1}}],[\"即赋值给这个接口的具体类型信息的元数据\",{\"1\":{\"307\":1}}],[\"即创建无缓冲区的channel\",{\"1\":{\"263\":1}}],[\"即是通道可以传递的消息类型\",{\"1\":{\"263\":1}}],[\"即找到一个d\",{\"1\":{\"249\":1}}],[\"即epoll使用mmap减少复制开销\",{\"1\":{\"226\":1}}],[\"即epoll最大的优点就在于它只管你\",{\"1\":{\"226\":1}}],[\"即cpu\",{\"1\":{\"220\":1}}],[\"即在一段时间内\",{\"1\":{\"217\":1}}],[\"即在当地执行\",{\"1\":{\"36\":1}}],[\"即它们已经复制了\",{\"1\":{\"181\":1}}],[\"即消费者\",{\"1\":{\"156\":1}}],[\"即kafka服务\",{\"1\":{\"156\":1}}],[\"即\",{\"1\":{\"123\":1,\"220\":1,\"516\":1,\"820\":1,\"873\":1,\"879\":1,\"930\":2,\"957\":1}}],[\"即通过\",{\"1\":{\"121\":1}}],[\"即通过哈希算法对数据取哈希值\",{\"1\":{\"81\":1}}],[\"即等待\",{\"1\":{\"104\":1}}],[\"即容器运行着真正的应用进程\",{\"1\":{\"98\":1}}],[\"即具有静态存储持续性\",{\"1\":{\"33\":1}}],[\"即该变量只能在定义它的文件中访问\",{\"1\":{\"33\":1}}],[\"即其存在与否并不影响对象的引用计数器\",{\"1\":{\"33\":1}}],[\"即使两层md5算法加密\",{\"1\":{\"1051\":1}}],[\"即使零值也会保存\",{\"1\":{\"997\":1}}],[\"即使其他事务更新了表的数据\",{\"1\":{\"820\":1}}],[\"即使管理员中途修改了该用户的权限\",{\"1\":{\"817\":1}}],[\"即使主机发生异常重启\",{\"1\":{\"810\":1}}],[\"即使主库宕机\",{\"1\":{\"730\":1,\"761\":1}}],[\"即使出现主库宕机\",{\"1\":{\"810\":1}}],[\"即使数据库崩溃了\",{\"1\":{\"810\":1}}],[\"即使数据相同\",{\"1\":{\"249\":1}}],[\"即使中途有其他事务插入了一条数据\",{\"1\":{\"783\":1}}],[\"即使没有显式输入begin开启事务和commit提交事务\",{\"1\":{\"739\":1}}],[\"即使消费者在处理消息时发生故障\",{\"1\":{\"711\":1}}],[\"即使有协程阻塞\",{\"1\":{\"378\":1}}],[\"即使有weak\",{\"1\":{\"33\":1}}],[\"即使文件描述符仍然处于就绪状态\",{\"1\":{\"226\":1}}],[\"即使程序不足一页大小\",{\"1\":{\"217\":1}}],[\"即使部分副本数据丢失\",{\"1\":{\"176\":1}}],[\"即使容器被删除\",{\"1\":{\"106\":1}}],[\"即使原先的对象被析构掉\",{\"1\":{\"33\":1}}],[\"即起别名\",{\"1\":{\"30\":1}}],[\"浅拷贝执行结果\",{\"1\":{\"33\":1}}],[\"浅拷贝只是拷贝一个指针\",{\"1\":{\"33\":1}}],[\"浅拷贝\",{\"1\":{\"33\":2}}],[\"浅拷贝和深拷贝\",{\"1\":{\"33\":1}}],[\"释放了锁\",{\"1\":{\"820\":1}}],[\"释放间隙锁的时刻\",{\"1\":{\"820\":1}}],[\"释放\",{\"1\":{\"820\":2,\"873\":1}}],[\"释放其他资源\",{\"1\":{\"640\":1}}],[\"释放资源\",{\"1\":{\"592\":1,\"624\":1}}],[\"释放互斥锁\",{\"1\":{\"531\":1}}],[\"释放操作后立即置空\",{\"1\":{\"33\":1}}],[\"释放内存的处理不同\",{\"1\":{\"217\":1}}],[\"释放内存了也不会影响到深拷贝得到的值\",{\"1\":{\"33\":1}}],[\"释放内存\",{\"1\":{\"33\":1}}],[\"悬空指针\",{\"1\":{\"33\":1}}],[\"野指针\",{\"1\":{\"33\":1}}],[\"野指针和悬空指针\",{\"1\":{\"33\":1}}],[\"要显示的日志等级\",{\"1\":{\"980\":1}}],[\"要显示的日志条数\",{\"1\":{\"146\":1}}],[\"要表明数据强一致性\",{\"1\":{\"952\":1}}],[\"要是有人利用不存在的key频繁攻击我们的应用\",{\"1\":{\"930\":1}}],[\"要是超卖数量过多\",{\"1\":{\"927\":1}}],[\"要放入的意思\",{\"1\":{\"906\":1}}],[\"要翻看内容可以直接通过目录找到页数\",{\"1\":{\"864\":1}}],[\"要赋予给用户的权限\",{\"1\":{\"846\":1}}],[\"要向用户授予权限\",{\"1\":{\"838\":1}}],[\"要看条件值的记录是否存在于表中\",{\"1\":{\"820\":1}}],[\"要看排序的数据量是否超过\",{\"1\":{\"813\":1}}],[\"要加上\",{\"1\":{\"820\":1}}],[\"要加分号标识结束\",{\"1\":{\"33\":1}}],[\"要解决这问题\",{\"1\":{\"820\":1}}],[\"要解决办法很简单\",{\"1\":{\"813\":1}}],[\"要释放表锁\",{\"1\":{\"820\":1}}],[\"要使用全局锁\",{\"1\":{\"820\":1}}],[\"要关注数据库引擎是否能够通过索引覆盖或者覆盖索引来提高查询性能\",{\"1\":{\"813\":1}}],[\"要不追求性能\",{\"1\":{\"810\":1}}],[\"要不追求数据安全性\",{\"1\":{\"810\":1}}],[\"要不全部失败\",{\"1\":{\"764\":1,\"810\":1}}],[\"要写到磁盘\",{\"1\":{\"810\":1}}],[\"要手动设置自增步长起始值\",{\"1\":{\"807\":1}}],[\"要慎用\",{\"1\":{\"807\":1}}],[\"要避免这类特殊场景下发生幻读的现象的话\",{\"1\":{\"795\":1}}],[\"要保证所有字段的长度\",{\"1\":{\"770\":1}}],[\"要算\",{\"1\":{\"770\":1}}],[\"要按\",{\"1\":{\"770\":1}}],[\"要把被更新的列的旧值记下来\",{\"1\":{\"741\":1,\"810\":1}}],[\"要把这条记录中的内容都记下来\",{\"1\":{\"741\":1,\"810\":1}}],[\"要把这条记录的主键值记下来\",{\"1\":{\"741\":1,\"810\":1}}],[\"要把回滚时需要的信息都记录到\",{\"1\":{\"741\":1,\"810\":1}}],[\"要怎么回滚到事务之前的数据呢\",{\"1\":{\"739\":1,\"810\":1}}],[\"要么先记\",{\"1\":{\"820\":1}}],[\"要么都不成功\",{\"1\":{\"813\":1}}],[\"要么都成功\",{\"1\":{\"813\":1}}],[\"要么全部不完成\",{\"1\":{\"774\":1}}],[\"要么全部完成\",{\"1\":{\"774\":1}}],[\"要么全部失败\",{\"1\":{\"727\":1}}],[\"要么置空\",{\"1\":{\"33\":1}}],[\"要消息队列配合业务逻辑配合完成\",{\"1\":{\"712\":1}}],[\"要携带acks\",{\"1\":{\"710\":1}}],[\"要实现一个相对可靠的分布式锁机制\",{\"1\":{\"918\":1,\"921\":1}}],[\"要实现真的主从故障转移的话\",{\"1\":{\"730\":1}}],[\"要实现外部接口\",{\"1\":{\"471\":1}}],[\"要实现\",{\"1\":{\"469\":1}}],[\"要完全复制一个切片\",{\"1\":{\"346\":1}}],[\"要读取或者要写入当前的channel的goroutine列表\",{\"1\":{\"259\":1}}],[\"要到新的url请求资源\",{\"1\":{\"240\":1}}],[\"要删除的文件或目录\",{\"1\":{\"209\":1}}],[\"要求基类函数必须是虚函数\",{\"1\":{\"33\":1}}],[\"要快\",{\"1\":{\"20\":1}}],[\"主线程会在事件循环\",{\"1\":{\"897\":1}}],[\"主线程使用\",{\"1\":{\"897\":1}}],[\"主线程和\",{\"1\":{\"897\":1}}],[\"主线程视角\",{\"1\":{\"897\":1}}],[\"主键列表查询\",{\"0\":{\"994\":1}}],[\"主键查询\",{\"0\":{\"989\":1}}],[\"主键\",{\"1\":{\"983\":2}}],[\"主键冲突\",{\"1\":{\"820\":1}}],[\"主键外的索引\",{\"1\":{\"817\":1}}],[\"主键索引为\",{\"1\":{\"820\":1}}],[\"主键索引冲突\",{\"1\":{\"820\":1}}],[\"主键索引查询\",{\"1\":{\"817\":3}}],[\"主键索引陷阱\",{\"1\":{\"813\":1}}],[\"主键索引也叫聚集索引\",{\"1\":{\"813\":1}}],[\"主键索引\",{\"1\":{\"813\":2,\"817\":1}}],[\"主\",{\"1\":{\"810\":1}}],[\"主节点没崩溃\",{\"1\":{\"952\":1}}],[\"主节点数据变更后\",{\"1\":{\"807\":1}}],[\"主节点是可见的\",{\"1\":{\"180\":1}}],[\"主从容灾\",{\"0\":{\"916\":1},\"1\":{\"915\":1,\"921\":2}}],[\"主从库就发生了数据不一致\",{\"1\":{\"820\":1}}],[\"主从架构\",{\"1\":{\"807\":1}}],[\"主从架构中\",{\"1\":{\"730\":1}}],[\"主从读写分离\",{\"1\":{\"807\":1}}],[\"主从复制的场景\",{\"1\":{\"820\":1}}],[\"主从复制的数据延迟怎么解决\",{\"1\":{\"730\":1}}],[\"主从复制还有哪些模型\",{\"1\":{\"810\":1}}],[\"主从复制是怎么实现\",{\"1\":{\"810\":1}}],[\"主从复制\",{\"1\":{\"810\":1}}],[\"主从复制中\",{\"1\":{\"810\":1}}],[\"主从复制等\",{\"1\":{\"759\":1}}],[\"主从复制没有实现发现主服务器宕机和处理故障迁移的功能\",{\"1\":{\"730\":1}}],[\"主从同步模型\",{\"0\":{\"761\":1}}],[\"主从同步过程\",{\"1\":{\"730\":1,\"761\":1}}],[\"主从同步\",{\"1\":{\"730\":1},\"2\":{\"732\":1}}],[\"主库的自增值是什么\",{\"1\":{\"820\":1}}],[\"主库的事务线程就可以返回给客户端\",{\"1\":{\"810\":1}}],[\"主库和备库的数据就保证了一致性\",{\"1\":{\"810\":1}}],[\"主库和所有从库任何一个数据库出问题\",{\"1\":{\"810\":1}}],[\"主库也要创建同样多的\",{\"1\":{\"810\":1}}],[\"主库在收到客户端提交事务的请求之后\",{\"1\":{\"810\":1}}],[\"主库写\",{\"1\":{\"810\":1}}],[\"主库掉了怎么办\",{\"1\":{\"730\":1}}],[\"主库提交事务的线程并不会等待\",{\"1\":{\"810\":1}}],[\"主库提交事务的线程要等待所有从库的复制成功响应\",{\"1\":{\"810\":1}}],[\"主库提交事务的线程要等待所有从库的同步成功\",{\"1\":{\"730\":1,\"761\":1}}],[\"主库提交事务的线程不会等待\",{\"1\":{\"730\":1,\"761\":1}}],[\"主库会创建一个\",{\"1\":{\"730\":1,\"761\":1}}],[\"主库修改数据后\",{\"1\":{\"730\":1,\"761\":1}}],[\"主库\",{\"1\":{\"730\":1,\"820\":1}}],[\"主动执\",{\"1\":{\"952\":1}}],[\"主动执行\",{\"1\":{\"952\":1}}],[\"主动删除redis数据只是为了减少不一致的时间\",{\"1\":{\"930\":1}}],[\"主动回滚死锁链条中的某一个事务\",{\"1\":{\"820\":1}}],[\"主动死锁检测在发现死锁后\",{\"1\":{\"820\":1}}],[\"主动调用提交函数\",{\"1\":{\"711\":1}}],[\"主动拉取消息\",{\"1\":{\"160\":1}}],[\"主机掉电的时候会丢数据\",{\"1\":{\"810\":1}}],[\"主机掉电时会丢\",{\"1\":{\"810\":1}}],[\"主机名可以是\",{\"1\":{\"249\":1}}],[\"主机不能ping通虚拟机\",{\"1\":{\"246\":1}}],[\"主机不断响应\",{\"1\":{\"243\":1}}],[\"主机资源耗尽\",{\"1\":{\"243\":1}}],[\"主机端口\",{\"1\":{\"139\":2}}],[\"主机可以跟容器通信\",{\"1\":{\"123\":1}}],[\"主要体现在\",{\"1\":{\"1020\":1}}],[\"主要是\",{\"1\":{\"930\":1}}],[\"主要是因为\",{\"1\":{\"770\":1}}],[\"主要思路\",{\"1\":{\"927\":1}}],[\"主要考虑到使用同一个网络的用户\",{\"1\":{\"927\":1}}],[\"主要考虑出现异常\",{\"1\":{\"882\":1}}],[\"主要包括连接器\",{\"1\":{\"817\":1}}],[\"主要包含\",{\"1\":{\"800\":1}}],[\"主要包含表结构定义\",{\"1\":{\"770\":1}}],[\"主要有三种\",{\"1\":{\"810\":1}}],[\"主要有下面几个时机\",{\"1\":{\"810\":1}}],[\"主要有两个方面的影响\",{\"1\":{\"766\":1,\"810\":1}}],[\"主要有两个原因\",{\"1\":{\"237\":1}}],[\"主要\",{\"1\":{\"810\":3}}],[\"主要从存储机制\",{\"1\":{\"770\":1}}],[\"主要的区别在于处理行溢出数据时有些区别\",{\"1\":{\"770\":1}}],[\"主要的几个刷盘时机\",{\"1\":{\"756\":1}}],[\"主要关注用户记录\",{\"1\":{\"748\":1}}],[\"主要请求动态页面\",{\"1\":{\"243\":1}}],[\"主要用来存放服务数据\",{\"1\":{\"223\":1}}],[\"主要用于数据备份和主从复制\",{\"1\":{\"737\":1}}],[\"主要用于掉电等故障恢复\",{\"1\":{\"737\":1}}],[\"主要用于事务回滚和mvcc\",{\"1\":{\"737\":1}}],[\"主要用于处理客户端的http请求并生成响应\",{\"1\":{\"646\":1}}],[\"主要用于读取用户输入的命令\",{\"1\":{\"190\":1}}],[\"主要用于定义类型别名\",{\"1\":{\"33\":1}}],[\"主要用于定义常量及书写复杂的内容\",{\"1\":{\"33\":1}}],[\"主要由客户端和服务端两大部分组成\",{\"1\":{\"100\":1}}],[\"主题分区变化\",{\"1\":{\"165\":1}}],[\"主题是一个逻辑概念\",{\"1\":{\"157\":1}}],[\"主题是kafka中的一个核心概念\",{\"1\":{\"157\":1}}],[\"主题\",{\"0\":{\"5\":1}}],[\"的模版文件放在\",{\"1\":{\"1031\":1}}],[\"的模拟过程\",{\"1\":{\"374\":1}}],[\"的初始化\",{\"0\":{\"1022\":1}}],[\"的字段\",{\"1\":{\"982\":1}}],[\"的字符串\",{\"1\":{\"33\":1,\"249\":1}}],[\"的默认日志是打印\",{\"1\":{\"980\":1}}],[\"的默认存储引擎\",{\"1\":{\"817\":1}}],[\"的更多使用方式可以参考官方文档\",{\"1\":{\"957\":1}}],[\"的更新\",{\"1\":{\"106\":1}}],[\"的特点及使用\",{\"1\":{\"957\":1}}],[\"的特点和用法都已了然于心\",{\"1\":{\"957\":1}}],[\"的特殊目录\",{\"1\":{\"106\":1}}],[\"的介绍\",{\"1\":{\"957\":1}}],[\"的系统时钟\",{\"1\":{\"957\":1}}],[\"的系统变量\",{\"1\":{\"820\":1}}],[\"的性能对比同样可以在官方\",{\"1\":{\"957\":1}}],[\"的性能高\",{\"1\":{\"810\":1}}],[\"的原因\",{\"1\":{\"957\":1}}],[\"的代码实现\",{\"1\":{\"957\":1}}],[\"的建议是每秒刷一次\",{\"1\":{\"952\":1}}],[\"的地址\",{\"1\":{\"944\":1}}],[\"的地方\",{\"1\":{\"944\":1}}],[\"的地方做了\",{\"1\":{\"752\":1}}],[\"的层层理解\",{\"1\":{\"944\":1}}],[\"的重点字段\",{\"1\":{\"943\":1}}],[\"的重新实现\",{\"1\":{\"190\":1}}],[\"的图示\",{\"1\":{\"939\":2}}],[\"的思路简单理解\",{\"1\":{\"936\":1}}],[\"的基本使用方法和一些高级特性\",{\"1\":{\"973\":1}}],[\"的基本用法\",{\"0\":{\"483\":1}}],[\"的基础上\",{\"1\":{\"930\":1}}],[\"的热点数据之上\",{\"1\":{\"930\":1}}],[\"的流量在20\",{\"1\":{\"930\":1}}],[\"的流程\",{\"1\":{\"913\":1,\"921\":1}}],[\"的流程如下\",{\"1\":{\"810\":2}}],[\"的候选池\",{\"1\":{\"906\":1}}],[\"的近似\",{\"1\":{\"906\":1}}],[\"的最近访问时间\",{\"1\":{\"906\":1}}],[\"的最主要目的是防止头文件的重复包含和编译\",{\"1\":{\"36\":1}}],[\"的键\",{\"1\":{\"900\":1}}],[\"的读写请求过来\",{\"1\":{\"897\":1}}],[\"的主线程入口\",{\"1\":{\"897\":1}}],[\"的主从复制依赖于\",{\"1\":{\"810\":1}}],[\"的定位是内存的\",{\"1\":{\"891\":1}}],[\"的跳表实现\",{\"1\":{\"885\":1}}],[\"的灵魂所在\",{\"1\":{\"885\":1}}],[\"的三个字段就是上面的\",{\"1\":{\"879\":1}}],[\"的三个状态\",{\"0\":{\"523\":1}}],[\"的总字节数大于\",{\"1\":{\"879\":1}}],[\"的总字节数都接近\",{\"1\":{\"879\":1}}],[\"的编码规则复杂\",{\"1\":{\"879\":1}}],[\"的编码模式取代了\",{\"1\":{\"867\":1}}],[\"的长度信息\",{\"1\":{\"879\":1}}],[\"的开头\",{\"1\":{\"879\":1}}],[\"的底层数据结构\",{\"1\":{\"879\":1}}],[\"的底层原理\",{\"0\":{\"526\":1}}],[\"的进阶版本\",{\"1\":{\"879\":1}}],[\"的边界\",{\"1\":{\"873\":1}}],[\"的空间\",{\"1\":{\"873\":1}}],[\"的空间不是固定\",{\"1\":{\"770\":1}}],[\"的位数\",{\"1\":{\"873\":1}}],[\"的所有键值对都会存储在这里\",{\"1\":{\"942\":1}}],[\"的所有\",{\"1\":{\"873\":1}}],[\"的所有数据会被\",{\"1\":{\"864\":1}}],[\"的名字一样\",{\"1\":{\"867\":1}}],[\"的限制\",{\"1\":{\"867\":2}}],[\"的负载情况\",{\"1\":{\"864\":1}}],[\"的密码\",{\"1\":{\"854\":1}}],[\"的查询结果会增加一条字段\",{\"1\":{\"823\":1}}],[\"的例子\",{\"1\":{\"820\":2}}],[\"的插入操作生成了一个插入意向锁\",{\"1\":{\"820\":1}}],[\"的next\",{\"1\":{\"820\":1}}],[\"的nil\",{\"1\":{\"526\":1}}],[\"的情况\",{\"1\":{\"820\":1}}],[\"的情况下\",{\"1\":{\"765\":1,\"770\":1,\"810\":2,\"820\":1,\"873\":2}}],[\"的机制实现的快照读\",{\"1\":{\"820\":1}}],[\"的范围查询\",{\"1\":{\"820\":2}}],[\"的上一条记录的\",{\"1\":{\"820\":1}}],[\"的这条记录中加了锁类型为\",{\"1\":{\"820\":1}}],[\"的这条记录就会加上\",{\"1\":{\"820\":1}}],[\"的这条记录加上了\",{\"1\":{\"820\":1}}],[\"的这条记录加上\",{\"1\":{\"820\":1}}],[\"的新记录\",{\"1\":{\"820\":2}}],[\"的组织形式\",{\"1\":{\"944\":1}}],[\"的组合\",{\"1\":{\"820\":2}}],[\"的组提交\",{\"1\":{\"810\":4}}],[\"的组提交逻辑中\",{\"1\":{\"810\":1}}],[\"的日志格式是\",{\"1\":{\"820\":1}}],[\"的日志内容\",{\"1\":{\"752\":1}}],[\"的期间\",{\"1\":{\"820\":2}}],[\"的存储引擎\",{\"1\":{\"820\":1}}],[\"的支持\",{\"1\":{\"820\":1}}],[\"的条件进行排序\",{\"1\":{\"823\":1}}],[\"的条件\",{\"1\":{\"817\":1}}],[\"的工作交给了存储引擎层\",{\"1\":{\"817\":1}}],[\"的第一条记录\",{\"1\":{\"817\":2}}],[\"的函数\",{\"1\":{\"817\":1}}],[\"的成本大\",{\"1\":{\"817\":1}}],[\"的执行速度只有被吊打的份\",{\"1\":{\"956\":1}}],[\"的执行过程\",{\"1\":{\"817\":1}}],[\"的执行顺序\",{\"1\":{\"511\":1}}],[\"的意思就是对\",{\"1\":{\"813\":1}}],[\"的意义\",{\"0\":{\"747\":1},\"1\":{\"747\":1}}],[\"的话\",{\"1\":{\"813\":1}}],[\"的优势是缓存对业务透明\",{\"1\":{\"930\":1}}],[\"的优化\",{\"1\":{\"867\":1}}],[\"的优化器的选择基于成本\",{\"1\":{\"813\":1}}],[\"的优化机制\",{\"1\":{\"813\":1}}],[\"的优先级高于\",{\"1\":{\"249\":1}}],[\"的冗余节点\",{\"1\":{\"813\":1}}],[\"的页无法存放那么多数据\",{\"1\":{\"813\":1}}],[\"的页来说\",{\"1\":{\"770\":1}}],[\"的树开始\",{\"1\":{\"813\":1}}],[\"的频率\",{\"1\":{\"810\":1}}],[\"的频率由参数\",{\"1\":{\"760\":1}}],[\"的设置\",{\"1\":{\"810\":1}}],[\"的事情了\",{\"1\":{\"810\":1}}],[\"的事务并没有提交\",{\"1\":{\"820\":1}}],[\"的事务\",{\"1\":{\"793\":1}}],[\"的事务id\",{\"1\":{\"744\":1}}],[\"的线程\",{\"1\":{\"810\":1}}],[\"的线程同步完成\",{\"1\":{\"810\":1}}],[\"的中继日志里\",{\"1\":{\"810\":1}}],[\"的响应\",{\"1\":{\"810\":2}}],[\"的响应内容并不包含\",{\"1\":{\"249\":1}}],[\"的缺点是每行数据的变化结果都会被记录\",{\"1\":{\"810\":1}}],[\"的移动都是顺时针方向\",{\"1\":{\"810\":1}}],[\"的脏页刷新到了磁盘中\",{\"1\":{\"810\":1}}],[\"的脏页刷新到磁盘里\",{\"1\":{\"751\":1,\"810\":1}}],[\"的大小小于\",{\"1\":{\"879\":1}}],[\"的大小是固定且一致的\",{\"1\":{\"810\":1}}],[\"的大小划分出一个个的页\",{\"1\":{\"748\":1,\"810\":1}}],[\"的策略\",{\"1\":{\"810\":2}}],[\"的能力\",{\"1\":{\"810\":2}}],[\"的版本链找到满足其可见性的记录\",{\"1\":{\"810\":1}}],[\"的记录加\",{\"1\":{\"820\":1}}],[\"的记录加什么锁\",{\"1\":{\"820\":1}}],[\"的记录加了什么锁\",{\"1\":{\"820\":1}}],[\"的记录上的\",{\"1\":{\"820\":1}}],[\"的记录和已有记录存在唯一键冲突\",{\"1\":{\"820\":1}}],[\"的记录就会被锁住\",{\"1\":{\"820\":1}}],[\"的记录的时候\",{\"1\":{\"820\":2}}],[\"的记录后\",{\"1\":{\"817\":1}}],[\"的记录并不是有序的\",{\"1\":{\"813\":1}}],[\"的记录并提交\",{\"1\":{\"793\":1,\"794\":1}}],[\"的记录\",{\"1\":{\"793\":3,\"820\":8,\"999\":2}}],[\"的列存储到\",{\"1\":{\"770\":1}}],[\"的命中率\",{\"1\":{\"770\":1}}],[\"的变长字段的长度\",{\"1\":{\"770\":1}}],[\"的内置类型都定义了对应的\",{\"1\":{\"957\":1}}],[\"的内容\",{\"1\":{\"810\":1}}],[\"的内容到内存中\",{\"1\":{\"770\":1}}],[\"的内存位置可能是\",{\"1\":{\"456\":1}}],[\"的内存有什么区别\",{\"1\":{\"217\":1}}],[\"的内存来存储页表\",{\"1\":{\"217\":1}}],[\"的内存来存页表\",{\"1\":{\"217\":1}}],[\"的连续存储空间\",{\"1\":{\"770\":1}}],[\"的连接\",{\"1\":{\"226\":1}}],[\"的表数据会保存在这个文件\",{\"1\":{\"770\":1}}],[\"的表结构会保存在这个文件\",{\"1\":{\"770\":1}}],[\"的次数\",{\"1\":{\"767\":1,\"810\":1}}],[\"的次数足够多时\",{\"1\":{\"516\":1}}],[\"的场景\",{\"1\":{\"759\":1}}],[\"的后台线程每隔\",{\"1\":{\"756\":1,\"810\":2}}],[\"的刷盘次数\",{\"1\":{\"810\":1}}],[\"的刷盘延迟到了\",{\"1\":{\"810\":1}}],[\"的刷盘时机如下图\",{\"1\":{\"810\":1}}],[\"的刷盘时机\",{\"0\":{\"756\":1}}],[\"的刷盘策略\",{\"0\":{\"755\":1}}],[\"的刷盘策略是一样的\",{\"1\":{\"745\":1}}],[\"的持久化如下图\",{\"1\":{\"755\":1}}],[\"的配置文件\",{\"1\":{\"952\":1}}],[\"的配置文件就不在\",{\"1\":{\"223\":1}}],[\"的配合\",{\"0\":{\"753\":1}}],[\"的写操作并不是立刻更新到磁盘上\",{\"1\":{\"810\":1}}],[\"的写操作并不是立刻写到磁盘上\",{\"1\":{\"751\":1,\"810\":3}}],[\"的写操作从磁盘的\",{\"1\":{\"810\":1}}],[\"的写入速度还是比较快的\",{\"1\":{\"810\":1}}],[\"的写入拆成了两个步骤\",{\"1\":{\"765\":1,\"810\":1}}],[\"的写入是顺序写入\",{\"1\":{\"754\":1}}],[\"的写时复制\",{\"1\":{\"217\":1}}],[\"的四个字段\",{\"0\":{\"787\":1},\"1\":{\"744\":1}}],[\"的比对\",{\"1\":{\"743\":1,\"810\":1}}],[\"的消息总是会映射到同一个哈希槽\",{\"1\":{\"723\":1}}],[\"的消息较为滞后\",{\"1\":{\"183\":1}}],[\"的哈希值\",{\"1\":{\"723\":1}}],[\"的困难\",{\"0\":{\"706\":1}}],[\"的路径匹配\",{\"1\":{\"656\":1}}],[\"的属性\",{\"1\":{\"637\":2}}],[\"的请求和响应\",{\"1\":{\"578\":1}}],[\"的过程拆解\",{\"1\":{\"813\":1}}],[\"的过程就是脏页刷新到磁盘中变成干净页\",{\"1\":{\"810\":1}}],[\"的过程\",{\"1\":{\"527\":1,\"529\":1}}],[\"的过期时间是给一个\",{\"1\":{\"882\":1}}],[\"的过期时间\",{\"1\":{\"249\":1}}],[\"的不足\",{\"0\":{\"527\":1}}],[\"的值先变成\",{\"1\":{\"930\":1}}],[\"的值原本是\",{\"1\":{\"810\":1}}],[\"的值\",{\"1\":{\"737\":2,\"810\":3,\"820\":1,\"1037\":2}}],[\"的值为\",{\"1\":{\"524\":1}}],[\"的值变成\",{\"1\":{\"524\":1}}],[\"的数据类型使用\",{\"1\":{\"957\":1}}],[\"的数据会更完整\",{\"1\":{\"949\":1}}],[\"的数据对象以及底层编码方式作深入展开\",{\"1\":{\"936\":1}}],[\"的数据在内存中的组织过程\",{\"1\":{\"936\":2}}],[\"的数据或id为特别大不存在的数据\",{\"1\":{\"930\":1}}],[\"的数据到\",{\"1\":{\"864\":1}}],[\"的数据都是以键值对形式存在内存中\",{\"1\":{\"894\":1}}],[\"的数据都是存放在\",{\"1\":{\"770\":1}}],[\"的数据都是存在磁盘中的\",{\"1\":{\"747\":1,\"810\":1}}],[\"的数据都可以说是发生了索引覆盖\",{\"1\":{\"813\":1}}],[\"的数据并提交了\",{\"1\":{\"780\":1}}],[\"的数据时\",{\"1\":{\"770\":1}}],[\"的数据库表\",{\"1\":{\"770\":1}}],[\"的数据是按\",{\"1\":{\"770\":1}}],[\"的数据存放在哪个文件\",{\"1\":{\"770\":1}}],[\"的数据状态\",{\"1\":{\"737\":2,\"810\":2}}],[\"的数据不全\",{\"1\":{\"529\":2}}],[\"的数据不一致\",{\"1\":{\"525\":1}}],[\"的数据流转过程\",{\"1\":{\"527\":1}}],[\"的数据\",{\"1\":{\"525\":1,\"780\":1,\"885\":2}}],[\"的数据过来\",{\"1\":{\"519\":1}}],[\"的数据双向流转机制\",{\"0\":{\"517\":1}}],[\"的数据结构\",{\"1\":{\"226\":1}}],[\"的封装\",{\"1\":{\"516\":2,\"957\":1}}],[\"的顶层封装\",{\"1\":{\"516\":1}}],[\"的并发读写\",{\"0\":{\"510\":1}}],[\"的使用情况\",{\"1\":{\"864\":1}}],[\"的使用\",{\"0\":{\"505\":1,\"513\":1}}],[\"的非原子性\",{\"0\":{\"477\":1}}],[\"的快照读\",{\"0\":{\"476\":1}}],[\"的关系\",{\"1\":{\"473\":1}}],[\"的栈什么时机会执行\",{\"1\":{\"473\":1}}],[\"的栈只占几\",{\"1\":{\"378\":1}}],[\"的方式将配置绑定到\",{\"1\":{\"957\":1}}],[\"的方式\",{\"1\":{\"810\":1}}],[\"的方式使用了追加操作\",{\"1\":{\"810\":1}}],[\"的方式工作的\",{\"1\":{\"757\":1,\"810\":1}}],[\"的方式加密明文数据\",{\"1\":{\"249\":1}}],[\"的方法\",{\"1\":{\"462\":1}}],[\"的类型系统\",{\"1\":{\"460\":1}}],[\"的指针互换\",{\"1\":{\"864\":1}}],[\"的指针\",{\"1\":{\"459\":1,\"946\":1}}],[\"的结合结构\",{\"1\":{\"867\":1}}],[\"的结果了\",{\"1\":{\"810\":1}}],[\"的结果展开讨论\",{\"1\":{\"373\":1}}],[\"的结构\",{\"0\":{\"451\":1,\"516\":1,\"522\":1},\"1\":{\"879\":1}}],[\"的返回值始终是\",{\"1\":{\"441\":1}}],[\"的返回值一直都是16\",{\"1\":{\"441\":1}}],[\"的实体\",{\"1\":{\"384\":1,\"521\":1}}],[\"的实现原理和使用方法\",{\"1\":{\"336\":1}}],[\"的协程\",{\"0\":{\"378\":1}}],[\"的协议\",{\"1\":{\"249\":1}}],[\"的待执行的\",{\"1\":{\"374\":1}}],[\"的一层封装\",{\"1\":{\"944\":2}}],[\"的一些问题\",{\"1\":{\"906\":1}}],[\"的一个普通的接口\",{\"1\":{\"472\":1}}],[\"的一个类型别名\",{\"1\":{\"460\":1}}],[\"的一半\",{\"1\":{\"374\":1}}],[\"的一方\",{\"1\":{\"237\":1}}],[\"的本地队列中\",{\"1\":{\"373\":2}}],[\"的核心\",{\"1\":{\"957\":1}}],[\"的核心特性\",{\"1\":{\"955\":1}}],[\"的核心思想\",{\"1\":{\"751\":1}}],[\"的核心数\",{\"1\":{\"373\":1}}],[\"的核心层软件\",{\"1\":{\"220\":1}}],[\"的信息\",{\"1\":{\"249\":1}}],[\"的端口号是\",{\"1\":{\"249\":2}}],[\"的端口到内部容器开放的网络端口\",{\"1\":{\"117\":1}}],[\"的握手过程\",{\"1\":{\"249\":1}}],[\"的报文传输\",{\"1\":{\"249\":1}}],[\"的下一个主要版本\",{\"1\":{\"249\":1}}],[\"的扩展性依然被用来添加新的功能\",{\"1\":{\"249\":1}}],[\"的发布\",{\"1\":{\"249\":1}}],[\"的发送窗口是\",{\"1\":{\"237\":1}}],[\"的操作\",{\"1\":{\"249\":1,\"469\":1,\"526\":1,\"810\":1}}],[\"的格式我就不详细介绍了\",{\"1\":{\"810\":1}}],[\"的格式也是不同的\",{\"1\":{\"810\":1}}],[\"的格式\",{\"1\":{\"249\":2}}],[\"的幂等性质就略费解一点\",{\"1\":{\"249\":1}}],[\"的含义就是两个只要满足一个即可\",{\"1\":{\"813\":1}}],[\"的含义\",{\"1\":{\"249\":2}}],[\"的简化版\",{\"1\":{\"249\":1}}],[\"的简写\",{\"1\":{\"36\":1}}],[\"的形式记录下来\",{\"1\":{\"810\":1}}],[\"的形式记录下来并写入\",{\"1\":{\"751\":1}}],[\"的形式保存数据\",{\"1\":{\"780\":1}}],[\"的形式\",{\"1\":{\"249\":2,\"846\":1}}],[\"的直接交互\",{\"1\":{\"249\":1}}],[\"的放大\",{\"1\":{\"243\":1}}],[\"的公钥\",{\"1\":{\"249\":1}}],[\"的公钥解密\",{\"1\":{\"240\":1,\"249\":1}}],[\"的公钥信息\",{\"1\":{\"240\":1,\"249\":1}}],[\"的保活机制\",{\"1\":{\"237\":1}}],[\"的同时\",{\"1\":{\"237\":1}}],[\"的时间\",{\"1\":{\"927\":1}}],[\"的时间线有关系\",{\"1\":{\"810\":1}}],[\"的时钟\",{\"1\":{\"906\":1}}],[\"的时机不同\",{\"1\":{\"743\":1,\"784\":1,\"810\":1}}],[\"的时长\",{\"1\":{\"237\":1}}],[\"的时候性能就会很高\",{\"1\":{\"770\":1}}],[\"的时候\",{\"1\":{\"374\":3,\"760\":1,\"770\":1,\"810\":9,\"820\":1,\"945\":1}}],[\"的时候十分方便\",{\"1\":{\"113\":1}}],[\"的时候使用引用\",{\"1\":{\"33\":1}}],[\"的输出文件\",{\"1\":{\"229\":1}}],[\"的二进制文件\",{\"1\":{\"229\":1}}],[\"的很多文本编辑器都会在\",{\"1\":{\"223\":1}}],[\"的状态为等待状态\",{\"1\":{\"820\":1}}],[\"的状态还是\",{\"1\":{\"765\":1,\"810\":1}}],[\"的状态解读\",{\"0\":{\"521\":1}}],[\"的状态码为三位数\",{\"1\":{\"249\":1}}],[\"的状态\",{\"1\":{\"223\":1,\"820\":1}}],[\"的缩写\",{\"1\":{\"223\":8,\"810\":1}}],[\"的虚拟地址空间是如何分布的\",{\"1\":{\"217\":1}}],[\"的文件大小非常重要\",{\"1\":{\"810\":1}}],[\"的文件描述符个数限制\",{\"1\":{\"226\":1}}],[\"的文件描述符\",{\"1\":{\"226\":1}}],[\"的文件\",{\"1\":{\"201\":1,\"1037\":1}}],[\"的标志位参数\",{\"1\":{\"229\":1}}],[\"的标配\",{\"1\":{\"190\":1}}],[\"的标识符称为\",{\"1\":{\"36\":1}}],[\"的动态调整\",{\"0\":{\"182\":1}}],[\"的\",{\"0\":{\"946\":1},\"1\":{\"177\":3,\"217\":1,\"229\":2,\"249\":1,\"512\":1,\"525\":3,\"743\":1,\"752\":1,\"759\":1,\"765\":1,\"770\":3,\"789\":1,\"810\":5,\"820\":15,\"864\":4,\"873\":1,\"879\":5,\"897\":1,\"906\":2,\"946\":1,\"952\":1,\"962\":5}}],[\"的多副本机制大致有如下优势\",{\"1\":{\"176\":1}}],[\"的副本机制优势\",{\"0\":{\"176\":1}}],[\"的副本机制\",{\"0\":{\"169\":1}}],[\"的常用命令\",{\"0\":{\"131\":1}}],[\"的容器\",{\"1\":{\"110\":1}}],[\"的修改会立马生效\",{\"1\":{\"106\":1}}],[\"的具体类型就自带了大小\",{\"1\":{\"879\":1}}],[\"的具体含义\",{\"1\":{\"249\":1}}],[\"的具体操作\",{\"1\":{\"102\":1}}],[\"的具体位置\",{\"1\":{\"20\":1}}],[\"的镜像仓库类似于代码仓库\",{\"1\":{\"99\":1}}],[\"的框架与核心概念\",{\"1\":{\"95\":1}}],[\"的作用\",{\"0\":{\"759\":1},\"1\":{\"33\":1,\"765\":2,\"810\":2}}],[\"的用法\",{\"1\":{\"33\":1,\"226\":1}}],[\"的区别是\",{\"1\":{\"770\":1}}],[\"的区别\",{\"1\":{\"33\":2,\"249\":1,\"770\":1,\"873\":1}}],[\"什么情况会这样呢\",{\"1\":{\"927\":1}}],[\"什么\",{\"1\":{\"820\":1}}],[\"什么时候做这个事情\",{\"1\":{\"952\":1}}],[\"什么时候启动多线程\",{\"1\":{\"897\":1}}],[\"什么时候才将\",{\"1\":{\"810\":1}}],[\"什么时候刷盘\",{\"1\":{\"810\":2}}],[\"什么时候\",{\"1\":{\"760\":1,\"810\":1}}],[\"什么时候分表\",{\"1\":{\"727\":1}}],[\"什么时候分库\",{\"1\":{\"727\":1}}],[\"什么时候用指针\",{\"1\":{\"33\":1}}],[\"什么场景需要有序\",{\"0\":{\"719\":1}}],[\"什么是隐式锁\",{\"1\":{\"820\":1}}],[\"什么是servlet\",{\"0\":{\"646\":1}}],[\"什么是listener\",{\"0\":{\"614\":1}}],[\"什么是filter\",{\"0\":{\"578\":1}}],[\"什么是海量数据处理\",{\"1\":{\"20\":1}}],[\"什么是数据处理\",{\"1\":{\"20\":1}}],[\"yaml\",{\"1\":{\"957\":10,\"962\":1,\"966\":3}}],[\"yyy\",{\"1\":{\"810\":2,\"1037\":2}}],[\"your\",{\"1\":{\"659\":1}}],[\"y\",{\"1\":{\"33\":2,\"210\":1,\"983\":2}}],[\"宏观分成3层\",{\"1\":{\"156\":1}}],[\"宏展开\",{\"1\":{\"36\":1}}],[\"宏代换\",{\"1\":{\"36\":1}}],[\"宏名\",{\"1\":{\"36\":2}}],[\"宏不是语句\",{\"1\":{\"33\":1}}],[\"宏不检查类型\",{\"1\":{\"33\":1}}],[\"宏不进行类型检查\",{\"1\":{\"33\":1}}],[\"宏替换发生在编译阶段之前\",{\"1\":{\"33\":1}}],[\"宏\",{\"1\":{\"33\":1,\"36\":1}}],[\"宏的潜在问题\",{\"1\":{\"33\":1}}],[\"宏没有返回值\",{\"1\":{\"33\":1}}],[\"宏定义可完成简单的操作\",{\"1\":{\"36\":1}}],[\"宏定义和\",{\"1\":{\"33\":1}}],[\"宏定义和函数的区别\",{\"1\":{\"33\":1}}],[\"宏定义\",{\"1\":{\"33\":1,\"36\":1},\"2\":{\"38\":1}}],[\"宏定义不要在最后加分号\",{\"1\":{\"33\":1}}],[\"宏定义参数没有类型\",{\"1\":{\"33\":1}}],[\"宏定义属于在结构中插入代码\",{\"1\":{\"33\":1}}],[\"宏在预处理阶段完成替换\",{\"1\":{\"33\":1}}],[\"7和8\",{\"1\":{\"817\":1}}],[\"7引入的自动资源管理\",{\"1\":{\"541\":1}}],[\"79\",{\"1\":{\"370\":1,\"371\":1}}],[\"78\",{\"1\":{\"370\":1,\"371\":1}}],[\"78125\",{\"1\":{\"249\":1}}],[\"77\",{\"1\":{\"370\":1,\"371\":1}}],[\"76\",{\"1\":{\"370\":1,\"371\":1}}],[\"75\",{\"1\":{\"370\":1,\"371\":1,\"770\":6}}],[\"74\",{\"1\":{\"370\":1,\"371\":1}}],[\"73\",{\"1\":{\"370\":1,\"371\":1,\"770\":2}}],[\"72\",{\"1\":{\"370\":1,\"371\":1,\"770\":2}}],[\"71\",{\"1\":{\"370\":1,\"371\":1,\"483\":3}}],[\"70\",{\"1\":{\"370\":1,\"371\":1,\"770\":2,\"807\":1}}],[\"7\",{\"0\":{\"211\":1,\"441\":1,\"454\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"471\":1,\"606\":1,\"607\":1,\"608\":1,\"609\":1,\"685\":1,\"686\":1,\"687\":1,\"688\":1,\"689\":1,\"690\":1,\"691\":1,\"692\":1,\"693\":1,\"745\":1,\"757\":1,\"844\":1,\"1011\":1},\"1\":{\"33\":1,\"249\":8,\"369\":1,\"370\":1,\"371\":1,\"442\":1,\"770\":3,\"807\":1,\"810\":3,\"817\":2,\"841\":2,\"867\":2,\"870\":1,\"876\":1,\"879\":3,\"885\":1,\"994\":2,\"1008\":1}}],[\"<a\",{\"1\":{\"1032\":1}}],[\"<artifactid>javax\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"<username>\",{\"1\":{\"854\":2}}],[\"<url\",{\"1\":{\"588\":1,\"658\":1}}],[\"<database\",{\"1\":{\"854\":2}}],[\"<dependency>\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"<3怎么建立索引\",{\"1\":{\"813\":1}}],[\"<>\",{\"1\":{\"807\":1,\"1001\":1}}],[\"<web\",{\"1\":{\"658\":1}}],[\"<body>\",{\"1\":{\"652\":1}}],[\"<title>hello\",{\"1\":{\"652\":1}}],[\"<h1>hello\",{\"1\":{\"652\":1}}],[\"<head>\",{\"1\":{\"652\":1}}],[\"<html>\",{\"1\":{\"249\":2,\"652\":1}}],[\"<listener\",{\"1\":{\"627\":3}}],[\"<listener>\",{\"1\":{\"627\":3}}],[\"<project\",{\"1\":{\"961\":1,\"964\":1}}],[\"<path\",{\"1\":{\"854\":1}}],[\"<password>\",{\"1\":{\"854\":1}}],[\"<param\",{\"1\":{\"588\":2}}],[\"<p>当前时间\",{\"1\":{\"652\":1}}],[\"<pid>\",{\"1\":{\"196\":1,\"198\":1}}],[\"<filter\",{\"1\":{\"588\":4}}],[\"<filter>\",{\"1\":{\"588\":1}}],[\"<session\",{\"1\":{\"691\":2}}],[\"<servlet\",{\"1\":{\"658\":4}}],[\"<servlet>\",{\"1\":{\"658\":1}}],[\"<scope>provided<\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"<string\",{\"1\":{\"33\":1}}],[\"<version>4\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"<groupid>javax\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"<init\",{\"1\":{\"588\":1}}],[\"<img\",{\"1\":{\"249\":1}}],[\"<iostream>\",{\"1\":{\"33\":3}}],[\"<端口号>\",{\"1\":{\"197\":2,\"199\":1}}],[\"<=\",{\"1\":{\"46\":1,\"226\":3,\"367\":1,\"770\":1}}],[\"<\",{\"1\":{\"33\":3,\"46\":1,\"88\":2,\"226\":1,\"249\":1,\"415\":1,\"426\":1,\"505\":2,\"510\":2,\"511\":2,\"515\":6,\"526\":1,\"530\":1,\"543\":1,\"583\":1,\"588\":4,\"623\":1,\"627\":3,\"651\":1,\"652\":6,\"658\":3,\"691\":2,\"817\":1,\"855\":1,\"975\":2,\"986\":1}}],[\"<chrono>\",{\"1\":{\"33\":1}}],[\"<cstdlib>\",{\"1\":{\"33\":1}}],[\"<<a<<endl\",{\"1\":{\"30\":1}}],[\"<<endl\",{\"1\":{\"30\":1,\"226\":3}}],[\"<<\",{\"1\":{\"20\":2,\"33\":47,\"444\":1}}],[\"所提供的\",{\"1\":{\"957\":1}}],[\"所指向的\",{\"1\":{\"946\":1}}],[\"所谓的长事务\",{\"1\":{\"820\":1}}],[\"所谓动态维护\",{\"1\":{\"182\":1}}],[\"所占用的每个字节的第一个\",{\"1\":{\"879\":1}}],[\"所占用的字节数\",{\"1\":{\"770\":1}}],[\"所占用的字节数是多少\",{\"1\":{\"770\":2}}],[\"所占用的字节数的\",{\"1\":{\"770\":3}}],[\"所占内存的大小\",{\"1\":{\"810\":1}}],[\"所定位的资源内部的一个\",{\"1\":{\"249\":1}}],[\"所类似的交互式特性\",{\"1\":{\"190\":1}}],[\"所属的\",{\"1\":{\"123\":1}}],[\"所有索引中的地址都要更新\",{\"1\":{\"813\":1}}],[\"所有的\",{\"1\":{\"941\":1}}],[\"所有的内置函数\",{\"1\":{\"817\":1}}],[\"所有的查询都需要回表\",{\"1\":{\"813\":1}}],[\"所有的数据在插入时就已经排好序\",{\"1\":{\"813\":1}}],[\"所有完整的用户记录都存放在聚集索引的叶子节点\",{\"1\":{\"813\":1}}],[\"所有\",{\"1\":{\"770\":1,\"813\":1}}],[\"所有存储引擎都可以使用\",{\"1\":{\"759\":1,\"810\":1}}],[\"所有类型都实现了空接口\",{\"1\":{\"467\":1}}],[\"所有字符串类型的值都是不可变的\",{\"1\":{\"351\":1}}],[\"所有请求都通过一个连接实现\",{\"1\":{\"249\":1}}],[\"所有在同一nat网络中的虚拟机可以相互通信\",{\"1\":{\"246\":1}}],[\"所有东西都是以文件的形式存在的\",{\"1\":{\"223\":1}}],[\"所有进程共享内核的代码和数据\",{\"1\":{\"217\":1}}],[\"所有进程都可以访问相同的内核地址空间\",{\"1\":{\"217\":1}}],[\"所有后台服务的统称\",{\"1\":{\"102\":1}}],[\"所有权会从源指针完全转移到目标指针\",{\"1\":{\"33\":1}}],[\"所以使用bcrypt时不需要我们在表里单独存储salt\",{\"1\":{\"1056\":1}}],[\"所以使用脚本点击的影响会降到很低\",{\"1\":{\"927\":1}}],[\"所以从\",{\"1\":{\"1008\":1}}],[\"所以看不到实际的内容\",{\"1\":{\"993\":1}}],[\"所以性能上无需担心\",{\"1\":{\"957\":1}}],[\"所以开发中是否需要使用\",{\"1\":{\"957\":1}}],[\"所以需要指定具体类型\",{\"1\":{\"957\":1}}],[\"所以如果有混合持久化\",{\"1\":{\"949\":1}}],[\"所以如果不小心整个数据库的数据被删除了\",{\"1\":{\"810\":1}}],[\"所以5\",{\"1\":{\"949\":1}}],[\"所以叫混合持久化\",{\"1\":{\"949\":1}}],[\"所以最终一致性是一定达成的\",{\"1\":{\"930\":1}}],[\"所以无法保证两条redis更新操作谁先执行\",{\"1\":{\"930\":1}}],[\"所以缓存是可以很大程度提升系统的吞吐量\",{\"1\":{\"930\":1}}],[\"所以第一步和第二步都是需要原子操作的\",{\"1\":{\"927\":1}}],[\"所以适合处理不那么重要的信息\",{\"1\":{\"924\":1}}],[\"所以锁剩余持有时间\",{\"1\":{\"917\":1,\"921\":1}}],[\"所以我们的lua脚本中\",{\"1\":{\"927\":1}}],[\"所以我们还是要尽可能避免这种情况\",{\"1\":{\"927\":1}}],[\"所以我们可以进一步给出解决方案\",{\"1\":{\"912\":1,\"921\":1}}],[\"所以我们认为\",{\"1\":{\"793\":1}}],[\"所以只让一个竞争者持有锁\",{\"1\":{\"909\":1,\"921\":1}}],[\"所以只需要传入一个待检测的\",{\"1\":{\"226\":1}}],[\"所以是不会重复占用内存\",{\"1\":{\"946\":1}}],[\"所以是不会重复占用内容\",{\"1\":{\"894\":1}}],[\"所以是幂等的\",{\"1\":{\"249\":1}}],[\"所以处理逻辑使用多线程不会有太多收益\",{\"1\":{\"891\":1}}],[\"所以查找复杂度是比较高的\",{\"1\":{\"879\":1}}],[\"所以查询不出来\",{\"1\":{\"793\":1}}],[\"所以查询一条记录的时候\",{\"1\":{\"748\":1}}],[\"所以压缩列表可以从后往前遍历\",{\"1\":{\"879\":1}}],[\"所以执行命令的过程是原子的\",{\"1\":{\"873\":1}}],[\"所以导致第二个事务会等待\",{\"1\":{\"820\":1}}],[\"所以导致事务\",{\"1\":{\"820\":1}}],[\"所以事务\",{\"1\":{\"820\":3}}],[\"所以所以两个事务中\",{\"1\":{\"820\":1}}],[\"所以两个事务先要查询该订单是否存在\",{\"1\":{\"820\":1}}],[\"所以为了能安全的对表结构进行变更\",{\"1\":{\"820\":1}}],[\"所以直接在存储引擎过滤出满足\",{\"1\":{\"817\":1}}],[\"所以直接读取最新的数据就好\",{\"1\":{\"784\":1}}],[\"所以接着向存储引擎层要求继续读刚才那条记录的下一条记录\",{\"1\":{\"817\":1}}],[\"所以还会再查一次\",{\"1\":{\"817\":2}}],[\"所以优化器决定选用访问类型为\",{\"1\":{\"817\":2}}],[\"所以插入前会检查一遍表中是否存在相同的数据\",{\"1\":{\"813\":1}}],[\"所以修改字段数据后不会立马自动更新全文索引\",{\"1\":{\"813\":1}}],[\"所以对一个字段建立全文索引后\",{\"1\":{\"813\":1}}],[\"所以先是拿\",{\"1\":{\"813\":1}}],[\"所以结果应该是\",{\"1\":{\"813\":2}}],[\"所以建立\",{\"1\":{\"813\":1}}],[\"所以也是符合最左匹配原则的\",{\"1\":{\"813\":1}}],[\"所以也是幂等的\",{\"1\":{\"249\":1}}],[\"所以外部排序一般使用\",{\"1\":{\"813\":1}}],[\"所以聚集索引只能有一个\",{\"1\":{\"813\":1}}],[\"所以说\",{\"1\":{\"810\":1}}],[\"所以说查询缓存很鸡肋\",{\"1\":{\"810\":1}}],[\"所以频繁的\",{\"1\":{\"810\":1}}],[\"所以针对这种格式\",{\"1\":{\"810\":1}}],[\"所以参数为\",{\"1\":{\"810\":2}}],[\"所以磁盘操作是\",{\"1\":{\"810\":2}}],[\"所以有了\",{\"1\":{\"810\":1}}],[\"所以决定要使用\",{\"1\":{\"810\":1}}],[\"所以想要真正的做好参数优化\",{\"1\":{\"807\":1}}],[\"所以主键是逻辑上相邻的\",{\"1\":{\"807\":1}}],[\"所以取出时需要去除空格\",{\"1\":{\"770\":1}}],[\"所以代表着变长字段允许存储的最大字节数是\",{\"1\":{\"770\":1}}],[\"所以会触发\",{\"1\":{\"957\":1}}],[\"所以会调用\",{\"1\":{\"817\":1}}],[\"所以会用\",{\"1\":{\"770\":2}}],[\"所以会有以下两个基本的影响\",{\"1\":{\"237\":1}}],[\"所以要在高位补\",{\"1\":{\"770\":1}}],[\"所以用二进制来表示是酱紫的\",{\"1\":{\"770\":1}}],[\"所以用非阻塞io模型可以避免阻塞在传输函数上\",{\"1\":{\"226\":1}}],[\"所以每一个字符占用的\",{\"1\":{\"770\":1}}],[\"所以每当执行一个\",{\"1\":{\"760\":1,\"810\":1}}],[\"所以每个进程的虚拟内存空间就是相互独立的\",{\"1\":{\"217\":1}}],[\"所以写入\",{\"1\":{\"756\":1,\"810\":2}}],[\"所以该版本的记录对当前事务\",{\"1\":{\"744\":4,\"789\":4}}],[\"所以可以观察到使用的虚拟内存空间很大\",{\"1\":{\"748\":1}}],[\"所以可以从缓存拿数据同步从库\",{\"1\":{\"730\":1}}],[\"所以可以转换成数字求次方\",{\"1\":{\"249\":1}}],[\"所以这里建议是不把宕机考虑到雪崩里去\",{\"1\":{\"930\":1}}],[\"所以这里不用管\",{\"1\":{\"770\":1}}],[\"所以这会成为性能瓶颈\",{\"1\":{\"810\":1}}],[\"所以这个结论也不影响消息队列的可靠性\",{\"1\":{\"709\":1}}],[\"所以这些页表是私有的\",{\"1\":{\"217\":1}}],[\"所以空接口可以存储任意类型的数值\",{\"1\":{\"467\":1}}],[\"所以就会被阻塞\",{\"1\":{\"820\":1}}],[\"所以就无法匹配上联合索引\",{\"1\":{\"813\":1}}],[\"所以就很好了避免幻读问题\",{\"1\":{\"783\":2}}],[\"所以就不能确定其内存大小\",{\"1\":{\"415\":1}}],[\"所以就被称为\",{\"1\":{\"249\":1}}],[\"所以传递指针不一定是高效的\",{\"1\":{\"409\":1}}],[\"所以全局\",{\"1\":{\"381\":1}}],[\"所以当其它事务持有该间隙的间隙锁时\",{\"1\":{\"820\":1}}],[\"所以当调用该函数的时候\",{\"1\":{\"817\":1}}],[\"所以当\",{\"1\":{\"374\":1}}],[\"所以创建的协程\",{\"1\":{\"373\":1}}],[\"所以channel是一个引用类型\",{\"1\":{\"258\":1}}],[\"所以由它来给各个公钥签名\",{\"1\":{\"249\":1}}],[\"所以密文很安全\",{\"1\":{\"249\":1}}],[\"所以即使你有公钥\",{\"1\":{\"249\":1}}],[\"所以在用户设置密码时应该禁止他们输入简单的密码\",{\"1\":{\"1056\":1}}],[\"所以在使用这两条语句的时候\",{\"1\":{\"820\":1}}],[\"所以在使用时要依据具体情况来决定是否使用宏定义\",{\"1\":{\"36\":1}}],[\"所以在删除的时候\",{\"1\":{\"813\":1}}],[\"所以在实际使用中\",{\"1\":{\"810\":1}}],[\"所以在设计数据库表的时候\",{\"1\":{\"770\":1}}],[\"所以在\",{\"1\":{\"249\":1,\"810\":1}}],[\"所以服务端可以处理的tcp连接理论上可以非常多\",{\"1\":{\"237\":1}}],[\"所以不知道从哪个索引值开始比较\",{\"1\":{\"813\":1}}],[\"所以不会发生复杂的树的变形\",{\"1\":{\"813\":1}}],[\"所以不会刷盘\",{\"1\":{\"810\":1}}],[\"所以不同类型的操作\",{\"1\":{\"810\":1}}],[\"所以不需要经过查询缓存\",{\"1\":{\"810\":1}}],[\"所以不该由消息队列来保证\",{\"1\":{\"709\":1}}],[\"所以不再继续运行\",{\"1\":{\"479\":1}}],[\"所以不是幂等的\",{\"1\":{\"249\":1}}],[\"所以不能对\",{\"1\":{\"237\":1}}],[\"所以不能用来得到动态分配\",{\"1\":{\"33\":1}}],[\"所以不要试图在这里存放任何文件\",{\"1\":{\"223\":1}}],[\"所以一共有\",{\"1\":{\"900\":1}}],[\"所以一般都选择删除\",{\"1\":{\"930\":1}}],[\"所以一般是推荐使用长连接\",{\"1\":{\"817\":1}}],[\"所以一般而言还会根据情况进一步地业务内分区\",{\"1\":{\"720\":1}}],[\"所以一旦重启\",{\"1\":{\"223\":1}}],[\"所以一个缓存机器肯定是不够的\",{\"1\":{\"81\":1}}],[\"所以快\",{\"1\":{\"217\":1}}],[\"所以堆的释放也是有区别的\",{\"1\":{\"217\":1}}],[\"所以页内会出现内存浪费\",{\"1\":{\"217\":1}}],[\"所以你想启动一个容器\",{\"1\":{\"97\":1}}],[\"所以雪花算法可以支持一定的未来时间\",{\"1\":{\"92\":1}}],[\"所以\",{\"1\":{\"75\":1,\"226\":1,\"249\":1,\"374\":1,\"405\":1,\"479\":1,\"730\":1,\"755\":1,\"763\":1,\"770\":12,\"810\":12,\"813\":5,\"817\":1,\"820\":5,\"873\":1,\"885\":1,\"911\":1,\"921\":1,\"952\":2}}],[\"所以二叉堆可以辅助我们快速找到最大值或最小值\",{\"1\":{\"51\":1}}],[\"所以预处理后的文件\",{\"1\":{\"36\":1}}],[\"所以动态对象它是不行的\",{\"1\":{\"33\":1}}],[\"所需内存\",{\"1\":{\"20\":3}}],[\"而开发环境日志输出的时间格式为\",{\"1\":{\"957\":2}}],[\"而通过\",{\"1\":{\"957\":1}}],[\"而通过原始数据映射之后得到的二进制值串就是哈希值\",{\"1\":{\"70\":1}}],[\"而查询数据量巨大\",{\"1\":{\"930\":1}}],[\"而用户不断发起请求\",{\"1\":{\"930\":1}}],[\"而存储服务自己维护访问逻辑\",{\"1\":{\"930\":1}}],[\"而对应用服务是透明的\",{\"1\":{\"930\":1}}],[\"而对象存在于堆内存\",{\"1\":{\"571\":1}}],[\"而这时候要是比原计划的数量卖多了\",{\"1\":{\"927\":1}}],[\"而b却还在继续执行\",{\"1\":{\"912\":1,\"921\":1}}],[\"而业务还会继续进行\",{\"1\":{\"912\":1,\"921\":1}}],[\"而本身访问\",{\"1\":{\"903\":1}}],[\"而瓶颈通常在网络\",{\"1\":{\"891\":1}}],[\"而最大层数限制在\",{\"1\":{\"885\":1}}],[\"而设置过期时间\",{\"1\":{\"882\":1}}],[\"而言偏移的字节数\",{\"1\":{\"879\":1}}],[\"而第二个事务是想对该记录加上\",{\"1\":{\"820\":1}}],[\"而接下来的插入操作为了获取到插入意向锁\",{\"1\":{\"820\":1}}],[\"而间隙锁与间隙锁之间是兼容的\",{\"1\":{\"820\":1}}],[\"而插入意向锁与间隙锁是冲突的\",{\"1\":{\"820\":1}}],[\"而出现幻读的问题\",{\"1\":{\"820\":1}}],[\"而出现备份文件的数据与预期的不一样\",{\"1\":{\"820\":1}}],[\"而普通的\",{\"1\":{\"820\":1}}],[\"而导致后续的申请读锁的查询操作也会被阻塞\",{\"1\":{\"820\":1}}],[\"而使用了单纯的\",{\"1\":{\"820\":1}}],[\"而使用索引下推后\",{\"1\":{\"817\":1}}],[\"而使用到的物理内存空间却很小\",{\"1\":{\"748\":1,\"810\":1}}],[\"而堆表中的数据是无序的\",{\"1\":{\"813\":1}}],[\"而无需额外的回表操作\",{\"1\":{\"813\":1}}],[\"而已经持久化到磁盘的数据就不会有影响\",{\"1\":{\"810\":1}}],[\"而当\",{\"1\":{\"810\":1}}],[\"而varchar\",{\"1\":{\"770\":1}}],[\"而varchar不会\",{\"1\":{\"770\":1}}],[\"而实际的数据都存储在溢出页中\",{\"1\":{\"770\":1}}],[\"而把剩余的数据放在\",{\"1\":{\"770\":1}}],[\"而一个\",{\"1\":{\"770\":1}}],[\"而数据页可以稍后再写入\",{\"1\":{\"751\":1}}],[\"而内存总是不可靠\",{\"1\":{\"751\":1,\"810\":1}}],[\"而非静态成员属于实例对象\",{\"1\":{\"573\":1}}],[\"而非系统必须使用的\",{\"1\":{\"223\":1}}],[\"而局部变量则不会自动赋值\",{\"1\":{\"571\":1}}],[\"而局部变量随着方法的调用而自动生成\",{\"1\":{\"571\":1}}],[\"而局部变量不能被访问控制修饰符及static所修饰\",{\"1\":{\"571\":1}}],[\"而局部变量是在代码块或方法中定义的变量或是方法的参数\",{\"1\":{\"571\":1}}],[\"而cookie是首选方式\",{\"1\":{\"249\":1}}],[\"而c赋予了\",{\"1\":{\"30\":1}}],[\"而html\",{\"1\":{\"249\":1}}],[\"而在\",{\"1\":{\"810\":1,\"813\":1}}],[\"而在运行时其实是调用makechan函数来完成初始化工作\",{\"1\":{\"263\":1}}],[\"而在http\",{\"1\":{\"249\":1}}],[\"而在tcp\",{\"1\":{\"249\":1}}],[\"而在收到目的主机的syn＋ack包后并不回应\",{\"1\":{\"243\":1}}],[\"而osi模型是理论上的指导框架\",{\"1\":{\"249\":1}}],[\"而tcp\",{\"1\":{\"249\":2}}],[\"而网络层在osi模型中也有对应\",{\"1\":{\"249\":1}}],[\"而不能更新数据\",{\"1\":{\"820\":1}}],[\"而不必访问实际的数据行\",{\"1\":{\"813\":1}}],[\"而不必针对给定查询扫描表中的每一行\",{\"1\":{\"813\":1}}],[\"而不使用完整字段值\",{\"1\":{\"807\":1}}],[\"而不经过上述大部分步骤\",{\"1\":{\"734\":1}}],[\"而不需要等待整个插入语句执行完后才释放锁\",{\"1\":{\"820\":1}}],[\"而不需要访问实际的数据行\",{\"1\":{\"813\":1}}],[\"而不需要在编译时知道这些元素的名称\",{\"1\":{\"550\":1}}],[\"而不需要通过内部结构体的实例来访问\",{\"1\":{\"462\":1}}],[\"而不需要提前指定参数的个数\",{\"1\":{\"458\":1}}],[\"而不需要全面重构\",{\"1\":{\"249\":1}}],[\"而不提倡通过共享内存来实现通信\",{\"1\":{\"254\":1}}],[\"而不是值\",{\"1\":{\"985\":1}}],[\"而不是去让黄牛赚外快\",{\"1\":{\"927\":1}}],[\"而不是相邻节点的指针\",{\"1\":{\"906\":1}}],[\"而不是链表\",{\"1\":{\"906\":1}}],[\"而不是直接\",{\"1\":{\"879\":1}}],[\"而不是空字符来判断字符串是否结束\",{\"1\":{\"873\":1}}],[\"而不是记录锁的意思\",{\"1\":{\"820\":3}}],[\"而不是经过\",{\"1\":{\"813\":1}}],[\"而不是经过函数计算后的值\",{\"1\":{\"813\":1}}],[\"而不是字节\",{\"1\":{\"770\":1}}],[\"而不是字符数\",{\"1\":{\"353\":1}}],[\"而不是其他\",{\"1\":{\"381\":1}}],[\"而不是一个\",{\"1\":{\"325\":1}}],[\"而不是\",{\"1\":{\"249\":1,\"770\":1,\"1015\":1}}],[\"而不是请求出错\",{\"1\":{\"249\":1}}],[\"而不是tcp4元组\",{\"1\":{\"240\":1}}],[\"而不是阻塞应用程序\",{\"1\":{\"226\":1}}],[\"而不是文本文件\",{\"1\":{\"223\":1}}],[\"而不是和宿主机共享\",{\"1\":{\"125\":1}}],[\"而不是类的任何特定对象\",{\"1\":{\"33\":1}}],[\"而不是每个对象独立的\",{\"1\":{\"33\":1}}],[\"而不是c++\",{\"1\":{\"33\":1}}],[\"而前者仅与\",{\"1\":{\"229\":1}}],[\"而跟连接总数无关\",{\"1\":{\"226\":1}}],[\"而mmap\",{\"1\":{\"217\":1}}],[\"而malloc\",{\"1\":{\"33\":1}}],[\"而消费者则通过订阅主题来接收相关的消息\",{\"1\":{\"157\":1}}],[\"而\",{\"1\":{\"123\":1,\"226\":2,\"249\":3,\"512\":2,\"516\":1,\"763\":3,\"810\":4,\"813\":1,\"820\":1,\"838\":1,\"840\":1,\"879\":2,\"930\":1,\"946\":1,\"952\":1,\"962\":1}}],[\"而是生成一个临时下载地址\",{\"1\":{\"1032\":1}}],[\"而是想让代码写起来更爽一些\",{\"1\":{\"957\":1}}],[\"而是二进制数据+日志数据的混合体\",{\"1\":{\"949\":1}}],[\"而是直接访问数据服务\",{\"1\":{\"930\":1}}],[\"而是将网络\",{\"1\":{\"897\":1}}],[\"而是会用隐式锁保护唯一二级索引的记录\",{\"1\":{\"820\":1}}],[\"而是会被下推到\",{\"1\":{\"813\":1}}],[\"而是再执行完插入语句后就会立即释放\",{\"1\":{\"820\":1}}],[\"而是\",{\"1\":{\"810\":1}}],[\"而是推迟到组提交的\",{\"1\":{\"810\":1}}],[\"而是按照区\",{\"1\":{\"770\":1}}],[\"而是以页为单位\",{\"1\":{\"770\":1}}],[\"而是对特定事件做出响应\",{\"1\":{\"614\":1}}],[\"而是修改或增强请求\",{\"1\":{\"578\":1}}],[\"而是默认输出字段的类型零值\",{\"1\":{\"487\":1}}],[\"而是发生了拷贝\",{\"1\":{\"356\":1}}],[\"而是先判断一下该索引中包含的列\",{\"1\":{\"817\":1}}],[\"而是先写\",{\"1\":{\"810\":2}}],[\"而是先写日志\",{\"1\":{\"810\":1}}],[\"而是先写日志文件\",{\"1\":{\"751\":1}}],[\"而是先记录在日志上\",{\"1\":{\"810\":1}}],[\"而是先存完连续的8个key\",{\"1\":{\"330\":1}}],[\"而是先经过一个中转站存放\",{\"1\":{\"156\":1}}],[\"而是由中间证书签发的\",{\"1\":{\"249\":1}}],[\"而是由\",{\"1\":{\"249\":1}}],[\"而是在数据库完成sql指令的编译后\",{\"1\":{\"243\":1}}],[\"而是自己创建一个隐藏文件夹\",{\"1\":{\"223\":1}}],[\"而是程序和内核交流的一些信息\",{\"1\":{\"223\":1}}],[\"而是和宿主机共用一个\",{\"1\":{\"124\":1}}],[\"而是和一个指定的容器共享\",{\"1\":{\"122\":1,\"125\":1}}],[\"而是使用宿主机的\",{\"1\":{\"122\":1}}],[\"而容器带有运行时需要的可写文件层\",{\"1\":{\"98\":1}}],[\"而iostream文件中有50000多行代码\",{\"1\":{\"36\":1}}],[\"而且还会记录在aof重写缓冲区\",{\"1\":{\"952\":1}}],[\"而且大家都盯着0点\",{\"1\":{\"927\":1}}],[\"而且设置了过期时间\",{\"1\":{\"894\":1}}],[\"而且每个\",{\"1\":{\"879\":1}}],[\"而且记录锁是有\",{\"1\":{\"820\":1}}],[\"而且意向锁之间也不会发生冲突\",{\"1\":{\"820\":1}}],[\"而且由于\",{\"1\":{\"820\":1}}],[\"而且是等值查询\",{\"1\":{\"817\":1}}],[\"而且\",{\"1\":{\"813\":2}}],[\"而且事务在执行过程中发生错误\",{\"1\":{\"774\":1}}],[\"而且磁盘的运行速度远慢于内存\",{\"1\":{\"755\":1,\"810\":1}}],[\"而且执行一条\",{\"1\":{\"739\":1}}],[\"而且栈内存的分配和释放\",{\"1\":{\"405\":1}}],[\"而且也需要在用户态与内核态之间拷贝文件描述符集合\",{\"1\":{\"226\":1}}],[\"而且所支持的文件描述符的个数是有限制的\",{\"1\":{\"226\":1}}],[\"而且宏定义所占用的目标代码空间相对较大\",{\"1\":{\"36\":1}}],[\"而且可重复利用\",{\"1\":{\"36\":1}}],[\"而返回局部变量的引用是没有意义的\",{\"1\":{\"33\":1}}],[\"6f\",{\"1\":{\"770\":3}}],[\"6c\",{\"1\":{\"770\":6}}],[\"6d\",{\"1\":{\"770\":8}}],[\"6e\",{\"1\":{\"770\":2}}],[\"69\",{\"1\":{\"370\":1,\"371\":1,\"770\":4}}],[\"68为实际存储的数据\",{\"1\":{\"770\":1}}],[\"68\",{\"1\":{\"370\":1,\"371\":1,\"770\":26}}],[\"67\",{\"1\":{\"370\":1,\"371\":1}}],[\"66\",{\"1\":{\"370\":1,\"371\":1,\"770\":2}}],[\"65536\",{\"1\":{\"903\":1}}],[\"65534\",{\"1\":{\"879\":2}}],[\"65533\",{\"1\":{\"770\":1}}],[\"65532字节\",{\"1\":{\"770\":1}}],[\"65532\",{\"1\":{\"770\":3}}],[\"65535\",{\"1\":{\"770\":10}}],[\"65\",{\"1\":{\"370\":1,\"371\":1,\"770\":5}}],[\"63\",{\"1\":{\"370\":1,\"371\":1}}],[\"6379\",{\"1\":{\"147\":1}}],[\"62\",{\"1\":{\"370\":1,\"371\":1}}],[\"60s\",{\"1\":{\"952\":1}}],[\"60\",{\"1\":{\"249\":1,\"370\":1,\"371\":1,\"374\":3}}],[\"61\",{\"1\":{\"249\":2,\"370\":1,\"371\":1,\"374\":2,\"770\":50}}],[\"6gb\",{\"1\":{\"237\":1}}],[\"6w\",{\"1\":{\"237\":1}}],[\"64\",{\"1\":{\"217\":2,\"370\":1,\"371\":1,\"770\":1,\"867\":1,\"873\":2,\"876\":1,\"885\":1,\"900\":1}}],[\"64位\",{\"1\":{\"33\":1}}],[\"6\",{\"0\":{\"81\":1,\"150\":1,\"210\":1,\"315\":1,\"440\":1,\"451\":1,\"452\":1,\"453\":1,\"470\":1,\"602\":1,\"603\":1,\"604\":1,\"605\":1,\"639\":1,\"640\":1,\"641\":1,\"679\":1,\"680\":1,\"681\":1,\"682\":1,\"683\":1,\"684\":1,\"744\":1,\"756\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":1,\"766\":1,\"767\":1,\"796\":1,\"843\":1,\"1010\":1,\"1013\":1,\"1014\":1,\"1015\":1},\"1\":{\"33\":2,\"226\":1,\"229\":1,\"249\":9,\"369\":1,\"370\":1,\"371\":1,\"442\":1,\"452\":1,\"743\":1,\"770\":4,\"807\":1,\"810\":2,\"813\":3,\"817\":2,\"820\":1,\"841\":2,\"867\":1,\"870\":1,\"876\":1,\"891\":1,\"897\":1,\"940\":1,\"1008\":2}}],[\"以给定的cost返回密码的bcrypt哈希\",{\"1\":{\"1058\":1}}],[\"以给每一个图片取一个唯一标识\",{\"1\":{\"75\":1}}],[\"以快著称\",{\"1\":{\"955\":1}}],[\"以过期时间兜底\",{\"1\":{\"930\":2}}],[\"以旁路缓存\",{\"1\":{\"930\":1}}],[\"以减轻热点数据频繁请求给自己带来的压力\",{\"1\":{\"930\":1}}],[\"以为自己还持有锁\",{\"1\":{\"918\":1,\"921\":1}}],[\"以为errors\",{\"1\":{\"472\":1}}],[\"以实现最大占据时间的特性\",{\"1\":{\"882\":1}}],[\"以实现消息的并行处理和负载均衡\",{\"1\":{\"157\":1}}],[\"以这种形式创建的索引也被称之为前缀索引\",{\"1\":{\"813\":1}}],[\"以这种方式来部署mysql\",{\"1\":{\"807\":1}}],[\"以腾出空间记录新的更新操作\",{\"1\":{\"810\":1}}],[\"以时间片调度的模式工作\",{\"1\":{\"807\":1}}],[\"以避免在索引列上使用函数或计算\",{\"1\":{\"807\":1}}],[\"以此实现开箱即用的效果\",{\"1\":{\"957\":1}}],[\"以此来防止全局的\",{\"1\":{\"957\":1}}],[\"以此类推\",{\"1\":{\"770\":1}}],[\"以此确定这个关键词应该在本机进行后续处理还是要发送给其他机器\",{\"1\":{\"79\":1}}],[\"以页作为磁盘和内存交互的基本单位\",{\"1\":{\"748\":1,\"810\":1}}],[\"以上代码通过\",{\"1\":{\"957\":1}}],[\"以上\",{\"1\":{\"727\":1}}],[\"以来\",{\"1\":{\"529\":1}}],[\"以确保多个\",{\"1\":{\"511\":1}}],[\"以确保对方已收到了最后一个ack报文\",{\"1\":{\"237\":1}}],[\"以小写字母开头\",{\"1\":{\"433\":1}}],[\"以大写字母开头\",{\"1\":{\"433\":1}}],[\"以前版本\",{\"1\":{\"432\":1}}],[\"以前使用\",{\"1\":{\"113\":1}}],[\"以下参数决定文件会存在哪里\",{\"1\":{\"952\":1}}],[\"以下是explain命令输出中type\",{\"1\":{\"807\":1}}],[\"以下是与事务相关的两个隐藏列\",{\"1\":{\"788\":1}}],[\"以下是并行事务可能引发的问题\",{\"1\":{\"776\":1}}],[\"以下是一个典型的\",{\"1\":{\"190\":1}}],[\"以下描述基于innodb存储引擎\",{\"1\":{\"770\":1}}],[\"以下均以默认存储引擎\",{\"1\":{\"770\":1}}],[\"以下分析适合\",{\"1\":{\"453\":1}}],[\"以下所有的逻辑都在锁内\",{\"1\":{\"265\":1}}],[\"以降低通信延迟\",{\"1\":{\"249\":1}}],[\"以唯一可用方法\",{\"1\":{\"249\":1}}],[\"以区分后来的版本\",{\"1\":{\"249\":1}}],[\"以json\",{\"1\":{\"249\":1}}],[\"以socket的角度\",{\"1\":{\"237\":1}}],[\"以防止其他事务在这个空隙间插入新的数据\",{\"1\":{\"820\":1}}],[\"以防止协议消息类型之间的名称冲突\",{\"1\":{\"229\":1}}],[\"以防止在重新分配期间发生数据丢失或重复\",{\"1\":{\"165\":1}}],[\"以链表形式来组织\",{\"1\":{\"226\":1}}],[\"以及如何在实际应用程序中使用\",{\"1\":{\"955\":1}}],[\"以及如果程序重启\",{\"1\":{\"882\":1}}],[\"以及降低aof文件的存储空间\",{\"1\":{\"949\":1}}],[\"以及对大型结构体返回的性能考量\",{\"1\":{\"430\":1}}],[\"以及k类型编号等\",{\"1\":{\"302\":1}}],[\"以及提供了6个方法\",{\"1\":{\"271\":1}}],[\"以及与地址解析协议\",{\"1\":{\"249\":1}}],[\"以及\",{\"1\":{\"223\":1,\"846\":1,\"888\":1,\"945\":1}}],[\"以及附带的所有标准软件工具\",{\"1\":{\"220\":1}}],[\"以及常量指针或引用\",{\"1\":{\"33\":1}}],[\"以便实现更多功能\",{\"1\":{\"941\":1}}],[\"以便于判断数据的可见性\",{\"1\":{\"744\":1}}],[\"以便后面完成真正的更新操作\",{\"1\":{\"531\":1}}],[\"以便在函数之间共享和修改数据\",{\"1\":{\"459\":1}}],[\"以便\",{\"1\":{\"229\":1}}],[\"以便我们自定义大小\",{\"1\":{\"217\":1}}],[\"以便子函数执行结束后能返回继续执行\",{\"1\":{\"36\":1}}],[\"以\",{\"1\":{\"217\":1,\"249\":1,\"587\":3,\"655\":3,\"838\":1,\"873\":1}}],[\"以逗号分隔的用户名\",{\"1\":{\"190\":1}}],[\"以保证分区的正常运行\",{\"1\":{\"181\":1}}],[\"以保证数据的可靠性和一致性\",{\"1\":{\"170\":2}}],[\"以保证数据的可靠性和高可用性\",{\"1\":{\"170\":1}}],[\"以保持数据的一致性和冗余\",{\"1\":{\"174\":1}}],[\"以包括新的消费者\",{\"1\":{\"165\":1}}],[\"以提高可用性\",{\"1\":{\"157\":1}}],[\"以供consumer订阅和消费\",{\"1\":{\"156\":1}}],[\"以通过\",{\"1\":{\"117\":1}}],[\"以表明这些参数和返回值在函数内部不能被修改\",{\"1\":{\"33\":1}}],[\"以清理对象占用的资源\",{\"1\":{\"33\":1}}],[\"以初始化对象\",{\"1\":{\"33\":1}}],[\"以容纳所需的对象\",{\"1\":{\"33\":1}}],[\"以查询和删除操作为例\",{\"1\":{\"23\":1}}],[\"操作redis\",{\"1\":{\"930\":2}}],[\"操作确实成为了瓶颈\",{\"1\":{\"897\":1}}],[\"操作触发的时候\",{\"1\":{\"888\":1}}],[\"操作监听客户端请求\",{\"1\":{\"888\":1}}],[\"操作中\",{\"1\":{\"888\":1}}],[\"操作时顺带迁移\",{\"1\":{\"864\":1}}],[\"操作时\",{\"1\":{\"820\":2}}],[\"操作时通常需要的cpu资源更少\",{\"1\":{\"807\":1}}],[\"操作成功\",{\"1\":{\"810\":1}}],[\"操作结束\",{\"1\":{\"529\":1}}],[\"操作无锁完成\",{\"1\":{\"526\":1}}],[\"操作\",{\"1\":{\"524\":1,\"748\":1,\"751\":1,\"755\":1,\"759\":1,\"767\":2,\"770\":1,\"810\":7,\"820\":2,\"897\":2,\"1015\":1}}],[\"操作在\",{\"1\":{\"524\":1}}],[\"操作揽下大部分操作\",{\"1\":{\"512\":1}}],[\"操作会立即返回一个错误\",{\"1\":{\"226\":1}}],[\"操作系统时钟\",{\"1\":{\"906\":1}}],[\"操作系统才会触发缺页中断\",{\"1\":{\"748\":1,\"810\":1}}],[\"操作系统会将数据复制到应用程序的缓冲区\",{\"1\":{\"226\":1}}],[\"操作系统会发送一个信号\",{\"1\":{\"226\":1}}],[\"操作系统\",{\"1\":{\"220\":1},\"2\":{\"218\":1,\"221\":1,\"224\":1}}],[\"操作系统管理堆内存是有一个链表的\",{\"1\":{\"217\":1}}],[\"操作系统提供了更好的安全性\",{\"1\":{\"217\":1}}],[\"操作符会调用内存释放函数\",{\"1\":{\"33\":1}}],[\"操作符会在分配的内存上调用对象的构造函数\",{\"1\":{\"33\":1}}],[\"操作符首先调用对象的析构函数\",{\"1\":{\"33\":1}}],[\"操作符首先调用内存分配函数\",{\"1\":{\"33\":1}}],[\"操作符返回一个指向新分配和初始化对象的指针\",{\"1\":{\"33\":1}}],[\"操作a等于操作b\",{\"1\":{\"30\":1}}],[\"速度慢\",{\"1\":{\"33\":1}}],[\"速度快的原因之一\",{\"1\":{\"957\":1}}],[\"速度快的原因是\",{\"1\":{\"956\":1}}],[\"速度快\",{\"1\":{\"33\":1}}],[\"栈\",{\"1\":{\"423\":1,\"477\":1}}],[\"栈空间足够时\",{\"0\":{\"412\":1}}],[\"栈空间不足逃逸\",{\"0\":{\"411\":1}}],[\"栈上面的变量在函数结束的时候会自动回收\",{\"1\":{\"405\":1}}],[\"栈上的数据需要在函数结束之后还能被访问\",{\"1\":{\"405\":1}}],[\"栈上分配\",{\"0\":{\"292\":1}}],[\"栈上操作比堆要快\",{\"1\":{\"217\":1}}],[\"栈有寄存器直接对栈进行访问\",{\"1\":{\"217\":1}}],[\"栈一般是8mb\",{\"1\":{\"217\":1}}],[\"栈自动分配和回收\",{\"1\":{\"217\":1}}],[\"栈的大小是固定的\",{\"1\":{\"217\":1}}],[\"栈段\",{\"1\":{\"217\":1}}],[\"栈等\",{\"1\":{\"217\":1}}],[\"栈由系统分配\",{\"1\":{\"33\":1}}],[\"栈由系统自动分配\",{\"1\":{\"33\":1}}],[\"栈是高地址向底地址拓展\",{\"1\":{\"33\":1}}],[\"栈顶和栈底是提前预设好的\",{\"1\":{\"33\":1}}],[\"申请自增主键后就释放锁\",{\"1\":{\"820\":2}}],[\"申请物理内存\",{\"1\":{\"748\":1,\"810\":1}}],[\"申请一片连续的内存空间\",{\"1\":{\"748\":1,\"810\":1}}],[\"申请的证书一般不是根证书签发的\",{\"1\":{\"249\":1}}],[\"申请的内存会马上归还给操作系统\",{\"1\":{\"217\":1}}],[\"申请的内存不会归给操作系统\",{\"1\":{\"217\":1}}],[\"申请的内存位置不同\",{\"1\":{\"217\":1}}],[\"申请数字证书\",{\"1\":{\"249\":1}}],[\"申请8gb的话要考虑是否开启swap分区\",{\"1\":{\"217\":1}}],[\"申请8gb的话会在申请阶段就失败\",{\"1\":{\"217\":1}}],[\"申请\",{\"1\":{\"217\":1,\"820\":2}}],[\"申请内存\",{\"1\":{\"217\":2}}],[\"申请效率不同\",{\"1\":{\"33\":1}}],[\"申请大小限制不同\",{\"1\":{\"33\":1}}],[\"申请方式不同\",{\"1\":{\"33\":1}}],[\"申请长度为\",{\"1\":{\"20\":1}}],[\"就退化到了方向\",{\"1\":{\"930\":1}}],[\"就有海量数据\",{\"1\":{\"930\":1}}],[\"就有必要做缓存\",{\"1\":{\"930\":1}}],[\"就有三层\",{\"1\":{\"885\":1}}],[\"就订阅所有\",{\"1\":{\"924\":1}}],[\"就执行一次近似\",{\"1\":{\"906\":1}}],[\"就存不下了\",{\"1\":{\"879\":1}}],[\"就定位到\",{\"1\":{\"879\":1}}],[\"就使用\",{\"1\":{\"870\":1}}],[\"就发生扩容\",{\"1\":{\"864\":1}}],[\"就发生了幻读\",{\"1\":{\"779\":1}}],[\"就发生了不可重复读\",{\"1\":{\"778\":1}}],[\"就出现下面这个提示\",{\"1\":{\"820\":1}}],[\"就出现了报错\",{\"1\":{\"820\":1}}],[\"就对这个事务进行回滚\",{\"1\":{\"820\":1}}],[\"就如前面的这个例子\",{\"1\":{\"820\":1}}],[\"就引出了\",{\"1\":{\"820\":1}}],[\"就表示锁的范围最右值\",{\"1\":{\"820\":1}}],[\"就表示锁的范围\",{\"1\":{\"820\":1}}],[\"就表示执行过程中使用了哪个索引\",{\"1\":{\"817\":1}}],[\"就采用轻量级锁\",{\"1\":{\"820\":1}}],[\"就采用\",{\"1\":{\"820\":1}}],[\"就把这个轻量级锁释放了\",{\"1\":{\"820\":1}}],[\"就把对应的计数加\",{\"1\":{\"79\":1}}],[\"就都会被阻塞\",{\"1\":{\"820\":1}}],[\"就无法申请到\",{\"1\":{\"820\":1}}],[\"就真正开始执行语句了\",{\"1\":{\"817\":1}}],[\"就确定了执行方案\",{\"1\":{\"817\":1}}],[\"就没必要在主键索引查找了\",{\"1\":{\"817\":1}}],[\"就往下执行\",{\"1\":{\"817\":1}}],[\"就选择第一个不包含\",{\"1\":{\"813\":1}}],[\"就忽视binlog\",{\"1\":{\"810\":1}}],[\"就马上将\",{\"1\":{\"810\":1}}],[\"就拿着\",{\"1\":{\"810\":1}}],[\"就直接返回给执行器更新\",{\"1\":{\"810\":2}}],[\"就返回客户端结果\",{\"1\":{\"810\":1}}],[\"就只需要缓冲一条记录吗\",{\"1\":{\"810\":1}}],[\"就读取\",{\"1\":{\"810\":2}}],[\"就被移除这个功能了\",{\"1\":{\"810\":1}}],[\"就被视为实现了该接口\",{\"1\":{\"463\":1}}],[\"就能看到事务\",{\"1\":{\"793\":1}}],[\"就能使用顺序\",{\"1\":{\"770\":1}}],[\"就创建一个新的文件继续写\",{\"1\":{\"759\":1,\"810\":1}}],[\"就创建了在主机和所有容器之间一个虚拟共享网络\",{\"1\":{\"123\":1}}],[\"就好了\",{\"1\":{\"741\":1,\"810\":2}}],[\"就立即返回数据给客户端\",{\"1\":{\"730\":1,\"761\":1}}],[\"就要暂存到磁盘\",{\"1\":{\"810\":1}}],[\"就要考虑分库\",{\"1\":{\"727\":1}}],[\"就要保证在这\",{\"1\":{\"708\":1}}],[\"就要用断言\",{\"1\":{\"469\":1}}],[\"就相当于\",{\"1\":{\"527\":1,\"813\":2}}],[\"就意味着能在\",{\"1\":{\"810\":1}}],[\"就意味着\",{\"1\":{\"518\":1,\"810\":1}}],[\"就不再单纯的是日志数据\",{\"1\":{\"949\":1}}],[\"就不再增加\",{\"1\":{\"807\":1}}],[\"就不用继续等待了\",{\"1\":{\"810\":1}}],[\"就不用担心无法回滚到事务之前的数据\",{\"1\":{\"739\":1,\"810\":1}}],[\"就不能称为逻辑日志了\",{\"1\":{\"810\":1}}],[\"就不能再重新绑定到其他对象\",{\"1\":{\"33\":1}}],[\"就不需要从磁盘获取数据了\",{\"1\":{\"747\":1,\"810\":1}}],[\"就不会让锁失效了\",{\"1\":{\"917\":1,\"921\":1}}],[\"就不会丢消息\",{\"1\":{\"710\":1}}],[\"就不会发生\",{\"1\":{\"511\":1}}],[\"就算\",{\"1\":{\"476\":1,\"765\":1,\"810\":1}}],[\"就全变成\",{\"1\":{\"446\":1}}],[\"就足够\",{\"1\":{\"378\":1}}],[\"就开始从\",{\"1\":{\"374\":1}}],[\"就像它的命名一样\",{\"1\":{\"955\":1}}],[\"就像石沉大海\",{\"1\":{\"911\":1,\"921\":1}}],[\"就像这个事务从来没有执行过一样\",{\"1\":{\"774\":1}}],[\"就像先前的\",{\"1\":{\"249\":1}}],[\"就像物理机一样\",{\"1\":{\"246\":1}}],[\"就像生活中的菜鸟驿站一样kafka的服务端就担任了菜鸟驿站的角色\",{\"1\":{\"156\":1}}],[\"就在用户家目录的隐藏文件里找\",{\"1\":{\"223\":1}}],[\"就去访问数据库\",{\"1\":{\"930\":1}}],[\"就去负载该槽的节点进行交互\",{\"1\":{\"723\":1}}],[\"就去\",{\"1\":{\"223\":1}}],[\"就可以将默认的\",{\"1\":{\"957\":1}}],[\"就可以一定程度解决网络延迟的问题\",{\"1\":{\"918\":1,\"921\":1}}],[\"就可以算出上一个节点的受位置\",{\"1\":{\"879\":1}}],[\"就可以匹配上联合索引\",{\"1\":{\"813\":1}}],[\"就可以走索引了\",{\"1\":{\"813\":1}}],[\"就可以保证即使数据库发生异常重启\",{\"1\":{\"810\":1}}],[\"就可以按客户来进行分区\",{\"1\":{\"723\":1}}],[\"就可以返回了\",{\"1\":{\"265\":1}}],[\"就可以重发ack报文\",{\"1\":{\"237\":1}}],[\"就可以通过命令把设备挂载到\",{\"1\":{\"223\":1}}],[\"就可以在那里找到\",{\"1\":{\"223\":1}}],[\"就可以分别在堆和文件映射段动态分配内存\",{\"1\":{\"217\":1}}],[\"就需要持久化\",{\"1\":{\"952\":1}}],[\"就需要遍历表里所有记录\",{\"1\":{\"820\":1}}],[\"就需要优化器来决定使用哪个索引了\",{\"1\":{\"817\":1}}],[\"就需要2字节\",{\"1\":{\"770\":1}}],[\"就需要考虑分表\",{\"1\":{\"727\":1}}],[\"就需要实现内部嵌套的接口对应的所有方法\",{\"1\":{\"471\":1}}],[\"就需要在\",{\"1\":{\"223\":1}}],[\"就需要\",{\"1\":{\"217\":1}}],[\"就将段基地址加上段内偏移量得到物理内存地址\",{\"1\":{\"217\":1}}],[\"就是在网上搜集的各种字符组合的hash加密结果\",{\"1\":{\"1049\":1}}],[\"就是在第一种的基础上\",{\"1\":{\"927\":1}}],[\"就是针对相同key的操作\",{\"1\":{\"952\":1}}],[\"就是是能被修改的\",{\"1\":{\"952\":1}}],[\"就是因为其他字符可能占据该值\",{\"1\":{\"930\":1}}],[\"就是将mysql的热点数据存储在redis中\",{\"1\":{\"930\":1}}],[\"就是为redis配置从节点\",{\"1\":{\"916\":1,\"921\":1}}],[\"就是有序集合\",{\"1\":{\"876\":1}}],[\"就是间隙锁\",{\"1\":{\"820\":1}}],[\"就是对\",{\"1\":{\"820\":3}}],[\"就是开启了事务\",{\"1\":{\"820\":1}}],[\"就是使用了主键索引\",{\"1\":{\"817\":1}}],[\"就是由存储引擎层实现的\",{\"1\":{\"817\":1}}],[\"就是排序的列\",{\"1\":{\"813\":1}}],[\"就是独立的列\",{\"1\":{\"807\":1}}],[\"就是尽量在开启事务之后\",{\"1\":{\"795\":1}}],[\"就是一条记录的存储结构\",{\"1\":{\"770\":1}}],[\"就是让链表中相邻的页的物理位置也相邻\",{\"1\":{\"770\":1}}],[\"就是根据业务确定分区\",{\"1\":{\"720\":1}}],[\"就是通过cas将expunged态的entry变成nil态\",{\"1\":{\"531\":1}}],[\"就是通过遍历文件描述符集合的方式\",{\"1\":{\"226\":1}}],[\"就是标记\",{\"1\":{\"516\":1}}],[\"就是网络世界里的公安局\",{\"1\":{\"249\":1}}],[\"就是空字符串\",{\"1\":{\"249\":1}}],[\"就是我电脑上的两块硬盘\",{\"1\":{\"223\":1}}],[\"就是\",{\"1\":{\"217\":1,\"512\":1,\"516\":1,\"810\":1,\"820\":1,\"873\":1,\"876\":1,\"879\":1}}],[\"就是说如果一个follower比一个leader落后超过了给定阈值\",{\"1\":{\"182\":1}}],[\"就是生产者\",{\"1\":{\"156\":1}}],[\"就是没有程序了\",{\"1\":{\"145\":1}}],[\"就会触发\",{\"1\":{\"952\":1}}],[\"就会释放锁\",{\"1\":{\"912\":1,\"921\":1}}],[\"就会将重写缓冲区内容\",{\"1\":{\"952\":1}}],[\"就会将池子中活性最低\",{\"1\":{\"906\":1}}],[\"就会将记录返回给执行器\",{\"1\":{\"817\":1}}],[\"就会进入多线程模式\",{\"1\":{\"897\":1}}],[\"就会进行缩容\",{\"1\":{\"864\":1}}],[\"就会进行全表扫描\",{\"1\":{\"813\":1}}],[\"就会产生通知\",{\"1\":{\"888\":1}}],[\"就会两个\",{\"1\":{\"864\":1}}],[\"就会阻塞\",{\"1\":{\"820\":1,\"924\":1}}],[\"就会报主键索引冲突的错误\",{\"1\":{\"820\":1}}],[\"就会退化成退化成记录锁或间隙锁\",{\"1\":{\"820\":1}}],[\"就会退化成无缓冲channel一样\",{\"1\":{\"257\":1}}],[\"就会有大量的线程被阻塞住\",{\"1\":{\"820\":1}}],[\"就会停止匹配\",{\"1\":{\"817\":1}}],[\"就会向执行器上报记录找不到的错误\",{\"1\":{\"817\":1}}],[\"就会在备份数据库之前先开启事务\",{\"1\":{\"820\":1}}],[\"就会在解析器这个阶段报错\",{\"1\":{\"817\":1}}],[\"就会在缓存中以\",{\"1\":{\"817\":1}}],[\"就会验证你的用户名和密码\",{\"1\":{\"817\":1}}],[\"就会下推到\",{\"1\":{\"813\":1}}],[\"就会发生阻塞\",{\"1\":{\"820\":1}}],[\"就会发生\",{\"1\":{\"813\":1}}],[\"就会发生脏读\",{\"1\":{\"777\":1}}],[\"就会被阻塞的\",{\"1\":{\"820\":1}}],[\"就会被阻塞\",{\"1\":{\"820\":4}}],[\"就会被持久化到磁盘\",{\"1\":{\"810\":1}}],[\"就会被捕获\",{\"1\":{\"479\":1}}],[\"就会导致对锁的争用\",{\"1\":{\"810\":1}}],[\"就会造成主从环境的数据不一致性\",{\"1\":{\"810\":1}}],[\"就会往后移动\",{\"1\":{\"810\":1}}],[\"就会得到\",{\"1\":{\"794\":1}}],[\"就会把该事务的事务\",{\"1\":{\"788\":1}}],[\"就会把部分\",{\"1\":{\"374\":1}}],[\"就会马上启动事务\",{\"1\":{\"785\":1}}],[\"就会用\",{\"1\":{\"770\":2}}],[\"就会为记录添加\",{\"1\":{\"770\":1}}],[\"就会跟裁判说还没准备好\",{\"1\":{\"764\":1,\"810\":1}}],[\"就会跟裁判说准备好了\",{\"1\":{\"764\":1,\"810\":1}}],[\"就会默认提交上一个事务\",{\"1\":{\"760\":1,\"810\":1}}],[\"就会顺着\",{\"1\":{\"743\":1,\"810\":1}}],[\"就会出现问题\",{\"1\":{\"912\":1,\"921\":1}}],[\"就会出现下面这个提示\",{\"1\":{\"820\":1}}],[\"就会出现两个重复的订单\",{\"1\":{\"820\":1}}],[\"就会出现\",{\"1\":{\"520\":1}}],[\"就会从\",{\"1\":{\"519\":1}}],[\"就会频繁关闭连接\",{\"1\":{\"237\":1}}],[\"就会复用处于\",{\"1\":{\"237\":1}}],[\"就会立刻停止\",{\"1\":{\"145\":1}}],[\"就会自动停止\",{\"1\":{\"145\":1}}],[\"就会执行删除命令\",{\"1\":{\"23\":1}}],[\"就必须要有要一个前台进程\",{\"1\":{\"145\":1}}],[\"就挂载为只读了\",{\"1\":{\"113\":1}}],[\"就随之启动了\",{\"1\":{\"104\":1}}],[\"就用从缓存中获得的数据\",{\"1\":{\"930\":1}}],[\"就用缓存数据直接打包返回\",{\"1\":{\"930\":1}}],[\"就用\",{\"1\":{\"88\":2,\"249\":1}}],[\"就初始化为\",{\"1\":{\"79\":1}}],[\"就已经规划好通过某种方式让每台机器都能获取到一部分分片后的日志数据\",{\"1\":{\"79\":1}}],[\"就释放该对象\",{\"1\":{\"33\":1}}],[\"效果都是\",{\"1\":{\"249\":1}}],[\"效果一致\",{\"1\":{\"23\":1}}],[\"效率会明显提高\",{\"1\":{\"813\":1}}],[\"效率会非常低\",{\"1\":{\"770\":1}}],[\"效率提升的幅度是否也大\",{\"1\":{\"807\":1}}],[\"效率提升\",{\"1\":{\"226\":1}}],[\"效率较低\",{\"1\":{\"226\":2}}],[\"效率上讲\",{\"1\":{\"33\":1}}],[\"传统加密算法的局限\",{\"0\":{\"1054\":1}}],[\"传到到函教参数\",{\"1\":{\"456\":1}}],[\"传入一个变量来指定其大小\",{\"1\":{\"415\":1}}],[\"传递消息的队列\",{\"1\":{\"924\":1}}],[\"传递给下一个过滤器或servlet\",{\"1\":{\"683\":1}}],[\"传递给下一个过滤器或目标资源\",{\"1\":{\"584\":1}}],[\"传递结束\",{\"1\":{\"479\":1}}],[\"传递链\",{\"1\":{\"479\":1}}],[\"传递地址也是值传递\",{\"1\":{\"454\":1}}],[\"传递指针可以减少底层值拷贝\",{\"1\":{\"409\":1}}],[\"传递的是地址值\",{\"1\":{\"33\":1}}],[\"传输协议固定为tcp的情况下讨论的\",{\"1\":{\"237\":1}}],[\"传输协议\",{\"1\":{\"237\":1}}],[\"传输层负责提供端到端的通信服务\",{\"1\":{\"249\":1}}],[\"传输层的报文\",{\"1\":{\"237\":1}}],[\"传输层\",{\"1\":{\"237\":1,\"249\":2},\"2\":{\"239\":1}}],[\"传输完成后用同一个哈希算法计算\",{\"1\":{\"76\":1}}],[\"传输前对每个文件块分别取哈希值\",{\"1\":{\"76\":1}}],[\"传地址\",{\"1\":{\"33\":1}}],[\"传值\",{\"1\":{\"33\":2}}],[\"有如下表\",{\"1\":{\"1013\":1}}],[\"有如下配置\",{\"1\":{\"952\":1}}],[\"有客户端等待数据的键\",{\"1\":{\"944\":1}}],[\"有一定要求\",{\"1\":{\"930\":1}}],[\"有一个问题要考虑\",{\"1\":{\"927\":1}}],[\"有一个索引下推功能\",{\"1\":{\"813\":1}}],[\"有一个比较特殊的查询条件\",{\"1\":{\"813\":1}}],[\"有一个个的槽位\",{\"1\":{\"748\":1}}],[\"有一个\",{\"1\":{\"373\":1}}],[\"有一个过期时间\",{\"1\":{\"249\":1}}],[\"有一个形参向函数所属的栈拷贝数据的过程\",{\"1\":{\"33\":1}}],[\"有先入先出的特性\",{\"1\":{\"924\":1}}],[\"有更高的吞吐量和低延迟\",{\"1\":{\"888\":1}}],[\"有多少元素空间\",{\"1\":{\"864\":1}}],[\"有多个\",{\"1\":{\"381\":1}}],[\"有其他事务插入了与第一个事务相同的记录\",{\"1\":{\"820\":1}}],[\"有其他事务插入了记录\",{\"1\":{\"820\":1}}],[\"有个事务\",{\"1\":{\"820\":1}}],[\"有可能上秒的快照还没完成\",{\"1\":{\"952\":1}}],[\"有可能出现幻读\",{\"1\":{\"820\":1}}],[\"有可能会被系统强制杀掉\",{\"1\":{\"817\":1}}],[\"有的\",{\"1\":{\"820\":1}}],[\"有哪些锁\",{\"1\":{\"820\":1}}],[\"有连接限制\",{\"1\":{\"817\":1}}],[\"有索引下推的查询过程\",{\"1\":{\"813\":1}}],[\"有冗余节点\",{\"1\":{\"813\":1}}],[\"有什么优化的方法\",{\"1\":{\"810\":1}}],[\"有什么区别\",{\"1\":{\"810\":1}}],[\"有动态函数的问题\",{\"1\":{\"810\":1}}],[\"有很多\",{\"1\":{\"770\":1}}],[\"有不同的存储结构\",{\"1\":{\"770\":1}}],[\"有了结构化\",{\"1\":{\"944\":1}}],[\"有了这套机制之后\",{\"1\":{\"927\":1}}],[\"有了\",{\"1\":{\"810\":1}}],[\"有了buffer\",{\"1\":{\"747\":1}}],[\"有了recover之后\",{\"1\":{\"478\":1}}],[\"有写入策略配置\",{\"1\":{\"710\":1}}],[\"有三种主要方式获取class对象\",{\"1\":{\"553\":1}}],[\"有三种情况\",{\"1\":{\"263\":1}}],[\"有数据在\",{\"1\":{\"516\":1}}],[\"有问题就报panic\",{\"1\":{\"469\":1}}],[\"有些场景也是需要过期时间支持\",{\"1\":{\"882\":1}}],[\"有些运算符拥有较高的优先级\",{\"1\":{\"445\":1}}],[\"有些服务器选择直接禁用\",{\"1\":{\"249\":1}}],[\"有缓冲区\",{\"1\":{\"263\":1}}],[\"有缓冲区buf\",{\"1\":{\"263\":1}}],[\"有缓冲channel\",{\"0\":{\"256\":1}}],[\"有着与\",{\"1\":{\"249\":1}}],[\"有几种可能\",{\"1\":{\"927\":1}}],[\"有几种构造函数\",{\"1\":{\"33\":1}}],[\"有几处基本的不同\",{\"1\":{\"249\":1}}],[\"有效磁盘数\",{\"1\":{\"807\":2}}],[\"有效期\",{\"1\":{\"249\":1}}],[\"有效时间等信息打成一个包\",{\"1\":{\"240\":1,\"249\":1}}],[\"有两个步骤\",{\"1\":{\"927\":1}}],[\"有两个字段\",{\"1\":{\"885\":1}}],[\"有两部分\",{\"1\":{\"879\":1}}],[\"有两种方法\",{\"1\":{\"915\":1,\"921\":1}}],[\"有两种方法可以指定\",{\"1\":{\"229\":1}}],[\"有两种策略通过\",{\"1\":{\"820\":1}}],[\"有两点格外重要\",{\"1\":{\"72\":1}}],[\"有以下几种输出模式\",{\"1\":{\"229\":1}}],[\"有事件发生时\",{\"1\":{\"226\":1}}],[\"有点像\",{\"1\":{\"223\":1}}],[\"有点类似于死锁的情况\",{\"1\":{\"33\":1}}],[\"有时候一种对象底层有几种实现以对应不同的场景\",{\"1\":{\"888\":1}}],[\"有时候又需要到叶子节点才能找到索引\",{\"1\":{\"813\":1}}],[\"有时候通过终端工具远程连接\",{\"1\":{\"807\":1}}],[\"有时候\",{\"1\":{\"491\":1}}],[\"有时候普通用户可以使用的命令\",{\"1\":{\"223\":1}}],[\"有时候在桌面找不到应用程序的快捷方式\",{\"1\":{\"223\":1}}],[\"有时\",{\"1\":{\"190\":1}}],[\"有机会被选举成为新的主节点\",{\"1\":{\"180\":1}}],[\"有\",{\"1\":{\"101\":1,\"119\":1,\"220\":1,\"516\":2,\"748\":1,\"810\":4,\"873\":1,\"882\":1}}],[\"有参构造函数\",{\"1\":{\"33\":1}}],[\"有类似语法提示的效果\",{\"1\":{\"10\":1}}],[\"函数创建了一个自定义的\",{\"1\":{\"957\":1}}],[\"函数\",{\"1\":{\"864\":1}}],[\"函数指针指向的还是\",{\"1\":{\"817\":1}}],[\"函数指针指向的函数\",{\"1\":{\"817\":4}}],[\"函数索引\",{\"1\":{\"813\":1}}],[\"函数来支持运行时修改日志级别\",{\"1\":{\"957\":1}}],[\"函数来重置连接\",{\"1\":{\"817\":1}}],[\"函数来验证\",{\"1\":{\"770\":1}}],[\"函数来检查它是否为空指针\",{\"1\":{\"33\":1}}],[\"函数都没有\",{\"1\":{\"479\":1}}],[\"函数发生了\",{\"1\":{\"479\":1}}],[\"函数跳出返回到\",{\"1\":{\"479\":1}}],[\"函数并传入任意数量的\",{\"1\":{\"458\":1}}],[\"函数中\",{\"1\":{\"458\":1,\"897\":1}}],[\"函数接受任意数量的\",{\"1\":{\"458\":1}}],[\"函数使用了可变参数语法\",{\"1\":{\"458\":1}}],[\"函数内部对副本的修改不会影响原始的结构体或数组\",{\"1\":{\"457\":1}}],[\"函数名\",{\"1\":{\"433\":1}}],[\"函数名是p\",{\"1\":{\"33\":1}}],[\"函数运行完毕后回收内存\",{\"1\":{\"405\":1}}],[\"函数运行在栈上\",{\"1\":{\"405\":1}}],[\"函数加入内核中的红黑树里\",{\"1\":{\"226\":1}}],[\"函数将文件描述符集合拷贝到内核里\",{\"1\":{\"226\":1}}],[\"函数会在＞某个阈值的时候\",{\"1\":{\"217\":1}}],[\"函数会进行类型检查\",{\"1\":{\"33\":1}}],[\"函数时\",{\"1\":{\"217\":1,\"226\":1}}],[\"函数的接口\",{\"1\":{\"817\":1}}],[\"函数的使用可以使程序更加模块化\",{\"1\":{\"36\":1}}],[\"函数的引用\",{\"1\":{\"30\":1}}],[\"函数参数为interface\",{\"1\":{\"414\":1}}],[\"函数参数和返回值\",{\"1\":{\"33\":1}}],[\"函数参数具有类型\",{\"1\":{\"33\":1}}],[\"函数传参时\",{\"1\":{\"33\":1}}],[\"函数有返回值\",{\"1\":{\"33\":1}}],[\"函数定义\",{\"1\":{\"33\":1}}],[\"函数调用具有返回值\",{\"1\":{\"33\":1}}],[\"函数调用在运行时需要跳转到具体调用函数\",{\"1\":{\"33\":1}}],[\"初始化gin引擎\",{\"1\":{\"1024\":1}}],[\"初始化字段配置\",{\"1\":{\"957\":1}}],[\"初始化操作\",{\"1\":{\"683\":1}}],[\"初始化servlet\",{\"1\":{\"664\":1}}],[\"初始化\",{\"1\":{\"662\":1}}],[\"初始化数据库连接池失败\",{\"1\":{\"640\":1}}],[\"初始化数据库连接池\",{\"1\":{\"640\":1}}],[\"初始化应用级别的资源\",{\"1\":{\"624\":1}}],[\"初始化过程中\",{\"1\":{\"590\":1}}],[\"初始化阶段\",{\"0\":{\"590\":1},\"1\":{\"629\":1,\"631\":1}}],[\"初始化中\",{\"1\":{\"584\":1,\"590\":1}}],[\"初始化之后值就不能被修改\",{\"1\":{\"570\":1}}],[\"初始化一个\",{\"1\":{\"510\":1,\"511\":1}}],[\"初始化切片容量的时候\",{\"1\":{\"415\":1}}],[\"初始化比特位\",{\"1\":{\"226\":1}}],[\"初始化后不能修改它所指向的地址\",{\"1\":{\"33\":1}}],[\"初始化后不能再改变\",{\"1\":{\"33\":1}}],[\"初始化和赋值没什么区别\",{\"1\":{\"33\":1}}],[\"初始化和赋值的区别\",{\"1\":{\"33\":1}}],[\"初始化时不能为null\",{\"1\":{\"33\":1}}],[\"只更新指定的单个字段\",{\"1\":{\"998\":1}}],[\"只在\",{\"1\":{\"957\":1}}],[\"只不过这些由数据服务托管保存\",{\"1\":{\"930\":1}}],[\"只输出\",{\"1\":{\"842\":1}}],[\"只存在于可重复读隔离级别\",{\"1\":{\"820\":1}}],[\"只存储\",{\"1\":{\"770\":1}}],[\"只存储qq号码存在与否\",{\"1\":{\"20\":1}}],[\"只存储必要信息\",{\"1\":{\"20\":1}}],[\"只查询\",{\"1\":{\"813\":1}}],[\"只查询用户当前需要查看的数据\",{\"1\":{\"807\":1}}],[\"只用\",{\"1\":{\"813\":1}}],[\"只说两阶段提交\",{\"1\":{\"810\":1}}],[\"只记录未被刷入磁盘的数据的物理日志\",{\"1\":{\"810\":1}}],[\"只返回需要的数据\",{\"1\":{\"807\":1}}],[\"只出现在数据表有变长字段的时候\",{\"1\":{\"770\":1}}],[\"只针对带有过期时间的键\",{\"1\":{\"900\":2}}],[\"只针对\",{\"1\":{\"767\":1,\"810\":1}}],[\"只执行一次\",{\"1\":{\"662\":2}}],[\"只匹配\",{\"1\":{\"587\":1,\"655\":1}}],[\"只面向虚拟机\",{\"1\":{\"566\":1}}],[\"只想json展示\",{\"1\":{\"488\":1}}],[\"只编译选定的源码而不构建可执行文件\",{\"1\":{\"391\":1}}],[\"只占几\",{\"1\":{\"378\":1}}],[\"只复制切片结构\",{\"1\":{\"342\":1}}],[\"只包含该接口方法\",{\"1\":{\"307\":1}}],[\"只包含响应文档本身\",{\"1\":{\"249\":1}}],[\"只分配hchan本身结构体大小的内存\",{\"1\":{\"263\":1}}],[\"只做一般的base64编码\",{\"1\":{\"249\":1}}],[\"只需要定义一个接收\",{\"1\":{\"957\":1}}],[\"只需要创建一个定制的\",{\"1\":{\"957\":1}}],[\"只需要保证\",{\"1\":{\"957\":1}}],[\"只需要\",{\"1\":{\"765\":1,\"810\":1}}],[\"只需要缓存一条记录吗\",{\"1\":{\"748\":1}}],[\"只需要两个cpu指令push和release\",{\"1\":{\"405\":1}}],[\"只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可\",{\"1\":{\"226\":1}}],[\"只需在虚拟机软件中选择nat模式即可\",{\"1\":{\"246\":1}}],[\"只要满足其中一个条件\",{\"1\":{\"952\":1}}],[\"只要超过一半\",{\"1\":{\"917\":1,\"921\":1}}],[\"只要不访问\",{\"1\":{\"882\":1}}],[\"只要知道怎么去区分不同类型即可\",{\"1\":{\"879\":1}}],[\"只要系统发生死锁\",{\"1\":{\"820\":1}}],[\"只要系统没有宕机\",{\"1\":{\"810\":1}}],[\"只要有条件列不是索引列\",{\"1\":{\"813\":1}}],[\"只要有一个副本是完整的\",{\"1\":{\"176\":1}}],[\"只要数据成功复制到任意一个从库上\",{\"1\":{\"810\":1}}],[\"只要数据是相同的\",{\"1\":{\"249\":1}}],[\"只要一部分复制成功响应回来就行\",{\"1\":{\"810\":1}}],[\"只要操作系统不宕机\",{\"1\":{\"810\":1}}],[\"只要先将\",{\"1\":{\"752\":1,\"810\":1}}],[\"只要成功同步到一个从库\",{\"1\":{\"730\":1,\"761\":1}}],[\"只要写入了队列\",{\"1\":{\"710\":1}}],[\"只要消息进入了\",{\"1\":{\"706\":1}}],[\"只要请求方和响应方都能理解就行\",{\"1\":{\"249\":1}}],[\"只要3次握手就可以完成3tcp+4tls的过程\",{\"1\":{\"240\":1}}],[\"只要文件描述符处于就绪状态\",{\"1\":{\"226\":1}}],[\"只会用\",{\"1\":{\"952\":1}}],[\"只会少卖不会多卖\",{\"1\":{\"927\":1}}],[\"只会调用postponeclientread将\",{\"1\":{\"897\":1}}],[\"只会和共享表锁\",{\"1\":{\"820\":1}}],[\"只会保存一份\",{\"1\":{\"813\":1}}],[\"只会将逻辑上存在的数据\",{\"1\":{\"525\":1}}],[\"只会返回有事件发生的文件描述符的个数\",{\"1\":{\"226\":1}}],[\"只会复制虚拟内存\",{\"1\":{\"217\":1}}],[\"只有这里加载了模板\",{\"1\":{\"1031\":1}}],[\"只有这些数据\",{\"1\":{\"820\":2}}],[\"只有活性比池子里活性最小的\",{\"1\":{\"906\":1}}],[\"只有活跃可用的fd才会调用callback函数\",{\"1\":{\"226\":1}}],[\"只有向前指针\",{\"1\":{\"885\":1}}],[\"只有被删改查的数据才会别迁移\",{\"1\":{\"864\":1}}],[\"只有当锁状态为正常状态时\",{\"1\":{\"820\":3}}],[\"只有当执行完一条\",{\"1\":{\"820\":1}}],[\"只有再新建的连接才会使用新的权限设置\",{\"1\":{\"817\":1}}],[\"只有在赋予他数据库和相关表的权限之后\",{\"1\":{\"846\":1}}],[\"只有在特殊情况下\",{\"1\":{\"820\":1}}],[\"只有在操作系统崩溃或者系统断电的情况下\",{\"1\":{\"810\":1}}],[\"只有在执行这个命令后\",{\"1\":{\"785\":1}}],[\"只有在对象实例化之后才存在\",{\"1\":{\"573\":1}}],[\"只有所有的副本都成功写入消息后\",{\"1\":{\"710\":1}}],[\"只有read有它的指针\",{\"1\":{\"531\":1}}],[\"只有\",{\"1\":{\"249\":1,\"450\":1,\"813\":2}}],[\"只有该数据包中包含数据的流才会被阻止\",{\"1\":{\"249\":1}}],[\"只有该用户才能使用\",{\"1\":{\"223\":1}}],[\"只有入队的先后顺序\",{\"1\":{\"249\":1}}],[\"只有一个变量\",{\"1\":{\"33\":1}}],[\"只是重写时使用了rdb进行了优化\",{\"1\":{\"949\":1}}],[\"只是在方向\",{\"1\":{\"930\":1}}],[\"只是在写操作时返回错误\",{\"1\":{\"900\":1}}],[\"只是在tcp\",{\"1\":{\"249\":1}}],[\"只是\",{\"1\":{\"894\":1,\"946\":1}}],[\"只是表示了类型\",{\"1\":{\"879\":1}}],[\"只是将这个记录的\",{\"1\":{\"770\":1}}],[\"只是将元素赋值一个临时变量\",{\"1\":{\"453\":1}}],[\"只是完成了\",{\"1\":{\"751\":1}}],[\"只是获取string顶层结构体的大小\",{\"1\":{\"441\":1}}],[\"只是其中的\",{\"1\":{\"374\":1}}],[\"只是生成一个唯一标识id发送给客户端\",{\"1\":{\"249\":1}}],[\"只是单纯的\",{\"1\":{\"249\":1}}],[\"只是操作系统位数不同而已\",{\"1\":{\"223\":1}}],[\"只是一个用户进程\",{\"1\":{\"190\":1}}],[\"只能有一个主要值\",{\"1\":{\"991\":1}}],[\"只能有一级\",{\"1\":{\"33\":1}}],[\"只能找程序员赔钱了\",{\"1\":{\"927\":1}}],[\"只能不停按时间间隔轮询\",{\"1\":{\"924\":1}}],[\"只能存一个数据\",{\"1\":{\"867\":1}}],[\"只能是\",{\"1\":{\"937\":1,\"1032\":1}}],[\"只能是用户自行处理\",{\"1\":{\"813\":1}}],[\"只能是编译器来分析代码确定\",{\"1\":{\"407\":1}}],[\"只能根据前缀进行比较\",{\"1\":{\"813\":1}}],[\"只能使用\",{\"1\":{\"810\":1}}],[\"只能处理一行数据\",{\"1\":{\"770\":1}}],[\"只能在同一应用内\",{\"1\":{\"682\":1}}],[\"只能在函数体内使用\",{\"1\":{\"438\":1}}],[\"只能出现在末尾\",{\"1\":{\"657\":1}}],[\"只能恢复当前函数级或以当前函数为首的调用链中的函数中的\",{\"1\":{\"479\":1}}],[\"只能监听\",{\"1\":{\"226\":1}}],[\"只能访问被标记为用户空间的内存\",{\"1\":{\"220\":1}}],[\"只知道虚拟地址空间\",{\"1\":{\"217\":1}}],[\"只消费一个分片\",{\"1\":{\"161\":1}}],[\"只显示容器的编号\",{\"1\":{\"140\":1}}],[\"只读\",{\"1\":{\"113\":1}}],[\"相信你对\",{\"1\":{\"957\":1}}],[\"相关命令就可以实现一个消息队列\",{\"1\":{\"924\":1}}],[\"相关的任务\",{\"1\":{\"249\":1}}],[\"相较于使用一个完整字段创建索引\",{\"1\":{\"813\":1}}],[\"相同点\",{\"1\":{\"930\":1}}],[\"相同的记录\",{\"1\":{\"817\":1}}],[\"相同的\",{\"1\":{\"810\":2}}],[\"相同的服务端发起连接请求\",{\"1\":{\"237\":1}}],[\"相同客户\",{\"1\":{\"723\":1}}],[\"相对方向\",{\"1\":{\"930\":1}}],[\"相对write\",{\"1\":{\"930\":1}}],[\"相对于\",{\"1\":{\"879\":1}}],[\"相对低一些\",{\"1\":{\"710\":1}}],[\"相对可靠\",{\"1\":{\"710\":1}}],[\"相对url\",{\"1\":{\"249\":1}}],[\"相比上次重写时的数据大一倍\",{\"1\":{\"952\":1}}],[\"相比于数据延迟而言\",{\"1\":{\"930\":1}}],[\"相比于没有使用索引下推\",{\"1\":{\"817\":1}}],[\"相比直接访问缓存\",{\"1\":{\"930\":1}}],[\"相比没有索引下推\",{\"1\":{\"813\":1}}],[\"相比\",{\"1\":{\"646\":1,\"813\":1,\"930\":1}}],[\"相等\",{\"1\":{\"249\":1,\"307\":1}}],[\"相应地\",{\"1\":{\"217\":1}}],[\"相当于做一层封装\",{\"1\":{\"930\":1}}],[\"相当于锁被自行释放了\",{\"1\":{\"913\":1,\"921\":1}}],[\"相当于锁住整个表\",{\"1\":{\"820\":1}}],[\"相当于缓存了个寂寞\",{\"1\":{\"817\":1}}],[\"相当于延迟了\",{\"1\":{\"810\":1}}],[\"相当于记录了逻辑操作\",{\"1\":{\"810\":1}}],[\"相当于一个环形\",{\"1\":{\"757\":1,\"810\":2}}],[\"相当于dirty的压力++\",{\"1\":{\"529\":1}}],[\"相当于写入或上传数据\",{\"1\":{\"249\":1}}],[\"相当于服务器是第三方身份\",{\"1\":{\"240\":1}}],[\"相当于客户端是第三方身份\",{\"1\":{\"240\":1}}],[\"相当于\",{\"1\":{\"237\":2,\"462\":1,\"813\":1,\"979\":1}}],[\"相当于nohup\",{\"1\":{\"139\":1}}],[\"相当于告诉编译器这部分代码是c语言写的\",{\"1\":{\"33\":1}}],[\"相当于直接插入了代码\",{\"1\":{\"33\":1}}],[\"相当于为该数据所在的地址起了一个别名\",{\"1\":{\"33\":1}}],[\"相当于传递地址值\",{\"1\":{\"33\":1}}],[\"相反\",{\"1\":{\"23\":1}}],[\"得物技术\",{\"1\":{\"952\":1}}],[\"得出结论是\",{\"1\":{\"817\":1}}],[\"得用\",{\"1\":{\"810\":1}}],[\"得先要从磁盘读取该记录\",{\"1\":{\"747\":1,\"810\":1}}],[\"得到的错误日志如下\",{\"1\":{\"957\":1}}],[\"得到初步数据\",{\"1\":{\"823\":1}}],[\"得到\",{\"1\":{\"820\":1}}],[\"得到了\",{\"1\":{\"794\":1}}],[\"得到客户端发来的随机数\",{\"1\":{\"249\":1}}],[\"得到公钥\",{\"1\":{\"249\":2}}],[\"得到一个哈希槽编号\",{\"1\":{\"723\":1}}],[\"得到一个哈希字符串\",{\"1\":{\"75\":1}}],[\"得到一个\",{\"1\":{\"240\":2,\"249\":2}}],[\"得到物理地址\",{\"1\":{\"217\":1}}],[\"得到物理页号\",{\"1\":{\"217\":1}}],[\"得到页表起始地址\",{\"1\":{\"217\":1}}],[\"得到哈希值后再与\",{\"1\":{\"79\":1}}],[\"得到引用所指向的变量大小\",{\"1\":{\"33\":1}}],[\"得到指针的大小\",{\"1\":{\"33\":1}}],[\"得传地址\",{\"1\":{\"30\":1}}],[\"大方向有\",{\"1\":{\"930\":1}}],[\"大概的思路就是多个机器\",{\"1\":{\"917\":1,\"921\":1}}],[\"大部分操作在内存上完成\",{\"1\":{\"888\":1}}],[\"大部分情况\",{\"1\":{\"770\":1}}],[\"大的位置\",{\"1\":{\"885\":1}}],[\"大多数的核心功能模块都在这实现\",{\"1\":{\"817\":1}}],[\"大事务\",{\"1\":{\"810\":1}}],[\"大于等于\",{\"1\":{\"820\":1}}],[\"大于\",{\"1\":{\"727\":1,\"873\":2,\"879\":1}}],[\"大致如下图所示\",{\"1\":{\"770\":1}}],[\"大致可以分为以下几个步骤\",{\"1\":{\"734\":1}}],[\"大致实现思路\",{\"1\":{\"723\":1}}],[\"大致架构\",{\"0\":{\"394\":1}}],[\"大业务\",{\"1\":{\"722\":1}}],[\"大业务分区\",{\"1\":{\"722\":1}}],[\"大大提高了检测的效率\",{\"1\":{\"226\":1}}],[\"大小会修改\",{\"1\":{\"982\":1}}],[\"大小\",{\"1\":{\"770\":1,\"813\":1}}],[\"大小客户分区\",{\"0\":{\"724\":1}}],[\"大小写转换\",{\"0\":{\"499\":1}}],[\"大小的数据流\",{\"1\":{\"237\":1}}],[\"大小不同\",{\"1\":{\"217\":1}}],[\"大小为\",{\"1\":{\"33\":1}}],[\"大写字母p\",{\"1\":{\"139\":1}}],[\"大顶堆的根节点就是整棵树上的最大值\",{\"1\":{\"51\":1}}],[\"大顶堆\",{\"1\":{\"51\":1}}],[\"大数据\",{\"2\":{\"21\":1}}],[\"基于这个场景\",{\"1\":{\"912\":1,\"921\":1}}],[\"基于这个特性\",{\"1\":{\"910\":1,\"921\":1}}],[\"基于内存设计\",{\"1\":{\"888\":1}}],[\"基于查询成本的考虑\",{\"1\":{\"817\":1}}],[\"基于索引字段做范围查询时\",{\"1\":{\"813\":1}}],[\"基于主外键字段上建立索引\",{\"1\":{\"813\":1}}],[\"基于成本的优化器\",{\"1\":{\"813\":1}}],[\"基于磁盘的平衡树\",{\"1\":{\"813\":1}}],[\"基于普通索引做\",{\"1\":{\"807\":1}}],[\"基于联合索引查询时请务必确保字段的顺序性\",{\"1\":{\"807\":1}}],[\"基于本地消息表来实现分布式事务\",{\"1\":{\"727\":1}}],[\"基于此可以再做一些小优化\",{\"1\":{\"715\":1}}],[\"基于java\",{\"1\":{\"646\":1}}],[\"基于观察者设计模式实现\",{\"1\":{\"614\":1}}],[\"基于\",{\"1\":{\"243\":2,\"249\":1,\"714\":2,\"807\":1,\"957\":2}}],[\"基于udp协议\",{\"1\":{\"240\":1}}],[\"基于tls1\",{\"1\":{\"240\":1}}],[\"基于https\",{\"1\":{\"240\":1}}],[\"基于轮询的分配策略\",{\"1\":{\"165\":1}}],[\"基于范围的分配策略\",{\"1\":{\"165\":1}}],[\"基本查询函数\",{\"0\":{\"988\":1}}],[\"基本使用方式如下\",{\"1\":{\"957\":1}}],[\"基本使用\",{\"0\":{\"957\":1},\"1\":{\"957\":1}}],[\"基本保证它们不会同时宕掉\",{\"1\":{\"917\":1,\"921\":1}}],[\"基本是基于单机考虑的\",{\"1\":{\"915\":1,\"921\":1}}],[\"基本连接命令\",{\"1\":{\"836\":1}}],[\"基本书写要求\",{\"1\":{\"829\":1}}],[\"基本上没法用\",{\"1\":{\"810\":1}}],[\"基本上不可能让消息真的不重复\",{\"1\":{\"712\":1}}],[\"基本语法\",{\"0\":{\"567\":1}}],[\"基本数据类型也可以\",{\"1\":{\"460\":1}}],[\"基本数据类型引用\",{\"1\":{\"30\":1}}],[\"基本类型\",{\"0\":{\"455\":1},\"1\":{\"568\":1}}],[\"基本规范\",{\"0\":{\"435\":1}}],[\"基本逃逸分析原则\",{\"0\":{\"407\":1}}],[\"基本的形式是\",{\"1\":{\"249\":1}}],[\"基本的\",{\"0\":{\"514\":1},\"1\":{\"249\":1}}],[\"基本组成\",{\"1\":{\"249\":1}}],[\"基本概念相似\",{\"1\":{\"249\":1}}],[\"基本实现原理\",{\"0\":{\"422\":1}}],[\"基本实现\",{\"0\":{\"88\":1}}],[\"基本原理\",{\"0\":{\"50\":1}}],[\"基础上进行了很薄的一层封装\",{\"1\":{\"957\":1}}],[\"基础服务组件\",{\"1\":{\"817\":1}}],[\"基础架构\",{\"0\":{\"800\":1}}],[\"基础语法\",{\"2\":{\"575\":1}}],[\"基础字符串操作\",{\"0\":{\"495\":1}}],[\"基础理论\",{\"0\":{\"121\":1}}],[\"基础知识\",{\"1\":{\"33\":1},\"2\":{\"35\":1}}],[\"基础复习\",{\"1\":{\"33\":1}}],[\"打开文件\",{\"1\":{\"1037\":1}}],[\"打开\",{\"1\":{\"949\":1}}],[\"打破循环等待条件\",{\"1\":{\"820\":1}}],[\"打印绑定后的user结构体和可能出现的错误\",{\"1\":{\"1039\":1,\"1040\":1,\"1041\":1}}],[\"打印错误并返回\",{\"1\":{\"1037\":1}}],[\"打印优化决策\",{\"1\":{\"398\":1}}],[\"打印输出的规律是什么\",{\"0\":{\"374\":1}}],[\"打印是有序的\",{\"1\":{\"373\":1}}],[\"打印\",{\"1\":{\"367\":1,\"478\":1}}],[\"打印100\",{\"1\":{\"30\":1}}],[\"打标签\",{\"1\":{\"10\":1}}],[\"加盐的安全性\",{\"0\":{\"1052\":1}}],[\"加盐\",{\"1\":{\"1051\":1}}],[\"加\",{\"1\":{\"820\":3}}],[\"加的是\",{\"1\":{\"820\":2}}],[\"加表锁\",{\"1\":{\"820\":1}}],[\"加上全局锁\",{\"1\":{\"820\":1}}],[\"加上完整\",{\"1\":{\"810\":1}}],[\"加上打印却可以避免\",{\"0\":{\"511\":1}}],[\"加载模板\",{\"1\":{\"1031\":1}}],[\"加载和实例化\",{\"1\":{\"662\":1}}],[\"加载servlet类\",{\"1\":{\"661\":1}}],[\"加载其他应用资源\",{\"1\":{\"640\":1}}],[\"加载当前\",{\"1\":{\"531\":1}}],[\"加载\",{\"1\":{\"529\":1,\"531\":1}}],[\"加载相应的\",{\"1\":{\"529\":1}}],[\"加起来就是\",{\"1\":{\"374\":1}}],[\"加入到clients\",{\"1\":{\"897\":1}}],[\"加入到当前channel的发送阻塞队列\",{\"1\":{\"264\":1}}],[\"加入了后台现线程后\",{\"1\":{\"810\":1}}],[\"加入了一个专门存放程序最常访问的页表项的\",{\"1\":{\"217\":1}}],[\"加入组提交\",{\"0\":{\"767\":1}}],[\"加入调度\",{\"1\":{\"373\":3,\"374\":2}}],[\"加解密\",{\"1\":{\"249\":1}}],[\"加密与加盐\",{\"0\":{\"1051\":1}}],[\"加密一下\",{\"1\":{\"249\":1}}],[\"加密过程\",{\"1\":{\"249\":1}}],[\"加密\",{\"1\":{\"249\":1,\"1051\":1},\"2\":{\"245\":1,\"1060\":1}}],[\"加了什么类型的锁\",{\"1\":{\"820\":2}}],[\"加了记录锁\",{\"1\":{\"820\":1}}],[\"加了间隙锁\",{\"1\":{\"820\":1}}],[\"加了\",{\"1\":{\"113\":1}}],[\"加了const可以只读令引用梦类型\",{\"1\":{\"30\":1}}],[\"加权轮询等\",{\"1\":{\"77\":1}}],[\"加锁之后其他服务无法加锁\",{\"1\":{\"910\":1,\"921\":1}}],[\"加锁和解锁必须是同一个竞争者\",{\"1\":{\"909\":1,\"921\":1}}],[\"加锁对象不是\",{\"1\":{\"820\":1}}],[\"加锁对象是\",{\"1\":{\"820\":1}}],[\"加锁的类型\",{\"1\":{\"820\":1}}],[\"加锁的规则也会不同\",{\"1\":{\"820\":1}}],[\"加锁的基本单位是\",{\"1\":{\"820\":1}}],[\"加锁的形式是不同的\",{\"1\":{\"820\":1}}],[\"加锁\",{\"1\":{\"820\":1}}],[\"加锁时\",{\"1\":{\"820\":3}}],[\"加锁操作\",{\"1\":{\"531\":1}}],[\"加锁以操作\",{\"1\":{\"529\":1}}],[\"加锁访问\",{\"1\":{\"529\":1}}],[\"加锁完成写操作\",{\"1\":{\"526\":1}}],[\"加锁失败说明请求已经在处理了\",{\"1\":{\"23\":1}}],[\"加锁成功执行请求处理\",{\"1\":{\"23\":1}}],[\"常规计数\",{\"1\":{\"873\":1}}],[\"常数的书写方式是固定的\",{\"1\":{\"829\":1}}],[\"常驻连接数可以配置成\",{\"1\":{\"807\":1}}],[\"常量必须初始化\",{\"1\":{\"570\":1}}],[\"常量用作枚举\",{\"0\":{\"441\":1}}],[\"常量数据类型只能是\",{\"1\":{\"440\":1}}],[\"常量\",{\"0\":{\"440\":1},\"1\":{\"433\":1}}],[\"常量定义\",{\"1\":{\"33\":1}}],[\"常说的tcp四元组\",{\"1\":{\"237\":1}}],[\"常用标签\",{\"1\":{\"983\":1}}],[\"常用实现方式\",{\"1\":{\"921\":1}}],[\"常用操作聚集在\",{\"1\":{\"873\":1}}],[\"常用操作\",{\"1\":{\"867\":1,\"870\":1,\"873\":1,\"876\":1}}],[\"常用的包括\",{\"1\":{\"846\":2}}],[\"常用的哈希函数包括\",{\"1\":{\"723\":1}}],[\"常用errors\",{\"1\":{\"472\":1}}],[\"常用于\",{\"1\":{\"392\":1}}],[\"常用于处理请求的超时\",{\"1\":{\"270\":1}}],[\"常用命令\",{\"0\":{\"391\":1,\"970\":1}}],[\"常用\",{\"1\":{\"149\":1}}],[\"常用其他命令\",{\"0\":{\"144\":1}}],[\"常见防重实现思路\",{\"0\":{\"714\":1}}],[\"常见问题与解决方案\",{\"0\":{\"606\":1,\"685\":1}}],[\"常见应用场景\",{\"0\":{\"597\":1,\"639\":1}}],[\"常见二叉树类型\",{\"0\":{\"59\":1}}],[\"常见类型及实现方式\",{\"1\":{\"58\":1}}],[\"常见的有数据页\",{\"1\":{\"770\":1}}],[\"常见的消费语义\",{\"0\":{\"705\":1}}],[\"常见的坑\",{\"1\":{\"145\":1}}],[\"常见的加密算法\",{\"0\":{\"73\":1}}],[\"常见的重复请求场景\",{\"1\":{\"23\":1}}],[\"常见的防重设计方法有\",{\"1\":{\"23\":1}}],[\"常引用\",{\"1\":{\"30\":1}}],[\"错误示例\",{\"1\":{\"689\":1}}],[\"错误处理\",{\"0\":{\"425\":1},\"1\":{\"568\":1}}],[\"错误\",{\"1\":{\"30\":1,\"440\":1,\"538\":1,\"980\":2}}],[\"内网运行\",{\"0\":{\"1026\":1}}],[\"内置的\",{\"0\":{\"1019\":1}}],[\"内部使用的config的结构定义\",{\"1\":{\"962\":1}}],[\"内部使用了锁\",{\"1\":{\"511\":1}}],[\"内部原有的的\",{\"1\":{\"957\":1}}],[\"内部错误\",{\"1\":{\"957\":1}}],[\"内部尽量避免使用\",{\"1\":{\"957\":1}}],[\"内部实现\",{\"1\":{\"873\":1}}],[\"内部开启一个\",{\"1\":{\"765\":1,\"810\":1}}],[\"内部\",{\"1\":{\"765\":3,\"810\":3,\"873\":1,\"957\":1}}],[\"内部是如何组织数据的\",{\"1\":{\"748\":1}}],[\"内部结构体的字段和方法会被提升到外部结构体中\",{\"1\":{\"462\":1}}],[\"内部的第一行之前\",{\"1\":{\"442\":1}}],[\"内部网络internal\",{\"1\":{\"246\":1}}],[\"内核再通过\",{\"1\":{\"760\":1}}],[\"内核线程\",{\"1\":{\"374\":1}}],[\"内核中间加一个\",{\"1\":{\"226\":1}}],[\"内核中创建ep对象\",{\"1\":{\"226\":1}}],[\"内核里维护了一个链表来记录就绪事件\",{\"1\":{\"226\":1}}],[\"内核里没有类似\",{\"1\":{\"226\":1}}],[\"内核态\",{\"2\":{\"222\":1}}],[\"内核态和用户态\",{\"1\":{\"220\":1}}],[\"内核态与用户态\",{\"1\":{\"220\":1}}],[\"内核的重要职责\",{\"1\":{\"220\":1}}],[\"内核\",{\"1\":{\"220\":2}}],[\"内核可能会继续交换出其他非活跃页\",{\"1\":{\"217\":1}}],[\"内核会将它们从交换空间读回物理内存\",{\"1\":{\"217\":1}}],[\"内核会选择一些非活跃页\",{\"1\":{\"217\":1}}],[\"内核空间是全局共享的\",{\"1\":{\"217\":1}}],[\"内核空间\",{\"1\":{\"217\":2}}],[\"内存中的高速页缓存\",{\"1\":{\"930\":1}}],[\"内存淘汰\",{\"2\":{\"905\":1,\"908\":1}}],[\"内存淘汰算法\",{\"1\":{\"903\":1,\"906\":1}}],[\"内存操作本身快\",{\"1\":{\"888\":1}}],[\"内存的读写速度对比磁盘和固态都快\",{\"1\":{\"888\":1}}],[\"内存占用少\",{\"1\":{\"870\":1}}],[\"内存不够紧凑\",{\"1\":{\"867\":1}}],[\"内存排列得很紧凑\",{\"1\":{\"867\":1}}],[\"内存排序\",{\"1\":{\"813\":1}}],[\"内存放不下时\",{\"1\":{\"813\":1}}],[\"内存临时表中每条记录的成本\",{\"1\":{\"813\":1}}],[\"内存临时表\",{\"1\":{\"813\":1}}],[\"内存和cpu缓存\",{\"1\":{\"807\":1}}],[\"内存空间的一半时\",{\"1\":{\"756\":1,\"810\":1}}],[\"内存位置\",{\"1\":{\"456\":1}}],[\"内存cookie\",{\"1\":{\"249\":1}}],[\"内存\",{\"1\":{\"243\":1,\"512\":1,\"900\":1}}],[\"内存资源\",{\"1\":{\"237\":2}}],[\"内存拷贝\",{\"1\":{\"226\":1}}],[\"内存溢出\",{\"1\":{\"217\":1}}],[\"内存回收策略不同\",{\"1\":{\"217\":1}}],[\"内存页的分类\",{\"1\":{\"217\":1}}],[\"内存分页管理\",{\"1\":{\"217\":1}}],[\"内存分段管理\",{\"1\":{\"217\":1}}],[\"内存区域\",{\"1\":{\"217\":1}}],[\"内存交换的效率低的问题\",{\"1\":{\"217\":1}}],[\"内存碎片的问题\",{\"1\":{\"217\":1}}],[\"内存对齐以及原因\",{\"1\":{\"33\":1}}],[\"内存仍会被释放\",{\"1\":{\"33\":1}}],[\"内存管理单元\",{\"1\":{\"217\":1}}],[\"内存管理\",{\"1\":{\"33\":1,\"217\":2,\"220\":1},\"2\":{\"219\":1,\"884\":1,\"896\":1,\"902\":1,\"948\":1}}],[\"内存限制为\",{\"1\":{\"20\":1}}],[\"内存限制4gb\",{\"1\":{\"20\":1}}],[\"内存限制1mb\",{\"1\":{\"20\":2}}],[\"内容指针\",{\"1\":{\"940\":1}}],[\"内容刷新到磁盘中\",{\"1\":{\"770\":1}}],[\"内容的一致性\",{\"1\":{\"532\":1}}],[\"内容\",{\"1\":{\"30\":1,\"209\":1,\"240\":1,\"249\":1}}],[\"给语法加点糖\",{\"1\":{\"957\":1}}],[\"给a的值加1\",{\"1\":{\"930\":1}}],[\"给了运维更多时间来修复\",{\"1\":{\"917\":1,\"921\":1}}],[\"给锁加上\",{\"1\":{\"912\":1,\"921\":1}}],[\"给链表增加了多级索引\",{\"1\":{\"885\":1}}],[\"给每个线程分配了一片内存用于缓冲\",{\"1\":{\"810\":1}}],[\"给每个协程加上一行打印语句\",{\"1\":{\"511\":1}}],[\"给每一个处理线程分配了一片内存用于缓冲\",{\"1\":{\"760\":1}}],[\"给\",{\"1\":{\"525\":2}}],[\"给控制变量增量或减量\",{\"1\":{\"451\":1}}],[\"给控制变量赋初值\",{\"1\":{\"451\":1}}],[\"给ifc赋值一个包含方法的结构体a之后\",{\"1\":{\"311\":1}}],[\"给常量取别名\",{\"1\":{\"30\":1}}],[\"给定10亿个手机号\",{\"1\":{\"20\":1}}],[\"给定1000万个整数\",{\"1\":{\"20\":1}}],[\"给定1gb单词\",{\"1\":{\"20\":1}}],[\"返回用于创建给定bcrypt哈希的哈希成本\",{\"1\":{\"1058\":1}}],[\"返回绑定后的数据作为json响应\",{\"1\":{\"1039\":1,\"1040\":1,\"1041\":1}}],[\"返回0\",{\"1\":{\"910\":1,\"921\":1}}],[\"返回数量不准确\",{\"1\":{\"870\":1}}],[\"返回数据给客户端\",{\"1\":{\"817\":1}}],[\"返回了读取完毕的信息\",{\"1\":{\"817\":1}}],[\"返回记录给执行器\",{\"1\":{\"810\":2}}],[\"返回结果\",{\"1\":{\"734\":1}}],[\"返回servlet信息\",{\"1\":{\"664\":1}}],[\"返回servletconfig对象\",{\"1\":{\"664\":1}}],[\"返回旧值和\",{\"1\":{\"531\":1}}],[\"返回\",{\"1\":{\"529\":1,\"531\":3,\"879\":1}}],[\"返回存储的值和一个布尔值\",{\"1\":{\"529\":1}}],[\"返回的其实是一个地址\",{\"1\":{\"472\":1}}],[\"返回的错误码\",{\"1\":{\"240\":1}}],[\"返回对应的返回值\",{\"1\":{\"265\":1}}],[\"返回给客户端\",{\"1\":{\"810\":1,\"817\":1}}],[\"返回给\",{\"1\":{\"452\":1}}],[\"返回给查询者\",{\"1\":{\"243\":1}}],[\"返回给用户态的内存起始地址比进程的堆空间起始地址多了\",{\"1\":{\"217\":1}}],[\"返回类型是\",{\"1\":{\"229\":1}}],[\"返回一个对象值\",{\"1\":{\"33\":1}}],[\"返回一个引用\",{\"1\":{\"33\":1}}],[\"返回一个num的引用\",{\"1\":{\"30\":1}}],[\"返回指针\",{\"1\":{\"33\":1}}],[\"返回值的内存布局如下\",{\"1\":{\"423\":1}}],[\"返回值被分配在栈上\",{\"1\":{\"423\":1}}],[\"返回值\",{\"1\":{\"33\":1,\"452\":1,\"873\":2}}],[\"返回值是int\",{\"1\":{\"33\":1}}],[\"返回值类型是引用类型\",{\"1\":{\"30\":1}}],[\"会过滤零值\",{\"1\":{\"1002\":2}}],[\"会转换为我们可以看得懂的方式\",{\"1\":{\"993\":1}}],[\"会多出一个\",{\"1\":{\"982\":1}}],[\"会选择此时启动一个空库\",{\"1\":{\"952\":1}}],[\"会选择查询代价小的普通索引\",{\"1\":{\"817\":1}}],[\"会生成如下\",{\"1\":{\"952\":1}}],[\"会生成一个插入意向锁\",{\"1\":{\"820\":1}}],[\"会不会影响执行性能\",{\"1\":{\"952\":1}}],[\"会阻塞主线程\",{\"1\":{\"952\":1}}],[\"会阻塞\",{\"1\":{\"952\":1}}],[\"会阻塞后续该表的所有\",{\"1\":{\"820\":1}}],[\"会激活\",{\"1\":{\"952\":1}}],[\"会相当复杂\",{\"1\":{\"927\":1}}],[\"会提高人力成本\",{\"1\":{\"916\":1,\"921\":1}}],[\"会提示唯一索引冲突\",{\"1\":{\"770\":1}}],[\"会释放掉服务\",{\"1\":{\"912\":1,\"921\":1}}],[\"会释放当前会话的所有表锁\",{\"1\":{\"820\":1}}],[\"会动态调整\",{\"1\":{\"906\":1}}],[\"会更新这个\",{\"1\":{\"906\":1}}],[\"会增加访问计数\",{\"1\":{\"903\":1}}],[\"会复用\",{\"1\":{\"903\":1}}],[\"会通过一次内存分配来分配一块连续的内存空间来保存redisobject和sds\",{\"1\":{\"873\":1}}],[\"会通过锁找到\",{\"1\":{\"512\":1}}],[\"会占用不少内存\",{\"1\":{\"867\":1}}],[\"会占用较多的文件描述符\",{\"1\":{\"237\":1}}],[\"会变\",{\"1\":{\"820\":1}}],[\"会显示\",{\"1\":{\"820\":2}}],[\"会显示如下错误\",{\"1\":{\"113\":1}}],[\"会因为主键冲突\",{\"1\":{\"820\":1}}],[\"会退化成记录锁或者间隙锁\",{\"1\":{\"820\":1}}],[\"会退化成记录锁\",{\"1\":{\"820\":1}}],[\"会影响插入性能\",{\"1\":{\"820\":1}}],[\"会影响并发性能\",{\"1\":{\"820\":1}}],[\"会加锁\",{\"1\":{\"820\":1}}],[\"会加一个表级别的\",{\"1\":{\"820\":1}}],[\"会加上\",{\"1\":{\"783\":1}}],[\"会加上这5w行代码\",{\"1\":{\"36\":1}}],[\"会调用一个叫flushappendonlyfile的函数\",{\"1\":{\"952\":1}}],[\"会调用readqueryfromclient这个方法\",{\"1\":{\"897\":1}}],[\"会调用\",{\"1\":{\"817\":3,\"897\":1}}],[\"会调用存储引擎的接口\",{\"1\":{\"810\":2}}],[\"会得到4个token\",{\"1\":{\"817\":1}}],[\"会根据你输入的字符串识别出关键字出来\",{\"1\":{\"817\":1}}],[\"会根据事务的\",{\"1\":{\"810\":1}}],[\"会读取该用户的权限\",{\"1\":{\"817\":1}}],[\"会比普通索引快上一截\",{\"1\":{\"813\":1}}],[\"会走索引\",{\"1\":{\"813\":2}}],[\"会走全表扫描\",{\"1\":{\"813\":1}}],[\"会发生\",{\"1\":{\"813\":1}}],[\"会减少回表的次数\",{\"1\":{\"813\":2}}],[\"会回主键索引找完整的数据行\",{\"1\":{\"813\":1}}],[\"会从联合索引从最左边的索引列开始匹配查询条件\",{\"1\":{\"813\":1}}],[\"会从会话中移除username属性\",{\"1\":{\"641\":1}}],[\"会等待一段时间\",{\"1\":{\"810\":1}}],[\"会缓存在\",{\"1\":{\"810\":2}}],[\"会的\",{\"1\":{\"810\":1}}],[\"会包含提交\",{\"1\":{\"810\":1}}],[\"会看一下更新前的记录和更新后的记录是否一样\",{\"1\":{\"810\":2}}],[\"会停下来将\",{\"1\":{\"810\":1}}],[\"会写入\",{\"1\":{\"810\":4}}],[\"会写到\",{\"1\":{\"760\":1,\"810\":1}}],[\"会触发\",{\"1\":{\"795\":1}}],[\"会触发落盘\",{\"1\":{\"756\":1,\"810\":1}}],[\"会填充空格到n个字节\",{\"1\":{\"770\":1}}],[\"会使用\",{\"1\":{\"949\":1}}],[\"会使用空格\",{\"1\":{\"770\":1}}],[\"会使用自己的私钥将该\",{\"1\":{\"240\":1,\"249\":1}}],[\"会同时维护\",{\"1\":{\"765\":1,\"810\":1}}],[\"会宣布比赛暂停\",{\"1\":{\"764\":1,\"810\":1}}],[\"会依次询问两位拳击手\",{\"1\":{\"764\":1,\"810\":1}}],[\"会导致正常用户也受到影响\",{\"1\":{\"927\":1}}],[\"会导致每次插入都需要调整树结构\",{\"1\":{\"813\":1}}],[\"会导致磁盘的\",{\"1\":{\"810\":1}}],[\"会导致磁盘的i\",{\"1\":{\"760\":1}}],[\"会导致两个指针指向同一资源\",{\"1\":{\"33\":1}}],[\"会切换回\",{\"1\":{\"757\":1,\"810\":1}}],[\"会切换至\",{\"1\":{\"757\":1,\"810\":1}}],[\"会记录对数据页的修改操作细节\",{\"1\":{\"753\":1}}],[\"会有一个默认值\",{\"1\":{\"982\":1}}],[\"会有一定时耗\",{\"1\":{\"917\":1,\"921\":1}}],[\"会有什么问题\",{\"1\":{\"906\":1}}],[\"会有哪些地方拖慢整个流程\",{\"1\":{\"888\":1}}],[\"会有磁盘上的页被加载缓存到\",{\"1\":{\"748\":1}}],[\"会有两种堆内存申请策略\",{\"1\":{\"217\":1}}],[\"会有两种方式向操作系统申请堆内存\",{\"1\":{\"217\":1}}],[\"会为被\",{\"1\":{\"820\":1}}],[\"会为\",{\"1\":{\"748\":1,\"810\":1,\"820\":1}}],[\"会每秒刷盘\",{\"1\":{\"745\":1,\"810\":1}}],[\"会将错误日志输出到\",{\"1\":{\"957\":1}}],[\"会将自动\",{\"1\":{\"813\":2}}],[\"会将这两个参数设置为\",{\"1\":{\"810\":1}}],[\"会将多个\",{\"1\":{\"767\":1,\"810\":1}}],[\"会将该事务执行过程中产生的所有\",{\"1\":{\"759\":1}}],[\"会将该事物执行过程中产生的所有\",{\"1\":{\"737\":1,\"810\":1}}],[\"会将整个页加载进\",{\"1\":{\"748\":1}}],[\"会将对象分配在堆上\",{\"1\":{\"415\":1}}],[\"会好很多\",{\"1\":{\"715\":1}}],[\"会无辜的多承担这部分的压力\",{\"1\":{\"715\":1}}],[\"会改变浏览器地址栏\",{\"1\":{\"682\":1}}],[\"会降低性能\",{\"1\":{\"520\":1}}],[\"会尽量在\",{\"1\":{\"512\":1}}],[\"会拥有全量的数据\",{\"1\":{\"512\":1}}],[\"会让请求在\",{\"1\":{\"512\":1}}],[\"会\",{\"1\":{\"457\":1,\"810\":1,\"820\":2}}],[\"会拷贝原地址\",{\"1\":{\"454\":1}}],[\"会跑到堆上\",{\"1\":{\"405\":1}}],[\"会造成内存的复制\",{\"1\":{\"867\":1}}],[\"会造成延迟和额外的系统负载\",{\"1\":{\"381\":1}}],[\"会造成空指针错误\",{\"1\":{\"30\":1}}],[\"会去全局队列中拿一批\",{\"1\":{\"374\":1}}],[\"会先将对象的编码从\",{\"1\":{\"873\":1}}],[\"会先创建\",{\"1\":{\"820\":1}}],[\"会先在二级索引的\",{\"1\":{\"813\":1}}],[\"会先更新内存\",{\"1\":{\"810\":2}}],[\"会先写入\",{\"1\":{\"810\":1}}],[\"会先写入内核的缓冲区\",{\"1\":{\"760\":1}}],[\"会先写入到\",{\"1\":{\"755\":1,\"810\":1}}],[\"会先生成一条\",{\"1\":{\"753\":1}}],[\"会先记录更新前的数据到\",{\"1\":{\"740\":1,\"810\":1}}],[\"会先调度\",{\"1\":{\"374\":1}}],[\"会先对\",{\"1\":{\"36\":1,\"817\":1}}],[\"会把redis宕机算进来\",{\"1\":{\"930\":1}}],[\"会把数据立即写入数据库中\",{\"1\":{\"930\":1}}],[\"会把一部分排序的结果放在磁盘上\",{\"1\":{\"813\":1}}],[\"会把缓存在\",{\"1\":{\"810\":1}}],[\"会把存储的数据划分为若干个\",{\"1\":{\"810\":1}}],[\"会把存储的数据划分为若干个页\",{\"1\":{\"748\":1}}],[\"会把\",{\"1\":{\"374\":1}}],[\"会把持有者的公钥\",{\"1\":{\"240\":1,\"249\":1}}],[\"会指向最新切换进来的协程\",{\"1\":{\"373\":1}}],[\"会被赋零值\",{\"1\":{\"1006\":1}}],[\"会被忽略\",{\"1\":{\"1002\":1}}],[\"会被转换成\",{\"1\":{\"957\":1}}],[\"会被淘汰\",{\"1\":{\"903\":1}}],[\"会被显式设置为\",{\"1\":{\"873\":1}}],[\"会被持久化到磁盘吗\",{\"1\":{\"810\":1}}],[\"会被保存到\",{\"1\":{\"810\":2}}],[\"会被阻塞\",{\"1\":{\"810\":1}}],[\"会被回滚到事务开始前的状态\",{\"1\":{\"774\":1}}],[\"会被复制到从库\",{\"1\":{\"763\":2,\"810\":2}}],[\"会被写入\",{\"1\":{\"753\":2}}],[\"会被当做\",{\"1\":{\"458\":1}}],[\"会被依次放入到\",{\"1\":{\"373\":1}}],[\"会被释放掉\",{\"1\":{\"30\":1}}],[\"会在插入间隙上获取插入意向锁\",{\"1\":{\"820\":1}}],[\"会在重启后回滚该组事务\",{\"1\":{\"810\":1}}],[\"会在中间确认两位拳击手的状态\",{\"1\":{\"764\":1,\"810\":1}}],[\"会在更新记录之前\",{\"1\":{\"748\":1}}],[\"会在会话中添加username属性\",{\"1\":{\"641\":1}}],[\"会在堆上分配内存\",{\"1\":{\"291\":1}}],[\"会在诸多分区中选举一个分区作为主节点\",{\"1\":{\"180\":1}}],[\"会判定缓冲区的剩余空间\",{\"1\":{\"264\":1}}],[\"会话安全\",{\"0\":{\"692\":1}}],[\"会话超时\",{\"0\":{\"691\":1}}],[\"会话和请求的事件\",{\"1\":{\"684\":1}}],[\"会话\",{\"1\":{\"634\":3}}],[\"会话销毁\",{\"1\":{\"625\":1}}],[\"会话销毁时\",{\"1\":{\"625\":1}}],[\"会话创建时不做处理\",{\"1\":{\"641\":1}}],[\"会话创建时\",{\"1\":{\"625\":1}}],[\"会话创建\",{\"1\":{\"612\":1,\"625\":1}}],[\"会话劫持防护等\",{\"1\":{\"579\":1}}],[\"会话管理问题\",{\"0\":{\"690\":1}}],[\"会话管理\",{\"1\":{\"579\":1,\"615\":1}}],[\"会话密钥\",{\"1\":{\"249\":2}}],[\"会话秘钥\",{\"1\":{\"249\":2}}],[\"会话检索等功能\",{\"1\":{\"249\":1}}],[\"会话信息存储\",{\"1\":{\"249\":1}}],[\"会话层只对何时建立连接\",{\"1\":{\"249\":1}}],[\"会主动关闭连接\",{\"1\":{\"237\":1}}],[\"会启动fin报文重传\",{\"1\":{\"237\":1}}],[\"会返回0\",{\"1\":{\"226\":1}}],[\"会怎么处理\",{\"1\":{\"226\":1}}],[\"会对每一个扫描到的索引加\",{\"1\":{\"820\":1}}],[\"会对传入进来的内存地址向左偏移\",{\"1\":{\"217\":1}}],[\"会对所有副本进行划分\",{\"1\":{\"181\":1}}],[\"会自动给这个表加上\",{\"1\":{\"820\":1}}],[\"会自动把字符串转为数字\",{\"1\":{\"813\":1}}],[\"会自动为\",{\"1\":{\"378\":1}}],[\"会自动为你创建一个文件夹\",{\"1\":{\"113\":1}}],[\"会自动扩容\",{\"1\":{\"337\":1}}],[\"会自动从其它副本中选取一个新的\",{\"1\":{\"176\":1}}],[\"会随机映射一个\",{\"1\":{\"117\":1}}],[\"会报错\",{\"1\":{\"113\":1,\"177\":1,\"817\":1}}],[\"会创建不同的数据库\",{\"1\":{\"807\":1}}],[\"会创建\",{\"1\":{\"104\":1}}],[\"会执行\",{\"1\":{\"36\":1}}],[\"会检查数据类型\",{\"1\":{\"33\":1}}],[\"会进行二次扣款\",{\"1\":{\"23\":1}}],[\"牛逼的地方在于实现了颗粒度更细的行级锁\",{\"1\":{\"820\":1}}],[\"牛逼\",{\"1\":{\"30\":1}}],[\"指的就是指把日志写入到\",{\"1\":{\"810\":1}}],[\"指令名字\",{\"1\":{\"211\":1}}],[\"指定在通过调用栈获取文件名和行号时跳过的调用深度\",{\"1\":{\"957\":1}}],[\"指定是否在日志输出内容中增加调用信息\",{\"1\":{\"957\":1}}],[\"指定日志记录器用来确定当前时间的\",{\"1\":{\"957\":1}}],[\"指定日志组件内部出现异常时的输出位置\",{\"1\":{\"957\":1}}],[\"指定日志编码器\",{\"1\":{\"957\":1}}],[\"指定一个时间点\",{\"1\":{\"882\":1}}],[\"指定json序列化\",{\"1\":{\"485\":1,\"486\":2}}],[\"指定的资源提交数据\",{\"1\":{\"249\":1}}],[\"指定的是运行的容器名\",{\"1\":{\"125\":1}}],[\"指定了protobuf的版本\",{\"1\":{\"229\":1}}],[\"指定目录\",{\"1\":{\"207\":1}}],[\"指定容器的端口\",{\"1\":{\"139\":1}}],[\"指定\",{\"1\":{\"125\":1}}],[\"指定为\",{\"1\":{\"113\":1}}],[\"指仅使用属性和方法的名称\",{\"1\":{\"33\":1}}],[\"指使用基类的属性和方法而无需额外编码的能力\",{\"1\":{\"33\":1}}],[\"指向冲突的下一对\",{\"1\":{\"945\":1}}],[\"指向一个\",{\"1\":{\"943\":2}}],[\"指向的是哈希数组的数组下标\",{\"1\":{\"942\":1}}],[\"指向的是下一条记录的\",{\"1\":{\"770\":2}}],[\"指向数据字典\",{\"1\":{\"894\":1}}],[\"指向该层下一个能跳到的节点\",{\"1\":{\"885\":1}}],[\"指向该对象的所有智能指针内部的引用计数加1\",{\"1\":{\"33\":1}}],[\"指向上一个节点的回退指针\",{\"1\":{\"885\":1}}],[\"指向开头\",{\"1\":{\"879\":1}}],[\"指向实际数据\",{\"1\":{\"940\":1,\"946\":1}}],[\"指向实际\",{\"1\":{\"864\":1}}],[\"指向下一层的地址\",{\"1\":{\"813\":1}}],[\"指向每一个旧版本记录\",{\"1\":{\"770\":1,\"788\":1}}],[\"指向同一块区域\",{\"1\":{\"454\":1}}],[\"指向同一片内存单元\",{\"1\":{\"30\":1}}],[\"指向底层字节数组的指针和长度\",{\"1\":{\"353\":1}}],[\"指向底层数组的指针\",{\"1\":{\"338\":1}}],[\"指向\",{\"1\":{\"307\":2,\"946\":1}}],[\"指针类型的go可以传nil\",{\"1\":{\"982\":1}}],[\"指针可以将这些\",{\"1\":{\"742\":1,\"810\":1}}],[\"指针可以初始化为空\",{\"1\":{\"33\":1}}],[\"指针和一个\",{\"1\":{\"742\":1,\"810\":1}}],[\"指针和引用\",{\"1\":{\"33\":1}}],[\"指针和引用的区别\",{\"1\":{\"33\":1}}],[\"指针为\",{\"1\":{\"531\":1}}],[\"指针指向\",{\"1\":{\"518\":1}}],[\"指针逃逸\",{\"0\":{\"409\":1},\"1\":{\"408\":1}}],[\"指针free或delete之后没有及时置空\",{\"1\":{\"33\":1}}],[\"指针变量未及时初始化\",{\"1\":{\"33\":1}}],[\"指针变量的引用\",{\"1\":{\"30\":1}}],[\"指针传递的话要解引用\",{\"1\":{\"33\":1}}],[\"指针传递和引用传递比值传递效率高\",{\"1\":{\"33\":1}}],[\"指针传递\",{\"1\":{\"33\":2}}],[\"指针作为参数传递的时候有一个形参向函数栈帧拷贝数据的过程\",{\"1\":{\"33\":1}}],[\"指针\",{\"1\":{\"33\":1,\"373\":1,\"436\":1,\"531\":1,\"813\":1}}],[\"指针是一个变量\",{\"1\":{\"33\":1}}],[\"代价是安全性不够\",{\"1\":{\"930\":1}}],[\"代替\",{\"1\":{\"780\":1}}],[\"代表了我们存入的\",{\"1\":{\"894\":1}}],[\"代表什么\",{\"1\":{\"770\":1}}],[\"代表该列的值不为null\",{\"1\":{\"770\":1}}],[\"代表该列的值为null\",{\"1\":{\"770\":1}}],[\"代表创建当前这个readview的事务id\",{\"1\":{\"787\":1}}],[\"代表创建当前这个\",{\"1\":{\"744\":1}}],[\"代表硬删除\",{\"1\":{\"531\":1}}],[\"代表逻辑和内存里都不存在这个\",{\"1\":{\"523\":1}}],[\"代表\",{\"1\":{\"523\":1,\"524\":1,\"894\":1}}],[\"代表的是最多存储的字符数量\",{\"1\":{\"770\":1}}],[\"代表的是\",{\"1\":{\"512\":1}}],[\"代表同一值\",{\"1\":{\"30\":1}}],[\"代理服务器\",{\"1\":{\"243\":1}}],[\"代理服务端\",{\"1\":{\"240\":1}}],[\"代理客户端\",{\"1\":{\"240\":1}}],[\"代码生成\",{\"0\":{\"965\":1}}],[\"代码定义\",{\"1\":{\"864\":1}}],[\"代码可能臃肿\",{\"1\":{\"813\":1}}],[\"代码可读性降低\",{\"1\":{\"552\":1}}],[\"代码优化和目标代码生成\",{\"1\":{\"400\":1}}],[\"代码优化和目标代码生成几个阶段\",{\"1\":{\"389\":1}}],[\"代码到这说明\",{\"1\":{\"265\":1}}],[\"代码\",{\"0\":{\"367\":1,\"940\":1,\"942\":1,\"944\":1},\"1\":{\"229\":4}}],[\"代码段\",{\"1\":{\"217\":1}}],[\"代码逻辑上更加紧凑\",{\"1\":{\"33\":1}}],[\"代码选择截图\",{\"1\":{\"13\":1}}],[\"代码视觉优化\",{\"0\":{\"8\":1}}],[\"开销\",{\"1\":{\"891\":1}}],[\"开销远比变量逃逸后动态地在堆上分配内存少的多\",{\"1\":{\"417\":1}}],[\"开销要更小\",{\"1\":{\"33\":1}}],[\"开放地址法通过探测空闲位置来解决哈希冲突\",{\"1\":{\"323\":1}}],[\"开放地址法\",{\"0\":{\"323\":1}}],[\"开放编码是go语言对defer实现的一种重要优化方式\",{\"1\":{\"293\":1}}],[\"开放编码\",{\"0\":{\"293\":1}}],[\"开始事务\",{\"1\":{\"1015\":1}}],[\"开始回表\",{\"1\":{\"813\":1}}],[\"开始比赛之前\",{\"1\":{\"764\":1,\"810\":1}}],[\"开始前\",{\"1\":{\"737\":1,\"810\":1}}],[\"开始调度堆积在全局队列的\",{\"1\":{\"374\":1}}],[\"开始\",{\"1\":{\"249\":1,\"817\":1,\"876\":1,\"1008\":1}}],[\"开始处理被分配到的新分区\",{\"1\":{\"165\":1}}],[\"开启主动死锁检测\",{\"1\":{\"820\":1}}],[\"开启两个事务\",{\"1\":{\"820\":1}}],[\"开启时机\",{\"1\":{\"785\":1}}],[\"开启事务\",{\"1\":{\"810\":2}}],[\"开启事务和\",{\"1\":{\"810\":1}}],[\"开启事务命令的区别\",{\"0\":{\"785\":1}}],[\"开启事务后\",{\"1\":{\"748\":1,\"753\":1,\"810\":2}}],[\"开启了\",{\"1\":{\"237\":1}}],[\"开启了swap\",{\"1\":{\"217\":1}}],[\"开启\",{\"1\":{\"237\":1,\"765\":1,\"810\":1}}],[\"开头的频道\",{\"1\":{\"924\":1}}],[\"开头的所有路径\",{\"1\":{\"587\":1,\"655\":1}}],[\"开头就是隐藏文件\",{\"1\":{\"223\":1}}],[\"开头为\",{\"1\":{\"201\":1}}],[\"开头\",{\"1\":{\"123\":1,\"587\":2,\"655\":2,\"657\":1}}],[\"开辟空间\",{\"1\":{\"30\":1}}],[\"开发的日志包\",{\"1\":{\"957\":1}}],[\"开发成本低\",{\"1\":{\"930\":1}}],[\"开发者只需要重写service\",{\"1\":{\"665\":1}}],[\"开发servlet应用需要以下组件\",{\"1\":{\"649\":1}}],[\"开发流程\",{\"1\":{\"644\":1}}],[\"开发listener应用需要以下组件\",{\"1\":{\"617\":1}}],[\"开发filter应用需要以下组件\",{\"1\":{\"581\":1}}],[\"开发环境下\",{\"1\":{\"957\":1}}],[\"开发环境等\",{\"1\":{\"246\":1}}],[\"开发环境\",{\"1\":{\"957\":1},\"2\":{\"27\":1}}],[\"开发实用\",{\"0\":{\"10\":1}}],[\"xk\",{\"1\":{\"1059\":1}}],[\"x不是为密码设计的算法\",{\"1\":{\"1054\":1}}],[\"x型锁\",{\"1\":{\"820\":1}}],[\"x锁\",{\"1\":{\"820\":1}}],[\"xiaomei\",{\"1\":{\"873\":1}}],[\"xiaolin\",{\"1\":{\"770\":1,\"810\":6,\"873\":1}}],[\"xid帮助数据库系统在崩溃后保持数据的一致性和完整性\",{\"1\":{\"810\":1}}],[\"xid用于在准备\",{\"1\":{\"810\":1}}],[\"xid用于标识全局事务\",{\"1\":{\"810\":1}}],[\"xid确保即使事务跨越多个数据库系统\",{\"1\":{\"810\":1}}],[\"xid是事务标识符\",{\"1\":{\"810\":1}}],[\"xid\",{\"1\":{\"765\":2,\"810\":9}}],[\"xa事务是一种遵循xa规范的事务\",{\"1\":{\"810\":1}}],[\"xa代表扩展架构\",{\"1\":{\"810\":1}}],[\"xa\",{\"1\":{\"765\":6,\"810\":8}}],[\"xsd\",{\"1\":{\"658\":1}}],[\"xsi\",{\"1\":{\"658\":1}}],[\"xsi=\",{\"1\":{\"658\":1}}],[\"xmlschema\",{\"1\":{\"658\":1}}],[\"xmlns\",{\"1\":{\"658\":4}}],[\"xmlns=\",{\"1\":{\"658\":1}}],[\"xml中设置全局会话超时\",{\"1\":{\"691\":1}}],[\"xml中的配置是否正确\",{\"1\":{\"607\":1}}],[\"xml中的出现顺序\",{\"1\":{\"595\":1}}],[\"xml中添加\",{\"1\":{\"588\":1,\"627\":1,\"658\":1}}],[\"xml中添加servlet\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"xml中配置\",{\"1\":{\"588\":1,\"627\":1,\"637\":1,\"658\":1}}],[\"xml配置错误\",{\"1\":{\"607\":1}}],[\"xml配置而不是注解\",{\"1\":{\"595\":1,\"608\":1}}],[\"xml配置时\",{\"1\":{\"595\":1}}],[\"xml配置\",{\"1\":{\"585\":1}}],[\"xml\",{\"0\":{\"588\":1,\"627\":1,\"658\":1},\"1\":{\"249\":1,\"658\":3,\"1038\":1}}],[\"xhtml+xml\",{\"1\":{\"249\":1}}],[\"xx\",{\"1\":{\"33\":7,\"813\":2,\"873\":1,\"992\":1}}],[\"xxxln\",{\"1\":{\"957\":1}}],[\"xxxf\",{\"1\":{\"957\":1}}],[\"xxxw\",{\"1\":{\"957\":1}}],[\"xxxxx\",{\"1\":{\"1035\":1}}],[\"xxxx\",{\"1\":{\"879\":1}}],[\"xxx\",{\"1\":{\"33\":2,\"409\":1,\"751\":1,\"810\":2,\"957\":3,\"985\":1,\"1035\":1,\"1037\":4}}],[\"x\",{\"1\":{\"30\":2,\"33\":11,\"36\":2,\"190\":5,\"249\":4,\"469\":5,\"505\":2,\"813\":1,\"820\":46,\"1041\":1,\"1058\":1,\"1059\":1}}],[\"结束标识\",{\"1\":{\"879\":1}}],[\"结束\",{\"1\":{\"879\":3}}],[\"结尾\",{\"1\":{\"587\":1,\"655\":1,\"829\":1}}],[\"结论都一样\",{\"1\":{\"817\":1}}],[\"结论\",{\"1\":{\"441\":1,\"709\":1,\"712\":1,\"813\":1,\"891\":1}}],[\"结构化\",{\"1\":{\"955\":1}}],[\"结构中\",{\"1\":{\"946\":1}}],[\"结构有一个\",{\"1\":{\"945\":1}}],[\"结构的好处\",{\"1\":{\"885\":1}}],[\"结构的指针\",{\"1\":{\"307\":1}}],[\"结构示意图\",{\"1\":{\"885\":1}}],[\"结构设计\",{\"1\":{\"879\":1}}],[\"结构里\",{\"1\":{\"864\":1}}],[\"结构图\",{\"1\":{\"864\":2,\"885\":1,\"894\":1}}],[\"结构代替\",{\"1\":{\"807\":1}}],[\"结构优化\",{\"1\":{\"807\":1}}],[\"结构字段\",{\"1\":{\"433\":1}}],[\"结构保存了接口的动态类型信息\",{\"1\":{\"307\":1}}],[\"结构\",{\"0\":{\"938\":1,\"941\":1,\"943\":1},\"1\":{\"307\":1,\"864\":2,\"873\":1,\"876\":2,\"885\":1,\"894\":1,\"903\":1,\"946\":1}}],[\"结构记录了这个接口的方法列表\",{\"1\":{\"307\":1}}],[\"结构体查询\",{\"0\":{\"991\":1,\"1002\":1}}],[\"结构体数组\",{\"1\":{\"885\":2}}],[\"结构体tag由一个或多个键值对组成\",{\"1\":{\"484\":1}}],[\"结构体tag介绍\",{\"0\":{\"484\":1}}],[\"结构体和数组也是按值传递的\",{\"1\":{\"457\":1}}],[\"结构体和数组\",{\"0\":{\"457\":1}}],[\"结构体属性个数\",{\"1\":{\"448\":1}}],[\"结构体\",{\"1\":{\"226\":1,\"462\":1,\"529\":1}}],[\"结构体大小\",{\"1\":{\"226\":2}}],[\"结构体声明变量省去struct\",{\"1\":{\"30\":1}}],[\"结果会发现表中依旧还存在一条\",{\"1\":{\"780\":1}}],[\"结果会产生一个名为\",{\"1\":{\"229\":1}}],[\"结果发送\",{\"1\":{\"734\":1}}],[\"结果集处理\",{\"1\":{\"734\":1}}],[\"结果返回\",{\"1\":{\"734\":1}}],[\"结果\",{\"1\":{\"540\":1,\"813\":1}}],[\"结果就是其他的请求承担了不应有的时间成本\",{\"1\":{\"249\":1}}],[\"结果也都是相同的\",{\"1\":{\"249\":1}}],[\"结果在编译时得到而非运行中获得\",{\"1\":{\"33\":1}}],[\"结果都是一致的\",{\"1\":{\"23\":1}}],[\"系统本身需要一旦内存资源\",{\"1\":{\"900\":1}}],[\"系统就会拒绝接下来的连接请求\",{\"1\":{\"817\":1}}],[\"系统可以检查binlog中是否存在对应的事务记录\",{\"1\":{\"810\":1}}],[\"系统内活跃且未提交的事务\",{\"1\":{\"787\":1}}],[\"系统内活跃且未提交的事务id列表\",{\"1\":{\"744\":1}}],[\"系统状态更新等\",{\"1\":{\"615\":1}}],[\"系统编程\",{\"2\":{\"225\":1}}],[\"系统中要给下一个事务分配的id值\",{\"1\":{\"744\":1,\"787\":1}}],[\"系统中\",{\"1\":{\"223\":1,\"226\":1}}],[\"系统中存放\",{\"1\":{\"223\":1}}],[\"系统异常等等信息都会记录在这里\",{\"1\":{\"223\":1}}],[\"系统\",{\"1\":{\"223\":1}}],[\"系统优化\",{\"2\":{\"219\":1}}],[\"系统认为它们不太可能被立刻访问\",{\"1\":{\"217\":1}}],[\"系统认为它们可能会被再次访问\",{\"1\":{\"217\":1}}],[\"系统调用\",{\"1\":{\"381\":1,\"760\":1},\"2\":{\"222\":1}}],[\"系统调用在文件映射区域分配内存\",{\"1\":{\"217\":1}}],[\"系统调用从堆分配内存\",{\"1\":{\"217\":1}}],[\"系统会把\",{\"1\":{\"223\":1}}],[\"系统会产生一个缺页异常\",{\"1\":{\"217\":1}}],[\"系统会对每个用户的身份做唯一标识\",{\"1\":{\"190\":1}}],[\"系统监控命令\",{\"0\":{\"194\":1}}],[\"系统管理命令\",{\"0\":{\"203\":1}}],[\"系统管理\",{\"2\":{\"191\":1,\"212\":1,\"213\":1}}],[\"系统管理员可以使用超级用户账号来执行各种系统管理任务\",{\"1\":{\"190\":1}}],[\"系统的每个用户都拥有唯一的登录名\",{\"1\":{\"190\":1}}],[\"系统的状态都保持一致\",{\"1\":{\"23\":1}}],[\"系统而言\",{\"1\":{\"190\":1}}],[\"系统架构\",{\"2\":{\"127\":1,\"233\":1,\"890\":1,\"893\":1,\"899\":1}}],[\"系统不会为引用\",{\"1\":{\"30\":1}}],[\"系统设计\",{\"2\":{\"24\":1,\"128\":1,\"234\":1,\"926\":1,\"929\":1,\"932\":1,\"935\":1}}],[\"服务架构\",{\"2\":{\"972\":1}}],[\"服务启动时如何加载持久化数据\",{\"1\":{\"949\":1}}],[\"服务可能就挂了\",{\"1\":{\"927\":1}}],[\"服务要能扛住\",{\"1\":{\"927\":1}}],[\"服务a获取了锁\",{\"1\":{\"912\":1,\"921\":1}}],[\"服务挂掉\",{\"1\":{\"911\":1,\"921\":1}}],[\"服务初始化的时候\",{\"1\":{\"897\":1}}],[\"服务收到\",{\"1\":{\"817\":1}}],[\"服务发送\",{\"1\":{\"817\":1}}],[\"服务异常重启的现象\",{\"1\":{\"817\":1}}],[\"服务占用内存太大\",{\"1\":{\"817\":1}}],[\"服务默认是\",{\"1\":{\"817\":1}}],[\"服务支持的最大连接数由\",{\"1\":{\"817\":1}}],[\"服务被多少个客户端连接了\",{\"1\":{\"817\":1}}],[\"服务\",{\"1\":{\"229\":2,\"817\":6,\"836\":2}}],[\"服务接口\",{\"1\":{\"229\":1}}],[\"服务或者\",{\"1\":{\"223\":1}}],[\"服务器退出之前的准备工作时\",{\"1\":{\"952\":1}}],[\"服务器端缓存\",{\"1\":{\"930\":1}}],[\"服务器的用户帐户\",{\"1\":{\"854\":1}}],[\"服务器的主机名\",{\"1\":{\"838\":1}}],[\"服务器后\",{\"1\":{\"854\":1}}],[\"服务器进程处理后再向客户端进程发送一段文本\",{\"1\":{\"817\":1}}],[\"服务器架构\",{\"1\":{\"800\":1}}],[\"服务器通信\",{\"1\":{\"734\":1}}],[\"服务器也是同样的操作\",{\"1\":{\"249\":1}}],[\"服务器确认的\",{\"1\":{\"249\":1}}],[\"服务器找到该id的session来确定请求方的身份和一些上下文信息\",{\"1\":{\"249\":1}}],[\"服务器接收到请求后解析得到sessionid\",{\"1\":{\"249\":1}}],[\"服务器会为客户端创建一个session\",{\"1\":{\"249\":1}}],[\"服务器可以在响应头里面添加一个\",{\"1\":{\"249\":1}}],[\"服务器上的资源\",{\"1\":{\"249\":1}}],[\"服务器不知道真实的客户端\",{\"1\":{\"240\":1}}],[\"服务器作为网关\",{\"1\":{\"240\":1}}],[\"服务器作为网关层\",{\"1\":{\"240\":1}}],[\"服务器很忙\",{\"1\":{\"240\":1}}],[\"服务器程序错误\",{\"1\":{\"240\":1}}],[\"服务器\",{\"1\":{\"223\":1,\"243\":1,\"249\":1,\"836\":2}}],[\"服务器验证token的有效性\",{\"1\":{\"23\":1}}],[\"服务层的内部组成比较丰富\",{\"1\":{\"157\":1}}],[\"服务层的内部架构\",{\"0\":{\"157\":1}}],[\"服务层\",{\"1\":{\"156\":1,\"800\":1,\"817\":1}}],[\"服务层和消费者的工作原理\",{\"1\":{\"155\":1}}],[\"服务端缓存\",{\"1\":{\"930\":1}}],[\"服务端将数据存入redis\",{\"1\":{\"930\":1}}],[\"服务端在启动时\",{\"1\":{\"888\":1}}],[\"服务端程序使用\",{\"1\":{\"817\":1}}],[\"服务端自然也就被限制\",{\"1\":{\"807\":1}}],[\"服务端连接池\",{\"1\":{\"807\":2}}],[\"服务端返回\",{\"1\":{\"249\":1}}],[\"服务端收到后\",{\"1\":{\"249\":1}}],[\"服务端收到后解密\",{\"1\":{\"249\":1}}],[\"服务端收到\",{\"1\":{\"249\":1}}],[\"服务端收到token后剥离出header和payload获取算法\",{\"1\":{\"249\":1}}],[\"服务端回应招呼\",{\"1\":{\"249\":1}}],[\"服务端的证书都是由\",{\"1\":{\"249\":1}}],[\"服务端的内核会在fin报文插入一个结束符eof并放在内核的接收缓冲区中\",{\"1\":{\"226\":1}}],[\"服务端创建\",{\"1\":{\"249\":1}}],[\"服务端错误\",{\"1\":{\"249\":1}}],[\"服务端发送\",{\"1\":{\"249\":2}}],[\"服务端发生错误\",{\"1\":{\"249\":1}}],[\"服务端发完http响应后\",{\"1\":{\"237\":1}}],[\"服务端不具备完成请求的功能\",{\"1\":{\"240\":1}}],[\"服务端无法处理\",{\"1\":{\"240\":1}}],[\"服务端正常处理客户端的请求\",{\"1\":{\"240\":1}}],[\"服务端正常执行完毕并释放了分布式锁但由于网络原因客户端没有正常收到服务端的响应\",{\"1\":{\"23\":1}}],[\"服务端为什么会主动关闭连接\",{\"1\":{\"237\":1}}],[\"服务端应该尽量避免主动断开连接\",{\"1\":{\"237\":1}}],[\"服务端要并发处理多个客户端的\",{\"1\":{\"226\":1}}],[\"服务端会自动释放链接\",{\"1\":{\"226\":1}}],[\"服务端一段时间后会触发tcp保活机制\",{\"1\":{\"226\":1}}],[\"服务端怎么感知客户端关闭tcp连接\",{\"1\":{\"226\":1}}],[\"服务端是\",{\"1\":{\"102\":1}}],[\"服务端\",{\"0\":{\"102\":1,\"1021\":1},\"1\":{\"237\":2}}],[\"服务端负责接收和处理指令\",{\"1\":{\"100\":1}}],[\"那肯定是优先使用混合持久化的数据\",{\"1\":{\"949\":1}}],[\"那进一步开启混合持久化\",{\"1\":{\"949\":1}}],[\"那还是得用aof\",{\"1\":{\"949\":1}}],[\"那还是需要用rdb\",{\"1\":{\"949\":1}}],[\"那谁来组织\",{\"1\":{\"942\":1}}],[\"那到底发不发货呢\",{\"1\":{\"927\":1}}],[\"那锁就不能获取了\",{\"1\":{\"915\":1,\"921\":1}}],[\"那就是后面覆盖前面\",{\"1\":{\"952\":1}}],[\"那就需要精确计数\",{\"1\":{\"927\":1}}],[\"那就需要再启动时\",{\"1\":{\"882\":1}}],[\"那就不会再创建其他线程\",{\"1\":{\"897\":1}}],[\"那大于\",{\"1\":{\"864\":1}}],[\"那在对表结构做变更操作的时候\",{\"1\":{\"820\":1}}],[\"那在哪个阶段\",{\"1\":{\"817\":1}}],[\"那如果数据库有一个长事务\",{\"1\":{\"820\":1}}],[\"那它是在什么时候释放的\",{\"1\":{\"820\":1}}],[\"那它系一定发生逃逸\",{\"1\":{\"407\":1}}],[\"那可以将结构改为hash结构\",{\"1\":{\"813\":1}}],[\"那有什么其他方式可以避免\",{\"1\":{\"820\":1}}],[\"那有\",{\"1\":{\"810\":1}}],[\"那一个事务在执行过程中\",{\"1\":{\"810\":1}}],[\"那与varchar相比\",{\"1\":{\"770\":1}}],[\"那具体怎么解决呢\",{\"1\":{\"770\":1}}],[\"那这些\",{\"1\":{\"940\":1}}],[\"那这里的并发问题如何解决\",{\"1\":{\"760\":1}}],[\"那这个参数或者类似的参数等等\",{\"1\":{\"710\":1}}],[\"那个是在\",{\"1\":{\"747\":1}}],[\"那直接修改\",{\"1\":{\"747\":1,\"810\":1}}],[\"那修改完这条记录是选择直接写回到磁盘\",{\"1\":{\"747\":1,\"810\":1}}],[\"那算出来就是10\",{\"1\":{\"723\":1}}],[\"那必然证书也是被信任的\",{\"1\":{\"249\":1}}],[\"那样轮询扫描整个\",{\"1\":{\"226\":1}}],[\"那把最常访问的几个页表项存储到访问速度更快的硬件\",{\"1\":{\"217\":1}}],[\"那不得不重新\",{\"1\":{\"217\":1}}],[\"那首先必须要有一个镜像\",{\"1\":{\"97\":1}}],[\"那么攻击者要做的就是手动生成彩虹表\",{\"1\":{\"1052\":1}}],[\"那么对于\",{\"1\":{\"957\":1}}],[\"那么数据可能存在\",{\"1\":{\"930\":1}}],[\"那么数据也就丢失了\",{\"1\":{\"930\":1}}],[\"那么数据完整性就会遭到破坏\",{\"1\":{\"237\":1}}],[\"那么两个进程就获取到了同一个分布式锁\",{\"1\":{\"918\":1,\"921\":1}}],[\"那么两个事务\",{\"1\":{\"820\":1}}],[\"那么也是获取锁失败\",{\"1\":{\"917\":1,\"921\":1}}],[\"那么上述情况发生概率就很高\",{\"1\":{\"912\":1,\"921\":1}}],[\"那么锁就一直得不到释放\",{\"1\":{\"911\":1,\"921\":1}}],[\"那么访问计数就会衰减\",{\"1\":{\"903\":1}}],[\"那么存储结构如下\",{\"1\":{\"894\":1}}],[\"那么过期键存在哪里\",{\"1\":{\"894\":1}}],[\"那么预留的空间有多大呢\",{\"1\":{\"873\":1}}],[\"那么此时该事务\",{\"1\":{\"820\":1}}],[\"那么此时客户端会再次使用\",{\"1\":{\"23\":1}}],[\"那么等值查询\",{\"1\":{\"820\":2}}],[\"那么不管是\",{\"1\":{\"820\":1}}],[\"那么不难想象根节点就是整棵树上的最小值\",{\"1\":{\"51\":1}}],[\"那么该记录的索引中的\",{\"1\":{\"820\":1}}],[\"那么该列右边的所有列都无法使用走索引\",{\"1\":{\"813\":1}}],[\"那么另外一个事务在获取相同范围的\",{\"1\":{\"820\":4}}],[\"那么其他事务即不能插入\",{\"1\":{\"820\":1}}],[\"那么其他事务就无法插入\",{\"1\":{\"820\":1}}],[\"那么加\",{\"1\":{\"820\":1}}],[\"那么将会被阻塞\",{\"1\":{\"820\":1}}],[\"那么将这\",{\"1\":{\"810\":1}}],[\"那么本线程接下来如果要对学生表执行写操作的语句\",{\"1\":{\"820\":1}}],[\"那么执行器与存储引擎的执行流程是这样的\",{\"1\":{\"817\":1}}],[\"那么当客户端执行了一个很大的操作后\",{\"1\":{\"817\":1}}],[\"那么我们很容易能够想到\",{\"1\":{\"957\":1}}],[\"那么我们可以定期断开长连接\",{\"1\":{\"817\":1}}],[\"那么我们要更新一条记录的时候\",{\"1\":{\"747\":1,\"810\":1}}],[\"那么索引会失效\",{\"1\":{\"813\":1}}],[\"那么多个普通字段组合在一起创建的索引就叫做联合索引\",{\"1\":{\"813\":1}}],[\"那么如果单个节点进行了主从切换\",{\"1\":{\"917\":1,\"921\":1}}],[\"那么如果等值查询的记录是存在于表中\",{\"1\":{\"820\":1}}],[\"那么如果数据库里有很多数据\",{\"1\":{\"820\":1}}],[\"那么如果出现\",{\"1\":{\"810\":1}}],[\"那么如果随着系统运行\",{\"1\":{\"810\":1}}],[\"那么总共就可以记录\",{\"1\":{\"810\":1}}],[\"那么可能需要考虑添加或优化索引以提高查询效率\",{\"1\":{\"807\":1}}],[\"那么在较长时间内\",{\"1\":{\"930\":1}}],[\"那么在异常情况下\",{\"1\":{\"912\":1,\"921\":1}}],[\"那么在加\",{\"1\":{\"820\":1}}],[\"那么在线程\",{\"1\":{\"820\":1}}],[\"那么在备份数据库之前先开启事务\",{\"1\":{\"820\":1}}],[\"那么在每个事务提交过程中\",{\"1\":{\"810\":1}}],[\"那么在范围查询\",{\"1\":{\"770\":1}}],[\"那么在事务执行中途发生了\",{\"1\":{\"739\":1,\"810\":1}}],[\"那么磁盘查询时就会有大量的随机i\",{\"1\":{\"770\":1}}],[\"那么链表中相邻的两个页之间的物理位置并不是连续的\",{\"1\":{\"770\":1}}],[\"那么这时执行器与存储引擎的执行流程是这样的\",{\"1\":{\"817\":1}}],[\"那么这个表的查询缓存就会被清空\",{\"1\":{\"817\":1}}],[\"那么这个插入语句就会被阻塞\",{\"1\":{\"783\":1}}],[\"那么这个成员变量是属于类的\",{\"1\":{\"571\":1}}],[\"那么这一行\",{\"1\":{\"763\":1,\"810\":1}}],[\"那么问题是\",{\"1\":{\"525\":1}}],[\"那么就立刻调用redis\",{\"1\":{\"952\":1}}],[\"那么就是获取到了锁\",{\"1\":{\"917\":1,\"921\":1}}],[\"那么就可能出现这样的情况\",{\"1\":{\"820\":1}}],[\"那么就会全表扫描\",{\"1\":{\"820\":1}}],[\"那么就会被阻塞\",{\"1\":{\"820\":1}}],[\"那么就会创建\",{\"1\":{\"770\":1}}],[\"那么就要看具体情况是否能实现索引覆盖\",{\"1\":{\"813\":1}}],[\"那么就有两种情况\",{\"1\":{\"810\":1}}],[\"那么就没有\",{\"1\":{\"770\":1}}],[\"那么就称这种类型为该接口的一种实现\",{\"1\":{\"464\":1}}],[\"那么就将其添加到isr列表当中\",{\"1\":{\"182\":1}}],[\"那么为什么最先调度的是\",{\"1\":{\"373\":1}}],[\"那么itab\",{\"1\":{\"307\":1}}],[\"那么直接就退出了\",{\"1\":{\"265\":1}}],[\"那么直接发送数据\",{\"1\":{\"264\":1}}],[\"那么下面就可以把元素放到\",{\"1\":{\"265\":1}}],[\"那么刚刚好\",{\"1\":{\"265\":1}}],[\"那么握手正式完成\",{\"1\":{\"249\":1}}],[\"那么session就是服务端行为\",{\"1\":{\"249\":1}}],[\"那么队列里后面的所有请求也不得不跟着一起等待\",{\"1\":{\"249\":1}}],[\"那么有了\",{\"1\":{\"226\":1,\"820\":1}}],[\"那么它之前的信息就相当于都确认了\",{\"1\":{\"163\":1}}],[\"那么消费者就会从server拉取消息做业务处理\",{\"1\":{\"156\":1}}],[\"那么再释放浅拷贝的指针的资源就会出现错误\",{\"1\":{\"33\":1}}],[\"那么\",{\"1\":{\"33\":1,\"770\":1,\"810\":1,\"813\":1,\"820\":6,\"879\":2}}],[\"那用分布式锁来处理幂等性可以吗\",{\"1\":{\"23\":1}}],[\"和where中的or等价\",{\"1\":{\"1005\":1}}],[\"和where中的not等价\",{\"1\":{\"1004\":1}}],[\"和反射来提高代码执行效率\",{\"1\":{\"957\":1}}],[\"和反射机制\",{\"1\":{\"957\":1}}],[\"和反射\",{\"1\":{\"956\":1}}],[\"和业务完全解耦\",{\"1\":{\"930\":1}}],[\"和缓存击穿不同的是\",{\"1\":{\"930\":1}}],[\"和数据不一致\",{\"1\":{\"930\":1}}],[\"和数据页的刷盘策略是一样的\",{\"1\":{\"810\":1}}],[\"和cache\",{\"1\":{\"930\":1}}],[\"和事务\",{\"1\":{\"820\":1}}],[\"和独占表锁\",{\"1\":{\"820\":1}}],[\"和普通索引\",{\"1\":{\"817\":1}}],[\"和所有跨存储引擎的功能\",{\"1\":{\"817\":1}}],[\"和时刻\",{\"1\":{\"810\":1}}],[\"和索引是否支持聚簇索引密切相关\",{\"1\":{\"770\":1}}],[\"和参与者\",{\"1\":{\"764\":1,\"810\":1}}],[\"和活化\",{\"1\":{\"638\":1}}],[\"和容量\",{\"1\":{\"338\":1}}],[\"和明文一起发给\",{\"1\":{\"249\":1}}],[\"和密文c\",{\"1\":{\"249\":1}}],[\"和后面的部分分离开\",{\"1\":{\"249\":1}}],[\"和设备\",{\"1\":{\"220\":1}}],[\"和段界限之间\",{\"1\":{\"217\":1}}],[\"和与之相对应的整数型用户id\",{\"1\":{\"190\":1}}],[\"和sticky\",{\"1\":{\"165\":1}}],[\"和桥接模式一样\",{\"1\":{\"125\":1}}],[\"和网桥连接\",{\"1\":{\"122\":1}}],[\"和端口\",{\"1\":{\"122\":1}}],[\"和重载的区别在于两个函数不在同一个类中\",{\"1\":{\"33\":1}}],[\"和重写的区别在于基类函数是否是虚函数\",{\"1\":{\"33\":1}}],[\"和myp一样\",{\"1\":{\"30\":1}}],[\"和\",{\"0\":{\"460\":1},\"1\":{\"23\":1,\"33\":7,\"123\":1,\"190\":2,\"223\":6,\"229\":2,\"237\":1,\"240\":1,\"249\":13,\"307\":1,\"333\":1,\"374\":1,\"381\":1,\"453\":1,\"479\":1,\"512\":2,\"520\":2,\"523\":1,\"524\":1,\"526\":1,\"529\":1,\"531\":3,\"743\":3,\"745\":1,\"757\":1,\"759\":1,\"763\":1,\"765\":1,\"770\":13,\"784\":1,\"789\":1,\"807\":1,\"810\":28,\"813\":8,\"817\":1,\"838\":2,\"840\":1,\"864\":1,\"867\":1,\"873\":4,\"879\":1,\"894\":2,\"903\":1,\"906\":1,\"930\":2,\"937\":1,\"938\":1,\"940\":1,\"944\":1,\"946\":2,\"949\":1,\"952\":1,\"957\":6}}],[\"思路2\",{\"0\":{\"721\":1}}],[\"思路1\",{\"0\":{\"720\":1}}],[\"思路缺点\",{\"1\":{\"20\":1}}],[\"思考下面\",{\"1\":{\"477\":1}}],[\"思考下面三种情况\",{\"1\":{\"23\":1}}],[\"思考以下问题\",{\"1\":{\"367\":1,\"763\":1}}],[\"思考\",{\"1\":{\"23\":1,\"374\":1}}],[\"但由于网络传输本身有延迟\",{\"1\":{\"930\":1}}],[\"但实际上很少用更新\",{\"1\":{\"930\":1}}],[\"但实际是成功的\",{\"1\":{\"927\":1}}],[\"但实际是可伸缩的\",{\"1\":{\"378\":1}}],[\"但胜在轻量\",{\"1\":{\"927\":1}}],[\"但这也是\",{\"1\":{\"957\":1}}],[\"但这里会觉得有些牵强\",{\"1\":{\"930\":1}}],[\"但这样容易误杀\",{\"1\":{\"927\":1}}],[\"但这不是永久的\",{\"1\":{\"240\":1}}],[\"但我们做活动\",{\"1\":{\"927\":1}}],[\"但要是被眼尖的消费者发现的话\",{\"1\":{\"927\":1}}],[\"但缺点就是它不是一完整的\",{\"1\":{\"906\":1}}],[\"但没有为每个密码使用唯一的盐\",{\"1\":{\"1052\":1}}],[\"但没有大小\",{\"1\":{\"879\":1}}],[\"但没有具体实现\",{\"1\":{\"298\":1}}],[\"但两个事务却不能在同一时间内\",{\"1\":{\"820\":2}}],[\"但普通索引则不需要考虑这个问题\",{\"1\":{\"813\":1}}],[\"但插入数据时就不同了\",{\"1\":{\"813\":1}}],[\"但中文呢\",{\"1\":{\"813\":1}}],[\"但比\",{\"1\":{\"813\":2}}],[\"但即使\",{\"1\":{\"810\":1}}],[\"但需要对多个记录进行比较\",{\"1\":{\"807\":1}}],[\"但累积\",{\"1\":{\"760\":1,\"810\":2}}],[\"但数据库文件还不是最新的\",{\"1\":{\"751\":1}}],[\"但还未完成将最新的数据记录\",{\"1\":{\"751\":1}}],[\"但仍然是协议无关的\",{\"1\":{\"665\":1}}],[\"但servlet作为底层技术\",{\"1\":{\"644\":1}}],[\"但如果只有\",{\"1\":{\"952\":1}}],[\"但如果需要使用xml配置\",{\"1\":{\"588\":1,\"627\":1,\"658\":1}}],[\"但如果子函数完成的功能比较少\",{\"1\":{\"36\":1}}],[\"但它可以修改请求和响应\",{\"1\":{\"578\":1}}],[\"但它允许多个虚拟机共享一个虚拟的私有网络\",{\"1\":{\"246\":1}}],[\"但键的值可能会因为并发操作而发生变化\",{\"1\":{\"532\":1}}],[\"但存在于\",{\"1\":{\"531\":1}}],[\"但也带来了更高的风险\",{\"1\":{\"460\":1}}],[\"但传递的是一个\",{\"1\":{\"456\":1}}],[\"但对于记录锁\",{\"1\":{\"820\":2}}],[\"但对于短字符串\",{\"1\":{\"497\":1}}],[\"但对于包含大量数据的返回值\",{\"1\":{\"428\":1}}],[\"但对于用于加密的哈希算法来说\",{\"1\":{\"72\":1}}],[\"但其实当参数为变量自身的时候\",{\"1\":{\"417\":1}}],[\"但其是针对地址的\",{\"1\":{\"33\":1}}],[\"但并不是只有bucket\",{\"1\":{\"325\":1}}],[\"但元素类型不含指针\",{\"1\":{\"263\":1}}],[\"但在这里通过select只更新一个字段\",{\"1\":{\"998\":1}}],[\"但在并发量较大的时候\",{\"1\":{\"810\":1}}],[\"但在多事务的情况下\",{\"1\":{\"766\":1}}],[\"但在\",{\"1\":{\"706\":1,\"810\":1}}],[\"但在整个本包内是可见而且是可用的\",{\"1\":{\"433\":1}}],[\"但在传输层部分使用\",{\"1\":{\"249\":1}}],[\"但在发生函数调用时\",{\"1\":{\"36\":1}}],[\"但首字母大写的可读性更好\",{\"1\":{\"249\":1}}],[\"但可以通过组合和接口来达到类似的效果\",{\"1\":{\"461\":1}}],[\"但可以通过起别名来实现绑定\",{\"1\":{\"460\":1}}],[\"但可以通过这个指针修改它所指向的整数\",{\"1\":{\"33\":1}}],[\"但可以没有\",{\"1\":{\"249\":1}}],[\"但和根目录的\",{\"1\":{\"223\":1}}],[\"但通常只有内核态代码才能访问内核空间\",{\"1\":{\"217\":1}}],[\"但跟菜鸟驿站不同的一点是server会持久化存储信息\",{\"1\":{\"156\":1}}],[\"但不一致的时间会比较明显\",{\"1\":{\"930\":1}}],[\"但不一定是utf\",{\"1\":{\"351\":1}}],[\"但不同于间隙锁的是\",{\"1\":{\"820\":1}}],[\"但不论是哪一种\",{\"1\":{\"820\":1}}],[\"但不是最大长度200\",{\"1\":{\"770\":1}}],[\"但不是每一次转化都发生上面的内存拷贝\",{\"1\":{\"360\":1}}],[\"但不会改变实参值\",{\"1\":{\"454\":1}}],[\"但不会创建输出目录本身\",{\"1\":{\"229\":1}}],[\"但不包含\",{\"1\":{\"249\":1}}],[\"但不能使用下划线\",{\"1\":{\"249\":1}}],[\"但不可自我描述的二进制线性格式\",{\"1\":{\"229\":1}}],[\"但不进行任何网络配置\",{\"1\":{\"126\":1}}],[\"但不增加引用计数\",{\"1\":{\"33\":1}}],[\"但\",{\"1\":{\"124\":1,\"520\":1,\"810\":2,\"946\":1}}],[\"但因其冲突概率极低在有限资源下很难破解\",{\"1\":{\"74\":1}}],[\"但复杂的操作还是要由函数调用来完成\",{\"1\":{\"36\":1}}],[\"但使用带参数的宏定义就不会出现这个问题\",{\"1\":{\"36\":1}}],[\"但指针本身是可以修改的\",{\"1\":{\"33\":1}}],[\"但悬空指针比较麻烦\",{\"1\":{\"33\":1}}],[\"但拷贝的数据是一个固定为4字节的地址\",{\"1\":{\"33\":1}}],[\"但综合效率以及网络故障概率等因素总体来说\",{\"1\":{\"23\":1}}],[\"但是序列化之后\",{\"1\":{\"993\":1}}],[\"但是多数情况下\",{\"1\":{\"957\":1}}],[\"但是开头有\",{\"1\":{\"952\":1}}],[\"但是向kafka发送消息失败\",{\"1\":{\"927\":1}}],[\"但是总数是不变的\",{\"1\":{\"927\":1}}],[\"但是相对完备的消息队列中间件比如kafka\",{\"1\":{\"924\":1}}],[\"但是接入和维护一个消息队列中间件\",{\"1\":{\"924\":1}}],[\"但是判断完才开始\",{\"1\":{\"918\":1,\"921\":1}}],[\"但是已经时过境迁\",{\"1\":{\"918\":1,\"921\":1}}],[\"但是主从切换\",{\"1\":{\"916\":1,\"921\":1}}],[\"但是主库宕机\",{\"1\":{\"730\":1,\"761\":1}}],[\"但是删除的时候已经是别人的了\",{\"1\":{\"913\":2,\"921\":2}}],[\"但是删除更为灵活\",{\"1\":{\"867\":1}}],[\"但是setnx和expire不具备原子性\",{\"1\":{\"911\":1,\"921\":1}}],[\"但是查询某个节点的效率比较低\",{\"1\":{\"885\":1}}],[\"但是对\",{\"1\":{\"882\":1}}],[\"但是对于\",{\"1\":{\"223\":1}}],[\"但是平均操作时间确是\",{\"1\":{\"879\":1}}],[\"但是平常并没有用到这个结构体\",{\"1\":{\"354\":1}}],[\"但是实际聊的比较多的还是\",{\"1\":{\"879\":1}}],[\"但是有上限\",{\"1\":{\"864\":1}}],[\"但是有一点要注意\",{\"1\":{\"820\":1}}],[\"但是他可能没有任何权限\",{\"1\":{\"846\":1}}],[\"但是他去更新了这条记录\",{\"1\":{\"793\":1}}],[\"但是表中数据区分大小写\",{\"1\":{\"829\":1}}],[\"但是表上有更新语句\",{\"1\":{\"810\":1}}],[\"但是只要破坏任意一个条件就死锁就不会成立\",{\"1\":{\"820\":1}}],[\"但是由于是并发操作\",{\"1\":{\"927\":1}}],[\"但是由于事务\",{\"1\":{\"820\":1}}],[\"但是由于网络原因没有收到ack导致消息重发\",{\"1\":{\"23\":1}}],[\"但是事务\",{\"1\":{\"820\":1}}],[\"但是除了报错之外\",{\"1\":{\"820\":2}}],[\"但是还没异步写入mysql之前\",{\"1\":{\"930\":1}}],[\"但是还要注意\",{\"1\":{\"820\":1}}],[\"但是还有一部分应用程序并不把配置储存在\",{\"1\":{\"223\":1}}],[\"但是现在处于等待状态\",{\"1\":{\"820\":1}}],[\"但是它并不是意向锁\",{\"1\":{\"820\":1}}],[\"但是它并\",{\"1\":{\"820\":1}}],[\"但是它的大小不能在编译时确定的情况\",{\"1\":{\"408\":1}}],[\"但是并没有什么区别\",{\"1\":{\"820\":1}}],[\"但是并没有把数据持久化到磁盘\",{\"1\":{\"810\":1}}],[\"但是一般还会有业务状态码是另外统一封装的\",{\"1\":{\"1029\":1}}],[\"但是一般来说系统会自动帮你挂载诸如\",{\"1\":{\"223\":1}}],[\"但是一秒一次\",{\"1\":{\"952\":1}}],[\"但是一致性问题\",{\"1\":{\"927\":1}}],[\"但是一下场景\",{\"1\":{\"903\":1}}],[\"但是一直不提交\",{\"1\":{\"820\":1}}],[\"但是一直还没提交\",{\"1\":{\"820\":1}}],[\"但是因为它包含在联合索引\",{\"1\":{\"817\":1}}],[\"但是执行的效率会不同\",{\"1\":{\"817\":1}}],[\"但是经过\",{\"1\":{\"817\":1}}],[\"但是注意\",{\"1\":{\"817\":1}}],[\"但是可以索引下推\",{\"1\":{\"813\":1}}],[\"但是可能带来缓存一致性问题\",{\"1\":{\"730\":1}}],[\"但是可能被重复发送处理\",{\"1\":{\"705\":1}}],[\"但是排序\",{\"1\":{\"813\":1}}],[\"但是该列的值包含范围查询\",{\"1\":{\"813\":1}}],[\"但是最多只涉及树的一条路径\",{\"1\":{\"813\":1}}],[\"但是最终都写到同一个\",{\"1\":{\"810\":1}}],[\"但是树非常矮\",{\"1\":{\"813\":1}}],[\"但是需要额外的写入和存储来维护索引\",{\"1\":{\"813\":1}}],[\"但是需要考虑消息重复发送的可能性\",{\"1\":{\"706\":1}}],[\"但是这样做下去说不定就做成mysql的\",{\"1\":{\"927\":1}}],[\"但是这样做的风险是\",{\"1\":{\"810\":2}}],[\"但是这次因为不是第一次查询了\",{\"1\":{\"817\":1}}],[\"但是这两个是独立的逻辑\",{\"1\":{\"763\":1,\"810\":1}}],[\"但是风险也是最大的\",{\"1\":{\"810\":1}}],[\"但是数据安全性方面比参数\",{\"1\":{\"810\":1}}],[\"但是数据库的读取并不以\",{\"1\":{\"770\":1}}],[\"但是问题来了\",{\"1\":{\"810\":1}}],[\"但是每个表只能有一个聚簇索引\",{\"1\":{\"807\":1}}],[\"但是每种浏览器也都有允许cookie失效的设置\",{\"1\":{\"249\":1}}],[\"但是会将连接恢复到刚刚创建完时的状态\",{\"1\":{\"817\":1}}],[\"但是会频繁修改\",{\"1\":{\"770\":1}}],[\"但是会出现外部内存碎片和内存交换的空间太大的问题\",{\"1\":{\"217\":1}}],[\"但是当第一个事务还未提交的时候\",{\"1\":{\"820\":1}}],[\"但是当搭配\",{\"1\":{\"820\":1}}],[\"但是当发生行溢出时\",{\"1\":{\"770\":1}}],[\"但是当前函数panic后面的代码不会被执行\",{\"1\":{\"478\":1}}],[\"但是性能很差\",{\"1\":{\"766\":1,\"810\":1}}],[\"但是前提是查询的数据量不大\",{\"1\":{\"730\":1}}],[\"但是能容忍消息重复的场景\",{\"1\":{\"705\":1}}],[\"但是绝对不会重复发送\",{\"1\":{\"705\":1}}],[\"但是值为\",{\"1\":{\"524\":1}}],[\"但是在崩溃场景下你可能会丢失1秒的数据\",{\"1\":{\"952\":1}}],[\"但是在范围查询字段的后面的字段无法用到联合索引\",{\"1\":{\"813\":1}}],[\"但是在内存仍然存在这个\",{\"1\":{\"523\":1}}],[\"但是在计算机里面都是二进制01\",{\"1\":{\"249\":1}}],[\"但是调用此函数的函数继续执行\",{\"1\":{\"479\":1}}],[\"但是调用该函数的代码可以接着执行\",{\"1\":{\"478\":1}}],[\"但是再上一层的还可以可以继续执行\",{\"1\":{\"479\":1}}],[\"但是属于副本读\",{\"1\":{\"452\":1}}],[\"但是iota\",{\"1\":{\"442\":2}}],[\"但是如果发生崩溃\",{\"1\":{\"952\":1}}],[\"但是如果\",{\"1\":{\"518\":1}}],[\"但是如果地址所指向的内容被修改了\",{\"1\":{\"476\":1}}],[\"但是如果拷贝的数据量小\",{\"1\":{\"409\":1}}],[\"但是如果是增量修改是需要保证幂等性的\",{\"1\":{\"23\":1}}],[\"但是发现到\",{\"1\":{\"374\":1}}],[\"但是不应处理复杂逻辑\",{\"1\":{\"962\":1}}],[\"但是不一定调用了flushappendonlyfile\",{\"1\":{\"952\":1}}],[\"但是不可以对该记录加\",{\"1\":{\"820\":1}}],[\"但是不包含记录本身\",{\"1\":{\"820\":1}}],[\"但是不会去查表或者字段存不存在\",{\"1\":{\"817\":1}}],[\"但是不会等待所有follow的确认\",{\"1\":{\"710\":1}}],[\"但是不想把密码也序列化\",{\"1\":{\"490\":1}}],[\"但是不能被修改\",{\"1\":{\"356\":1}}],[\"但是不要这么写\",{\"1\":{\"33\":1}}],[\"但是要满足一定条件\",{\"1\":{\"257\":1}}],[\"但是要注意的是\",{\"1\":{\"157\":1}}],[\"但是反过来\",{\"1\":{\"249\":1}}],[\"但是没有完全解决幻读\",{\"1\":{\"792\":1}}],[\"但是没有正确的处理这些异常情况\",{\"1\":{\"706\":1}}],[\"但是没有及时收到上游服务器的请求\",{\"1\":{\"240\":1}}],[\"但是没有body数据\",{\"1\":{\"240\":1}}],[\"但是访问后端服务器错误\",{\"1\":{\"240\":1}}],[\"但是服务端内部处理发生错误\",{\"1\":{\"240\":1}}],[\"但是tcp连接在服务端会受限于系统资源\",{\"1\":{\"237\":1}}],[\"但是从输出文件名中删除了指定的目录前缀\",{\"1\":{\"229\":1}}],[\"但是像\",{\"1\":{\"229\":1}}],[\"但是随着客户端越来越多\",{\"1\":{\"226\":1}}],[\"但是编程复杂性较高\",{\"1\":{\"226\":1}}],[\"但是下面要进行类型转换\",{\"1\":{\"226\":1}}],[\"但是得写全绝对路径才行\",{\"1\":{\"223\":1}}],[\"但是虚拟地址到物理地址的转换就多了几道转换的工序\",{\"1\":{\"217\":1}}],[\"但是kafka都是leader提供读写\",{\"1\":{\"176\":1}}],[\"但是\",{\"1\":{\"98\":1,\"183\":1,\"223\":1,\"249\":1,\"374\":1,\"525\":1,\"571\":1,\"752\":1,\"763\":1,\"770\":1,\"810\":6,\"813\":5,\"817\":2,\"820\":2,\"879\":1,\"906\":1,\"930\":1,\"952\":2}}],[\"但是子类必须提供实现的能力\",{\"1\":{\"33\":1}}],[\"但是基类函数不是虚函数\",{\"1\":{\"33\":1}}],[\"但是理论上malloc的内存可以被delete释放\",{\"1\":{\"33\":1}}],[\"但是num是局部变量\",{\"1\":{\"30\":1}}],[\"但是此时服务端返回的确却是\",{\"1\":{\"23\":1}}],[\"但是业务逻辑执行失败了\",{\"1\":{\"23\":1}}],[\"但是却存在着不够精准的场景\",{\"1\":{\"23\":1}}],[\"但是用户没有看到支付成功的结果\",{\"1\":{\"23\":1}}],[\"执行以上代码\",{\"1\":{\"957\":5}}],[\"执行以下sql语句\",{\"1\":{\"840\":1}}],[\"执行如下命令\",{\"1\":{\"952\":1}}],[\"执行本身不应该成为瓶颈\",{\"1\":{\"891\":1}}],[\"执行向表\",{\"1\":{\"820\":1}}],[\"执行语句的\",{\"1\":{\"820\":1}}],[\"执行后\",{\"1\":{\"820\":1}}],[\"执行阶段\",{\"1\":{\"817\":1}}],[\"执行过程中使用了普通索引\",{\"1\":{\"817\":1}}],[\"执行过程到理解mysql\",{\"1\":{\"733\":1}}],[\"执行完毕后\",{\"1\":{\"913\":1,\"921\":1}}],[\"执行完这里的时候\",{\"1\":{\"820\":1}}],[\"执行完成后\",{\"1\":{\"817\":1}}],[\"执行完就自动提交事务的\",{\"1\":{\"810\":1}}],[\"执行写sql时效率会降低\",{\"1\":{\"813\":1}}],[\"执行的请求依旧超出单机\",{\"1\":{\"807\":1}}],[\"执行计划如下\",{\"1\":{\"813\":1}}],[\"执行计划是什么等等来估计一下上限\",{\"1\":{\"807\":1}}],[\"执行计划优化\",{\"1\":{\"804\":1}}],[\"执行了相同的\",{\"1\":{\"820\":1}}],[\"执行了下面这条语句\",{\"1\":{\"820\":1}}],[\"执行了这条等值查询语句\",{\"1\":{\"820\":2}}],[\"执行了第一条\",{\"1\":{\"785\":1}}],[\"执行了\",{\"1\":{\"785\":2,\"820\":1}}],[\"执行sql\",{\"1\":{\"763\":1,\"817\":4}}],[\"执行器与存储引擎的执行流程是这样的\",{\"1\":{\"817\":1}}],[\"执行器收到存储引擎报告的查询完毕的信息\",{\"1\":{\"817\":1}}],[\"执行器继续判断条件\",{\"1\":{\"817\":1}}],[\"执行器会判断读到的这条记录的\",{\"1\":{\"817\":1}}],[\"执行器查询的过程是一个\",{\"1\":{\"817\":2}}],[\"执行器从存储引擎读到记录后\",{\"1\":{\"817\":1}}],[\"执行器第一次查询\",{\"1\":{\"817\":2}}],[\"执行器就退出循环\",{\"1\":{\"817\":1}}],[\"执行器就会和存储引擎交互了\",{\"1\":{\"817\":1}}],[\"执行器就按照执行计划开始进行更新操作\",{\"1\":{\"810\":1}}],[\"执行器\",{\"1\":{\"817\":1}}],[\"执行器阶段\",{\"1\":{\"817\":1}}],[\"执行器等\",{\"1\":{\"817\":1}}],[\"执行器得到聚簇索引记录后\",{\"1\":{\"810\":2}}],[\"执行器负责具体执行\",{\"1\":{\"810\":3}}],[\"执行器把\",{\"1\":{\"760\":1,\"810\":1}}],[\"执行器将存储引擎返回的数据进行处理\",{\"1\":{\"734\":1}}],[\"执行一条语句是否自动提交事务\",{\"1\":{\"810\":2}}],[\"执行一条\",{\"1\":{\"810\":2,\"817\":2}}],[\"执行一条更新语句的过程\",{\"1\":{\"810\":1}}],[\"执行一条查询语句的过程\",{\"1\":{\"810\":1}}],[\"执行一个事务的过程中\",{\"1\":{\"755\":1,\"810\":1}}],[\"执行一次阻塞持久化\",{\"1\":{\"952\":1}}],[\"执行一次\",{\"1\":{\"451\":1}}],[\"执行更新操作的同时会涉及对三种日志的改动\",{\"1\":{\"735\":1}}],[\"执行查询\",{\"1\":{\"734\":1,\"793\":1}}],[\"执行清理操作\",{\"1\":{\"662\":1}}],[\"执行初始化操作\",{\"1\":{\"662\":1}}],[\"执行流程\",{\"0\":{\"661\":1}}],[\"执行顺序\",{\"1\":{\"596\":1,\"823\":2}}],[\"执行defer\",{\"1\":{\"477\":1}}],[\"执行到\",{\"1\":{\"473\":1}}],[\"执行权限\",{\"1\":{\"265\":1}}],[\"执行\",{\"1\":{\"229\":1,\"381\":1,\"817\":3,\"820\":1,\"897\":1,\"952\":2}}],[\"执行硬件指令可使\",{\"1\":{\"220\":1}}],[\"执行所访问的存储空间也局限于某个内存区域\",{\"1\":{\"217\":1}}],[\"执行速度比较\",{\"1\":{\"33\":1}}],[\"执行起来更快\",{\"1\":{\"33\":1}}],[\"执行成功\",{\"1\":{\"23\":1}}],[\"执行失败\",{\"1\":{\"23\":1}}],[\"或sha\",{\"1\":{\"1054\":1}}],[\"或使用kratos\",{\"1\":{\"969\":1}}],[\"或文件路径\",{\"1\":{\"957\":2}}],[\"或双引号\",{\"1\":{\"838\":1}}],[\"或回滚\",{\"1\":{\"810\":1}}],[\"或是cpu调度\",{\"1\":{\"807\":1}}],[\"或是大的结构体对象\",{\"1\":{\"33\":1}}],[\"或申请一块新的切片内存空间\",{\"1\":{\"357\":1}}],[\"或与之类似的路径名\",{\"1\":{\"220\":1}}],[\"或修改文件与目录的名称\",{\"1\":{\"202\":1}}],[\"或许是\",{\"1\":{\"190\":1}}],[\"或\",{\"1\":{\"23\":1,\"33\":1,\"36\":1,\"117\":1,\"190\":2,\"223\":1,\"657\":1,\"723\":1,\"864\":2}}],[\"或者崩溃了\",{\"1\":{\"930\":1}}],[\"或者在回包时将回包内容以请求参数为key缓存\",{\"1\":{\"930\":1}}],[\"或者在结构体中嵌入指向其他结构体的指针\",{\"1\":{\"459\":1}}],[\"或者网络延迟\",{\"1\":{\"912\":1,\"921\":1}}],[\"或者这样画\",{\"1\":{\"885\":1}}],[\"或者导航到\",{\"1\":{\"854\":1}}],[\"或者数据库中的一个或者多个表导出为一个\",{\"1\":{\"854\":1}}],[\"或者用这个\",{\"1\":{\"810\":1}}],[\"或者extra字段出现了using\",{\"1\":{\"807\":1}}],[\"或者进行某些常见的sql重写优化\",{\"1\":{\"734\":1}}],[\"或者会话超时\",{\"1\":{\"637\":1}}],[\"或者根据特定条件阻止请求的继续处理\",{\"1\":{\"578\":1}}],[\"或者是女的\",{\"1\":{\"1001\":1}}],[\"或者是\",{\"1\":{\"900\":1,\"957\":1}}],[\"或者是否是某个具体的类型\",{\"1\":{\"469\":1}}],[\"或者是数据太大\",{\"1\":{\"20\":1}}],[\"或者超级用户却被告知找不到该命令\",{\"1\":{\"223\":1}}],[\"或者查看\",{\"1\":{\"223\":1}}],[\"或者它们还没有复制\",{\"1\":{\"181\":1}}],[\"或者说\",{\"1\":{\"777\":1,\"949\":1}}],[\"或者说是join类型\",{\"1\":{\"807\":1}}],[\"或者说是\",{\"1\":{\"249\":1}}],[\"或者说是跟得上节奏的副本集合\",{\"1\":{\"181\":1}}],[\"或者说信息摘要\",{\"1\":{\"75\":1}}],[\"或者名称不同图片内容相同的情况\",{\"1\":{\"75\":1}}],[\"或者操作系统提供的其他内存分配函数\",{\"1\":{\"33\":1}}],[\"或者\",{\"1\":{\"23\":1,\"217\":1,\"452\":2,\"472\":1,\"723\":1,\"810\":1,\"820\":1,\"835\":2,\"836\":1}}],[\"响应文件\",{\"0\":{\"1032\":1}}],[\"响应结构体\",{\"1\":{\"1021\":1}}],[\"响应处理比较原始\",{\"1\":{\"1020\":1}}],[\"响应处理后\",{\"1\":{\"683\":1}}],[\"响应处理后的操作\",{\"1\":{\"683\":1}}],[\"响应时间\",{\"1\":{\"807\":1}}],[\"响应乱码\",{\"0\":{\"688\":1}}],[\"响应特定事件\",{\"1\":{\"615\":1}}],[\"响应阶段\",{\"1\":{\"596\":2}}],[\"响应则按照相反的顺序经过这些filter返回客户端\",{\"1\":{\"594\":1}}],[\"响应内容修改\",{\"1\":{\"579\":1}}],[\"响应内容的压缩等\",{\"1\":{\"579\":1}}],[\"响应也极其简单的\",{\"1\":{\"249\":1}}],[\"响应头部\",{\"1\":{\"249\":1}}],[\"响应头字段set\",{\"1\":{\"249\":1}}],[\"响应的数据加解密\",{\"1\":{\"249\":1}}],[\"响应的传输路径\",{\"1\":{\"249\":1}}],[\"响应的连接复用和空闲超时\",{\"1\":{\"237\":1}}],[\"响应报文结构\",{\"1\":{\"249\":1}}],[\"响应报文组成\",{\"1\":{\"249\":1}}],[\"响应客户端消息\",{\"1\":{\"226\":1}}],[\"响应\",{\"0\":{\"1028\":1,\"1029\":1,\"1031\":1},\"1\":{\"23\":1,\"578\":1}}],[\"响应速度快\",{\"1\":{\"12\":1}}],[\"接受实现了\",{\"1\":{\"470\":1}}],[\"接受客户端消息\",{\"1\":{\"226\":1}}],[\"接下来只需要通过\",{\"1\":{\"957\":1}}],[\"接下来以全景的视角来看\",{\"1\":{\"944\":1}}],[\"接下来就讲这个\",{\"1\":{\"810\":1}}],[\"接下来插入几条测试数据\",{\"1\":{\"770\":1}}],[\"接下来对比char类型的字符串\",{\"1\":{\"770\":1}}],[\"接下来看看\",{\"1\":{\"770\":1}}],[\"接下来\",{\"1\":{\"770\":1,\"817\":1,\"820\":1,\"840\":1}}],[\"接下来会执行defer函数\",{\"1\":{\"478\":1}}],[\"接下来把\",{\"1\":{\"374\":1}}],[\"接下来是第二个连接\",{\"1\":{\"249\":1}}],[\"接下来定义了一个message类型的person\",{\"1\":{\"229\":1}}],[\"接下来的41位是时间戳\",{\"1\":{\"92\":1}}],[\"接着判断记录是否符合查询条件\",{\"1\":{\"817\":1}}],[\"接着就要进入执行\",{\"1\":{\"817\":1}}],[\"接着对旧的\",{\"1\":{\"810\":1}}],[\"接着还会做语法分析\",{\"1\":{\"810\":1}}],[\"接着\",{\"1\":{\"793\":1,\"810\":2,\"817\":2,\"820\":4}}],[\"接着调用引擎的提交事务接口\",{\"1\":{\"765\":1,\"810\":2}}],[\"接着将虚拟地址和物理地址建立映射关系\",{\"1\":{\"748\":1,\"810\":1}}],[\"接着运行\",{\"1\":{\"479\":1}}],[\"接着再把整个文件描述符集合拷贝回用户态里\",{\"1\":{\"226\":1}}],[\"接着再把每个段划分为多个页\",{\"1\":{\"217\":1}}],[\"接着去执行业务逻辑\",{\"1\":{\"23\":1}}],[\"接收一个\",{\"1\":{\"957\":1}}],[\"接收和处理来自客户端的请求\",{\"1\":{\"647\":1}}],[\"接收新连接写到内核对象中\",{\"1\":{\"226\":1}}],[\"接收服务器信息\",{\"1\":{\"226\":1}}],[\"接收客户端发送的数据\",{\"1\":{\"226\":2}}],[\"接收客户端发送的消息\",{\"1\":{\"226\":1}}],[\"接收到push操作的阻塞键\",{\"1\":{\"944\":1}}],[\"接收到的明文的hash值进行对比\",{\"1\":{\"249\":1}}],[\"接收到数据的socket\",{\"1\":{\"226\":1}}],[\"接收到无效客户端socket\",{\"1\":{\"226\":1}}],[\"接收到网络报文\",{\"1\":{\"123\":1}}],[\"接收失败\",{\"1\":{\"226\":1}}],[\"接收\",{\"1\":{\"123\":1}}],[\"接口测试工具能走通的\",{\"1\":{\"1037\":1}}],[\"接口在这里定义\",{\"1\":{\"962\":1}}],[\"接口层增加校验\",{\"1\":{\"930\":1}}],[\"接口嵌套\",{\"0\":{\"471\":1}}],[\"接口的方法\",{\"1\":{\"470\":2}}],[\"接口的类型作为参数\",{\"1\":{\"470\":1}}],[\"接口的数据结构有关\",{\"1\":{\"469\":1}}],[\"接口作为函数参数\",{\"0\":{\"470\":1}}],[\"接口用来抽象一系列行为\",{\"1\":{\"464\":1}}],[\"接口赋值示例\",{\"0\":{\"310\":1}}],[\"接口赋值过程\",{\"0\":{\"309\":1}}],[\"接口基础概念\",{\"0\":{\"298\":1}}],[\"接口详解\",{\"0\":{\"275\":1}}],[\"接口定义\",{\"0\":{\"272\":1,\"465\":1}}],[\"接口安全设计\",{\"1\":{\"243\":1}}],[\"接口安全\",{\"1\":{\"243\":1}}],[\"接口\",{\"0\":{\"463\":1},\"1\":{\"123\":1,\"229\":1,\"470\":2,\"550\":1,\"559\":1,\"817\":1,\"962\":1},\"2\":{\"317\":1}}],[\"接口继承\",{\"1\":{\"33\":1}}],[\"接口设计\",{\"2\":{\"25\":1}}],[\"接口类型的方法调用是动态调度\",{\"1\":{\"408\":1}}],[\"接口类型在运行时由interfacetype结构表示\",{\"1\":{\"308\":1}}],[\"接口类型\",{\"0\":{\"472\":1},\"1\":{\"23\":1}}],[\"接口超时重试\",{\"1\":{\"23\":1}}],[\"接口幂等性的验证和实施需要消耗一定的资源\",{\"1\":{\"23\":1}}],[\"接口幂等性的定义\",{\"1\":{\"23\":1}}],[\"接口幂等性的必要性\",{\"1\":{\"23\":1}}],[\"接口幂等性设计\",{\"1\":{\"23\":1}}],[\"接口幂等性指的是某个操作无论执行多少次\",{\"1\":{\"23\":1}}],[\"假设用编码int\",{\"1\":{\"939\":1}}],[\"假设用embstr编码\",{\"1\":{\"939\":1}}],[\"假设a的初始值为2\",{\"1\":{\"930\":1}}],[\"假设节点层高随机到\",{\"1\":{\"885\":1}}],[\"假设这时有两事务\",{\"1\":{\"820\":1}}],[\"假设事务\",{\"1\":{\"820\":3}}],[\"假设执行了这条查询语句\",{\"1\":{\"817\":1}}],[\"假设每个\",{\"1\":{\"810\":1}}],[\"假设此时平台要升级\",{\"1\":{\"780\":1}}],[\"假设增加一个分区\",{\"1\":{\"723\":1}}],[\"假设他们都要传递消息给消息队列\",{\"1\":{\"722\":1}}],[\"假设在时刻b有一个报文丢失并被重传\",{\"1\":{\"237\":1}}],[\"假设\",{\"1\":{\"237\":1,\"810\":1,\"820\":2}}],[\"假设要描述一个人\",{\"1\":{\"229\":1}}],[\"假设一个页的大小是\",{\"1\":{\"217\":1}}],[\"假设为\",{\"1\":{\"123\":1}}],[\"假设某个客户端第一次发起请求\",{\"1\":{\"23\":1}}],[\"假设系统在返回支付结果的时候出现网络异常\",{\"1\":{\"23\":1}}],[\"业界的唯一id生成算法生成\",{\"1\":{\"23\":1}}],[\"业务状态码对应的具体含义\",{\"1\":{\"1030\":1}}],[\"业务状态码\",{\"1\":{\"1030\":1}}],[\"业务数据访问\",{\"1\":{\"962\":1}}],[\"业务逻辑的组装层\",{\"1\":{\"962\":1}}],[\"业务逻辑层防重\",{\"1\":{\"23\":1}}],[\"业务代码更简洁\",{\"1\":{\"930\":1}}],[\"业务代码自己控制提交时机\",{\"1\":{\"711\":1}}],[\"业务本身要幂等可重入\",{\"1\":{\"918\":1,\"921\":1}}],[\"业务b已经拿到了锁\",{\"1\":{\"912\":1,\"921\":1}}],[\"业务只能读数据\",{\"1\":{\"820\":1}}],[\"业务内多分区\",{\"0\":{\"721\":1}}],[\"业务单分区\",{\"0\":{\"720\":1}}],[\"业务收到消息之后因为各种原因没有及时提交偏移\",{\"1\":{\"713\":1}}],[\"业务需要等等因素合理拉取消息\",{\"1\":{\"162\":1}}],[\"业务层防重\",{\"1\":{\"23\":1}}],[\"保护\",{\"1\":{\"820\":1}}],[\"保护对映射数据的并发访问\",{\"1\":{\"516\":1}}],[\"保障事务的原子性\",{\"1\":{\"810\":1}}],[\"保存修改\",{\"1\":{\"997\":1}}],[\"保存一个字符串\",{\"1\":{\"873\":1}}],[\"保存一个\",{\"1\":{\"873\":1}}],[\"保存图片\",{\"1\":{\"873\":1}}],[\"保存未被刷入磁盘的脏页日志\",{\"1\":{\"810\":1}}],[\"保存的是全量的日志\",{\"1\":{\"759\":1,\"810\":1}}],[\"保存文件\",{\"1\":{\"693\":1}}],[\"保存在硬盘里\",{\"1\":{\"249\":1}}],[\"保存在内存中\",{\"1\":{\"249\":1}}],[\"保存在段寄存器里面\",{\"1\":{\"217\":1}}],[\"保留字\",{\"1\":{\"568\":1}}],[\"保留没有重复的字符串\",{\"1\":{\"20\":1}}],[\"保持只读\",{\"1\":{\"180\":1}}],[\"保持完全二叉树特点\",{\"1\":{\"52\":1}}],[\"保持完全二叉树的特点\",{\"1\":{\"52\":1}}],[\"保证日志最终会被输出\",{\"1\":{\"957\":1}}],[\"保证触达的用户不是黄牛\",{\"1\":{\"927\":1}}],[\"保证了事务四大特性中的持久性\",{\"1\":{\"810\":1}}],[\"保证了事务中的持久性\",{\"1\":{\"737\":1}}],[\"保证了事务中的原子性\",{\"1\":{\"737\":1}}],[\"保证持久化\",{\"1\":{\"745\":1,\"810\":1}}],[\"保证事务的持久性\",{\"1\":{\"737\":1,\"810\":1}}],[\"保证事务的原子性和一致性\",{\"1\":{\"737\":1,\"810\":1}}],[\"保证业务的连续性\",{\"1\":{\"730\":1}}],[\"保证消息不丢失\",{\"1\":{\"708\":1}}],[\"保证\",{\"1\":{\"237\":1}}],[\"保证宿主机的网络报文若发往\",{\"1\":{\"123\":1}}],[\"保证宿主机的网络报\",{\"1\":{\"123\":1}}],[\"保证每个id都是唯一的\",{\"1\":{\"92\":1}}],[\"保证原子性\",{\"1\":{\"23\":1}}],[\"则将成本设置为defaultcost\",{\"1\":{\"1058\":1}}],[\"则将sendx置0\",{\"1\":{\"264\":1}}],[\"则攻击者需要针对每个密码为每个组合生成一个列表再去查找\",{\"1\":{\"1052\":1}}],[\"则表示\",{\"1\":{\"957\":1}}],[\"则表明是重复请求\",{\"1\":{\"23\":1}}],[\"则不会改变日志级别\",{\"1\":{\"957\":1}}],[\"则不需要在web\",{\"1\":{\"588\":1,\"627\":1,\"658\":1}}],[\"则不需要采取进一步的操作\",{\"1\":{\"530\":1}}],[\"则可以为任意类型\",{\"1\":{\"957\":1}}],[\"则需要根据\",{\"1\":{\"957\":1}}],[\"则需要将用户名和主机名分别按如下方式引用\",{\"1\":{\"838\":1}}],[\"则触发重写\",{\"1\":{\"952\":1}}],[\"则mysql中\",{\"1\":{\"930\":1}}],[\"则写入操作都会失败\",{\"1\":{\"900\":1}}],[\"则最多往后找\",{\"1\":{\"864\":1}}],[\"则要执行这条命令\",{\"1\":{\"820\":2}}],[\"则执行回表操作\",{\"1\":{\"817\":1}}],[\"则直接跳过该二级索引\",{\"1\":{\"817\":1}}],[\"则提交事务\",{\"1\":{\"810\":1}}],[\"则回滚事务\",{\"1\":{\"810\":1}}],[\"则继续增大\",{\"1\":{\"807\":1}}],[\"则插入记录后就分配了100个字节\",{\"1\":{\"770\":1}}],[\"则在字节的高位补\",{\"1\":{\"770\":1}}],[\"则每个列对应一个二进制位\",{\"1\":{\"770\":1}}],[\"则会产生很多脏数据\",{\"1\":{\"930\":1}}],[\"则会将key设置为value\",{\"1\":{\"910\":1,\"921\":1}}],[\"则会将存储的数据\",{\"1\":{\"770\":1}}],[\"则会额外预留1mb的空间\",{\"1\":{\"873\":1}}],[\"则会额外预留1\",{\"1\":{\"873\":1}}],[\"则会报错\",{\"1\":{\"817\":1}}],[\"则会自动以类型的默认值而赋值\",{\"1\":{\"571\":1}}],[\"则忽略或更新该记录\",{\"1\":{\"714\":1}}],[\"则使用它\",{\"1\":{\"656\":3}}],[\"则按照filter类名的字母顺序\",{\"1\":{\"595\":1}}],[\"则按照filtername的字母顺序\",{\"1\":{\"595\":1}}],[\"则返回\",{\"1\":{\"531\":1}}],[\"则为默认值\",{\"1\":{\"447\":1}}],[\"则为可信赖的证书\",{\"1\":{\"240\":1,\"249\":1}}],[\"则必定放到堆中\",{\"1\":{\"406\":1}}],[\"则优先放到栈中\",{\"1\":{\"406\":1}}],[\"则说明握手时密钥交换算法和签名算法都是使用\",{\"1\":{\"249\":1}}],[\"则解决\",{\"1\":{\"249\":1}}],[\"则它必须重传\",{\"1\":{\"249\":1}}],[\"则是\",{\"1\":{\"249\":1}}],[\"则生成的\",{\"1\":{\"229\":1}}],[\"则指定的最后一个条目优先\",{\"1\":{\"229\":1}}],[\"则后者优先于前者\",{\"1\":{\"229\":1}}],[\"则输出的生成文件会保存在example\",{\"1\":{\"229\":1}}],[\"则默认是proto2\",{\"1\":{\"229\":1}}],[\"则阻塞进程\",{\"1\":{\"226\":1}}],[\"则通过\",{\"1\":{\"217\":2}}],[\"则leader将其从isr中移除\",{\"1\":{\"182\":1}}],[\"则立即会被\",{\"1\":{\"123\":1}}],[\"则这部分转换开销就相对较大了\",{\"1\":{\"36\":1}}],[\"则存在\",{\"1\":{\"20\":1}}],[\"然后通过\",{\"1\":{\"957\":1}}],[\"然后通过分布式存储系统快速检索\",{\"1\":{\"80\":1}}],[\"然后重建缓存\",{\"1\":{\"930\":2}}],[\"然后异步把数据一起写入数据库\",{\"1\":{\"930\":1}}],[\"然后写缓存\",{\"1\":{\"930\":1}}],[\"然后直接删除缓存\",{\"1\":{\"930\":1}}],[\"然后直到事务结束才会释放锁\",{\"1\":{\"820\":1}}],[\"然后淘汰最久未访问的\",{\"1\":{\"906\":1}}],[\"然后构造一个新节点\",{\"1\":{\"885\":1}}],[\"然后构建语法树\",{\"1\":{\"817\":1}}],[\"然后看事务\",{\"1\":{\"820\":1}}],[\"然后锁超时\",{\"1\":{\"918\":1,\"921\":1}}],[\"然后锁的状态设置为等待状态\",{\"1\":{\"820\":2}}],[\"然后锁范围的最左值是\",{\"1\":{\"820\":1}}],[\"然后锁范围的\",{\"1\":{\"820\":1}}],[\"然后会退化为间隙锁\",{\"1\":{\"820\":1}}],[\"然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞\",{\"1\":{\"820\":1}}],[\"然后如果遇到下面这些情况\",{\"1\":{\"820\":1}}],[\"然后设置锁的状态\",{\"1\":{\"820\":3}}],[\"然后创建了一个相同结构的表\",{\"1\":{\"820\":1}}],[\"然后给该字段赋值一个自增的值\",{\"1\":{\"820\":1}}],[\"然后为被\",{\"1\":{\"820\":1}}],[\"然后整个事务执行期间都在用这个\",{\"1\":{\"820\":1}}],[\"然后整个事务期间都在用这个\",{\"1\":{\"743\":1,\"784\":1,\"791\":1,\"810\":1}}],[\"然后向存储引擎索要下一条记录\",{\"1\":{\"817\":1}}],[\"然后向执行器\",{\"1\":{\"817\":1}}],[\"然后回表操作\",{\"1\":{\"817\":1}}],[\"然后回放\",{\"1\":{\"810\":1}}],[\"然后查询结束\",{\"1\":{\"817\":1}}],[\"然后后面的权限逻辑判断都基于此时读取到的权限\",{\"1\":{\"817\":1}}],[\"然后保存起来\",{\"1\":{\"817\":1}}],[\"然后保存表结构和表数据的文件都会存放在这个目录里\",{\"1\":{\"770\":1}}],[\"然后过滤出符合条件的数据后再返回给\",{\"1\":{\"813\":1}}],[\"然后依次从从左到右的顺序匹配\",{\"1\":{\"813\":1}}],[\"然后把这\",{\"1\":{\"813\":1}}],[\"然后把这条\",{\"1\":{\"748\":1}}],[\"然后根据对应的字段进行\",{\"1\":{\"813\":1}}],[\"然后根据自己的加密密钥来生成signature\",{\"1\":{\"249\":1}}],[\"然后利用链表向右遍历\",{\"1\":{\"813\":1}}],[\"然后交由操作系统控制持久化到磁盘的时机\",{\"1\":{\"810\":1}}],[\"然后开始记录该语句对应的\",{\"1\":{\"810\":2}}],[\"然后标记\",{\"1\":{\"810\":2}}],[\"然后等事务提交的时候\",{\"1\":{\"810\":1}}],[\"然后才写到磁盘\",{\"1\":{\"810\":1}}],[\"然后进行查找\",{\"1\":{\"1052\":1}}],[\"然后进行回表操作\",{\"1\":{\"817\":1}}],[\"然后进行\",{\"1\":{\"810\":1}}],[\"然后执行一条\",{\"1\":{\"820\":1}}],[\"然后执行计划中的\",{\"1\":{\"817\":1}}],[\"然后执行\",{\"1\":{\"810\":1}}],[\"然后执行回滚操作的时候\",{\"1\":{\"810\":1}}],[\"然后执行业务逻辑\",{\"1\":{\"23\":1}}],[\"然后做原先相反操作\",{\"1\":{\"810\":1}}],[\"然后更新\",{\"1\":{\"810\":1}}],[\"然后由不同的业务连接不同的数据库\",{\"1\":{\"807\":1}}],[\"然后事务a改完原本的最后一条数据后\",{\"1\":{\"780\":1}}],[\"然后真实数据处用\",{\"1\":{\"770\":1}}],[\"然后这个隐藏列是个指针\",{\"1\":{\"770\":1}}],[\"然后拳击手听到后做出应答\",{\"1\":{\"764\":1,\"810\":1}}],[\"然后马上执行\",{\"1\":{\"760\":1,\"810\":1}}],[\"然后在加1变成了6\",{\"1\":{\"930\":1}}],[\"然后在进行比较\",{\"1\":{\"813\":1}}],[\"然后在合适的时间再将修改的行数据写到磁盘上\",{\"1\":{\"810\":2}}],[\"然后在合适的时间再将新的记录写到磁盘上\",{\"1\":{\"751\":1}}],[\"然后在合适的时间再更新到磁盘上\",{\"1\":{\"810\":1}}],[\"然后在合适的时间再写到磁盘上\",{\"1\":{\"810\":1}}],[\"然后在适当时机批量写入磁盘\",{\"1\":{\"754\":1}}],[\"然后在\",{\"1\":{\"753\":1,\"813\":1}}],[\"然后在内存中修改这条记录\",{\"1\":{\"747\":1,\"810\":1}}],[\"然后按照默认的\",{\"1\":{\"748\":1,\"810\":1}}],[\"然后销毁servletrequest\",{\"1\":{\"631\":1}}],[\"然后销毁servletcontext\",{\"1\":{\"629\":1}}],[\"然后销毁httpsession\",{\"1\":{\"630\":1}}],[\"然后到达目标资源\",{\"1\":{\"594\":1}}],[\"然后可能将其转换回原来的类型或不同的类型\",{\"1\":{\"460\":1}}],[\"然后被调度执行\",{\"1\":{\"373\":1}}],[\"然后存储了8个键值对\",{\"1\":{\"330\":1}}],[\"然后发给\",{\"1\":{\"249\":1}}],[\"然后对于这条记录加上了\",{\"1\":{\"820\":1}}],[\"然后对读取的记录加独占锁\",{\"1\":{\"820\":1}}],[\"然后对读取的记录加共享锁\",{\"1\":{\"820\":1}}],[\"然后对该记录加独占锁\",{\"1\":{\"820\":1}}],[\"然后对外提供服务\",{\"1\":{\"730\":1}}],[\"然后对这些信息进行\",{\"1\":{\"240\":1,\"249\":1}}],[\"然后对机器个数取模\",{\"1\":{\"81\":1}}],[\"然后使用这个连接传输一个\",{\"1\":{\"237\":1}}],[\"然后再调用其\",{\"1\":{\"957\":1}}],[\"然后再调用配置对象的\",{\"1\":{\"957\":1}}],[\"然后再做表结构的变更\",{\"1\":{\"820\":1}}],[\"然后再一起刷盘\",{\"1\":{\"810\":1}}],[\"然后再次查询\",{\"1\":{\"793\":1}}],[\"然后再次发起请求重试\",{\"1\":{\"23\":1}}],[\"然后再在\",{\"1\":{\"374\":1}}],[\"然后再对其处理\",{\"1\":{\"226\":1}}],[\"然后用户态还需要再通过遍历的方法找到可读或可写的\",{\"1\":{\"226\":1}}],[\"然后调用所有servletrequestlistener的requestinitialized\",{\"1\":{\"631\":1}}],[\"然后调用所有servletcontextlistener的contextinitialized\",{\"1\":{\"629\":1}}],[\"然后调用所有httpsessionlistener的sessioncreated\",{\"1\":{\"630\":1}}],[\"然后调用\",{\"1\":{\"226\":1,\"810\":1}}],[\"然后应用程序就可以遍历这个集合\",{\"1\":{\"226\":1}}],[\"然后从这个\",{\"1\":{\"217\":1}}],[\"然后\",{\"1\":{\"196\":1,\"229\":1,\"240\":1,\"249\":1,\"518\":1,\"751\":1,\"770\":1,\"810\":1,\"820\":5}}],[\"然后启动容器的真正进程\",{\"1\":{\"104\":1}}],[\"然后停止\",{\"1\":{\"104\":1}}],[\"然后将锁的状态设置为等待状态\",{\"1\":{\"820\":1}}],[\"然后将记录返回给\",{\"1\":{\"817\":1}}],[\"然后将记录写到\",{\"1\":{\"810\":2}}],[\"然后将本次对这个页的修改以\",{\"1\":{\"810\":1}}],[\"然后将\",{\"1\":{\"765\":2,\"810\":3}}],[\"然后将其页设置为脏页\",{\"1\":{\"747\":1,\"810\":1}}],[\"然后将客户端的请求转化为\",{\"1\":{\"102\":1}}],[\"然后将这两个结果集进行了合并\",{\"1\":{\"813\":1}}],[\"然后将这\",{\"1\":{\"75\":1}}],[\"然后是机器id\",{\"1\":{\"92\":1}}],[\"然后各自在本机上对读取到的关键词进行哈希函数运算\",{\"1\":{\"79\":1}}],[\"然后采用多台机器处理\",{\"1\":{\"79\":1}}],[\"然后第二次请求由于某些原因过了一会儿才到达服务端\",{\"1\":{\"23\":1}}],[\"然后服务端收到后将token从redis中删除\",{\"1\":{\"23\":1}}],[\"然后正常执行后续的业务逻辑\",{\"1\":{\"23\":1}}],[\"然后一直点提交按钮\",{\"1\":{\"23\":1}}],[\"并简单介绍了如何使用\",{\"1\":{\"957\":1}}],[\"并简化调用\",{\"1\":{\"229\":1}}],[\"并记录\",{\"1\":{\"957\":1}}],[\"并放到缓存中\",{\"1\":{\"930\":1}}],[\"并返回1\",{\"1\":{\"910\":1,\"921\":1}}],[\"并返回指针指向堆上这块hchan内存区域\",{\"1\":{\"258\":1}}],[\"并保证后续其它竞争者也能加锁\",{\"1\":{\"909\":1,\"921\":1}}],[\"并初始化一个\",{\"1\":{\"897\":1}}],[\"并做了很多优化\",{\"1\":{\"888\":1}}],[\"并集的功能\",{\"1\":{\"870\":1}}],[\"并未提交\",{\"1\":{\"820\":1}}],[\"并报错提示\",{\"1\":{\"817\":1}}],[\"并调用它手动更新全文索引中的数据\",{\"1\":{\"813\":1}}],[\"并调用其init\",{\"1\":{\"590\":1}}],[\"并根据binlog中的信息确定是否提交或回滚事务\",{\"1\":{\"810\":1}}],[\"并清空\",{\"1\":{\"810\":1}}],[\"并清空binlog\",{\"1\":{\"760\":1}}],[\"并更新偏移索引\",{\"1\":{\"864\":1}}],[\"并更新存储引擎中的数据\",{\"1\":{\"810\":1}}],[\"并更新本地存储数据\",{\"1\":{\"810\":1}}],[\"并行事务引发的问题\",{\"0\":{\"776\":1}}],[\"并行的请求能在同一个链接中处理\",{\"1\":{\"249\":1}}],[\"并插入2条记录\",{\"1\":{\"770\":1}}],[\"并提交了事务\",{\"1\":{\"743\":1,\"810\":1}}],[\"并选择其中的最优计划\",{\"1\":{\"734\":1}}],[\"并结合实际场景分析其性能特点和最佳实践\",{\"1\":{\"494\":1}}],[\"并添加omitemptytag\",{\"1\":{\"490\":1}}],[\"并发多个事务的时候\",{\"1\":{\"820\":1}}],[\"并发访问的多个版本通过快照控制\",{\"1\":{\"743\":1}}],[\"并发处理\",{\"1\":{\"706\":1}}],[\"并发冲突\",{\"1\":{\"520\":1}}],[\"并发调用\",{\"1\":{\"511\":1}}],[\"并发读操作\",{\"1\":{\"510\":1,\"511\":1}}],[\"并发写操作\",{\"1\":{\"510\":1,\"511\":1}}],[\"并发模型\",{\"2\":{\"386\":1}}],[\"并发控制\",{\"2\":{\"285\":1,\"822\":1,\"920\":1,\"923\":1}}],[\"并发\",{\"2\":{\"268\":1,\"385\":1}}],[\"并发编程\",{\"2\":{\"267\":1,\"284\":1}}],[\"并为每个流独立实现数据包丢失检测和重传\",{\"1\":{\"249\":1}}],[\"并允许客户端和服务器之间约定以最合适的内容进行交换\",{\"1\":{\"249\":1}}],[\"并具有相同的响应\",{\"1\":{\"249\":1}}],[\"并相应调整行为\",{\"1\":{\"249\":1}}],[\"并与客户端的sign进行一致性验证\",{\"1\":{\"249\":1}}],[\"并通过宿主机的网络连接访问外部网络\",{\"1\":{\"246\":1}}],[\"并通知应用程序\",{\"1\":{\"226\":1}}],[\"并指定example\",{\"1\":{\"229\":1}}],[\"并指定topic名称\",{\"1\":{\"177\":1}}],[\"并执行相应的程序以响应命令\",{\"1\":{\"190\":1}}],[\"并尽量减少在再平衡过程中的分区移动\",{\"1\":{\"165\":1}}],[\"并退出\",{\"1\":{\"141\":1}}],[\"并被改名为\",{\"1\":{\"123\":1}}],[\"并将角色赋予这些用户即可\",{\"1\":{\"850\":1}}],[\"并将\",{\"1\":{\"530\":1}}],[\"并将通过特殊算法算出一个session的id\",{\"1\":{\"249\":1}}],[\"并将输出文件\",{\"1\":{\"229\":1}}],[\"并将数据同步到本地的副本中\",{\"1\":{\"170\":1}}],[\"并将容器连接到一个\",{\"1\":{\"122\":1}}],[\"并将引用计数计为1\",{\"1\":{\"33\":1}}],[\"并没有成功获取到插入意向锁\",{\"1\":{\"820\":1}}],[\"并没有退化为间隙锁\",{\"1\":{\"820\":1}}],[\"并没有刷新到硬盘上的\",{\"1\":{\"810\":2}}],[\"并没有传统面向对象语言中的继承概念\",{\"1\":{\"461\":1}}],[\"并没有对其进行任何网络设置\",{\"1\":{\"122\":1}}],[\"并没有新开辟一个地址\",{\"1\":{\"33\":1}}],[\"并加载一个\",{\"1\":{\"110\":1}}],[\"并编译程序段\",{\"1\":{\"36\":1}}],[\"并在适当的时机\",{\"1\":{\"753\":1}}],[\"并在内存中进行修改\",{\"1\":{\"753\":1}}],[\"并在应用层实现可靠机制\",{\"1\":{\"240\":1}}],[\"并在过程中产生临时对象\",{\"1\":{\"33\":1}}],[\"并在请求时将该全局id与其他数据一同发送\",{\"1\":{\"23\":1}}],[\"并不存在互斥关系\",{\"1\":{\"820\":1}}],[\"并不需要等语句执行后才释放\",{\"1\":{\"820\":1}}],[\"并不冲突\",{\"1\":{\"820\":1}}],[\"并不意味着写入到了磁盘\",{\"1\":{\"810\":2}}],[\"并不能完全避免幻读现象\",{\"1\":{\"793\":1}}],[\"并不代表事务启动了\",{\"1\":{\"785\":1}}],[\"并不会加锁\",{\"1\":{\"820\":1}}],[\"并不会马上执行刷盘的操作\",{\"1\":{\"810\":1}}],[\"并不会真正的删除记录\",{\"1\":{\"770\":1}}],[\"并不会深入到实际数据\",{\"1\":{\"441\":1}}],[\"并不会对当前系统资源进行改变\",{\"1\":{\"23\":1}}],[\"并不具有实际传输数据的功能\",{\"1\":{\"249\":1}}],[\"并不是和上图一样绝对均衡的\",{\"1\":{\"885\":1}}],[\"并不是一个真实的记录\",{\"1\":{\"820\":1}}],[\"并不是一条语句执行完就释放行锁\",{\"1\":{\"820\":1}}],[\"并不是意味着事务成功获取到了锁\",{\"1\":{\"820\":3}}],[\"并不是在解析器里做的\",{\"1\":{\"817\":1}}],[\"并不是\",{\"1\":{\"817\":1}}],[\"并不是完全解决了\",{\"1\":{\"783\":1}}],[\"并不是字节大小\",{\"1\":{\"770\":1}}],[\"并不是将这个行记录从磁盘读出来\",{\"1\":{\"770\":1}}],[\"并不是指\",{\"1\":{\"249\":1}}],[\"并不是真实存在的网络设备\",{\"1\":{\"121\":1}}],[\"并不是函数\",{\"1\":{\"33\":1}}],[\"并且结构体中的条件都是and关系\",{\"1\":{\"1002\":1}}],[\"并且使用\",{\"1\":{\"956\":1}}],[\"并且使用了时间戳选项\",{\"1\":{\"237\":1}}],[\"并且出于容错考虑\",{\"1\":{\"930\":1}}],[\"并且还可以找到上一节点的起始位置的办法\",{\"1\":{\"879\":1}}],[\"并且自己设定了一个限制\",{\"1\":{\"879\":1}}],[\"并且字段\",{\"1\":{\"873\":1}}],[\"并且已经存在\",{\"1\":{\"820\":2}}],[\"并且锁定记录本身\",{\"1\":{\"820\":2}}],[\"并且key字段是null\",{\"1\":{\"807\":1}}],[\"并且查询非常快\",{\"1\":{\"807\":1}}],[\"并且提交了事务\",{\"1\":{\"793\":1}}],[\"并且记录对于的\",{\"1\":{\"753\":1}}],[\"并且支持原子性的读写操作\",{\"1\":{\"516\":1,\"522\":1}}],[\"并且会权衡整体操作性能的并发安全\",{\"1\":{\"512\":1}}],[\"并且不超过\",{\"1\":{\"897\":1}}],[\"并且不携带任何堆栈信息\",{\"1\":{\"472\":1}}],[\"并且不需要阻塞或轮询\",{\"1\":{\"226\":1}}],[\"并且可以根据需要实现不同的接口\",{\"1\":{\"466\":1}}],[\"并且可以直接与物理网络中的其他设备通信\",{\"1\":{\"246\":1}}],[\"并且将内部结构体实例作为方法的接收者\",{\"1\":{\"462\":1}}],[\"并且这些字段会被初始化为内部结构体的实例\",{\"1\":{\"462\":1}}],[\"并且这几\",{\"1\":{\"378\":1}}],[\"并且恢复默认记数\",{\"1\":{\"442\":1}}],[\"并且\",{\"1\":{\"381\":1,\"529\":2,\"820\":1,\"841\":1,\"873\":1,\"888\":1,\"957\":1}}],[\"并且没有元素的场景直接就可以返回了\",{\"1\":{\"265\":1}}],[\"并且channel的缓冲区满了之后\",{\"1\":{\"264\":1}}],[\"并且完全有服务端掌控\",{\"1\":{\"249\":1}}],[\"并且比json更快\",{\"1\":{\"229\":1}}],[\"并且与\",{\"1\":{\"181\":1}}],[\"并且容器中的进程属于运行状态\",{\"1\":{\"98\":1}}],[\"并且id的生成是有序的\",{\"1\":{\"92\":1}}],[\"并且具有一定的有序性\",{\"1\":{\"92\":1}}],[\"并且返回值是int类型的\",{\"1\":{\"33\":1}}],[\"并且执行业务逻辑\",{\"1\":{\"23\":1}}],[\"调下载接口的请求\",{\"1\":{\"1032\":1}}],[\"调高性能\",{\"1\":{\"885\":1}}],[\"调优\",{\"2\":{\"809\":1}}],[\"调优的五个维度\",{\"1\":{\"807\":1}}],[\"调整空闲线程的存活时间\",{\"1\":{\"807\":1}}],[\"调整临时表空间\",{\"1\":{\"807\":1}}],[\"调整工作线程的缓冲区\",{\"1\":{\"807\":1}}],[\"调整\",{\"1\":{\"807\":1}}],[\"调整参数的默认值\",{\"1\":{\"807\":1}}],[\"调整客户端db连接池的参数和db连接层的参数\",{\"1\":{\"807\":1}}],[\"调整完之后对\",{\"1\":{\"23\":1}}],[\"调度器的功能是把可运行的\",{\"1\":{\"384\":1}}],[\"调度\",{\"1\":{\"378\":1,\"381\":1}}],[\"调度过程不仅仅只处理用户定义的协程\",{\"1\":{\"374\":1}}],[\"调度后\",{\"1\":{\"374\":1}}],[\"调度又会发生很多不同\",{\"1\":{\"374\":1}}],[\"调用完create之后\",{\"1\":{\"985\":1}}],[\"调用时实际为\",{\"1\":{\"864\":1}}],[\"调用引擎的提交事务接口\",{\"1\":{\"810\":1}}],[\"调用doget或dopost等方法\",{\"1\":{\"662\":1}}],[\"调用init\",{\"1\":{\"661\":1}}],[\"调用代理方法\",{\"1\":{\"559\":1}}],[\"调用处理器\",{\"1\":{\"559\":1}}],[\"调用方法\",{\"1\":{\"558\":1}}],[\"调用方在调用接口之前会首先向后端请求一个全局id\",{\"1\":{\"23\":1}}],[\"调用任意方法\",{\"1\":{\"551\":1}}],[\"调用其\",{\"1\":{\"529\":1}}],[\"调用链\",{\"1\":{\"479\":1}}],[\"调用栈\",{\"1\":{\"473\":1}}],[\"调用\",{\"1\":{\"425\":1,\"810\":2,\"888\":1,\"897\":1}}],[\"调用接口类型的方法\",{\"1\":{\"408\":1}}],[\"调用gopark方法挂起当前goroutine\",{\"1\":{\"264\":1}}],[\"调用编译器时\",{\"1\":{\"229\":1}}],[\"调用epoll\",{\"1\":{\"226\":1}}],[\"调用析构函数\",{\"1\":{\"33\":1}}],[\"调用构造函数\",{\"1\":{\"33\":1}}],[\"调用ob1的函数返回了一个结构体类型的变量\",{\"1\":{\"30\":1}}],[\"调试器\",{\"1\":{\"565\":1},\"2\":{\"28\":1}}],[\"ws加请求头\",{\"1\":{\"1037\":1}}],[\"w\",{\"1\":{\"957\":1,\"1059\":5}}],[\"w3\",{\"1\":{\"658\":1}}],[\"wronly\",{\"1\":{\"957\":2}}],[\"wrapcore\",{\"1\":{\"957\":1}}],[\"wrapper\",{\"1\":{\"609\":1}}],[\"writing\",{\"1\":{\"471\":2}}],[\"writefile\",{\"1\":{\"1037\":1}}],[\"writesyncer\",{\"1\":{\"957\":1}}],[\"writestring\",{\"1\":{\"505\":3}}],[\"writebyte\",{\"1\":{\"505\":1}}],[\"writer\",{\"1\":{\"471\":2,\"677\":2}}],[\"write\",{\"1\":{\"226\":5,\"471\":3,\"510\":1,\"693\":1,\"751\":1,\"760\":4,\"765\":1,\"810\":16,\"820\":2,\"930\":13,\"952\":1,\"1021\":1}}],[\"warnlevel\",{\"1\":{\"957\":2}}],[\"warn\",{\"1\":{\"956\":1,\"957\":15}}],[\"warnings\",{\"1\":{\"770\":1}}],[\"warning\",{\"1\":{\"600\":1}}],[\"watched\",{\"1\":{\"944\":1}}],[\"wal\",{\"1\":{\"751\":2,\"752\":1,\"810\":6}}],[\"waitgroup\",{\"1\":{\"367\":1,\"515\":1}}],[\"waitreasonchanreceive\",{\"1\":{\"265\":1}}],[\"waiter\",{\"1\":{\"265\":1}}],[\"waiting\",{\"1\":{\"265\":4,\"820\":1}}],[\"waitlink\",{\"1\":{\"265\":1}}],[\"waitq结构\",{\"0\":{\"260\":1}}],[\"waitq是一个对sudog链表进行封装之后的一个结构\",{\"1\":{\"259\":1}}],[\"wait过多\",{\"1\":{\"237\":1}}],[\"wait的连接\",{\"1\":{\"237\":1}}],[\"wait也不会再次返回这个事件\",{\"1\":{\"226\":1}}],[\"wait都会返回这个事件\",{\"1\":{\"226\":1}}],[\"wait时才会返回这个事件\",{\"1\":{\"226\":1}}],[\"wait时\",{\"1\":{\"226\":1}}],[\"wait返回给用户的满足条件的事件\",{\"1\":{\"226\":1}}],[\"wait检查是否有事件发生时\",{\"1\":{\"226\":1}}],[\"wait会调用put\",{\"1\":{\"226\":1}}],[\"wait\",{\"1\":{\"226\":6,\"237\":12,\"367\":1,\"515\":1,\"817\":3,\"820\":1}}],[\"wg\",{\"1\":{\"367\":4,\"515\":10}}],[\"www\",{\"1\":{\"249\":1,\"658\":1,\"1041\":1}}],[\"world\",{\"0\":{\"1024\":1},\"1\":{\"497\":1,\"499\":4,\"500\":2,\"505\":1,\"652\":1,\"677\":1,\"1024\":1}}],[\"word\",{\"1\":{\"223\":1}}],[\"work\",{\"1\":{\"201\":1}}],[\"workdir\",{\"1\":{\"104\":1}}],[\"workbench\",{\"1\":{\"3\":1}}],[\"wq\",{\"1\":{\"214\":1}}],[\"weight\",{\"1\":{\"483\":4,\"485\":1,\"486\":1}}],[\"wed\",{\"1\":{\"249\":2}}],[\"wepapp\",{\"1\":{\"110\":1,\"113\":1}}],[\"webframework\",{\"0\":{\"1086\":1}}],[\"webfilter注解时\",{\"1\":{\"595\":1}}],[\"webfilter注解\",{\"1\":{\"588\":1}}],[\"webfilter注解配置\",{\"0\":{\"586\":1}}],[\"webfilter注解或web\",{\"1\":{\"585\":1}}],[\"webfilter\",{\"1\":{\"584\":2,\"586\":3,\"587\":4,\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"683\":1}}],[\"web服务器接收请求并将其转发给servlet容器\",{\"1\":{\"661\":1}}],[\"web服务端通常会有个参数来定义\",{\"1\":{\"237\":1}}],[\"webservlet注解\",{\"1\":{\"658\":1}}],[\"webservlet注解提供了多种配置urlpattern的方式\",{\"1\":{\"654\":1}}],[\"webservlet注解配置\",{\"0\":{\"654\":1}}],[\"webservlet\",{\"1\":{\"652\":2,\"654\":3,\"655\":4,\"693\":1}}],[\"website\",{\"1\":{\"489\":1}}],[\"web框架\",{\"1\":{\"644\":1},\"2\":{\"1044\":1}}],[\"web应用的核心组件\",{\"1\":{\"646\":1}}],[\"web应用关闭中\",{\"1\":{\"624\":1}}],[\"web应用启动中\",{\"1\":{\"624\":1}}],[\"weblistener注解\",{\"1\":{\"627\":1,\"637\":1}}],[\"weblistener\",{\"1\":{\"624\":2,\"625\":2,\"626\":2,\"633\":2,\"634\":2,\"635\":2,\"640\":1,\"641\":1,\"684\":1}}],[\"web开发通常使用更高级的框架\",{\"1\":{\"644\":1}}],[\"web开发的基础\",{\"1\":{\"644\":2}}],[\"web开发\",{\"2\":{\"611\":1,\"643\":1,\"695\":1,\"1045\":1}}],[\"web开发中的监听器技术\",{\"1\":{\"612\":1}}],[\"web开发中的重要组件\",{\"1\":{\"576\":1,\"612\":1}}],[\"web开发中的过滤器技术\",{\"1\":{\"576\":1}}],[\"webinitparam\",{\"1\":{\"586\":1}}],[\"webapp\",{\"1\":{\"110\":3,\"113\":6}}],[\"web\",{\"0\":{\"1021\":1},\"1\":{\"110\":2,\"113\":1,\"114\":1,\"223\":1,\"249\":1,\"588\":1,\"607\":1,\"627\":1,\"658\":3}}],[\"weak\",{\"1\":{\"33\":5}}],[\"width\",{\"1\":{\"470\":3}}],[\"wi\",{\"1\":{\"249\":1}}],[\"wire等等\",{\"1\":{\"965\":1}}],[\"wire\",{\"1\":{\"229\":1,\"962\":2}}],[\"windows系统\",{\"0\":{\"836\":1}}],[\"windows\",{\"1\":{\"223\":1,\"249\":2,\"836\":1}}],[\"window\",{\"1\":{\"88\":5,\"217\":1,\"770\":1,\"817\":1}}],[\"withclock\",{\"1\":{\"957\":1}}],[\"withcaller\",{\"1\":{\"957\":2}}],[\"withfatalhook\",{\"1\":{\"957\":1}}],[\"withoptions\",{\"1\":{\"957\":3}}],[\"with\",{\"0\":{\"541\":1},\"1\":{\"33\":2,\"249\":2,\"785\":2,\"820\":1}}],[\"which\",{\"1\":{\"211\":2}}],[\"while\",{\"1\":{\"33\":1,\"226\":5,\"541\":1,\"542\":1,\"817\":2,\"829\":1}}],[\"whoami\",{\"1\":{\"207\":1}}],[\"where条件查询\",{\"0\":{\"1001\":1}}],[\"where\",{\"1\":{\"23\":1,\"735\":1,\"763\":1,\"794\":2,\"807\":3,\"810\":5,\"813\":27,\"817\":5,\"820\":8,\"823\":1,\"840\":1,\"990\":1,\"1001\":6,\"1002\":1,\"1003\":2,\"1012\":2}}],[\"uber\",{\"0\":{\"955\":1},\"1\":{\"955\":1,\"957\":6}}],[\"u$user\",{\"1\":{\"817\":1}}],[\"uuid\",{\"1\":{\"810\":1,\"813\":4,\"983\":3}}],[\"upgrade\",{\"1\":{\"968\":1,\"970\":1}}],[\"uploads\",{\"1\":{\"693\":1,\"1037\":2}}],[\"upload\",{\"1\":{\"693\":1}}],[\"update语法\",{\"1\":{\"841\":1}}],[\"update等语句\",{\"1\":{\"820\":1}}],[\"update\",{\"0\":{\"735\":1},\"1\":{\"23\":1,\"249\":1,\"714\":1,\"735\":3,\"739\":1,\"741\":1,\"748\":1,\"763\":1,\"783\":2,\"794\":1,\"795\":1,\"810\":12,\"820\":16,\"829\":1,\"840\":1,\"841\":1,\"846\":1,\"998\":2,\"1014\":2,\"1015\":2}}],[\"utc\",{\"1\":{\"957\":2}}],[\"utilities\",{\"1\":{\"817\":1}}],[\"util\",{\"1\":{\"625\":1,\"652\":1}}],[\"utf8mb4\",{\"1\":{\"770\":1}}],[\"utf\",{\"1\":{\"599\":1,\"687\":2,\"688\":1,\"770\":2}}],[\"u1\",{\"1\":{\"487\":2,\"489\":2,\"490\":3}}],[\"urn\",{\"1\":{\"249\":2}}],[\"uri\",{\"1\":{\"249\":10,\"672\":1}}],[\"urlencoded或multipart\",{\"1\":{\"1041\":1}}],[\"urls\",{\"1\":{\"957\":2}}],[\"url变化\",{\"1\":{\"682\":1}}],[\"url模式必须以\",{\"1\":{\"657\":1}}],[\"url模式配置错误\",{\"1\":{\"607\":1}}],[\"url模式匹配规则\",{\"0\":{\"587\":1,\"655\":1}}],[\"urlpattern是servlet映射的核心配置\",{\"1\":{\"653\":1}}],[\"urlpatterns\",{\"1\":{\"586\":2,\"596\":2,\"654\":2}}],[\"urlpattern配置详解\",{\"0\":{\"585\":1,\"653\":1}}],[\"url还有\",{\"1\":{\"249\":1}}],[\"url\",{\"1\":{\"229\":2,\"249\":4,\"588\":1,\"658\":1,\"672\":1,\"957\":25,\"1021\":1}}],[\"u\",{\"1\":{\"214\":1,\"223\":5,\"836\":1,\"840\":1}}],[\"unlink\",{\"1\":{\"867\":1}}],[\"unlock\",{\"1\":{\"265\":4,\"529\":1,\"531\":1,\"532\":1,\"820\":2,\"844\":1}}],[\"undo+rview\",{\"1\":{\"810\":1}}],[\"undo页\",{\"1\":{\"748\":1}}],[\"undo\",{\"1\":{\"745\":3,\"748\":1,\"753\":3,\"770\":2,\"775\":1,\"788\":1,\"802\":1,\"810\":60,\"927\":1},\"2\":{\"769\":1,\"812\":1}}],[\"undolog日志文件\",{\"1\":{\"740\":1}}],[\"undolog\",{\"0\":{\"738\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"743\":1,\"745\":1,\"753\":1},\"1\":{\"735\":1,\"737\":2,\"739\":1,\"740\":1,\"741\":1,\"742\":2,\"743\":2,\"745\":1,\"748\":3,\"753\":6}}],[\"unmodifiableset\",{\"1\":{\"641\":1}}],[\"unmarsha\",{\"1\":{\"491\":1}}],[\"unmarshal\",{\"0\":{\"483\":1},\"1\":{\"483\":2,\"491\":1,\"957\":1}}],[\"uncommitted\",{\"1\":{\"782\":1}}],[\"unchecked\",{\"1\":{\"538\":1}}],[\"unclean\",{\"1\":{\"181\":2,\"183\":1}}],[\"unexpungelocked\",{\"1\":{\"531\":1}}],[\"unsafeservlet\",{\"1\":{\"689\":1}}],[\"unsafe\",{\"0\":{\"460\":1},\"1\":{\"265\":1,\"441\":3,\"460\":5}}],[\"unsigned\",{\"1\":{\"226\":1,\"770\":2,\"940\":3,\"944\":1}}],[\"unkown\",{\"1\":{\"229\":1}}],[\"un\",{\"1\":{\"226\":2}}],[\"unicode\",{\"2\":{\"365\":1}}],[\"uniform\",{\"1\":{\"249\":3}}],[\"universal\",{\"1\":{\"223\":1}}],[\"unix\",{\"1\":{\"190\":3,\"906\":2,\"957\":2}}],[\"unique\",{\"1\":{\"33\":3,\"826\":3,\"983\":3}}],[\"ult\",{\"1\":{\"121\":1}}],[\"ulimit\",{\"1\":{\"33\":1}}],[\"udp运行多个流\",{\"1\":{\"249\":1}}],[\"udp协议解决tcp的对头阻塞问题\",{\"1\":{\"240\":1}}],[\"udp可以使用同一个端口\",{\"1\":{\"237\":1}}],[\"udp\",{\"1\":{\"117\":3,\"243\":1,\"249\":2},\"2\":{\"239\":1}}],[\"ufs\",{\"1\":{\"106\":1}}],[\"used\",{\"1\":{\"864\":6}}],[\"use\",{\"1\":{\"468\":1,\"949\":1}}],[\"userid\",{\"1\":{\"1036\":2}}],[\"userinfo\",{\"1\":{\"817\":1}}],[\"users\",{\"1\":{\"1001\":13,\"1002\":2,\"1003\":2,\"1004\":2,\"1005\":2,\"1007\":3,\"1012\":3,\"1036\":3,\"1037\":1}}],[\"userserviceimpl\",{\"1\":{\"559\":2}}],[\"userservice\",{\"1\":{\"546\":1,\"559\":9}}],[\"user=root\",{\"1\":{\"855\":1}}],[\"user=<username>\",{\"1\":{\"854\":1}}],[\"user语法\",{\"1\":{\"841\":1}}],[\"user表中的email索引\",{\"1\":{\"826\":1}}],[\"useragent字段对应请求头中的\",{\"1\":{\"1043\":1}}],[\"useragent\",{\"1\":{\"671\":1,\"1043\":1}}],[\"useradd\",{\"1\":{\"207\":2,\"208\":1}}],[\"user函数\",{\"1\":{\"226\":1}}],[\"usermod\",{\"1\":{\"208\":1}}],[\"userdel\",{\"1\":{\"207\":2}}],[\"user3\",{\"1\":{\"190\":2}}],[\"user2\",{\"1\":{\"190\":2,\"847\":1}}],[\"user1\",{\"1\":{\"190\":2,\"847\":1}}],[\"user\",{\"1\":{\"190\":1,\"211\":1,\"223\":2,\"249\":4,\"487\":2,\"488\":1,\"489\":5,\"490\":4,\"546\":3,\"559\":4,\"598\":1,\"637\":6,\"655\":5,\"656\":4,\"671\":1,\"723\":2,\"735\":1,\"763\":2,\"770\":4,\"810\":4,\"813\":4,\"817\":1,\"820\":2,\"826\":10,\"838\":3,\"839\":1,\"840\":5,\"841\":1,\"842\":5,\"843\":4,\"844\":1,\"846\":2,\"848\":1,\"873\":5,\"1013\":2,\"1014\":1,\"1015\":1,\"1039\":7,\"1040\":8,\"1041\":7,\"1042\":5,\"1043\":3}}],[\"username\",{\"1\":{\"190\":2,\"546\":5,\"637\":6,\"641\":15,\"670\":2,\"817\":1,\"838\":6,\"846\":1,\"976\":2}}],[\"us\",{\"1\":{\"249\":3}}],[\"usr\",{\"1\":{\"104\":1,\"223\":11,\"842\":1}}],[\"using\",{\"1\":{\"33\":2,\"770\":1,\"807\":1,\"813\":1,\"817\":2,\"820\":1}}],[\"uid=1234\",{\"1\":{\"249\":1}}],[\"uid\",{\"1\":{\"147\":1,\"190\":2}}],[\"uintptr是一个可变长的整数类型\",{\"1\":{\"460\":1}}],[\"uintptr指针算术\",{\"1\":{\"460\":1}}],[\"uintptr\",{\"0\":{\"460\":1},\"1\":{\"441\":1,\"460\":1}}],[\"uint\",{\"1\":{\"20\":1,\"982\":1,\"1013\":1}}],[\"ui\",{\"0\":{\"4\":1}}],[\"9f\",{\"1\":{\"770\":1}}],[\"9b\",{\"1\":{\"770\":157}}],[\"9+项目\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"99\",{\"1\":{\"370\":1,\"371\":1,\"813\":1}}],[\"9999\",{\"1\":{\"23\":1}}],[\"98\",{\"1\":{\"370\":1,\"371\":1}}],[\"97\",{\"1\":{\"370\":1,\"371\":1}}],[\"96\",{\"1\":{\"370\":1,\"371\":1,\"770\":1}}],[\"960^943\",{\"1\":{\"249\":2}}],[\"960\",{\"1\":{\"249\":1}}],[\"95\",{\"1\":{\"370\":1,\"371\":1}}],[\"9578461\",{\"1\":{\"249\":1}}],[\"94\",{\"1\":{\"370\":1,\"371\":1}}],[\"943\",{\"1\":{\"249\":1}}],[\"93\",{\"1\":{\"370\":1,\"371\":1}}],[\"92\",{\"1\":{\"370\":1,\"371\":1}}],[\"91\",{\"1\":{\"370\":1,\"371\":1}}],[\"900s\",{\"1\":{\"952\":1}}],[\"9000\",{\"1\":{\"23\":1,\"966\":2}}],[\"90\",{\"1\":{\"370\":1,\"371\":1,\"927\":1}}],[\"9092\",{\"1\":{\"177\":1}}],[\"9\",{\"0\":{\"461\":1},\"1\":{\"33\":1,\"229\":1,\"249\":9,\"369\":1,\"370\":1,\"371\":1,\"723\":1,\"770\":2,\"807\":1,\"813\":5,\"867\":1,\"870\":1,\"952\":1}}],[\"9gb\",{\"1\":{\"20\":1}}],[\"npc\",{\"1\":{\"918\":1,\"921\":1}}],[\"nx表示具备setnx\",{\"1\":{\"911\":1,\"921\":1}}],[\"nx\",{\"1\":{\"873\":1,\"911\":1}}],[\"nysql\",{\"1\":{\"813\":1}}],[\"n>1\",{\"1\":{\"810\":1}}],[\"ns\",{\"1\":{\"658\":3}}],[\"niuniu\",{\"1\":{\"867\":1}}],[\"niugetest4\",{\"1\":{\"177\":1}}],[\"nil\",{\"0\":{\"524\":1},\"1\":{\"265\":10,\"373\":1,\"374\":2,\"425\":3,\"436\":1,\"459\":1,\"483\":2,\"487\":2,\"489\":1,\"490\":1,\"491\":1,\"518\":1,\"519\":1,\"520\":3,\"523\":1,\"524\":6,\"525\":5,\"529\":2,\"530\":1,\"531\":8,\"532\":1,\"976\":1,\"1014\":3,\"1015\":2,\"1021\":1,\"1031\":1,\"1037\":1,\"1059\":1}}],[\"n这是个模运算啊\",{\"1\":{\"249\":1}}],[\"ncsa\",{\"1\":{\"249\":2}}],[\"ngnix\",{\"1\":{\"240\":1}}],[\"nginx的\",{\"1\":{\"237\":1}}],[\"nginx\",{\"1\":{\"145\":1,\"240\":1,\"927\":1}}],[\"nfds\",{\"1\":{\"226\":10}}],[\"ntoa\",{\"1\":{\"226\":1}}],[\"n=1\",{\"1\":{\"140\":1}}],[\"n=\",{\"1\":{\"140\":1}}],[\"namingstrategy\",{\"1\":{\"979\":2}}],[\"name字段对应请求头中的\",{\"1\":{\"1043\":1}}],[\"name字段对应表单数据或查询参数中的\",{\"1\":{\"1041\":1}}],[\"name字段对应url查询参数中的\",{\"1\":{\"1039\":1}}],[\"name字段为姓名字段\",{\"1\":{\"826\":1}}],[\"namekey\",{\"1\":{\"957\":3}}],[\"name>helloservlet<\",{\"1\":{\"658\":2}}],[\"name>loglevel<\",{\"1\":{\"588\":1}}],[\"name>loggingfilter<\",{\"1\":{\"588\":2}}],[\"name>\",{\"1\":{\"588\":3,\"658\":2,\"854\":2,\"961\":1,\"964\":1}}],[\"namefield\",{\"1\":{\"557\":4}}],[\"name3\",{\"1\":{\"437\":1}}],[\"name2\",{\"1\":{\"437\":2,\"851\":2}}],[\"name1\",{\"1\":{\"437\":2,\"851\":2,\"982\":2}}],[\"name=fengfeng\",{\"1\":{\"1035\":1}}],[\"name=yyyy\",{\"1\":{\"1035\":1}}],[\"name=xxxx\",{\"1\":{\"1035\":1}}],[\"name=mario\",{\"1\":{\"249\":1}}],[\"name=\",{\"1\":{\"139\":1}}],[\"namespace\",{\"1\":{\"33\":1,\"104\":1,\"122\":3,\"123\":1,\"124\":2,\"125\":1,\"126\":1}}],[\"name\",{\"1\":{\"23\":1,\"33\":13,\"110\":1,\"113\":1,\"119\":1,\"122\":1,\"139\":1,\"190\":1,\"211\":2,\"229\":5,\"249\":1,\"410\":4,\"435\":1,\"436\":1,\"447\":2,\"462\":5,\"464\":1,\"483\":4,\"485\":2,\"486\":2,\"487\":4,\"488\":3,\"489\":13,\"490\":4,\"557\":4,\"558\":3,\"559\":3,\"586\":1,\"633\":7,\"634\":7,\"635\":10,\"654\":1,\"687\":2,\"735\":1,\"763\":6,\"770\":6,\"810\":9,\"813\":7,\"817\":6,\"820\":2,\"826\":13,\"838\":1,\"846\":4,\"873\":2,\"979\":2,\"982\":2,\"983\":4,\"985\":1,\"986\":1,\"990\":3,\"991\":1,\"995\":1,\"1001\":4,\"1002\":1,\"1003\":2,\"1006\":1,\"1013\":2,\"1014\":2,\"1015\":2,\"1035\":3,\"1037\":5,\"1039\":5,\"1040\":5,\"1041\":5,\"1042\":2,\"1043\":3}}],[\"napt\",{\"1\":{\"197\":1,\"199\":1}}],[\"nat模式是一种虚拟机网络连接模式\",{\"1\":{\"246\":1}}],[\"nat网络中的虚拟机与外部网络有一定的隔离\",{\"1\":{\"246\":1}}],[\"nat网络中的虚拟机可以访问外部网络\",{\"1\":{\"246\":1}}],[\"nat网络模式类似于nat模式\",{\"1\":{\"246\":1}}],[\"nat网络\",{\"1\":{\"246\":2}}],[\"nat\",{\"1\":{\"122\":1,\"124\":2,\"246\":3,\"249\":1}}],[\"next\",{\"1\":{\"770\":1,\"783\":3,\"795\":1,\"820\":55,\"945\":1}}],[\"nestedstructdemo\",{\"1\":{\"489\":1}}],[\"need\",{\"1\":{\"468\":1}}],[\"needs\",{\"1\":{\"88\":1}}],[\"netstat\",{\"1\":{\"197\":1,\"198\":1,\"199\":1}}],[\"net=bridge\",{\"1\":{\"122\":1}}],[\"net=none\",{\"1\":{\"122\":1}}],[\"net=container\",{\"1\":{\"122\":1}}],[\"net=host\",{\"1\":{\"122\":1}}],[\"net\",{\"1\":{\"119\":3,\"226\":1,\"836\":1,\"1021\":1,\"1059\":1}}],[\"networkerrcode\",{\"1\":{\"1030\":2}}],[\"network=none\",{\"1\":{\"126\":1}}],[\"network=container\",{\"1\":{\"125\":1}}],[\"network\",{\"1\":{\"119\":2,\"122\":4,\"124\":2,\"125\":1,\"126\":1,\"246\":1,\"918\":2,\"921\":2}}],[\"newlogger\",{\"1\":{\"980\":2}}],[\"newtee\",{\"1\":{\"957\":3}}],[\"newcustomlogger\",{\"1\":{\"957\":3}}],[\"newexample\",{\"1\":{\"957\":1}}],[\"newentry\",{\"1\":{\"531\":1}}],[\"newatomiclevelat\",{\"1\":{\"957\":3}}],[\"newdevelopmentencoderconfig\",{\"1\":{\"957\":3}}],[\"newdevelopmentconfig\",{\"1\":{\"957\":2}}],[\"newdevelopment\",{\"1\":{\"957\":6}}],[\"newproductionencoderconfig\",{\"1\":{\"957\":3}}],[\"newproductionconfig\",{\"1\":{\"957\":2}}],[\"newproduction\",{\"1\":{\"957\":7}}],[\"newproxyinstance\",{\"1\":{\"559\":1}}],[\"newuser\",{\"1\":{\"840\":5}}],[\"newusername\",{\"1\":{\"641\":3}}],[\"newsession\",{\"1\":{\"692\":1}}],[\"newvalue\",{\"1\":{\"633\":2,\"634\":2,\"635\":3}}],[\"newvalue1\",{\"1\":{\"514\":1}}],[\"newinstance\",{\"1\":{\"556\":1,\"557\":1,\"558\":1}}],[\"new和delete会自动进行检查其类型和大小\",{\"1\":{\"33\":1}}],[\"new的实现过程是\",{\"1\":{\"33\":1}}],[\"new\",{\"1\":{\"33\":9,\"113\":2,\"217\":1,\"410\":1,\"425\":1,\"427\":1,\"472\":2,\"541\":2,\"542\":2,\"543\":2,\"546\":4,\"559\":2,\"568\":1,\"624\":1,\"625\":1,\"637\":1,\"638\":3,\"640\":1,\"641\":1,\"652\":1,\"687\":1,\"770\":1,\"817\":1,\"957\":2,\"961\":1,\"964\":1,\"980\":2}}],[\"n\",{\"0\":{\"369\":1,\"370\":1,\"371\":1},\"1\":{\"33\":1,\"79\":1,\"86\":1,\"88\":1,\"226\":8,\"249\":17,\"367\":5,\"373\":1,\"374\":15,\"392\":1,\"398\":1,\"467\":1,\"469\":1,\"483\":4,\"487\":2,\"489\":2,\"490\":2,\"491\":2,\"502\":1,\"514\":1,\"515\":2,\"527\":1,\"760\":1,\"770\":25,\"810\":7,\"813\":1,\"864\":2,\"906\":2,\"918\":1,\"921\":1,\"957\":1,\"980\":1}}],[\"nolowercase\",{\"1\":{\"979\":1}}],[\"noeviction\",{\"1\":{\"900\":2}}],[\"non\",{\"0\":{\"778\":1}}],[\"none\",{\"0\":{\"126\":1},\"1\":{\"122\":1,\"126\":2}}],[\"no\",{\"1\":{\"675\":1,\"810\":3,\"820\":27,\"952\":1}}],[\"nov\",{\"1\":{\"249\":2}}],[\"noqueue\",{\"1\":{\"121\":1}}],[\"now\",{\"1\":{\"33\":2,\"204\":2,\"810\":1,\"820\":2,\"957\":1}}],[\"not条件\",{\"0\":{\"1004\":1}}],[\"not\",{\"1\":{\"33\":1,\"36\":1,\"514\":1,\"676\":1,\"770\":6,\"807\":2,\"820\":5,\"829\":1,\"838\":2,\"983\":3,\"1004\":1,\"1062\":1}}],[\"nmixing\",{\"1\":{\"33\":1}}],[\"null关键字\",{\"1\":{\"807\":1}}],[\"null值列表所占用的字节数\",{\"1\":{\"770\":1}}],[\"null值列表用十六进制表示是\",{\"1\":{\"770\":1}}],[\"null值列表中\",{\"1\":{\"770\":1}}],[\"nullpointerexception\",{\"1\":{\"538\":1}}],[\"null\",{\"1\":{\"33\":1,\"226\":1,\"487\":1,\"541\":1,\"542\":1,\"546\":2,\"598\":2,\"599\":1,\"624\":1,\"626\":1,\"641\":1,\"770\":45,\"813\":1,\"820\":3,\"829\":1,\"930\":1,\"983\":3}}],[\"nusing\",{\"1\":{\"33\":1}}],[\"num++\",{\"1\":{\"477\":2}}],[\"nums\",{\"1\":{\"458\":5}}],[\"number\",{\"1\":{\"146\":1}}],[\"num\",{\"1\":{\"20\":2,\"30\":5,\"33\":1,\"449\":1,\"458\":2,\"476\":5,\"477\":5,\"723\":1,\"952\":2}}],[\"发货会超预算亏损\",{\"1\":{\"927\":1}}],[\"发\",{\"1\":{\"249\":1}}],[\"发的\",{\"1\":{\"249\":1}}],[\"发起大量http\",{\"1\":{\"243\":1}}],[\"发起接口请求的时候要携带版本号\",{\"1\":{\"23\":1}}],[\"发生阻塞\",{\"1\":{\"820\":1}}],[\"发生像主库那样两个\",{\"1\":{\"820\":1}}],[\"发生冲突\",{\"1\":{\"820\":1}}],[\"发生重复消费的场景\",{\"0\":{\"713\":1}}],[\"发生数据流转\",{\"1\":{\"530\":1}}],[\"发生逃逸\",{\"0\":{\"413\":1}}],[\"发生逃逸的时机\",{\"0\":{\"405\":1}}],[\"发生内存逃逸\",{\"1\":{\"405\":1}}],[\"发生的环节\",{\"1\":{\"243\":2}}],[\"发生了主键索引冲突\",{\"1\":{\"820\":1}}],[\"发生了这种情况\",{\"1\":{\"820\":1}}],[\"发生了崩溃\",{\"1\":{\"739\":1,\"810\":1}}],[\"发生了\",{\"1\":{\"479\":1}}],[\"发生了函数外引用\",{\"1\":{\"409\":1}}],[\"发生了写操作\",{\"1\":{\"217\":1}}],[\"发生了一定的异常也可以保证系统正常运作\",{\"1\":{\"176\":1}}],[\"发送文件到客户端\",{\"1\":{\"1032\":1}}],[\"发送回包都属于\",{\"1\":{\"897\":1}}],[\"发送给客户端\",{\"1\":{\"888\":1}}],[\"发送时就重复了\",{\"1\":{\"713\":1}}],[\"发送消息到leader节点后\",{\"1\":{\"710\":1}}],[\"发送错误状态\",{\"1\":{\"676\":1}}],[\"发送http请求到web服务器\",{\"1\":{\"661\":1}}],[\"发送goroutine就会阻塞\",{\"1\":{\"264\":1}}],[\"发送\",{\"1\":{\"249\":1}}],[\"发送方会为每个\",{\"1\":{\"237\":1}}],[\"发送一个消息给客户端\",{\"1\":{\"237\":1}}],[\"发送fin报文到服务端后\",{\"1\":{\"226\":1}}],[\"发送了消息\",{\"1\":{\"23\":1}}],[\"发现缓存失效\",{\"1\":{\"930\":1}}],[\"发现\",{\"1\":{\"882\":1}}],[\"发现需要扩容会进行\",{\"1\":{\"864\":1}}],[\"发现自己没有提供服务\",{\"1\":{\"145\":1}}],[\"发现没有应用\",{\"1\":{\"145\":1}}],[\"字典攻击\",{\"1\":{\"1048\":1}}],[\"字典\",{\"1\":{\"942\":1}}],[\"字典中的每个键值对都包含一个指向对象的指针\",{\"1\":{\"906\":1}}],[\"字典上\",{\"1\":{\"894\":1}}],[\"字典包含平常我存储的\",{\"1\":{\"894\":1}}],[\"字典的可执行文件\",{\"1\":{\"223\":1}}],[\"字占用3个字节\",{\"1\":{\"770\":1}}],[\"字\",{\"1\":{\"770\":1}}],[\"字符小\",{\"1\":{\"813\":1}}],[\"字符比\",{\"1\":{\"813\":1}}],[\"字符比较\",{\"1\":{\"813\":1}}],[\"字符和\",{\"1\":{\"813\":1}}],[\"字符和整形之间\",{\"1\":{\"807\":1}}],[\"字符的组合\",{\"1\":{\"813\":1}}],[\"字符集下\",{\"1\":{\"770\":1}}],[\"字符集为\",{\"1\":{\"770\":1}}],[\"字符集是\",{\"1\":{\"770\":2}}],[\"字符编码filter\",{\"0\":{\"599\":1}}],[\"字符串是否大于\",{\"1\":{\"873\":1}}],[\"字符串是所有8bit字节的集合\",{\"1\":{\"351\":1}}],[\"字符串对象的内部编码\",{\"1\":{\"873\":1}}],[\"字符串相当于\",{\"1\":{\"813\":1}}],[\"字符串处理\",{\"2\":{\"507\":1}}],[\"字符串连接\",{\"0\":{\"503\":1}}],[\"字符串分割\",{\"0\":{\"502\":1}}],[\"字符串分割与连接\",{\"0\":{\"501\":1}}],[\"字符串修剪\",{\"0\":{\"500\":1}}],[\"字符串转换与修改\",{\"0\":{\"498\":1}}],[\"字符串查找\",{\"0\":{\"497\":1}}],[\"字符串比较大小是逐位从高位到低位逐个比较\",{\"1\":{\"813\":1}}],[\"字符串比较\",{\"0\":{\"496\":1}}],[\"字符串继续迭代读取\",{\"1\":{\"452\":1}}],[\"字符串的改进\",{\"1\":{\"873\":1}}],[\"字符串的\",{\"1\":{\"441\":1}}],[\"字符串型\",{\"1\":{\"440\":1}}],[\"字符串类型对应一个16字节大小的结构体\",{\"1\":{\"441\":1}}],[\"字符串类型\",{\"1\":{\"436\":1}}],[\"字符串\",{\"1\":{\"813\":2},\"2\":{\"365\":1}}],[\"字符串拼接\",{\"0\":{\"362\":1}}],[\"字符串表示方式\",{\"0\":{\"361\":1}}],[\"字符串操作\",{\"0\":{\"355\":1}}],[\"字符串在go语言中由两部分组成\",{\"1\":{\"353\":1}}],[\"字符串数据结构\",{\"0\":{\"353\":1}}],[\"字符串本质是一串字符数组\",{\"1\":{\"352\":1}}],[\"字符串本质\",{\"0\":{\"352\":1}}],[\"字符串不可以被修改\",{\"1\":{\"351\":1}}],[\"字符串可以是empty但不能是nil\",{\"1\":{\"351\":1}}],[\"字符串基本概念\",{\"0\":{\"350\":1}}],[\"字段属性配置\",{\"0\":{\"983\":1}}],[\"字段外\",{\"1\":{\"940\":1}}],[\"字段存储的是\",{\"1\":{\"906\":1}}],[\"字段记录上一个节点的长度\",{\"1\":{\"879\":1}}],[\"字段如下\",{\"1\":{\"864\":1}}],[\"字段普通索引\",{\"1\":{\"820\":1}}],[\"字段为日志输出目标地址\",{\"1\":{\"957\":1}}],[\"字段为唯一二级索引\",{\"1\":{\"820\":1}}],[\"字段为主键索引\",{\"1\":{\"820\":2}}],[\"字段为sudog队列的首尾指针\",{\"1\":{\"259\":1}}],[\"字段则无法利用到索引\",{\"1\":{\"817\":1}}],[\"字段能用到联合索引\",{\"1\":{\"817\":1}}],[\"字段能索引下推\",{\"1\":{\"813\":2}}],[\"字段建立了联合索引\",{\"1\":{\"817\":1}}],[\"字段设置为索引即可\",{\"1\":{\"813\":1}}],[\"字段在\",{\"1\":{\"813\":1}}],[\"字段还有局部排序\",{\"1\":{\"813\":1}}],[\"字段还是旧值\",{\"1\":{\"763\":1,\"810\":1}}],[\"字段个数\",{\"1\":{\"813\":1}}],[\"字段特性\",{\"1\":{\"813\":1}}],[\"字段数量不能太多\",{\"1\":{\"807\":1}}],[\"字段结构\",{\"1\":{\"807\":2}}],[\"字段的值是在\",{\"1\":{\"813\":1}}],[\"字段的值\",{\"1\":{\"813\":1}}],[\"字段的值就是被使用的索引的名称\",{\"1\":{\"807\":1}}],[\"字段的顺序是没有意义的\",{\"1\":{\"249\":1}}],[\"字段且字符集是\",{\"1\":{\"770\":1}}],[\"字段类型的\",{\"1\":{\"770\":1}}],[\"字段都是变长字段\",{\"1\":{\"770\":1}}],[\"字段恢复到新值\",{\"1\":{\"763\":1,\"810\":1}}],[\"字段操作\",{\"0\":{\"557\":1}}],[\"字段和方法等程序元素\",{\"1\":{\"550\":1}}],[\"字段中找到条目\",{\"1\":{\"529\":1}}],[\"字段是一个整形数据\",{\"1\":{\"879\":1}}],[\"字段是一个原子指针\",{\"1\":{\"516\":1,\"522\":1}}],[\"字段是允许为\",{\"1\":{\"770\":1}}],[\"字段是新值\",{\"1\":{\"763\":1,\"810\":1}}],[\"字段是旧值\",{\"1\":{\"763\":1,\"810\":1}}],[\"字段是否已经被提升为\",{\"1\":{\"529\":1}}],[\"字段\",{\"1\":{\"516\":1,\"770\":1,\"817\":1,\"906\":1,\"938\":1,\"945\":1}}],[\"字段含义\",{\"1\":{\"326\":1,\"327\":1,\"328\":1}}],[\"字段实现的\",{\"1\":{\"249\":1}}],[\"字段原则上不能重复\",{\"1\":{\"249\":1}}],[\"字段名是蛇形单数\",{\"1\":{\"979\":1}}],[\"字段名\",{\"1\":{\"817\":1}}],[\"字段名后面必须紧接着\",{\"1\":{\"249\":1}}],[\"字段名里不允许出现空格\",{\"1\":{\"249\":1}}],[\"字段名不区分大小写\",{\"1\":{\"249\":1}}],[\"字段之间用冒号\",{\"1\":{\"190\":2}}],[\"字段来记录当前记录的版本号\",{\"1\":{\"23\":1}}],[\"字节就到了节点起始位置\",{\"1\":{\"879\":1}}],[\"字节就是保存了该内存块的描述信息\",{\"1\":{\"217\":1}}],[\"字节太小了\",{\"1\":{\"879\":1}}],[\"字节编码\",{\"1\":{\"879\":1}}],[\"字节来保存这个长度值\",{\"1\":{\"879\":1}}],[\"字节来表示大小\",{\"1\":{\"879\":1}}],[\"字节来表示\",{\"1\":{\"770\":2}}],[\"字节长的空间来保存这个长度值\",{\"1\":{\"879\":1}}],[\"字节表示\",{\"1\":{\"770\":2}}],[\"字节空间的\",{\"1\":{\"770\":1}}],[\"字节空间吗\",{\"1\":{\"770\":1}}],[\"字节空间\",{\"1\":{\"770\":1}}],[\"字节的数据到头部\",{\"1\":{\"879\":1}}],[\"字节的节点到头部\",{\"1\":{\"879\":1}}],[\"字节的\",{\"1\":{\"770\":1}}],[\"字节的空间\",{\"1\":{\"770\":1}}],[\"字节的分析出当前的内存块的大小\",{\"1\":{\"217\":1}}],[\"字节码\",{\"0\":{\"566\":1}}],[\"字节\",{\"1\":{\"33\":2,\"217\":2,\"770\":7,\"867\":1,\"873\":6,\"876\":1,\"879\":5,\"1037\":1}}],[\"字节存储指向溢出页的地址\",{\"1\":{\"770\":1}}],[\"字节存储\",{\"1\":{\"20\":1}}],[\"乐观锁\",{\"1\":{\"23\":1}}],[\"✅\",{\"1\":{\"23\":2}}],[\"查看帮助信息\",{\"1\":{\"970\":1}}],[\"查看当前登录的用户\",{\"1\":{\"842\":1}}],[\"查看当前用户的信息\",{\"1\":{\"842\":1}}],[\"查看当前用户的认证信息\",{\"1\":{\"842\":1}}],[\"查看当前用户\",{\"1\":{\"207\":1}}],[\"查看全部用户\",{\"1\":{\"842\":1}}],[\"查看索引\",{\"1\":{\"826\":1}}],[\"查看事务执行\",{\"1\":{\"820\":2}}],[\"查看是否有记录存在独占锁\",{\"1\":{\"820\":1}}],[\"查看是否存在此\",{\"1\":{\"810\":1}}],[\"查看\",{\"1\":{\"817\":1}}],[\"查看执行计划\",{\"1\":{\"807\":1}}],[\"查看逃逸分析结果\",{\"1\":{\"399\":1}}],[\"查看go\",{\"1\":{\"391\":1}}],[\"查看go帮助\",{\"1\":{\"391\":1}}],[\"查看环境变量信息\",{\"1\":{\"391\":1}}],[\"查看文件内容\",{\"1\":{\"209\":2}}],[\"查看tcp状态\",{\"0\":{\"199\":1}}],[\"查看进程占用的端口\",{\"0\":{\"198\":1}}],[\"查看进程的线程\",{\"0\":{\"196\":1}}],[\"查看进程的父子关系\",{\"1\":{\"104\":1}}],[\"查看端口被哪个进程占用\",{\"0\":{\"197\":1}}],[\"查看端口映射配置\",{\"0\":{\"118\":1}}],[\"查看cpu占用率和进程pid\",{\"0\":{\"195\":1}}],[\"查看镜像的元数据\",{\"0\":{\"148\":1}}],[\"查看容器中进程的信息\",{\"0\":{\"147\":1}}],[\"查看容器的数据卷具体信息\",{\"0\":{\"114\":1}}],[\"查看日志\",{\"0\":{\"146\":1}}],[\"查看指定数据卷的信息\",{\"0\":{\"109\":1}}],[\"查看所有数据卷\",{\"0\":{\"108\":1}}],[\"查看堆顶元素\",{\"1\":{\"52\":1}}],[\"查找分数为\",{\"1\":{\"885\":1}}],[\"查找时需要\",{\"1\":{\"870\":1}}],[\"查找数据时删除空格可能也会耗费一些cpu性能\",{\"1\":{\"770\":1}}],[\"查找关键字\",{\"1\":{\"214\":1}}],[\"查找指令所在的目录\",{\"1\":{\"211\":1}}],[\"查找文件\",{\"1\":{\"211\":1}}],[\"查找元素\",{\"1\":{\"43\":1}}],[\"查找元素首次出现位置\",{\"0\":{\"43\":1}}],[\"查找qq号的时间要求\",{\"1\":{\"20\":1}}],[\"查询大于平均年龄的用户\",{\"1\":{\"1012\":1}}],[\"查询男生的个数和女生的个数\",{\"1\":{\"1010\":1}}],[\"查询是qq邮箱的\",{\"1\":{\"1001\":1}}],[\"查询年龄大于23\",{\"1\":{\"1001\":1}}],[\"查询姓李的\",{\"1\":{\"1001\":1}}],[\"查询主键为\",{\"1\":{\"999\":1}}],[\"查询第一条记录\",{\"1\":{\"997\":1,\"998\":1}}],[\"查询多条记录\",{\"0\":{\"993\":1}}],[\"查询失败有查询为空\",{\"1\":{\"992\":1}}],[\"查询结果处理\",{\"0\":{\"992\":1}}],[\"查询结果也会更新到查询缓存中\",{\"1\":{\"817\":1}}],[\"查询单条记录\",{\"0\":{\"987\":1}}],[\"查询时\",{\"1\":{\"930\":1}}],[\"查询时尽量不要对字段做空值判断\",{\"1\":{\"807\":1}}],[\"查询时尽量不要使用\",{\"1\":{\"807\":1}}],[\"查询指定数据的节点\",{\"1\":{\"879\":1}}],[\"查询数据\",{\"1\":{\"879\":1}}],[\"查询一个元素的性能很高\",{\"1\":{\"870\":1}}],[\"查询一条记录\",{\"1\":{\"748\":1,\"810\":1}}],[\"查询用户名包含\",{\"1\":{\"1001\":1}}],[\"查询用户名不是qqh的\",{\"1\":{\"1001\":1}}],[\"查询用户名是qqh的\",{\"1\":{\"1001\":1}}],[\"查询用户的锁定状态\",{\"1\":{\"843\":1}}],[\"查询用于根据条件获取资源\",{\"1\":{\"23\":1}}],[\"查询表中数据\",{\"1\":{\"829\":1}}],[\"查询的记录是\",{\"1\":{\"820\":2}}],[\"查询的记录存不存在\",{\"1\":{\"820\":1}}],[\"查询的性能仍然会受益于索引的使用\",{\"1\":{\"813\":1}}],[\"查询语句会锁住\",{\"1\":{\"820\":1}}],[\"查询语句进行词法分析\",{\"1\":{\"817\":1}}],[\"查询语句如果命中查询缓存则直接返回\",{\"1\":{\"817\":1}}],[\"查询语句为例\",{\"1\":{\"817\":1}}],[\"查询语句中的表或者字段是否存在\",{\"1\":{\"817\":1}}],[\"查询语句的执行方案确定下来\",{\"1\":{\"817\":1}}],[\"查询语句的流程了\",{\"1\":{\"817\":1}}],[\"查询语句的那一套流程\",{\"1\":{\"810\":1}}],[\"查询语句之前\",{\"1\":{\"817\":1}}],[\"查询语句\",{\"1\":{\"817\":2}}],[\"查询缓冲就被清空了\",{\"1\":{\"817\":1}}],[\"查询缓存的命中率很低的\",{\"1\":{\"817\":1}}],[\"查询缓存\",{\"1\":{\"734\":1,\"804\":1,\"817\":3}}],[\"查询过程\",{\"1\":{\"817\":1}}],[\"查询方式是覆盖查询\",{\"1\":{\"813\":1}}],[\"查询方式是在联合索引找到主键值后\",{\"1\":{\"813\":1}}],[\"查询得到的记录\",{\"1\":{\"813\":1}}],[\"查询条件错误\",{\"1\":{\"992\":1}}],[\"查询条件中的各个列必须是联合索引中从最左边开始连续的列\",{\"1\":{\"813\":1}}],[\"查询条件字段的顺序并不会影响\",{\"1\":{\"813\":1}}],[\"查询条件\",{\"1\":{\"813\":1}}],[\"查询\",{\"1\":{\"813\":1,\"873\":1,\"879\":1}}],[\"查询会导致索引失效\",{\"1\":{\"807\":1}}],[\"查询可以直接使用索引而无需回表\",{\"1\":{\"807\":1}}],[\"查询到目标记录后\",{\"1\":{\"735\":1}}],[\"查询到的\",{\"1\":{\"519\":1}}],[\"查询执行\",{\"1\":{\"734\":1},\"2\":{\"825\":1}}],[\"查询重写\",{\"1\":{\"734\":1}}],[\"查询优化器可以使用索引来快速定位数据\",{\"1\":{\"813\":1}}],[\"查询优化的核心机制\",{\"1\":{\"804\":1}}],[\"查询优化\",{\"1\":{\"734\":1}}],[\"查询解析\",{\"1\":{\"734\":1}}],[\"查询问题\",{\"1\":{\"727\":1}}],[\"查询元素\",{\"1\":{\"514\":1}}],[\"查询原理详解\",{\"1\":{\"249\":1}}],[\"查询参数的模式\",{\"1\":{\"1036\":1}}],[\"查询参数不是get请求专属的\",{\"1\":{\"1035\":1}}],[\"查询参数\",{\"0\":{\"1035\":1,\"1039\":1},\"1\":{\"249\":1}}],[\"查询者只接受最先返回的响应\",{\"1\":{\"243\":1}}],[\"查询目标网站域名的的ip时\",{\"1\":{\"243\":1}}],[\"查询操作\",{\"1\":{\"23\":1,\"730\":1}}],[\"把我们搭建的消费服务作为mysql的一个slave\",{\"1\":{\"930\":1}}],[\"把新客户端的锁释放了\",{\"1\":{\"913\":1,\"921\":1}}],[\"把有效的\",{\"1\":{\"879\":1}}],[\"把条件\",{\"1\":{\"817\":1}}],[\"把数据写到\",{\"1\":{\"730\":1}}],[\"把数据分别放到不同的数据库中\",{\"1\":{\"727\":1}}],[\"把数据全给\",{\"1\":{\"520\":1}}],[\"把全局队列的\",{\"1\":{\"374\":1}}],[\"把原本指向的\",{\"1\":{\"373\":1}}],[\"把之前所有发送的数据做个摘要\",{\"1\":{\"249\":1}}],[\"把密文\",{\"1\":{\"249\":1}}],[\"把时间成本由原来的一个\",{\"1\":{\"249\":1}}],[\"把\",{\"1\":{\"249\":1,\"374\":1,\"730\":1,\"761\":1,\"765\":1,\"810\":2,\"817\":1,\"864\":1}}],[\"把所有需要监听的\",{\"1\":{\"226\":1}}],[\"把需要监控的\",{\"1\":{\"226\":1}}],[\"把二叉树底层的最右侧元素摘除并移动到堆顶\",{\"1\":{\"52\":1}}],[\"把堆顶元素删除\",{\"1\":{\"52\":1}}],[\"把客观事物封装成抽象类\",{\"1\":{\"33\":1}}],[\"把表中id为xxx的记录的a字段值增加1\",{\"1\":{\"23\":1}}],[\"把表中id为xxx的记录的a字段值设置为1\",{\"1\":{\"23\":1}}],[\"把规模大的数据转化为规模小的数据\",{\"1\":{\"20\":1}}],[\"✖\",{\"1\":{\"23\":1}}],[\"是明文字符串最终被bcrypt应用这些设置哈希后的哈希文本\",{\"1\":{\"1056\":1}}],[\"是添加到要进行哈希的字符串中的随机字符\",{\"1\":{\"1056\":1}}],[\"是进行哈希的次数\",{\"1\":{\"1056\":1}}],[\"是消息摘要算法\",{\"1\":{\"1054\":1}}],[\"是下一次查询的起始位置\",{\"1\":{\"1008\":1}}],[\"是qq邮箱的\",{\"1\":{\"1001\":1}}],[\"是对\",{\"1\":{\"957\":1}}],[\"是默认开启的\",{\"1\":{\"952\":1}}],[\"是默认值\",{\"1\":{\"760\":1}}],[\"是在write之后\",{\"1\":{\"952\":1}}],[\"是在事务提交后才会释放\",{\"1\":{\"820\":1}}],[\"是分好几步\",{\"1\":{\"952\":1}}],[\"是几分钟才做一次持久化\",{\"1\":{\"952\":1}}],[\"是缓存命中时性能不如\",{\"1\":{\"930\":1}}],[\"是可能会出现缓存和数据库不一致的情况\",{\"1\":{\"930\":1}}],[\"是可以挡住删除的流量的\",{\"1\":{\"524\":1}}],[\"是可以共享的\",{\"1\":{\"520\":1}}],[\"是三种不同功能要求下的消息传递手段\",{\"1\":{\"924\":1}}],[\"是新客户端\",{\"1\":{\"913\":1,\"921\":1}}],[\"是新的用户名\",{\"1\":{\"840\":1}}],[\"是要有归属的\",{\"1\":{\"912\":1,\"921\":1}}],[\"是字符串对象\",{\"1\":{\"894\":1}}],[\"是数据库对象\",{\"1\":{\"894\":1}}],[\"是内存存储\",{\"1\":{\"894\":1}}],[\"是双端访问结构\",{\"1\":{\"879\":1}}],[\"是双向链表\",{\"1\":{\"867\":1}}],[\"是特殊字符\",{\"1\":{\"879\":1}}],[\"是安全的\",{\"1\":{\"873\":1}}],[\"是具体的值\",{\"1\":{\"873\":1}}],[\"是最常见的模式\",{\"1\":{\"930\":1}}],[\"是最基本的\",{\"1\":{\"873\":1}}],[\"是最安全但是性能损耗最大的设置\",{\"1\":{\"810\":1}}],[\"是单个节点\",{\"1\":{\"867\":1}}],[\"是面试热点\",{\"1\":{\"864\":1}}],[\"是表示\",{\"1\":{\"864\":1}}],[\"是表中\",{\"1\":{\"820\":1}}],[\"是传进来的参数\",{\"1\":{\"864\":1}}],[\"是链表结构\",{\"1\":{\"864\":1}}],[\"是你要备份的数据库的名称\",{\"1\":{\"854\":1}}],[\"是你的显卡亮度\",{\"1\":{\"223\":1}}],[\"是备份文件的路径\",{\"1\":{\"854\":1}}],[\"是登录到\",{\"1\":{\"854\":1}}],[\"是等待状态\",{\"1\":{\"820\":1}}],[\"是与\",{\"1\":{\"820\":1}}],[\"是存在幻读的问题\",{\"1\":{\"820\":1}}],[\"是怎么确定的\",{\"1\":{\"820\":2}}],[\"是前开后闭区间\",{\"1\":{\"820\":1}}],[\"是先写缓存\",{\"1\":{\"930\":1}}],[\"是先生成锁结构\",{\"1\":{\"820\":3}}],[\"是先返回全部结果集再进行计算\",{\"1\":{\"807\":1}}],[\"是包含间隙锁+记录锁的\",{\"1\":{\"820\":2}}],[\"是性能最高的方式\",{\"1\":{\"820\":1}}],[\"是无锁的\",{\"1\":{\"820\":1}}],[\"是为了数据多的时候提高更新效率\",{\"1\":{\"867\":1}}],[\"是为了在数据少的时候节约内存\",{\"1\":{\"867\":1}}],[\"是为了保证当用户对表执行\",{\"1\":{\"820\":1}}],[\"是为了防止\",{\"1\":{\"810\":1}}],[\"是因为客户端是等查询语句查询完成后\",{\"1\":{\"817\":1}}],[\"是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个\",{\"1\":{\"770\":1}}],[\"是唯一表示\",{\"1\":{\"873\":1}}],[\"是唯一\",{\"1\":{\"817\":1}}],[\"是典型的\",{\"1\":{\"817\":1}}],[\"是短小精悍\",{\"1\":{\"813\":1}}],[\"是走了全表扫描\",{\"1\":{\"813\":1}}],[\"是普通列\",{\"1\":{\"813\":1}}],[\"是主键\",{\"1\":{\"813\":1}}],[\"是主键索引\",{\"1\":{\"810\":1}}],[\"是按照索引值有序排列存储的\",{\"1\":{\"813\":1}}],[\"是按照每个表的主键构建的\",{\"1\":{\"807\":1}}],[\"是局部有序性\",{\"1\":{\"813\":1}}],[\"是局部变量\",{\"1\":{\"30\":1}}],[\"是还没持久化到磁盘的\",{\"1\":{\"810\":1}}],[\"是有问题的\",{\"1\":{\"810\":1}}],[\"是循环写\",{\"1\":{\"810\":1}}],[\"是循环写的方式\",{\"1\":{\"810\":1}}],[\"是没有\",{\"1\":{\"810\":1}}],[\"是另一个公司以插件形式引入\",{\"1\":{\"810\":1}}],[\"是直接写入磁盘的吗\",{\"1\":{\"810\":1}}],[\"是直接操作内存的\",{\"1\":{\"217\":1}}],[\"是提高了读写效率没错\",{\"1\":{\"810\":1}}],[\"是如何刷盘的\",{\"1\":{\"810\":1}}],[\"是如何实现的\",{\"0\":{\"381\":1}}],[\"是会导致主线程阻塞的\",{\"1\":{\"952\":1}}],[\"是会消耗性能的\",{\"1\":{\"867\":1}}],[\"是会大于\",{\"1\":{\"864\":1}}],[\"是会继续往下找\",{\"1\":{\"864\":1}}],[\"是会被阻塞的\",{\"1\":{\"820\":3}}],[\"是会边写边擦除日志的\",{\"1\":{\"810\":1}}],[\"是会把整个页的数据加载到\",{\"1\":{\"810\":1}}],[\"是会把整个表的查询缓存清空的\",{\"1\":{\"810\":1}}],[\"是会动态增长\",{\"1\":{\"217\":1}}],[\"是线程模型\",{\"1\":{\"807\":1}}],[\"是查询不出来这条数据的\",{\"1\":{\"783\":1}}],[\"是必需的\",{\"1\":{\"770\":1}}],[\"是固定\",{\"1\":{\"770\":1}}],[\"是用户连接到\",{\"1\":{\"838\":1}}],[\"是用户的名称\",{\"1\":{\"838\":1}}],[\"是用来设置超时时间的\",{\"1\":{\"820\":1}}],[\"是用来控制选择用\",{\"1\":{\"820\":1}}],[\"是用来在系统崩溃后进行数据恢复的\",{\"1\":{\"753\":1}}],[\"是用整数字节的二进制位来表示\",{\"1\":{\"770\":1}}],[\"是变长的\",{\"1\":{\"770\":1}}],[\"是定长的\",{\"1\":{\"770\":1}}],[\"是支持聚簇索引的\",{\"1\":{\"770\":1}}],[\"是支持多副本的\",{\"1\":{\"176\":1}}],[\"是的没错\",{\"1\":{\"817\":1}}],[\"是的\",{\"1\":{\"765\":1,\"770\":1,\"810\":1}}],[\"是追加写\",{\"1\":{\"759\":1,\"810\":1}}],[\"是专门用来缓存文件数据的\",{\"1\":{\"756\":1,\"810\":1}}],[\"是物理日志\",{\"1\":{\"752\":1,\"810\":2}}],[\"是基于内存的\",{\"1\":{\"751\":1,\"810\":1}}],[\"是由\",{\"1\":{\"739\":1,\"810\":1,\"955\":1}}],[\"是innodb存储引擎层生成的日志\",{\"1\":{\"737\":2}}],[\"是不断写入的\",{\"1\":{\"952\":1}}],[\"是不是\",{\"1\":{\"817\":1}}],[\"是不必写入磁盘\",{\"1\":{\"810\":1}}],[\"是不会用\",{\"1\":{\"952\":1}}],[\"是不会发生阻塞的\",{\"1\":{\"820\":1}}],[\"是不会加行级锁的\",{\"1\":{\"820\":1}}],[\"是不会存放在行格式中记录的真实数据部分里的\",{\"1\":{\"770\":1}}],[\"是不会重复的\",{\"1\":{\"713\":1}}],[\"是不支持聚簇索引的\",{\"1\":{\"770\":1}}],[\"是不能被拆开的\",{\"1\":{\"760\":1,\"810\":1}}],[\"是不可以直接进行比较的\",{\"1\":{\"472\":1}}],[\"是携带在自定义的消息结构里面\",{\"1\":{\"710\":1}}],[\"是非空且唯一的\",{\"1\":{\"826\":1}}],[\"是非常慢的\",{\"1\":{\"770\":1}}],[\"是非常可靠的\",{\"1\":{\"710\":1}}],[\"是非线程安全的\",{\"1\":{\"333\":1}}],[\"是持久的\",{\"1\":{\"710\":1}}],[\"是很古老的行格式了\",{\"1\":{\"770\":1}}],[\"是很容易实现至少一次语义的\",{\"1\":{\"706\":1}}],[\"是很多框架实现的基础\",{\"1\":{\"552\":1}}],[\"是运行在web服务器上的java程序\",{\"1\":{\"646\":1}}],[\"是运算符\",{\"1\":{\"33\":1}}],[\"是实现诸如资源初始化\",{\"1\":{\"612\":1}}],[\"是实现诸如权限验证\",{\"1\":{\"576\":1}}],[\"是java\",{\"1\":{\"578\":1,\"614\":1}}],[\"是java的一个强大特性\",{\"1\":{\"550\":1}}],[\"是通过\",{\"1\":{\"743\":1,\"810\":2,\"820\":1}}],[\"是通过加锁来做了限流保护的\",{\"1\":{\"512\":1}}],[\"是通过无锁的\",{\"1\":{\"512\":1}}],[\"是程序运行的基础\",{\"1\":{\"388\":1}}],[\"是相关的\",{\"1\":{\"381\":1}}],[\"是什么呢\",{\"1\":{\"770\":1}}],[\"是什么\",{\"1\":{\"302\":1,\"748\":1,\"867\":1,\"870\":1,\"876\":1,\"882\":1,\"885\":1,\"906\":1,\"924\":1,\"927\":1}}],[\"是反解不出来的\",{\"1\":{\"249\":1}}],[\"是超文本传输协议\",{\"1\":{\"249\":1}}],[\"是二级索引\",{\"1\":{\"820\":1}}],[\"是二进制协议而不是文本协议\",{\"1\":{\"249\":1}}],[\"是二叉堆的常用实现方式\",{\"1\":{\"55\":1}}],[\"是属于该组的用户列表\",{\"1\":{\"190\":1}}],[\"是组id\",{\"1\":{\"190\":1}}],[\"是组名\",{\"1\":{\"190\":1}}],[\"是密码占位符\",{\"1\":{\"190\":1}}],[\"是指在开发环境下\",{\"1\":{\"956\":1}}],[\"是指大量的应用请求因为异常无法在redis缓存中进行处理\",{\"1\":{\"930\":1}}],[\"是指缓存和数据库中都没有的数据\",{\"1\":{\"930\":1}}],[\"是指使用的时候\",{\"1\":{\"882\":1}}],[\"是指字段\",{\"1\":{\"873\":1}}],[\"是指事务操作前和操作后\",{\"1\":{\"774\":1}}],[\"是指协议对于事务处理没有记忆能力\",{\"1\":{\"249\":1}}],[\"是指请求方法不会\",{\"1\":{\"249\":1}}],[\"是指默认\",{\"1\":{\"237\":1}}],[\"是指与\",{\"1\":{\"181\":2}}],[\"是指分区的所有副本\",{\"1\":{\"181\":1}}],[\"是指针类型\",{\"1\":{\"33\":1}}],[\"是天然提供容灾解决方案的\",{\"1\":{\"169\":1}}],[\"是kafka中的另一个重要角色\",{\"1\":{\"156\":1}}],[\"是真正用来运行容器的\",{\"1\":{\"103\":1}}],[\"是\",{\"1\":{\"99\":1,\"177\":4,\"190\":2,\"223\":6,\"249\":3,\"302\":1,\"460\":2,\"512\":1,\"519\":1,\"521\":1,\"737\":1,\"753\":1,\"759\":1,\"783\":2,\"807\":1,\"810\":5,\"820\":5,\"854\":1,\"867\":1,\"873\":3,\"879\":2,\"885\":3,\"897\":1,\"900\":1,\"937\":1,\"952\":1,\"957\":2,\"973\":1}}],[\"是容器启动的基础\",{\"1\":{\"97\":1}}],[\"是一张哈希表\",{\"1\":{\"941\":1}}],[\"是一组按关联积分有序的字符串集合\",{\"1\":{\"876\":1}}],[\"是一组连接起来的字符串集合\",{\"1\":{\"867\":1}}],[\"是一起分配内存的\",{\"1\":{\"867\":1}}],[\"是一直持有的\",{\"1\":{\"820\":1}}],[\"是一种可以快速查找的多级链表结构\",{\"1\":{\"876\":1}}],[\"是一种用于撤销回退的日志\",{\"1\":{\"810\":1}}],[\"是一种用于生成分布式系统中唯一id的算法\",{\"1\":{\"92\":1}}],[\"是一种紧凑的行格式\",{\"1\":{\"770\":1}}],[\"是一种数据库管理技术\",{\"1\":{\"743\":1}}],[\"是一种具有特殊用途的程序\",{\"1\":{\"190\":1}}],[\"是一个很好的兜底文件\",{\"1\":{\"952\":1}}],[\"是一个很好的选择\",{\"1\":{\"949\":1}}],[\"是一个双端列表\",{\"1\":{\"924\":1}}],[\"是一个流行的资源淘汰算法\",{\"1\":{\"906\":1}}],[\"是一个不重复\",{\"1\":{\"870\":1}}],[\"是一个偏向数组的结构\",{\"1\":{\"867\":1}}],[\"是一个耗时的操作\",{\"1\":{\"520\":1}}],[\"是一个特殊的常量\",{\"1\":{\"442\":1}}],[\"是一个指针数组\",{\"1\":{\"307\":1}}],[\"是一个绝对时间\",{\"1\":{\"249\":1}}],[\"是一个相对时间\",{\"1\":{\"249\":1}}],[\"是一个包含url和urn的超集\",{\"1\":{\"249\":1}}],[\"是一个笼统的错误\",{\"1\":{\"240\":1}}],[\"是一个随时更新的\",{\"1\":{\"226\":1}}],[\"是一个非常小巧的\",{\"1\":{\"104\":1}}],[\"是一个非常重要的后台管理进程\",{\"1\":{\"102\":1}}],[\"是一个用来运行容器的轻量级工具\",{\"1\":{\"103\":1}}],[\"是一个数组变量\",{\"1\":{\"33\":1}}],[\"是一个主题包\",{\"1\":{\"5\":1}}],[\"是将移出窗口的字符\",{\"1\":{\"88\":1}}],[\"是将移入窗口的字符\",{\"1\":{\"88\":1}}],[\"是宏定义的一种\",{\"1\":{\"36\":1}}],[\"是否查询失败\",{\"1\":{\"992\":1}}],[\"是否活跃\",{\"1\":{\"903\":1}}],[\"是否能增加一层的概率为\",{\"1\":{\"885\":1}}],[\"是否有事务已经对表加上了\",{\"1\":{\"820\":1}}],[\"是否成立\",{\"1\":{\"817\":2}}],[\"是否等于\",{\"1\":{\"817\":4}}],[\"是否扫描了额外的记录\",{\"1\":{\"807\":1}}],[\"是否请求了不需要的数据\",{\"1\":{\"807\":1}}],[\"是否解决幻读\",{\"0\":{\"783\":1}}],[\"是否可行\",{\"1\":{\"770\":2}}],[\"是否可用\",{\"1\":{\"249\":1}}],[\"是否准备好了\",{\"1\":{\"764\":1,\"810\":1}}],[\"是否在\",{\"1\":{\"744\":1,\"789\":1}}],[\"是否为开发模式\",{\"1\":{\"957\":1}}],[\"是否为数组\",{\"1\":{\"555\":1}}],[\"是否为枚举\",{\"1\":{\"555\":1}}],[\"是否为接口\",{\"1\":{\"555\":1}}],[\"是否数据缺失\",{\"1\":{\"516\":1}}],[\"是否需要阻塞\",{\"1\":{\"265\":1}}],[\"是否要等待同步完成取决于选择哪种写入策略\",{\"1\":{\"180\":1}}],[\"是否执行该代码段\",{\"1\":{\"36\":1}}],[\"是否幂等\",{\"1\":{\"23\":1}}],[\"是函数指针\",{\"1\":{\"33\":1}}],[\"是函数声明\",{\"1\":{\"33\":1}}],[\"是const\",{\"1\":{\"30\":1}}],[\"描述数据库结构\",{\"1\":{\"820\":1}}],[\"描述请求或响应的基本信息\",{\"1\":{\"249\":1}}],[\"描述\",{\"1\":{\"23\":1}}],[\"后用的多线程\",{\"1\":{\"891\":1}}],[\"后用户表使用列\",{\"1\":{\"841\":1}}],[\"后对使用多线程处理异步删除的操作\",{\"1\":{\"891\":1}}],[\"后移不叫连锁更新\",{\"1\":{\"879\":1}}],[\"后几位表示长度\",{\"1\":{\"879\":1}}],[\"后使用\",{\"1\":{\"867\":1}}],[\"后一个事务在执行这条语句的时候\",{\"1\":{\"820\":1}}],[\"后的条件列不是索引列\",{\"1\":{\"813\":1}}],[\"后的字段值前可以有多个空格\",{\"1\":{\"249\":1}}],[\"后期也推出了支持索引组织表的存储方式\",{\"1\":{\"813\":1}}],[\"后缀\",{\"1\":{\"500\":1}}],[\"后面混合持久化会用到\",{\"1\":{\"952\":1}}],[\"后面主线程再分配\",{\"1\":{\"897\":1}}],[\"后面又拉到了相同消息\",{\"1\":{\"713\":1}}],[\"后面会解读\",{\"1\":{\"512\":1}}],[\"后面先调度本地队列\",{\"1\":{\"374\":1}}],[\"后面要做两个事情\",{\"1\":{\"265\":1}}],[\"后面的数字是硬盘分区\",{\"1\":{\"223\":1}}],[\"后来它的版本号被定位在\",{\"1\":{\"249\":1}}],[\"后来的查询结果会被丢弃\",{\"1\":{\"243\":1}}],[\"后续通过日志重放恢复数据\",{\"1\":{\"952\":1}}],[\"后续通过加载\",{\"1\":{\"952\":1}}],[\"后续有对该表的\",{\"1\":{\"820\":1}}],[\"后续在持久化到磁盘如下图\",{\"1\":{\"810\":1}}],[\"后续在服务端应用程序调用read\",{\"1\":{\"226\":1}}],[\"后续修改时可能出现页分裂\",{\"1\":{\"770\":1}}],[\"后续修改不会造成页分裂\",{\"1\":{\"770\":1}}],[\"后续交由操作系统决定何时将数据持久化到磁盘\",{\"1\":{\"760\":1,\"810\":1}}],[\"后续再持久化到磁盘\",{\"1\":{\"755\":1}}],[\"后续\",{\"1\":{\"751\":1,\"810\":1}}],[\"后续由后台线程选择一个合适的时机将脏页写入到磁盘\",{\"1\":{\"747\":1,\"810\":3}}],[\"后续追加的元素不会影响当前的迭代过程\",{\"1\":{\"453\":1}}],[\"后续就不再使用非对称加密\",{\"1\":{\"249\":1}}],[\"后续的交互将没有重复的用户信息传输\",{\"1\":{\"249\":1}}],[\"后结果\",{\"1\":{\"249\":1}}],[\"后者仅与\",{\"1\":{\"229\":1}}],[\"后台线程\",{\"1\":{\"810\":1}}],[\"后台命令执行以及函数\",{\"1\":{\"190\":1}}],[\"后台启动容器\",{\"0\":{\"145\":1}}],[\"后台方式运行\",{\"1\":{\"139\":1}}],[\"后台的业务接口无非就是增删改查四种接口\",{\"1\":{\"23\":1}}],[\"后\",{\"1\":{\"33\":1,\"249\":2,\"519\":1,\"744\":1,\"760\":1,\"789\":1,\"807\":1,\"810\":2,\"813\":1,\"820\":2,\"903\":1}}],[\"后端不返回实际文件内容\",{\"1\":{\"1032\":1}}],[\"后端会将该token作为键\",{\"1\":{\"23\":1}}],[\"后端\",{\"2\":{\"21\":1,\"24\":1}}],[\"后端开发\",{\"2\":{\"18\":1}}],[\"后端优化场景\",{\"0\":{\"17\":1}}],[\"都表现为一个\",{\"1\":{\"944\":1}}],[\"都复用这个字段\",{\"1\":{\"940\":1}}],[\"都用在验证码输入上\",{\"1\":{\"927\":1}}],[\"都用宏定义中的字符串去代换\",{\"1\":{\"36\":1}}],[\"都叫压缩列表\",{\"1\":{\"879\":1}}],[\"都要进行回表操作\",{\"1\":{\"817\":1}}],[\"都要持久化到磁盘\",{\"1\":{\"763\":1,\"810\":1}}],[\"都在等待对方事务的间隙锁释放\",{\"1\":{\"820\":1}}],[\"都在\",{\"1\":{\"817\":1}}],[\"都能走索引\",{\"1\":{\"813\":5}}],[\"都优秀\",{\"1\":{\"813\":1}}],[\"都配置为\",{\"1\":{\"810\":1}}],[\"都进行了优化\",{\"1\":{\"810\":1}}],[\"都设置为\",{\"1\":{\"810\":1}}],[\"都将缓存在\",{\"1\":{\"810\":1}}],[\"都已经完成了刷盘\",{\"1\":{\"810\":1}}],[\"都已经写入磁盘\",{\"1\":{\"810\":1}}],[\"都处于\",{\"1\":{\"810\":1}}],[\"都有可能\",{\"1\":{\"873\":1}}],[\"都有可能发生崩溃\",{\"1\":{\"810\":1}}],[\"都有一个\",{\"1\":{\"742\":1}}],[\"都可以恢复\",{\"1\":{\"810\":1}}],[\"都回答准备好了\",{\"1\":{\"764\":1,\"810\":1}}],[\"都只是缓存在\",{\"1\":{\"756\":1,\"810\":2}}],[\"都\",{\"1\":{\"756\":1,\"810\":1}}],[\"都记录下回滚时需要的信息到一个日志里\",{\"1\":{\"810\":1}}],[\"都记录下回滚时需要的信息到一个日志\",{\"1\":{\"739\":1}}],[\"都存储在里面\",{\"1\":{\"941\":1}}],[\"都存着\",{\"1\":{\"524\":1}}],[\"都存放在\",{\"1\":{\"223\":1}}],[\"都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁\",{\"1\":{\"820\":2}}],[\"都需要额外操作索引\",{\"1\":{\"813\":1}}],[\"都需要通过\",{\"1\":{\"745\":1,\"810\":1}}],[\"都需要理解urlpattern的配置规则\",{\"1\":{\"653\":1}}],[\"都需要每个\",{\"1\":{\"381\":1}}],[\"都需要把\",{\"1\":{\"226\":2}}],[\"都必须访问全局\",{\"1\":{\"381\":1}}],[\"都放到\",{\"1\":{\"226\":1}}],[\"都放到一个文件描述符集合\",{\"1\":{\"226\":1}}],[\"都发起\",{\"1\":{\"226\":1}}],[\"都被自动挂载到\",{\"1\":{\"223\":1}}],[\"都会得到如下输出\",{\"1\":{\"957\":1}}],[\"都会写入到\",{\"1\":{\"952\":1}}],[\"都会存储一份\",{\"1\":{\"946\":1}}],[\"都会放入池中\",{\"1\":{\"906\":1}}],[\"都会有一份\",{\"1\":{\"894\":1}}],[\"都会以处理二进制的方式来处理\",{\"1\":{\"873\":1}}],[\"都会使用上次使用后返回的游标作为本次游标参数\",{\"1\":{\"870\":1}}],[\"都会检查一下是否完成整个迁移\",{\"1\":{\"864\":1}}],[\"都会\",{\"1\":{\"810\":1}}],[\"都会影响业务\",{\"1\":{\"810\":1}}],[\"都会被阻塞\",{\"1\":{\"820\":1}}],[\"都会被记录到\",{\"1\":{\"810\":1}}],[\"都会被隐藏\",{\"1\":{\"33\":1}}],[\"都会重新生成一个\",{\"1\":{\"784\":1}}],[\"都会把旧版本的记录写入到\",{\"1\":{\"770\":1,\"788\":1}}],[\"都会在\",{\"1\":{\"770\":1}}],[\"都会生成一个新的\",{\"1\":{\"743\":1,\"796\":1,\"810\":1}}],[\"都会去全局队列中获取一个\",{\"1\":{\"374\":1}}],[\"都会将报文传输给另一方\",{\"1\":{\"123\":1}}],[\"都会出现重复请求\",{\"1\":{\"23\":1}}],[\"都是先创建一个配置对象\",{\"1\":{\"957\":1}}],[\"都是指向一个dict\",{\"1\":{\"946\":1}}],[\"都是写入时候会更新数据库\",{\"1\":{\"930\":1}}],[\"都是硬伤\",{\"1\":{\"927\":1}}],[\"都是很优秀的消息队列中间件\",{\"1\":{\"924\":1}}],[\"都是\",{\"1\":{\"879\":1}}],[\"都是在这些记录的索引上加\",{\"1\":{\"820\":3}}],[\"都是连续的\",{\"1\":{\"820\":1}}],[\"都是二级索引\",{\"1\":{\"813\":1}}],[\"都是存储了实际的字符+字符长度\",{\"1\":{\"770\":1}}],[\"都是使用线性结构存储进程关注的\",{\"1\":{\"226\":1}}],[\"都是维护一个全局资源\",{\"1\":{\"23\":1}}],[\"都是将相关数据进行删除\",{\"1\":{\"23\":1}}],[\"对上一点的解释\",{\"1\":{\"952\":1}}],[\"对编程者的业务能力\",{\"1\":{\"930\":1}}],[\"对缓存及时性要求更高\",{\"1\":{\"930\":1}}],[\"对服务端远程调用之后\",{\"1\":{\"930\":1}}],[\"对近似\",{\"1\":{\"906\":1}}],[\"对跳表做了一些优化\",{\"1\":{\"885\":1}}],[\"对过期\",{\"1\":{\"882\":1}}],[\"对内存不友好\",{\"1\":{\"882\":1}}],[\"对症下药\",{\"1\":{\"879\":1}}],[\"对读取的记录加排他锁\",{\"1\":{\"820\":1}}],[\"对读取的记录加独占锁\",{\"1\":{\"820\":2}}],[\"对读取的记录加共享锁\",{\"1\":{\"820\":3}}],[\"对一张表做结构变更操作的时候\",{\"1\":{\"820\":1}}],[\"对一张表进行\",{\"1\":{\"820\":1}}],[\"对表结构的更改操作\",{\"1\":{\"820\":1}}],[\"对表建立联合索引之后\",{\"1\":{\"813\":1}}],[\"对普通字段建立的索引叫做二级索引\",{\"1\":{\"813\":1}}],[\"对主键字段建立的索引叫做聚簇索引\",{\"1\":{\"813\":1}}],[\"对主库资源消耗比较高\",{\"1\":{\"810\":1}}],[\"对索引中包含的字段先做判断\",{\"1\":{\"813\":1}}],[\"对索引隐式类型转换\",{\"1\":{\"813\":1}}],[\"对索引进行表达式计算\",{\"1\":{\"813\":1}}],[\"对索引使用函数\",{\"1\":{\"813\":1}}],[\"对索引使用左\",{\"1\":{\"813\":1}}],[\"对查询性能的影响\",{\"1\":{\"813\":1}}],[\"对回表频率高的查询\",{\"1\":{\"813\":1}}],[\"对范围查找非常有帮助\",{\"1\":{\"813\":1}}],[\"对每个组合使用盐\",{\"1\":{\"1052\":1}}],[\"对每个阶段引入了队列后\",{\"1\":{\"810\":1}}],[\"对每一个\",{\"1\":{\"226\":1}}],[\"对没错\",{\"1\":{\"793\":1}}],[\"对数据进行初步的筛选\",{\"1\":{\"823\":1}}],[\"对数据进行加密\",{\"1\":{\"249\":1}}],[\"对数据的增删改操作\",{\"1\":{\"820\":1}}],[\"对数据的修改就是永久的\",{\"1\":{\"774\":1}}],[\"对其他并发事务是隔离的\",{\"1\":{\"774\":1}}],[\"对两阶段提交加强\",{\"0\":{\"767\":1}}],[\"对输出内容进行适当编码\",{\"1\":{\"604\":1}}],[\"对添加到\",{\"1\":{\"531\":1}}],[\"对用一个\",{\"1\":{\"524\":1}}],[\"对副本的任何修改都不会影响原始变量\",{\"1\":{\"455\":1}}],[\"对包外不可见\",{\"1\":{\"433\":1}}],[\"对齐\",{\"1\":{\"302\":1}}],[\"对这个接口有4种实现\",{\"1\":{\"271\":1}}],[\"对这份文件的数字签名及使用的算法\",{\"1\":{\"249\":1}}],[\"对称性\",{\"0\":{\"914\":1},\"1\":{\"909\":1,\"921\":2}}],[\"对称算法\",{\"1\":{\"249\":1}}],[\"对称加密算法\",{\"1\":{\"249\":1}}],[\"对明文的hash值进行加密\",{\"1\":{\"249\":1}}],[\"对乘法逆元感兴趣的朋友可以网上搜搜怎么算\",{\"1\":{\"249\":1}}],[\"对模φ\",{\"1\":{\"249\":1}}],[\"对他们来说是透明的\",{\"1\":{\"249\":1}}],[\"对网络中的服务器发起请求\",{\"1\":{\"243\":1}}],[\"对攻击的服务器发起大量的请求\",{\"1\":{\"243\":1}}],[\"对证书做了签名\",{\"1\":{\"240\":1,\"249\":1}}],[\"对比来看\",{\"1\":{\"957\":1}}],[\"对比cache\",{\"1\":{\"930\":1}}],[\"对比多线程\",{\"1\":{\"888\":1}}],[\"对比而言\",{\"1\":{\"807\":1}}],[\"对比\",{\"1\":{\"229\":1,\"249\":1,\"930\":1}}],[\"对比两次哈希值\",{\"1\":{\"76\":1}}],[\"对象了\",{\"1\":{\"957\":1}}],[\"对象和\",{\"1\":{\"957\":1}}],[\"对象增加了一个选项\",{\"1\":{\"957\":1}}],[\"对象的\",{\"1\":{\"957\":1}}],[\"对象的指针\",{\"1\":{\"946\":1}}],[\"对象转换成一个\",{\"1\":{\"957\":1}}],[\"对象指针\",{\"1\":{\"894\":1}}],[\"对象过期时间\",{\"1\":{\"882\":1}}],[\"对象有两种编码方式\",{\"1\":{\"867\":1}}],[\"对象从会话\",{\"1\":{\"637\":1}}],[\"对象被绑定到会话\",{\"1\":{\"637\":1}}],[\"对象类型零值是\",{\"1\":{\"487\":1}}],[\"对象中\",{\"1\":{\"226\":1,\"906\":1}}],[\"对象\",{\"1\":{\"226\":1,\"472\":1,\"894\":2,\"937\":1,\"944\":2,\"945\":1,\"946\":1,\"957\":7}}],[\"对大文件效率更高\",{\"1\":{\"209\":1}}],[\"对\",{\"1\":{\"106\":2,\"190\":1,\"226\":2,\"745\":1,\"767\":1,\"793\":1,\"810\":4,\"813\":1,\"820\":2,\"873\":1,\"882\":1,\"944\":3}}],[\"对客户端\",{\"1\":{\"77\":1}}],[\"对程序中所有出现的\",{\"1\":{\"36\":1}}],[\"对于一个线上的\",{\"1\":{\"850\":1}}],[\"对于这种范围为\",{\"1\":{\"820\":1}}],[\"对于更新比较频繁的表\",{\"1\":{\"817\":1}}],[\"对于唯一索引\",{\"1\":{\"813\":1}}],[\"对于处于\",{\"1\":{\"810\":1}}],[\"对于有共同前缀的字符串\",{\"1\":{\"807\":1}}],[\"对于char\",{\"1\":{\"770\":1}}],[\"对于char类型的字段\",{\"1\":{\"770\":1}}],[\"对于utf8mb4\",{\"1\":{\"770\":1}}],[\"对于第三条数据\",{\"1\":{\"770\":1}}],[\"对于第二条数据\",{\"1\":{\"770\":1}}],[\"对于第一条数据\",{\"1\":{\"770\":1}}],[\"对于读提交和可重复读隔离级别的事务来说\",{\"1\":{\"743\":1}}],[\"对于不同的业务需求\",{\"1\":{\"705\":1}}],[\"对于消息一般有如下几种消费模式\",{\"1\":{\"705\":1}}],[\"对于请求\",{\"1\":{\"656\":1}}],[\"对于频繁访问的资源\",{\"1\":{\"603\":1}}],[\"对于jakarta\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"对于长字符串搜索效率较高\",{\"1\":{\"497\":1}}],[\"对于简单的相等性比较\",{\"1\":{\"496\":1}}],[\"对于简单类型来说\",{\"1\":{\"33\":1}}],[\"对于内部结构体的方法\",{\"1\":{\"462\":1}}],[\"对于内部结构体的字段\",{\"1\":{\"462\":1}}],[\"对于引用类型和指针\",{\"1\":{\"456\":1}}],[\"对于基础数据类型\",{\"1\":{\"455\":1}}],[\"对于小型结构体\",{\"1\":{\"428\":1}}],[\"对于小顶堆\",{\"1\":{\"51\":1}}],[\"对于上面这段代码\",{\"1\":{\"423\":1}}],[\"对于上面例子中的person\",{\"1\":{\"229\":1}}],[\"对于性能要求高且访问频次高的函数调用\",{\"1\":{\"416\":1}}],[\"对于非单字节编码的字符\",{\"1\":{\"353\":1}}],[\"对于go\",{\"1\":{\"229\":1}}],[\"对于桌面版\",{\"1\":{\"223\":1}}],[\"对于程序而言\",{\"1\":{\"217\":1}}],[\"对于多进程的系统来说\",{\"1\":{\"217\":1}}],[\"对于那些没有被经常使用到的内存\",{\"1\":{\"217\":1}}],[\"对于生产者来说\",{\"1\":{\"180\":1}}],[\"对于\",{\"1\":{\"177\":1,\"512\":2,\"766\":1,\"770\":1,\"810\":2,\"817\":1,\"820\":1}}],[\"对于类和复杂数据类型来说\",{\"1\":{\"33\":1}}],[\"对于删除操作\",{\"1\":{\"23\":1}}],[\"对栈空间大小比较敏感\",{\"1\":{\"33\":1}}],[\"对应数据刷入内核缓冲区\",{\"1\":{\"952\":1}}],[\"对应0\",{\"1\":{\"943\":1}}],[\"对应\",{\"1\":{\"906\":1}}],[\"对应时刻\",{\"1\":{\"810\":2}}],[\"对应上面的2c\",{\"1\":{\"770\":1}}],[\"对应上面标红的12\",{\"1\":{\"770\":1}}],[\"对应事务中的回滚操作\",{\"1\":{\"764\":1,\"810\":1}}],[\"对应同一块\",{\"1\":{\"512\":1}}],[\"对应位置留空\",{\"1\":{\"330\":1}}],[\"对应的记录也就没用了\",{\"1\":{\"810\":1}}],[\"对应的事务状态设置为\",{\"1\":{\"765\":1,\"810\":2}}],[\"对应的\",{\"1\":{\"249\":1}}],[\"对应的二进制位设置为\",{\"1\":{\"20\":1}}],[\"对应两个系统调用brk和mmap\",{\"1\":{\"217\":1}}],[\"对应不同的集合\",{\"1\":{\"181\":1}}],[\"对应第几个数组\",{\"1\":{\"20\":1}}],[\"因而从这个角度来说\",{\"1\":{\"820\":2}}],[\"因为没有使用\",{\"1\":{\"957\":1}}],[\"因为没必要\",{\"1\":{\"770\":1}}],[\"因为如果决定走数据备份的方案\",{\"1\":{\"952\":1}}],[\"因为通常来说\",{\"1\":{\"949\":1}}],[\"因为更新容易带来时序性问题\",{\"1\":{\"930\":1}}],[\"因为更新相比删除会更容易造成时序性问题\",{\"1\":{\"930\":1}}],[\"因为超时并不会进入生成订单流程\",{\"1\":{\"927\":1}}],[\"因为秒杀有时候就是赔本赚吆喝\",{\"1\":{\"927\":1}}],[\"因为redis本身的数据持久化都是有时间空隙的\",{\"1\":{\"924\":1}}],[\"因为最大支持\",{\"1\":{\"900\":1}}],[\"因为执行本身不是瓶颈\",{\"1\":{\"888\":1}}],[\"因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用\",{\"1\":{\"873\":1}}],[\"因为再拼接时会检查\",{\"1\":{\"873\":1}}],[\"因为是拉链法处理扩容\",{\"1\":{\"864\":1}}],[\"因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是\",{\"1\":{\"820\":1}}],[\"因为向事务\",{\"1\":{\"820\":1}}],[\"因为都在相互等待对方释放锁\",{\"1\":{\"820\":1}}],[\"因为都是基于\",{\"1\":{\"770\":1}}],[\"因为需要对订单做幂等性校验\",{\"1\":{\"820\":1}}],[\"因为存在等值查询的条件\",{\"1\":{\"820\":1}}],[\"因为存储时\",{\"1\":{\"770\":1}}],[\"因为间隙锁的目的是防止插入幻影记录而提出的\",{\"1\":{\"820\":1}}],[\"因为另一个事务中的插入会被阻塞\",{\"1\":{\"820\":1}}],[\"因为申请不到\",{\"1\":{\"820\":1}}],[\"因为表锁的颗粒度太大\",{\"1\":{\"820\":1}}],[\"因为表数据和索引数据分别放在两个文件\",{\"1\":{\"770\":1}}],[\"因为优化器选择的访问类型为\",{\"1\":{\"817\":4}}],[\"因为查询主键索引的\",{\"1\":{\"817\":1}}],[\"因为查询的结果可能是\",{\"1\":{\"813\":1}}],[\"因为二级索引的\",{\"1\":{\"817\":1}}],[\"因为能很大程度提升连表查询的性能\",{\"1\":{\"813\":1}}],[\"因为要确保数据不重复\",{\"1\":{\"813\":1}}],[\"因为要复制到所有节点才返回响应\",{\"1\":{\"810\":1}}],[\"因为联合索引\",{\"1\":{\"813\":1}}],[\"因为索引有序\",{\"1\":{\"813\":1}}],[\"因为索引\",{\"1\":{\"813\":1}}],[\"因为范围查询\",{\"1\":{\"813\":1}}],[\"因为非叶子节点有\",{\"1\":{\"813\":1}}],[\"因为事务没提交的时候\",{\"1\":{\"810\":1}}],[\"因为当我们执行以下插入语句时\",{\"1\":{\"820\":1}}],[\"因为当我们对数据库表进行操作时\",{\"1\":{\"820\":1}}],[\"因为当事务提交了\",{\"1\":{\"820\":1}}],[\"因为当设置为\",{\"1\":{\"810\":1}}],[\"因为当执行\",{\"1\":{\"783\":1}}],[\"因为一旦主机发生异常重启\",{\"1\":{\"810\":1}}],[\"因为一个公钥加密的数据\",{\"1\":{\"249\":1}}],[\"因为数据还缓存在文件系统的\",{\"1\":{\"810\":1}}],[\"因为从库数量增加\",{\"1\":{\"810\":1}}],[\"因为参数\",{\"1\":{\"810\":1}}],[\"因为简单的数据类型\",{\"1\":{\"807\":1}}],[\"因为字段空值过多会影响索引性能\",{\"1\":{\"807\":1}}],[\"因为这种模式下只要写入数据就加载了缓存\",{\"1\":{\"930\":1}}],[\"因为这种特殊现象的存在\",{\"1\":{\"793\":1}}],[\"因为这条语句想加\",{\"1\":{\"820\":1}}],[\"因为这是更新操作\",{\"1\":{\"810\":2}}],[\"因为这是一条\",{\"1\":{\"810\":1}}],[\"因为这样会产生大量的\",{\"1\":{\"755\":1,\"810\":1}}],[\"因为多个事务同时使用相同的数据时\",{\"1\":{\"774\":1}}],[\"因为char多存储一些空格\",{\"1\":{\"770\":1}}],[\"因为channel是用来实现goroutine间通信的\",{\"1\":{\"258\":1}}],[\"因为我们的函数调用栈并不是\",{\"1\":{\"957\":1}}],[\"因为我们在算\",{\"1\":{\"770\":1}}],[\"因为我们这个案例是只有\",{\"1\":{\"770\":1}}],[\"因为只是简单的增加访可计数的方法并不完美\",{\"1\":{\"903\":1}}],[\"因为只要一个表有更新操作\",{\"1\":{\"817\":1}}],[\"因为只要\",{\"1\":{\"765\":1,\"810\":1}}],[\"因为只有一个\",{\"1\":{\"373\":1}}],[\"因为操作系统的文件系统中有个\",{\"1\":{\"756\":1,\"810\":2}}],[\"因为可以读到未提交事务修改的数据\",{\"1\":{\"784\":1}}],[\"因为可以让使用者清楚地知道哪些成员函数是安全的\",{\"1\":{\"33\":1}}],[\"因为可重复读隔离级别下\",{\"1\":{\"783\":1}}],[\"因为可能这期间另外一个事务修改了该记录\",{\"1\":{\"743\":1,\"810\":1}}],[\"因为写入缓存速度快\",{\"1\":{\"730\":1}}],[\"因为后端的任何一个环节都要考虑故障情况\",{\"1\":{\"706\":1}}],[\"因为错误的类型转换可能会导致程序崩溃\",{\"1\":{\"460\":1}}],[\"因为go中接口类型的方法调用都是动态\",{\"1\":{\"416\":1}}],[\"因为设置了\",{\"1\":{\"374\":1}}],[\"因为不符合最左匹配原则\",{\"1\":{\"813\":1}}],[\"因为不涉及磁盘\",{\"1\":{\"810\":1}}],[\"因为不是本文主题\",{\"1\":{\"249\":1}}],[\"因为不安全\",{\"1\":{\"33\":1}}],[\"因为标头在一系列请求中常常是相似的\",{\"1\":{\"249\":1}}],[\"因为各种现代浏览器都默认开通cookie功能\",{\"1\":{\"249\":1}}],[\"因为\",{\"1\":{\"249\":1,\"373\":1,\"381\":1,\"453\":1,\"461\":1,\"770\":2,\"810\":5,\"813\":4,\"817\":1,\"820\":2,\"879\":2,\"927\":1,\"952\":2}}],[\"因为客户端与服务器的整个连接过程很短暂\",{\"1\":{\"249\":1}}],[\"因为传输协议不同\",{\"1\":{\"237\":1}}],[\"因为内核会重用一个旧连接的五元组\",{\"1\":{\"237\":2}}],[\"因为在头部增加一个节点会导致后面的节点都往后移动\",{\"1\":{\"879\":1}}],[\"因为在可重复读的隔离级别下\",{\"1\":{\"820\":1}}],[\"因为在海量数据基于磁盘存储效率足够优秀\",{\"1\":{\"813\":1}}],[\"因为在\",{\"1\":{\"249\":1}}],[\"因为在内核维护了红黑树\",{\"1\":{\"226\":1}}],[\"因为在同一宿主机内的容器都接入同一个网桥\",{\"1\":{\"121\":1}}],[\"因为有key本身的过期时间作为保障\",{\"1\":{\"930\":1}}],[\"因为有\",{\"1\":{\"873\":1}}],[\"因为有查询优化器\",{\"1\":{\"813\":1}}],[\"因为有的命令是特定用户家目录里的\",{\"1\":{\"223\":1}}],[\"因为有可能存在名称相同但图片内容不同\",{\"1\":{\"75\":1}}],[\"因为程序运行符合局部性原理\",{\"1\":{\"217\":1}}],[\"因为消息不是从生产者直接发送到消费者的\",{\"1\":{\"156\":1}}],[\"因为它属于快照读\",{\"1\":{\"820\":2}}],[\"因为它将\",{\"1\":{\"817\":1}}],[\"因为它们会占用更少的磁盘\",{\"1\":{\"807\":1}}],[\"因为它有兜底完成\",{\"1\":{\"512\":1}}],[\"因为它是通过\",{\"1\":{\"820\":1}}],[\"因为它是基于现实世界的需求而设计的\",{\"1\":{\"249\":1}}],[\"因为它是随着互联网的发展而发展起来的\",{\"1\":{\"249\":1}}],[\"因为它是在预处理阶段即进行了宏展开\",{\"1\":{\"36\":1}}],[\"因为它可能会阻止你的解决方案通过\",{\"1\":{\"88\":1}}],[\"因为它可能在程序的其他部分或外部环境中被改变\",{\"1\":{\"33\":1}}],[\"因为它只是读取数据而不修改数据\",{\"1\":{\"23\":1}}],[\"因为编译器知道返回的对象即将被销毁\",{\"1\":{\"33\":1}}],[\"因为sizeof值在编译时确定\",{\"1\":{\"33\":1}}],[\"因为10\",{\"1\":{\"30\":1}}],[\"因此lfu\",{\"1\":{\"903\":1}}],[\"因此事务\",{\"1\":{\"820\":1}}],[\"因此是可以共存的\",{\"1\":{\"820\":1}}],[\"因此可以采用这种方式来备份数据库\",{\"1\":{\"820\":1}}],[\"因此可能会增加语句的响应时间\",{\"1\":{\"810\":1}}],[\"因此普通索引的数据插入会快一些\",{\"1\":{\"813\":1}}],[\"因此全文索引在检索中文时\",{\"1\":{\"813\":1}}],[\"因此全文索引的文件会额外的大\",{\"1\":{\"813\":1}}],[\"因此当修改字段值后\",{\"1\":{\"813\":1}}],[\"因此只有一个条件列是索引列是没有意义的\",{\"1\":{\"813\":1}}],[\"因此保证了事务写入的顺序\",{\"1\":{\"810\":1}}],[\"因此所以针对并发量大的系统\",{\"1\":{\"810\":1}}],[\"因此从这个版本之后\",{\"1\":{\"770\":1}}],[\"因此要有对应的同步机制和协调\",{\"1\":{\"706\":1}}],[\"因此要按照c语言进行编译\",{\"1\":{\"33\":1}}],[\"因此需要注意线程安全问题\",{\"1\":{\"662\":1}}],[\"因此如果发生错误\",{\"1\":{\"249\":1}}],[\"因此如果用户量很大的场景\",{\"1\":{\"249\":1}}],[\"因此对于session机制来说还需要一个备胎\",{\"1\":{\"249\":1}}],[\"因此就算参数中含有指令\",{\"1\":{\"243\":1}}],[\"因此在实际的网络环境中\",{\"1\":{\"226\":1}}],[\"因此都需要遍历文件描述符集合来找到可读或可写的\",{\"1\":{\"226\":1}}],[\"因此会先共享这份物理内存\",{\"1\":{\"217\":1}}],[\"因此无论这个事务有多大\",{\"1\":{\"760\":1,\"810\":1}}],[\"因此无法访问非静态成员变量和函数\",{\"1\":{\"33\":1}}],[\"因此无需进行幂等性验证\",{\"1\":{\"23\":1}}],[\"因此\",{\"1\":{\"33\":2,\"748\":1,\"766\":1,\"770\":1,\"810\":3,\"813\":1,\"820\":5,\"873\":2,\"903\":1,\"906\":1,\"918\":1,\"921\":1,\"927\":1,\"957\":1}}],[\"因此也无需进行幂等性验证\",{\"1\":{\"23\":1}}],[\"因此并非每个接口都应该被赋予幂等性验证\",{\"1\":{\"23\":1}}],[\"黑客会针对一个用户进行重复提交投票\",{\"1\":{\"23\":1}}],[\"恶意攻击\",{\"1\":{\"23\":1}}],[\"为不开启事物\",{\"1\":{\"978\":1}}],[\"为不完整\",{\"1\":{\"531\":1}}],[\"为我们提供了解决方案\",{\"1\":{\"957\":1}}],[\"为基础\",{\"1\":{\"930\":1}}],[\"为所有数据维护一个顺序列表\",{\"1\":{\"906\":1}}],[\"为多线程模式创建资源\",{\"1\":{\"897\":1}}],[\"为后续追加数据留余地\",{\"1\":{\"873\":1}}],[\"为实际的用户名\",{\"1\":{\"840\":1}}],[\"为该字段创建唯一索引\",{\"1\":{\"826\":1}}],[\"为该字段创建索引\",{\"1\":{\"826\":1}}],[\"为唯一二级索引\",{\"1\":{\"820\":1}}],[\"为唯一键\",{\"1\":{\"23\":1}}],[\"为查询结果\",{\"1\":{\"817\":1}}],[\"为查询语句\",{\"1\":{\"817\":1}}],[\"为此\",{\"1\":{\"810\":1}}],[\"为每一种\",{\"1\":{\"957\":1}}],[\"为每条记录保存多份历史数据\",{\"1\":{\"810\":1}}],[\"为每个消息分配一个全局唯一的标识符\",{\"1\":{\"714\":1}}],[\"为某个索引分配空间的时候就不再按照页为单位分配了\",{\"1\":{\"770\":1}}],[\"为单位分配\",{\"1\":{\"770\":1}}],[\"为单位的\",{\"1\":{\"770\":1}}],[\"为单位来读写的\",{\"1\":{\"770\":2}}],[\"为单位\",{\"1\":{\"770\":2}}],[\"为名的目录\",{\"1\":{\"770\":1}}],[\"为旧值就好了\",{\"1\":{\"741\":1}}],[\"为接口类型\",{\"1\":{\"469\":1}}],[\"为错误处理和多值返回提供了便利\",{\"1\":{\"430\":1}}],[\"为可执行文件\",{\"1\":{\"391\":1}}],[\"为例\",{\"1\":{\"249\":2,\"770\":1,\"873\":1}}],[\"为网际协议族\",{\"1\":{\"249\":1}}],[\"为什么说可能呢\",{\"1\":{\"930\":1}}],[\"为什么不直接更新呢\",{\"1\":{\"930\":1}}],[\"为什么不能以下标的形式修改字符串\",{\"1\":{\"356\":1}}],[\"为什么选择单线程\",{\"1\":{\"891\":1}}],[\"为什么只有\",{\"1\":{\"879\":1}}],[\"为什么间隙锁与间隙锁之间是兼容的\",{\"1\":{\"820\":1}}],[\"为什么上面事务\",{\"1\":{\"820\":1}}],[\"为什么会产生死锁\",{\"1\":{\"820\":1}}],[\"为什么唯一索引等值查询并且查询记录存在的场景下\",{\"1\":{\"820\":1}}],[\"为什么线程\",{\"1\":{\"820\":1}}],[\"为什么联合索引不遵循最左匹配原则就会失效\",{\"1\":{\"813\":1}}],[\"为什么锁竞争激烈\",{\"1\":{\"810\":1}}],[\"为什么两阶段提交的磁盘\",{\"1\":{\"810\":1}}],[\"为什么有了\",{\"1\":{\"810\":1}}],[\"为什么比\",{\"1\":{\"810\":1}}],[\"为什么需要\",{\"0\":{\"739\":1,\"751\":1},\"1\":{\"810\":3,\"873\":1}}],[\"为什么需要虚拟内存\",{\"1\":{\"217\":1}}],[\"为什么自己要置为\",{\"1\":{\"520\":1}}],[\"为什么是删除而不是更新\",{\"1\":{\"930\":1}}],[\"为什么是通常呢\",{\"1\":{\"879\":1}}],[\"为什么是\",{\"1\":{\"476\":1}}],[\"为什么先打印它\",{\"0\":{\"373\":1},\"1\":{\"367\":1}}],[\"为什么在堆上创建而不是栈上\",{\"1\":{\"258\":1}}],[\"为什么公钥自己加密的数据自己还解不出来\",{\"1\":{\"249\":1}}],[\"为什么默认关闭\",{\"1\":{\"237\":1}}],[\"为什么要衰减\",{\"1\":{\"903\":1}}],[\"为什么要过期\",{\"1\":{\"882\":1}}],[\"为什么要两阶段提交\",{\"1\":{\"810\":1}}],[\"为什么要多此一举\",{\"1\":{\"810\":1}}],[\"为什么要把数据集当成皮球一样踢来踢去呢\",{\"1\":{\"520\":1}}],[\"为什么要双向流转\",{\"0\":{\"520\":1}}],[\"为什么要设计分层网络模型\",{\"1\":{\"249\":1}}],[\"为什么要等待\",{\"1\":{\"237\":1}}],[\"为什么要这么设计\",{\"1\":{\"217\":1,\"810\":1}}],[\"为什么\",{\"1\":{\"217\":1,\"333\":1,\"770\":1,\"903\":1}}],[\"为\",{\"1\":{\"190\":1,\"265\":1,\"469\":1,\"516\":1,\"525\":1,\"531\":1,\"770\":1,\"810\":2,\"817\":2,\"820\":20,\"826\":2,\"873\":1,\"879\":2,\"885\":1,\"957\":2}}],[\"为空时\",{\"1\":{\"374\":1}}],[\"为空\",{\"0\":{\"183\":1}}],[\"为kafka内部的topic配置多副本\",{\"0\":{\"178\":1}}],[\"为用户的消息创建多副本\",{\"0\":{\"177\":1}}],[\"为了简单忽略错误处理\",{\"1\":{\"1059\":2}}],[\"为了满足不同需求\",{\"1\":{\"957\":1}}],[\"为了性能\",{\"1\":{\"927\":1}}],[\"为了打击黄牛\",{\"1\":{\"927\":1}}],[\"为了方便分析\",{\"1\":{\"918\":1,\"921\":1}}],[\"为了方便说明\",{\"1\":{\"810\":1}}],[\"为了保证核心单线程服务性能\",{\"1\":{\"906\":1}}],[\"为了保证这两个日志的一致性\",{\"1\":{\"765\":1,\"810\":1}}],[\"为了调高查找性能\",{\"1\":{\"885\":1}}],[\"为了避免\",{\"1\":{\"952\":1}}],[\"为了避免幻读\",{\"1\":{\"820\":1}}],[\"为了避免出现两份日志之间的逻辑不一致的问题\",{\"1\":{\"810\":1}}],[\"为了提高写入的性能\",{\"1\":{\"810\":1}}],[\"为了提高性能\",{\"1\":{\"313\":1}}],[\"为了防止断电导致数据丢失的问题\",{\"1\":{\"810\":1}}],[\"为了防止网络波动超时等造成请求失败\",{\"1\":{\"23\":1}}],[\"为了减少磁盘i\",{\"1\":{\"747\":1,\"810\":3}}],[\"为了继续执行\",{\"1\":{\"381\":1}}],[\"为了让服务端的公钥被大家信任\",{\"1\":{\"249\":1}}],[\"为了更优异的表现\",{\"1\":{\"249\":1}}],[\"为了生成\",{\"1\":{\"229\":1}}],[\"为了对这些副本更好的管理\",{\"1\":{\"181\":1}}],[\"为了实现高可用性和数据冗余\",{\"1\":{\"172\":1}}],[\"为了解决在同一毫秒内生成多个id时的冲突问题\",{\"1\":{\"92\":1}}],[\"为了解决这一问题\",{\"1\":{\"33\":1}}],[\"为了在分布式系统中保证每个机器生成的id的唯一性\",{\"1\":{\"92\":1}}],[\"为了应对客户端连续点击或调用方的超时重试等情况\",{\"1\":{\"23\":1}}],[\"rfc3339timeencoder\",{\"1\":{\"957\":1}}],[\"rfc规定\",{\"1\":{\"249\":1}}],[\"rdb文件内容\",{\"1\":{\"952\":1}}],[\"rdb文件结构\",{\"1\":{\"952\":1}}],[\"rdb\",{\"1\":{\"949\":2,\"952\":26},\"2\":{\"954\":1}}],[\"rdlist\",{\"1\":{\"226\":1}}],[\"rpop\",{\"1\":{\"867\":1}}],[\"rpush\",{\"1\":{\"867\":1,\"924\":1}}],[\"rpc\",{\"1\":{\"229\":5,\"249\":1},\"2\":{\"231\":1}}],[\"rpc请求在实现的时候都会添加超时重试机制\",{\"1\":{\"23\":1}}],[\"rr\",{\"0\":{\"783\":1},\"1\":{\"782\":1}}],[\"rc\",{\"1\":{\"782\":1}}],[\"rcdhe算法\",{\"1\":{\"240\":1}}],[\"ru\",{\"1\":{\"782\":1}}],[\"runqput\",{\"1\":{\"374\":1}}],[\"runq\",{\"1\":{\"374\":4}}],[\"runqsize\",{\"1\":{\"374\":5}}],[\"runnable\",{\"1\":{\"374\":1}}],[\"runnext\",{\"1\":{\"373\":5,\"374\":3}}],[\"running\",{\"1\":{\"229\":1}}],[\"runtimeexception\",{\"1\":{\"538\":1,\"545\":1}}],[\"runtime\",{\"1\":{\"104\":3,\"367\":2,\"373\":1,\"374\":1,\"378\":2}}],[\"run\",{\"1\":{\"104\":5,\"110\":3,\"113\":1,\"117\":5,\"119\":1,\"139\":1,\"141\":1,\"145\":2,\"223\":2,\"391\":1,\"700\":1,\"966\":1,\"970\":1,\"1024\":1,\"1026\":2,\"1031\":1,\"1040\":1}}],[\"runc\",{\"1\":{\"103\":3,\"104\":1}}],[\"rune\",{\"1\":{\"88\":5}}],[\"rw\",{\"1\":{\"471\":4}}],[\"ringbuffer\",{\"1\":{\"265\":3}}],[\"right++\",{\"1\":{\"88\":1}}],[\"right\",{\"1\":{\"88\":5}}],[\"rsa\",{\"1\":{\"249\":7}}],[\"rsa算法计算流程如下\",{\"1\":{\"249\":1}}],[\"rsa算法\",{\"1\":{\"240\":2,\"249\":1}}],[\"rv\",{\"1\":{\"249\":2}}],[\"rtt\",{\"1\":{\"237\":1,\"249\":3}}],[\"rbr\",{\"1\":{\"226\":1}}],[\"rb\",{\"1\":{\"226\":1}}],[\"r\",{\"1\":{\"202\":1,\"204\":1,\"207\":1,\"209\":1,\"470\":5,\"813\":1,\"980\":1,\"1024\":3,\"1026\":2,\"1031\":5,\"1033\":2,\"1036\":1,\"1037\":1,\"1040\":3,\"1059\":1}}],[\"rocketmq\",{\"1\":{\"924\":1}}],[\"roleerrcode\",{\"1\":{\"1030\":2}}],[\"role\",{\"1\":{\"851\":6}}],[\"rollback\",{\"1\":{\"810\":2,\"829\":1,\"1015\":3}}],[\"roll\",{\"1\":{\"742\":2,\"743\":1,\"770\":3,\"788\":1,\"810\":3}}],[\"rowsaffected\",{\"1\":{\"992\":1}}],[\"rows\",{\"1\":{\"770\":4,\"817\":1,\"820\":4}}],[\"row\",{\"1\":{\"770\":22,\"810\":5,\"813\":3,\"817\":1,\"820\":3,\"930\":1}}],[\"roundrobin\",{\"1\":{\"165\":1}}],[\"root\",{\"1\":{\"104\":1,\"137\":3,\"141\":1,\"145\":1,\"147\":1,\"190\":2,\"209\":1,\"223\":2,\"226\":1,\"770\":1,\"976\":4}}],[\"rabbitmq\",{\"1\":{\"924\":1}}],[\"raw\",{\"1\":{\"873\":7,\"1011\":1}}],[\"raed\",{\"1\":{\"531\":1}}],[\"radius\",{\"1\":{\"463\":3,\"470\":4}}],[\"raceaddr\",{\"1\":{\"265\":1}}],[\"raceacquire\",{\"1\":{\"265\":1}}],[\"raceenabled\",{\"1\":{\"265\":1}}],[\"random\",{\"1\":{\"249\":4,\"900\":2}}],[\"range表示使用了索引范围扫描\",{\"1\":{\"807\":1}}],[\"range\",{\"0\":{\"452\":1,\"453\":1,\"532\":1},\"1\":{\"165\":1,\"412\":1,\"413\":1,\"426\":1,\"452\":3,\"453\":7,\"458\":1,\"514\":1,\"515\":2,\"532\":4,\"807\":1,\"993\":2}}],[\"ram\",{\"1\":{\"220\":1}}],[\"ramey\",{\"1\":{\"190\":1}}],[\"rainbow\",{\"1\":{\"8\":3}}],[\"rmdir\",{\"1\":{\"201\":1}}],[\"rmi\",{\"0\":{\"137\":1},\"1\":{\"137\":3}}],[\"rm\",{\"1\":{\"111\":1,\"119\":1,\"142\":4,\"202\":1,\"209\":1}}],[\"reason\",{\"1\":{\"962\":3}}],[\"reactor\",{\"1\":{\"888\":2}}],[\"readall\",{\"1\":{\"1037\":1}}],[\"readme\",{\"1\":{\"962\":6}}],[\"readmap没有的\",{\"1\":{\"516\":1}}],[\"readmap\",{\"1\":{\"512\":5,\"516\":1,\"518\":1,\"519\":1,\"524\":2,\"525\":1,\"529\":1}}],[\"ready\",{\"1\":{\"944\":1}}],[\"read任务队列中\",{\"1\":{\"897\":1}}],[\"readqueryfromclient命令读取处理器与新连接对应的文件描述符关联起来\",{\"1\":{\"897\":1}}],[\"readview\",{\"0\":{\"743\":1,\"744\":1},\"1\":{\"743\":6,\"744\":8,\"793\":1,\"810\":2}}],[\"readline\",{\"1\":{\"541\":1,\"542\":1}}],[\"readfile\",{\"1\":{\"541\":1,\"542\":2}}],[\"read中获取\",{\"1\":{\"529\":1}}],[\"reading\",{\"1\":{\"471\":2}}],[\"readwriter\",{\"1\":{\"471\":2}}],[\"reader\",{\"1\":{\"471\":2,\"541\":2,\"542\":3}}],[\"read\",{\"0\":{\"518\":1,\"519\":1,\"777\":1,\"778\":1,\"779\":1,\"787\":1},\"1\":{\"113\":1,\"226\":8,\"471\":3,\"510\":1,\"512\":2,\"515\":1,\"516\":5,\"518\":2,\"519\":1,\"520\":5,\"524\":2,\"525\":5,\"526\":2,\"527\":1,\"529\":16,\"530\":3,\"531\":13,\"532\":8,\"782\":3,\"784\":5,\"789\":6,\"791\":2,\"796\":1,\"810\":7,\"813\":2,\"817\":5,\"820\":6,\"930\":3}}],[\"readonly\",{\"1\":{\"113\":2,\"516\":3,\"529\":1,\"530\":1,\"531\":1,\"532\":1}}],[\"rehashidx\",{\"1\":{\"864\":3,\"942\":1}}],[\"rehash\",{\"1\":{\"864\":7}}],[\"reidsdb\",{\"1\":{\"894\":2}}],[\"reids\",{\"1\":{\"864\":1,\"873\":1,\"885\":1,\"888\":1,\"891\":2,\"894\":1,\"927\":3}}],[\"rename\",{\"1\":{\"840\":2}}],[\"reward列\",{\"1\":{\"817\":1}}],[\"reward\",{\"1\":{\"817\":11}}],[\"redlock也不能扛住npc的挑战\",{\"1\":{\"918\":1,\"921\":1}}],[\"redlock算做了些考量\",{\"1\":{\"918\":1,\"921\":1}}],[\"redlock\",{\"0\":{\"918\":1},\"1\":{\"921\":1}}],[\"redlcok\",{\"1\":{\"917\":1,\"921\":1}}],[\"redundant\",{\"1\":{\"770\":4}}],[\"redo\",{\"1\":{\"751\":3,\"752\":1,\"753\":4,\"754\":1,\"755\":7,\"756\":13,\"757\":1,\"763\":5,\"765\":5,\"766\":1,\"775\":1,\"802\":1,\"810\":158,\"927\":1},\"2\":{\"769\":1,\"812\":1}}],[\"redolog和\",{\"1\":{\"763\":1}}],[\"redolog与数据分开写入磁盘的必要性\",{\"0\":{\"754\":1}}],[\"redolog\",{\"0\":{\"750\":1,\"751\":1,\"752\":1,\"753\":1,\"755\":1,\"756\":1,\"757\":1},\"1\":{\"735\":1,\"737\":2,\"745\":3,\"751\":1,\"752\":3,\"753\":6,\"757\":2,\"765\":2,\"810\":4}}],[\"redirection\",{\"1\":{\"249\":1}}],[\"redis不但将新的操作记录在原\",{\"1\":{\"952\":1}}],[\"redis不做处理\",{\"1\":{\"930\":1}}],[\"redis可以在aof文件体积变得过大时\",{\"1\":{\"952\":1}}],[\"redis源码中一共有4个时机\",{\"1\":{\"952\":1}}],[\"redis持久化机制详解\",{\"0\":{\"952\":1}}],[\"redisdb\",{\"0\":{\"943\":1,\"944\":1,\"946\":1},\"1\":{\"942\":1,\"943\":2,\"944\":3,\"946\":1}}],[\"redis内存数据管理详解\",{\"0\":{\"936\":1}}],[\"redis内存存储结构详解\",{\"0\":{\"894\":1}}],[\"redis中都是老旧数据\",{\"1\":{\"930\":1}}],[\"redis中有expire命令\",{\"1\":{\"911\":1,\"921\":1}}],[\"redis的更新对业务方透明\",{\"1\":{\"930\":1}}],[\"redis的数据就先变成了5\",{\"1\":{\"930\":1}}],[\"redis的淘汰池是一个字典结构\",{\"1\":{\"906\":1}}],[\"redis原生接口\",{\"1\":{\"930\":1}}],[\"redis由于性能高效\",{\"1\":{\"930\":1}}],[\"redis场景应用一\",{\"1\":{\"930\":1}}],[\"redis缓存系统详解\",{\"0\":{\"930\":1}}],[\"redis有时候也可以扮演队列的角色\",{\"1\":{\"927\":1}}],[\"redis扮演扣减库存的角色\",{\"1\":{\"927\":1}}],[\"redis角色\",{\"1\":{\"927\":1}}],[\"redis➕lua\",{\"1\":{\"927\":2}}],[\"redis实现限流器详解\",{\"0\":{\"933\":1}}],[\"redis实现秒杀系统详解\",{\"0\":{\"927\":1}}],[\"redis实现分布式锁的方式\",{\"1\":{\"909\":1}}],[\"redis这三种\",{\"1\":{\"924\":1}}],[\"redis消息队列实现详解\",{\"0\":{\"924\":1}}],[\"redis分布式锁实现详解\",{\"0\":{\"921\":1}}],[\"redis还有个特性\",{\"1\":{\"913\":1,\"921\":1}}],[\"redis+lua\",{\"1\":{\"913\":1,\"921\":1}}],[\"redis考虑到了这种场景\",{\"1\":{\"911\":1}}],[\"redis锁机制详解\",{\"0\":{\"909\":1}}],[\"redis需要使用哈希表算法来查找大于当前最大可用内存的键\",{\"1\":{\"906\":1}}],[\"redis3\",{\"1\":{\"906\":1}}],[\"redis如何选择要删除的内容\",{\"1\":{\"900\":1}}],[\"redis数据存储容量分析\",{\"0\":{\"900\":1}}],[\"redis多线程机制详解\",{\"0\":{\"897\":1}}],[\"redis单线程与多线程模型对比\",{\"0\":{\"891\":1}}],[\"redis单线程高性能原理解析\",{\"0\":{\"888\":1}}],[\"redis5\",{\"1\":{\"885\":1}}],[\"redis跳表实现详解\",{\"0\":{\"885\":1}}],[\"redis对象过期机制详解\",{\"0\":{\"882\":1}}],[\"redis压缩列表详解\",{\"0\":{\"879\":1}}],[\"redisobject\",{\"0\":{\"937\":1,\"938\":1,\"940\":1},\"1\":{\"873\":1,\"903\":1,\"906\":1,\"939\":1,\"940\":2,\"941\":2,\"942\":1,\"944\":3}}],[\"redis使用scan\",{\"1\":{\"870\":1}}],[\"redis哈希表底层结构详解\",{\"0\":{\"864\":1}}],[\"redis\",{\"0\":{\"252\":1,\"861\":1,\"867\":1,\"870\":1,\"873\":1,\"876\":1,\"903\":1,\"906\":1,\"945\":1,\"949\":1},\"1\":{\"135\":1,\"147\":1,\"226\":1,\"714\":2,\"715\":1,\"730\":2,\"807\":2,\"864\":1,\"867\":1,\"873\":7,\"879\":1,\"882\":4,\"885\":6,\"888\":10,\"891\":2,\"894\":5,\"897\":7,\"900\":1,\"906\":7,\"909\":1,\"921\":1,\"924\":3,\"927\":3,\"930\":2,\"936\":4,\"937\":2,\"938\":1,\"939\":1,\"940\":1,\"941\":2,\"942\":1,\"943\":1,\"944\":3,\"945\":2,\"949\":4,\"952\":17},\"2\":{\"862\":1,\"863\":1,\"865\":1,\"866\":1,\"868\":1,\"869\":1,\"871\":1,\"872\":1,\"874\":1,\"875\":1,\"877\":1,\"878\":1,\"880\":1,\"881\":1,\"883\":1,\"884\":1,\"886\":1,\"887\":1,\"889\":1,\"890\":1,\"892\":1,\"893\":1,\"895\":1,\"896\":1,\"898\":1,\"899\":1,\"901\":1,\"902\":1,\"904\":1,\"905\":1,\"907\":1,\"908\":1,\"919\":1,\"920\":1,\"922\":1,\"923\":1,\"925\":1,\"926\":1,\"928\":1,\"929\":1,\"931\":1,\"932\":1,\"934\":1,\"935\":1,\"947\":1,\"948\":1,\"950\":1,\"951\":1,\"953\":1,\"954\":1}}],[\"req\",{\"1\":{\"662\":2,\"664\":1,\"1021\":2}}],[\"requestdispatcher\",{\"1\":{\"681\":1}}],[\"requestdestroyed\",{\"1\":{\"626\":1}}],[\"requestattributelistener\",{\"1\":{\"635\":1}}],[\"requeststarttime\",{\"1\":{\"626\":2}}],[\"requests默认是100\",{\"1\":{\"237\":1}}],[\"requestinitialized\",{\"1\":{\"626\":1}}],[\"requestloglistener<\",{\"1\":{\"627\":1}}],[\"requestloglistener\",{\"1\":{\"626\":1}}],[\"requesturi\",{\"1\":{\"584\":2,\"598\":7,\"600\":3,\"626\":4,\"635\":6}}],[\"request\",{\"1\":{\"584\":4,\"591\":2,\"596\":4,\"598\":3,\"599\":3,\"600\":3,\"601\":2,\"626\":9,\"635\":6,\"652\":1,\"670\":4,\"671\":2,\"672\":4,\"673\":2,\"681\":3,\"683\":2,\"687\":2,\"689\":4,\"691\":1,\"692\":3,\"693\":2,\"1021\":1,\"1059\":1}}],[\"refcount\",{\"1\":{\"940\":2}}],[\"ref和ref表示通过索引查找记录\",{\"1\":{\"807\":1}}],[\"ref\",{\"1\":{\"807\":2}}],[\"reflect\",{\"1\":{\"559\":3}}],[\"reflectiondemo\",{\"1\":{\"555\":1}}],[\"reflection\",{\"1\":{\"550\":1}}],[\"referer\",{\"1\":{\"249\":2}}],[\"referer=xxx\",{\"1\":{\"249\":1}}],[\"revoke生效时机\",{\"1\":{\"847\":1}}],[\"revoke语法\",{\"1\":{\"847\":1}}],[\"revoke\",{\"1\":{\"829\":1,\"847\":1}}],[\"revocer\",{\"1\":{\"479\":1}}],[\"revents\",{\"1\":{\"226\":2}}],[\"release\",{\"1\":{\"1027\":1}}],[\"releasetime\",{\"1\":{\"265\":1}}],[\"relay\",{\"1\":{\"730\":1,\"761\":1,\"810\":2}}],[\"relative\",{\"1\":{\"229\":2,\"940\":1}}],[\"reuse\",{\"1\":{\"237\":3}}],[\"remoteaddr\",{\"1\":{\"584\":2,\"626\":2}}],[\"remote\",{\"1\":{\"229\":1}}],[\"removeattribute\",{\"1\":{\"637\":1}}],[\"remove\",{\"1\":{\"201\":1,\"202\":1,\"641\":3}}],[\"rec\",{\"1\":{\"820\":4}}],[\"rectangle\",{\"1\":{\"470\":3}}],[\"received\",{\"1\":{\"265\":1}}],[\"recvq\",{\"1\":{\"265\":1}}],[\"recvq可以理解为\",{\"1\":{\"261\":1}}],[\"recvx++\",{\"1\":{\"265\":1}}],[\"recvx\",{\"1\":{\"265\":3}}],[\"recv\",{\"1\":{\"226\":3,\"265\":1,\"888\":2}}],[\"record\",{\"1\":{\"770\":2,\"817\":5,\"820\":11}}],[\"records\",{\"1\":{\"162\":1,\"770\":1}}],[\"recover捕获异常\",{\"1\":{\"475\":1}}],[\"recover\",{\"0\":{\"475\":1},\"1\":{\"479\":7,\"509\":1}}],[\"recommended\",{\"1\":{\"33\":1}}],[\"reboot\",{\"1\":{\"204\":2}}],[\"repo\",{\"1\":{\"962\":3}}],[\"repository\",{\"1\":{\"134\":1}}],[\"replace\",{\"1\":{\"957\":2}}],[\"replacedefault\",{\"1\":{\"957\":2}}],[\"replication\",{\"1\":{\"177\":1}}],[\"replica是指kafka集群中的一个副本\",{\"1\":{\"170\":1}}],[\"replica\",{\"1\":{\"157\":1,\"170\":1,\"172\":1}}],[\"repeatable\",{\"0\":{\"778\":1},\"1\":{\"782\":1}}],[\"repeat\",{\"1\":{\"503\":2}}],[\"repeated\",{\"1\":{\"229\":6}}],[\"repeated表示一个字段可以包含零个或多个值\",{\"1\":{\"229\":1}}],[\"reset\",{\"1\":{\"817\":2}}],[\"resp\",{\"1\":{\"662\":2}}],[\"responsewriter\",{\"1\":{\"1021\":1,\"1059\":1}}],[\"response\",{\"1\":{\"249\":1,\"584\":2,\"591\":2,\"596\":4,\"598\":3,\"599\":4,\"600\":2,\"601\":3,\"652\":3,\"675\":2,\"676\":2,\"677\":2,\"678\":1,\"681\":2,\"682\":1,\"683\":2,\"688\":2,\"689\":2,\"692\":1,\"693\":2,\"1021\":3}}],[\"res++\",{\"1\":{\"477\":1}}],[\"res\",{\"1\":{\"453\":10,\"477\":7,\"664\":1,\"1021\":2}}],[\"resourcemanagementdemo\",{\"1\":{\"541\":1}}],[\"resources\",{\"0\":{\"541\":1}}],[\"resource\",{\"1\":{\"223\":1,\"249\":3}}],[\"resolution\",{\"1\":{\"33\":2}}],[\"restart\",{\"1\":{\"143\":1}}],[\"rest\",{\"1\":{\"101\":1}}],[\"results\",{\"1\":{\"229\":2}}],[\"result是另一个消息类型\",{\"1\":{\"229\":1}}],[\"result\",{\"1\":{\"33\":6,\"229\":4,\"427\":2,\"441\":1,\"453\":2,\"468\":1,\"469\":1,\"476\":1,\"477\":3,\"505\":4,\"510\":1,\"540\":2,\"559\":3,\"854\":1}}],[\"return并非一个原子操作\",{\"1\":{\"477\":1}}],[\"returns\",{\"1\":{\"229\":1}}],[\"return\",{\"0\":{\"477\":1},\"1\":{\"30\":2,\"33\":6,\"46\":2,\"226\":1,\"265\":5,\"374\":2,\"410\":1,\"423\":1,\"425\":4,\"426\":1,\"427\":2,\"458\":1,\"460\":1,\"463\":1,\"465\":3,\"470\":2,\"473\":1,\"476\":1,\"477\":3,\"483\":2,\"487\":1,\"489\":1,\"490\":1,\"491\":1,\"514\":1,\"515\":1,\"529\":2,\"530\":1,\"531\":5,\"540\":1,\"546\":1,\"559\":2,\"568\":1,\"625\":1,\"641\":2,\"693\":2,\"699\":1,\"957\":11,\"1014\":3,\"1037\":1,\"1059\":3}}],[\"这有别于使用\",{\"1\":{\"957\":1}}],[\"这句话简单明了的概括了\",{\"1\":{\"955\":1}}],[\"这点从5\",{\"1\":{\"949\":1}}],[\"这点redlock是无法解决的\",{\"1\":{\"918\":1,\"921\":1}}],[\"这需要对binlog文件以及mysql有非常深入的理解\",{\"1\":{\"930\":1}}],[\"这更让人疑惑和不能接受\",{\"1\":{\"930\":1}}],[\"这将使\",{\"1\":{\"957\":1}}],[\"这将导致这个不存在的数据每次请求都要到存储层去查询\",{\"1\":{\"930\":1}}],[\"这将加速提升\",{\"1\":{\"529\":1}}],[\"这四种策略\",{\"1\":{\"900\":1}}],[\"这主要是通过\",{\"1\":{\"820\":1}}],[\"这非常影响性能\",{\"1\":{\"813\":1}}],[\"这通常取决于具体的数据库系统和查询优化器的实现\",{\"1\":{\"813\":1}}],[\"这通常意味着效率很高\",{\"1\":{\"807\":1}}],[\"这被称为\",{\"1\":{\"813\":1}}],[\"这取决于是否能在\",{\"1\":{\"810\":1}}],[\"这在处理分布式事务和两阶段提交\",{\"1\":{\"810\":1}}],[\"这在实现身份验证等功能时非常有用\",{\"1\":{\"591\":1}}],[\"这三个参数的数据安全性和写入性能的比较如下\",{\"1\":{\"810\":1}}],[\"这三个参数的应用场景是什么\",{\"1\":{\"810\":1}}],[\"这三个值分别代表的策略如下\",{\"1\":{\"810\":1}}],[\"这三个文件分别代表着\",{\"1\":{\"770\":1}}],[\"这三种日志\",{\"1\":{\"810\":1}}],[\"这属于\",{\"1\":{\"810\":1}}],[\"这类当前读的语句\",{\"1\":{\"795\":1}}],[\"这条语句\",{\"1\":{\"820\":2}}],[\"这条查询语句的查询条件没有用到索引\",{\"1\":{\"817\":1}}],[\"这条查询语句的查询条件用到了主键索引\",{\"1\":{\"817\":1}}],[\"这条查询语句的结果既可以使用主键索引\",{\"1\":{\"817\":1}}],[\"这条新记录的\",{\"1\":{\"793\":1}}],[\"这条记录加上了\",{\"1\":{\"820\":1}}],[\"这条记录了\",{\"1\":{\"820\":1}}],[\"这条记录进行了更新操作\",{\"1\":{\"793\":1}}],[\"这条记录\",{\"1\":{\"793\":2,\"820\":1}}],[\"这场景确实很违和\",{\"1\":{\"793\":1}}],[\"这部分不需要\",{\"1\":{\"770\":1}}],[\"这行数据的字段\",{\"1\":{\"810\":1}}],[\"这行数据的\",{\"1\":{\"763\":2,\"810\":2}}],[\"这带来了更高的灵活性\",{\"1\":{\"460\":1}}],[\"这一点在使用上显然不如\",{\"1\":{\"957\":1}}],[\"这一点要尽可能保证\",{\"1\":{\"909\":1,\"921\":1}}],[\"这一步受刷盘策略影响是最深的\",{\"1\":{\"952\":1}}],[\"这一步就是让dirty也能有这个key和entry\",{\"1\":{\"531\":1}}],[\"这一通下操作都不是原子化的\",{\"1\":{\"913\":1,\"921\":1}}],[\"这一行所在的数据页本来就在\",{\"1\":{\"810\":2}}],[\"这一行记录\",{\"1\":{\"810\":2}}],[\"这一个地址最终指向的是\",{\"1\":{\"453\":1}}],[\"这一层包括所有高级协议\",{\"1\":{\"249\":1}}],[\"这时可能会发生哈希冲突\",{\"1\":{\"945\":1}}],[\"这时由于并发用户特别多\",{\"1\":{\"930\":1}}],[\"这时也可以将key\",{\"1\":{\"930\":1}}],[\"这时的用户很可能是攻击者\",{\"1\":{\"930\":1}}],[\"这时会判断到插入的位置已经被事务\",{\"1\":{\"820\":1}}],[\"这时会发生内存逃逸\",{\"1\":{\"405\":1}}],[\"这时从库是按\",{\"1\":{\"820\":1}}],[\"这时数据库的线程很快就会爆满了\",{\"1\":{\"820\":1}}],[\"这时线程\",{\"1\":{\"820\":1}}],[\"这时其他线程执行以下操作\",{\"1\":{\"820\":1}}],[\"这时就不再是纯粹的索引覆盖\",{\"1\":{\"813\":1}}],[\"这时就会发生重复提交表单请求\",{\"1\":{\"23\":1}}],[\"这时\",{\"1\":{\"810\":1,\"817\":3,\"820\":1}}],[\"这时一个页可能就存不了一条记录\",{\"1\":{\"770\":1}}],[\"这时候竞争者b拿到了锁\",{\"1\":{\"918\":1,\"921\":1}}],[\"这时候gc回来了\",{\"1\":{\"918\":1,\"921\":1}}],[\"这时候\",{\"1\":{\"912\":1,\"921\":1}}],[\"这时候去尝试释放一些内存\",{\"1\":{\"900\":1}}],[\"这时候接待你的就是连接器\",{\"1\":{\"817\":1}}],[\"这时候的性能是最好的\",{\"1\":{\"810\":1}}],[\"这时候我们擦除这些旧记录\",{\"1\":{\"810\":1}}],[\"这时候怎么表示\",{\"1\":{\"770\":1}}],[\"这时候表里的行格式就不会有\",{\"1\":{\"770\":2}}],[\"这时更新操作就算完成了\",{\"1\":{\"751\":1}}],[\"这段话表明尽管\",{\"1\":{\"820\":1}}],[\"这段\",{\"1\":{\"373\":1}}],[\"这8个键值对不是按照key\",{\"1\":{\"330\":1}}],[\"这意味着即使系统发生故障或重启\",{\"1\":{\"710\":1}}],[\"这意味着\",{\"1\":{\"459\":1,\"820\":1}}],[\"这意味着只有\",{\"1\":{\"249\":1}}],[\"这意味着每个进程都有一份独立的用户空间划分\",{\"1\":{\"217\":1}}],[\"这包括处理与物理网络硬件\",{\"1\":{\"249\":1}}],[\"这包括用来管理计算机资源的核心层软件\",{\"1\":{\"220\":1}}],[\"这当然是可以的\",{\"1\":{\"229\":1}}],[\"这颗树中存储着所有添加到epoll中的需要监控的事件\",{\"1\":{\"226\":1}}],[\"这可以帮助释放存储空间\",{\"1\":{\"807\":1}}],[\"这可以减少维护成本并提高写操作的性能\",{\"1\":{\"807\":1}}],[\"这可以在一个单独的进程或线程中同时处理多个i\",{\"1\":{\"226\":1}}],[\"这可能导致数据包被误导\",{\"1\":{\"237\":2}}],[\"这可能导致未定义行为\",{\"1\":{\"33\":2}}],[\"这期间\",{\"1\":{\"226\":1}}],[\"这些部分用于确定创建哈希的设置\",{\"1\":{\"1056\":1}}],[\"这些命令整体上会作为原子操作来进行\",{\"1\":{\"927\":1}}],[\"这些命令将启动或停止mysql服务器\",{\"1\":{\"835\":1}}],[\"这些都是额外的工作\",{\"1\":{\"882\":1}}],[\"这些条件必然成立\",{\"1\":{\"820\":1}}],[\"这些连接对象资源只有在连接断开时才会释放\",{\"1\":{\"817\":1}}],[\"这些分词结果也会被存储在全文索引中\",{\"1\":{\"813\":1}}],[\"这些缓存在\",{\"1\":{\"810\":1}}],[\"这些函数\",{\"1\":{\"810\":1}}],[\"这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放\",{\"1\":{\"770\":1}}],[\"这些信息会先写入\",{\"1\":{\"753\":1}}],[\"这些小的操作分布在不同的服务器上\",{\"1\":{\"727\":1}}],[\"这些哈希槽将用于将客户分配到不同的队列中\",{\"1\":{\"723\":1}}],[\"这些副本是独立的\",{\"1\":{\"455\":1}}],[\"这些方法地址实际上是从interfacetype结构中的mhdr\",{\"1\":{\"307\":1}}],[\"这些等待队列使用双向链表waitq表示\",{\"1\":{\"259\":1}}],[\"这些错误可能是服务器本身的错误\",{\"1\":{\"249\":1}}],[\"这些状态代码表示服务器在尝试处理请求时发生内部错误\",{\"1\":{\"249\":1}}],[\"这些状态代码表示请求可能出错\",{\"1\":{\"249\":1}}],[\"这些状态代码用来重定向\",{\"1\":{\"249\":1}}],[\"这些\",{\"1\":{\"249\":1}}],[\"这些网络服务器会对\",{\"1\":{\"243\":1}}],[\"这些字段都是以\",{\"1\":{\"229\":1}}],[\"这些没啥可说的\",{\"1\":{\"223\":1}}],[\"这些消息存储在kafka集群的不同节点\",{\"1\":{\"172\":1}}],[\"这也会会带来危险\",{\"1\":{\"839\":1}}],[\"这也是配置决定\",{\"1\":{\"952\":1}}],[\"这也是我们打过很多次交道的老朋友了\",{\"1\":{\"952\":1}}],[\"这也是\",{\"1\":{\"747\":1,\"956\":1}}],[\"这也是枚举类型的默认值\",{\"1\":{\"229\":1}}],[\"这也是和设备挂载相关的一个文件夹\",{\"1\":{\"223\":1}}],[\"这也意味着外部网络无法通过直接\",{\"1\":{\"121\":1}}],[\"这显然就降低了这俩地址转换的速度\",{\"1\":{\"217\":1}}],[\"这款\",{\"1\":{\"190\":1}}],[\"这就出现数据对不上的问题\",{\"1\":{\"930\":1}}],[\"这就叫\",{\"1\":{\"743\":1,\"810\":1}}],[\"这就代表read和dirty都有个nil的entry\",{\"1\":{\"531\":1}}],[\"这就形成了激烈的锁竞争\",{\"1\":{\"381\":1}}],[\"这就形成了一个先进先出的\",{\"1\":{\"249\":1}}],[\"这就降低了编程的难度\",{\"1\":{\"378\":1}}],[\"这就能在有限的内存空间内支持大量\",{\"1\":{\"378\":1}}],[\"这就是生产环境日志输出的时间格式为\",{\"1\":{\"957\":1}}],[\"这就是漏洞\",{\"1\":{\"930\":1}}],[\"这就是事务四大特性中的隔离性\",{\"1\":{\"820\":1}}],[\"这就是表明使用了覆盖索引优化\",{\"1\":{\"817\":1}}],[\"这就是一主多从的\",{\"1\":{\"810\":1}}],[\"这就是\",{\"1\":{\"751\":1,\"810\":3}}],[\"这就是非对称加密的核心机密\",{\"1\":{\"249\":1}}],[\"这就是默认输出模式\",{\"1\":{\"229\":1}}],[\"这就是为什么\",{\"1\":{\"223\":1}}],[\"这就解决了多进程之间地址冲突的问题\",{\"1\":{\"217\":1}}],[\"这就意味着如果partition数量变了\",{\"1\":{\"164\":1}}],[\"这就避免了空指针的问题\",{\"1\":{\"33\":1}}],[\"这对于应用程序来说\",{\"1\":{\"930\":1}}],[\"这对于类的接口设计非常重要\",{\"1\":{\"33\":1}}],[\"这对接口一端在容器内\",{\"1\":{\"123\":1}}],[\"这是另外一种类型的攻击\",{\"1\":{\"1052\":1}}],[\"这是通过对主键字段声明\",{\"1\":{\"820\":1}}],[\"这是使用utf8mb4编码的\",{\"1\":{\"770\":1}}],[\"这是mysql层的描述\",{\"1\":{\"770\":1}}],[\"这是因为申请\",{\"1\":{\"820\":1}}],[\"这是因为有一个线程只能同时有一个事务在执行的设定\",{\"1\":{\"810\":1}}],[\"这是因为\",{\"1\":{\"810\":2,\"813\":1}}],[\"这是因为我们存储字段类型为\",{\"1\":{\"770\":1}}],[\"这是因为只有这些虚拟内存被访问后\",{\"1\":{\"748\":1,\"810\":1}}],[\"这是默认值\",{\"1\":{\"756\":1}}],[\"这是最简单的做法\",{\"1\":{\"720\":1}}],[\"这是最常见的i\",{\"1\":{\"226\":1}}],[\"这是\",{\"1\":{\"460\":1,\"867\":1}}],[\"这是区别于c语言等传统语言的一个重要特性\",{\"1\":{\"420\":1}}],[\"这是一个优秀的日志库必备功能\",{\"1\":{\"956\":1}}],[\"这是一个重要的字段\",{\"1\":{\"807\":1}}],[\"这是一个线性时间复杂度\",{\"1\":{\"527\":1}}],[\"这是一个故意的设计选择\",{\"1\":{\"459\":1}}],[\"这是一个多路复用协议\",{\"1\":{\"249\":1}}],[\"这是一个非常简单的\",{\"1\":{\"249\":1}}],[\"这是传输层的机制\",{\"1\":{\"237\":1}}],[\"这是无法忍受的\",{\"1\":{\"229\":1}}],[\"这是普通用户的家目录\",{\"1\":{\"223\":1}}],[\"这是我的家目录的部分文件\",{\"1\":{\"223\":1}}],[\"这是我的\",{\"1\":{\"223\":1}}],[\"这是非常大的内存了\",{\"1\":{\"217\":1}}],[\"这是从副本\",{\"1\":{\"174\":1}}],[\"这是当前分区的主副本\",{\"1\":{\"174\":1}}],[\"这是容器与直接运行在主机上进程的本质区别\",{\"1\":{\"98\":1}}],[\"这是c++类对象传递的标准方式\",{\"1\":{\"33\":1}}],[\"这应该是预处理功能三种\",{\"1\":{\"36\":1}}],[\"这都需要一定的时间\",{\"1\":{\"36\":1}}],[\"这称为覆盖索引\",{\"1\":{\"807\":1}}],[\"这称为\",{\"1\":{\"36\":1}}],[\"这里通常维护一些本地调试用的样例配置文件\",{\"1\":{\"962\":1}}],[\"这里就不多介绍了\",{\"1\":{\"957\":1}}],[\"这里就会涉及磁盘\",{\"1\":{\"810\":1}}],[\"这里其实是支持一个刷盘时机的配置\",{\"1\":{\"952\":1}}],[\"这里有两个问题\",{\"1\":{\"918\":1,\"921\":1}}],[\"这里有图文讲解redis\",{\"1\":{\"879\":1}}],[\"这里为所有线程\",{\"1\":{\"897\":1}}],[\"这里\",{\"1\":{\"820\":2,\"885\":1}}],[\"这里只关注在记录上加锁的类型\",{\"1\":{\"820\":4}}],[\"这里我们列举两个场景\",{\"1\":{\"820\":1}}],[\"这里我们重点关注行锁\",{\"1\":{\"820\":1}}],[\"这里的操作分两种方式\",{\"1\":{\"930\":1}}],[\"这里的活性低就是空闲时间长\",{\"1\":{\"906\":1}}],[\"这里的共同间隙包括两种场景\",{\"1\":{\"820\":1}}],[\"这里的文件也不是真正的文件\",{\"1\":{\"223\":1}}],[\"这里在查询记录是否存在的时候\",{\"1\":{\"820\":1}}],[\"这里一张用户表如下\",{\"1\":{\"817\":1}}],[\"这里说的查询缓存是\",{\"1\":{\"817\":1}}],[\"这里包含了所有的\",{\"1\":{\"813\":1}}],[\"这里面包括了所有\",{\"1\":{\"813\":1}}],[\"这里涉及磁盘i\",{\"1\":{\"760\":1}}],[\"这里不考虑这种情况\",{\"1\":{\"820\":1}}],[\"这里不说组提交的过程\",{\"1\":{\"810\":1}}],[\"这里不涉及磁盘i\",{\"1\":{\"760\":1}}],[\"这里不会调用析构函数\",{\"1\":{\"33\":1}}],[\"这里不会调用构造函数\",{\"1\":{\"33\":1}}],[\"这里附上一张更具体的图来辅助理解\",{\"1\":{\"748\":1}}],[\"这里会考虑索引的使用\",{\"1\":{\"734\":1}}],[\"这里会涉及到数据的双向流转机制\",{\"1\":{\"512\":1}}],[\"这里会有一个以你用户名命名的文件夹\",{\"1\":{\"223\":1}}],[\"这里会有隐式类型转换\",{\"1\":{\"33\":1}}],[\"这里打印的是切片v的索引\",{\"1\":{\"453\":1}}],[\"这里可行\",{\"1\":{\"438\":1}}],[\"这里处理write事件\",{\"1\":{\"226\":3}}],[\"这里处理read事件\",{\"1\":{\"226\":3}}],[\"这里处理accept事件\",{\"1\":{\"226\":3}}],[\"这里进行一些初始化的设置\",{\"1\":{\"226\":1}}],[\"这里大都是用户使用的工具\",{\"1\":{\"223\":1}}],[\"这里是尝试删除\",{\"1\":{\"930\":1}}],[\"这里是\",{\"1\":{\"885\":1,\"888\":1,\"1008\":1}}],[\"这里是指能兼容\",{\"1\":{\"873\":1}}],[\"这里是重点\",{\"1\":{\"489\":1}}],[\"这里是被唤醒的开始的地方\",{\"1\":{\"265\":1}}],[\"这里是图片内容\",{\"1\":{\"249\":1}}],[\"这里是你手动挂载设备的地方\",{\"1\":{\"223\":1}}],[\"这里是系统启动需要的文件\",{\"1\":{\"223\":1}}],[\"这里存放的是一些非系统必须的资源\",{\"1\":{\"223\":1}}],[\"这里存放的是全部正在运行程序的状态信息\",{\"1\":{\"223\":1}}],[\"这里存放的命令可以对系统配置进行操作\",{\"1\":{\"223\":1}}],[\"这里存放所有的设备文件\",{\"1\":{\"223\":1}}],[\"这里指的是有条件的删除而不是删除所有数据\",{\"1\":{\"23\":1}}],[\"这提高了代码的稳定性\",{\"1\":{\"33\":1}}],[\"这个选项的作用是指定在通过调用栈获得行号时跳过的调用深度\",{\"1\":{\"957\":1}}],[\"这个方法会根据请求的content\",{\"1\":{\"1038\":1}}],[\"这个方法主要用于测试\",{\"1\":{\"957\":1}}],[\"这个方法是基于\",{\"1\":{\"810\":1}}],[\"这个缓存名字是aof\",{\"1\":{\"952\":1}}],[\"这个确实是属于rdb和aof优点的融合\",{\"1\":{\"949\":1}}],[\"这个异步写操作是write\",{\"1\":{\"930\":1}}],[\"这个主要源自redis比关系型存储高很多的处理性能\",{\"1\":{\"927\":1}}],[\"这个规模的流量砸下来\",{\"1\":{\"927\":1}}],[\"这个可以在做业务之前\",{\"1\":{\"918\":1,\"921\":1}}],[\"这个可以作为判断依据\",{\"1\":{\"917\":1,\"921\":1}}],[\"这个命令的语法是\",{\"1\":{\"910\":1,\"921\":1}}],[\"这个命令将在localhost上的mysql中重命名用户\",{\"1\":{\"840\":1}}],[\"这个命令将在\",{\"1\":{\"229\":1}}],[\"这个链表就成本就很大\",{\"1\":{\"906\":1}}],[\"这个链表就被称为版本链\",{\"1\":{\"742\":1,\"810\":1}}],[\"这个底层数据结构\",{\"1\":{\"879\":1}}],[\"这个分数是给抽象概念\",{\"1\":{\"876\":1}}],[\"这个分支是快速分支\",{\"1\":{\"265\":1}}],[\"这个属性和哈希值一起决定一个键一个被放在\",{\"1\":{\"864\":1}}],[\"这个新的用户可以登录\",{\"1\":{\"846\":1}}],[\"这个表中看到\",{\"1\":{\"820\":1}}],[\"这个动作\",{\"1\":{\"817\":1}}],[\"这个语句就执行完成了\",{\"1\":{\"817\":2}}],[\"这个函数会使用write函数来将数据写入操作系统缓冲区\",{\"1\":{\"952\":1}}],[\"这个函数指针被指向为一个永远返回\",{\"1\":{\"817\":1}}],[\"这个函数指针被指向为\",{\"1\":{\"817\":2}}],[\"这个函数属于类\",{\"1\":{\"33\":1}}],[\"这个工作是由\",{\"1\":{\"817\":1}}],[\"这个工作交由\",{\"1\":{\"817\":1}}],[\"这个客户端并不会马上知道\",{\"1\":{\"817\":1}}],[\"这个是在执行事务\",{\"1\":{\"820\":1}}],[\"这个是字符串比较\",{\"1\":{\"813\":1}}],[\"这个是业务去定义的\",{\"1\":{\"23\":1}}],[\"这个就更看场景了\",{\"1\":{\"930\":1}}],[\"这个就是数字比较\",{\"1\":{\"813\":1}}],[\"这个就不多说了\",{\"1\":{\"36\":1}}],[\"这个等待的时长由\",{\"1\":{\"810\":1}}],[\"这个优化是将\",{\"1\":{\"810\":1}}],[\"这个要看\",{\"1\":{\"810\":1}}],[\"这个过程很耗时\",{\"1\":{\"850\":1}}],[\"这个过程不需要重连和重新做权限验证\",{\"1\":{\"817\":1}}],[\"这个过程一般是\",{\"1\":{\"810\":1}}],[\"这个过程会产生性能瓶颈\",{\"1\":{\"217\":1}}],[\"这个默认的行为\",{\"1\":{\"810\":1}}],[\"这个能力称为\",{\"1\":{\"810\":1}}],[\"这个索引\",{\"1\":{\"810\":1}}],[\"这个字段来统计访问情况\",{\"1\":{\"903\":1}}],[\"这个字段可以快速定位到尾部节点\",{\"1\":{\"879\":1}}],[\"这个字段包含不适合在其他字段显示的额外信息\",{\"1\":{\"807\":1}}],[\"这个字段显示了mysql实际从表中使用的索引\",{\"1\":{\"807\":1}}],[\"这个隐藏列是个指针\",{\"1\":{\"788\":1}}],[\"这个行为是由参数\",{\"1\":{\"770\":1}}],[\"这个策略可由\",{\"1\":{\"756\":1,\"810\":1}}],[\"这个操作是为了保证在事务回滚时能够恢复到原始状态\",{\"1\":{\"753\":1}}],[\"这个依托于持久化存储\",{\"1\":{\"710\":1}}],[\"这个环节是在数据进入消息队列之前\",{\"1\":{\"709\":1}}],[\"这个阶段通常用于释放应用级别的资源\",{\"1\":{\"629\":1}}],[\"这个阶段通常用于初始化应用级别的资源\",{\"1\":{\"629\":1}}],[\"这个成员变量是属于实例的\",{\"1\":{\"571\":1}}],[\"这个流转的可以理解为\",{\"1\":{\"518\":1}}],[\"这个指针可以安全地在不同的\",{\"1\":{\"516\":1,\"522\":1}}],[\"这个时候服务a恢复过来并做完了业务\",{\"1\":{\"912\":1,\"921\":1}}],[\"这个时候可以先查找到\",{\"1\":{\"813\":1}}],[\"这个时候可以在结构体tag中添加string来告诉json包从字符串中解析相应字段的数据\",{\"1\":{\"491\":1}}],[\"这个时候更新就算完成了\",{\"1\":{\"810\":3}}],[\"这个时候就需要加锁\",{\"1\":{\"909\":1,\"921\":1}}],[\"这个时候就需要在\",{\"1\":{\"525\":1}}],[\"这个时候就会发生行溢出\",{\"1\":{\"770\":1}}],[\"这个时候我们就可以使用创建另外一个结构体publicuser匿名嵌套原user\",{\"1\":{\"490\":1}}],[\"这个问题该如何解决呢\",{\"1\":{\"915\":1,\"921\":1}}],[\"这个问题跟\",{\"1\":{\"810\":1}}],[\"这个问题我们有两个答案\",{\"1\":{\"810\":1}}],[\"这个问题需要了解一个\",{\"1\":{\"748\":1}}],[\"这个问题请关注我的go语言学习专栏吧\",{\"1\":{\"488\":1}}],[\"这个问题可以通过哈希算法给每张图片生成唯一标识\",{\"1\":{\"80\":1}}],[\"这个x可以有无限个\",{\"1\":{\"249\":1}}],[\"这个地址在宿主机的私有网络范围内\",{\"1\":{\"246\":1}}],[\"这个开销在\",{\"1\":{\"226\":2}}],[\"这个名字是历史遗留的\",{\"1\":{\"223\":1}}],[\"这个数据服务可以理解为一个代理\",{\"1\":{\"930\":1}}],[\"这个数据结构\",{\"1\":{\"879\":1}}],[\"这个数字包含\",{\"1\":{\"879\":1}}],[\"这个数字超级大\",{\"1\":{\"249\":1}}],[\"这个数字其实是\",{\"1\":{\"223\":1}}],[\"这个数组大小是10\",{\"1\":{\"33\":1}}],[\"这个文件夹一般是空的\",{\"1\":{\"223\":1}}],[\"这个文件夹的使用比较随意\",{\"1\":{\"223\":1}}],[\"这个文件夹里\",{\"1\":{\"223\":1}}],[\"这个目录经常使用\",{\"1\":{\"223\":1}}],[\"这个\",{\"1\":{\"217\":1,\"462\":1,\"753\":1,\"770\":1,\"820\":1,\"924\":1}}],[\"这个基地址与页内偏移的组合就形成了物理内存地址\",{\"1\":{\"217\":1}}],[\"这个参数就是分区的策略\",{\"1\":{\"165\":1}}],[\"这个参数限制每次拉取返回的消息数量\",{\"1\":{\"162\":1}}],[\"这个模式指定新创建的容器和已经存在的一个容器共享一个\",{\"1\":{\"125\":1}}],[\"这个功能在进行测试\",{\"1\":{\"113\":1}}],[\"这个容器会在后台运行一个简单的sleep任务\",{\"1\":{\"104\":1}}],[\"这个最终值就是应该存储的缓存机器编号\",{\"1\":{\"81\":1}}],[\"这个映射的规则就是哈希算法\",{\"1\":{\"70\":1}}],[\"这多次请求同时到达服务端\",{\"1\":{\"23\":1}}],[\"这两份日志的一致性了\",{\"1\":{\"810\":1}}],[\"这两份日志的时候\",{\"1\":{\"810\":1}}],[\"这两个配置的不同\",{\"1\":{\"957\":1}}],[\"这两个复制命令\",{\"1\":{\"864\":1}}],[\"这两个命令\",{\"1\":{\"864\":1}}],[\"这两个锁是冲突的\",{\"1\":{\"820\":1}}],[\"这两个日志有四个区别\",{\"1\":{\"810\":1}}],[\"这两个日志都是\",{\"1\":{\"810\":1}}],[\"这两个日志的刷盘先后顺序可能会导致下面两种情况\",{\"1\":{\"763\":1}}],[\"这两个隔离级别实现是通过\",{\"1\":{\"810\":1}}],[\"这两个行格式和\",{\"1\":{\"770\":1}}],[\"这两个行格式跟\",{\"1\":{\"770\":1}}],[\"这两个\",{\"1\":{\"512\":1,\"810\":1}}],[\"这两个位置的数据都存储在内存中\",{\"1\":{\"223\":1}}],[\"这两种查询会加锁的语句称为\",{\"1\":{\"820\":1}}],[\"这两种日志是属于\",{\"1\":{\"810\":1}}],[\"这两种格式采用完全的行溢出方式\",{\"1\":{\"770\":1}}],[\"这两种方式返回的\",{\"1\":{\"472\":1}}],[\"这两种操作通常不需要进行幂等性验证\",{\"1\":{\"23\":1}}],[\"这两者的区别就大了\",{\"1\":{\"33\":1}}],[\"这两步建议用lua脚本实现\",{\"1\":{\"23\":1}}],[\"这种就被称为查询参数\",{\"1\":{\"1035\":1}}],[\"这种常量日志级别的设定\",{\"1\":{\"957\":1}}],[\"这种显式指明类型的写法\",{\"1\":{\"957\":1}}],[\"这种策略下\",{\"1\":{\"952\":1}}],[\"这种活动通常会吸引几十万甚至数百万人参与\",{\"1\":{\"927\":1}}],[\"这种多机模式都可以使用\",{\"1\":{\"917\":1,\"921\":1}}],[\"这种内存数据对内存十分珍惜\",{\"1\":{\"891\":1}}],[\"这种现象叫连锁更新\",{\"1\":{\"879\":1}}],[\"这种特殊字符\",{\"1\":{\"873\":1}}],[\"这种机制称为隐式锁\",{\"1\":{\"820\":1}}],[\"这种查询会加锁的语句称为\",{\"1\":{\"820\":1}}],[\"这种不支持事务的引擎\",{\"1\":{\"820\":1}}],[\"这种其实严格意义上来说是属于索引截断\",{\"1\":{\"813\":1}}],[\"这种\",{\"1\":{\"810\":1}}],[\"这种格式的日志\",{\"1\":{\"810\":1}}],[\"这种随时在变的函数会导致复制的数据不一致\",{\"1\":{\"810\":1}}],[\"这种大对象类型\",{\"1\":{\"770\":1}}],[\"这种场景就是客户自己有序即可\",{\"1\":{\"723\":1}}],[\"这种场景下是正常请求\",{\"1\":{\"23\":1}}],[\"这种锁机制会导致其他\",{\"1\":{\"511\":1}}],[\"这种致命错误是会导致程序直接崩溃\",{\"1\":{\"478\":1}}],[\"这种灵活性允许一个类型定义多种行为\",{\"1\":{\"466\":1}}],[\"这种形式的标识符对象可以被外部包的代码所使用\",{\"1\":{\"433\":1}}],[\"这种方便的写法是有一定代价的\",{\"1\":{\"957\":1}}],[\"这种方法只适用于支持\",{\"1\":{\"820\":1}}],[\"这种方式可以大大降低aof重写的性能损耗\",{\"1\":{\"949\":1}}],[\"这种方式实现简单\",{\"1\":{\"930\":1}}],[\"这种方式在实际项目中\",{\"1\":{\"810\":1}}],[\"这种方式有一个缺点\",{\"1\":{\"723\":1}}],[\"这种方式非常适合需要访问互联网但不需要外部设备访问虚拟机的场景\",{\"1\":{\"246\":1}}],[\"这种方案实用性较强没有明显的缺陷\",{\"1\":{\"23\":1}}],[\"这种重用可能导致新的连接混淆\",{\"1\":{\"237\":2}}],[\"这种指定\",{\"1\":{\"229\":1}}],[\"这种模式的好处在于\",{\"1\":{\"917\":1,\"921\":1}}],[\"这种模式一旦主库宕机\",{\"1\":{\"810\":1}}],[\"这种模式下会存在些许数据不一致\",{\"1\":{\"807\":1}}],[\"这种模式避免了阻塞和轮询\",{\"1\":{\"226\":1}}],[\"这种模型的优点是应用程序不需要等待i\",{\"1\":{\"226\":1}}],[\"这种有序性可以提高数据库索引的效率\",{\"1\":{\"92\":1}}],[\"这种转换时间开销可以忽略\",{\"1\":{\"36\":1}}],[\"这种情况也会白白消耗redis中的库存\",{\"1\":{\"927\":1}}],[\"这种情况返回给用户\",{\"1\":{\"927\":1}}],[\"这种情况符合预期\",{\"1\":{\"927\":1}}],[\"这种情况几乎无解\",{\"1\":{\"918\":1,\"921\":1}}],[\"这种情况\",{\"1\":{\"810\":1}}],[\"这种情况下\",{\"1\":{\"33\":1,\"813\":1,\"927\":1}}],[\"这种情况下幂等性失效\",{\"1\":{\"23\":1}}],[\"这种情况能保证幂等性\",{\"1\":{\"23\":1}}],[\"这种操作就不是冪等的\",{\"1\":{\"23\":1}}],[\"这种操作不管执行多少次都是幂等的\",{\"1\":{\"23\":1}}],[\"这种决策应该基于实际业务需求和操作类型进行区分\",{\"1\":{\"23\":1}}],[\"这样如果函数内部写为\",{\"1\":{\"957\":1}}],[\"这样如果一个事务的\",{\"1\":{\"810\":1}}],[\"这样说是这一步操作是可能失败了\",{\"1\":{\"930\":1}}],[\"这样及时加载或更新缓存数据\",{\"1\":{\"930\":1}}],[\"这样下次请求相同数据时就能直接拿到结果\",{\"1\":{\"930\":1}}],[\"这样下次有查询语句命中了这条记录\",{\"1\":{\"747\":1,\"810\":1}}],[\"这样事务\",{\"1\":{\"820\":2}}],[\"这样其他事务就无法对这条记录进行修改了\",{\"1\":{\"820\":1}}],[\"这样其它线程\",{\"1\":{\"730\":1}}],[\"这样效率会很慢\",{\"1\":{\"820\":1}}],[\"这样备份期间备份的数据一直是在开启事务时的数据\",{\"1\":{\"820\":1}}],[\"这样在\",{\"1\":{\"820\":1}}],[\"这样在备份数据库期间\",{\"1\":{\"820\":1}}],[\"这样在插入重复订单时会报错\",{\"1\":{\"23\":1}}],[\"这样大家能清楚的知道\",{\"1\":{\"817\":1}}],[\"这样方便后面模块获取\",{\"1\":{\"817\":1}}],[\"这样才能提高索引的检索效率\",{\"1\":{\"813\":1}}],[\"这样做的好处就是避免了全表扫描\",{\"1\":{\"813\":1}}],[\"这样做的后果是这个分区就不可用\",{\"1\":{\"183\":1}}],[\"这样删除非常快\",{\"1\":{\"813\":1}}],[\"这样使得删除一个节点的时候\",{\"1\":{\"813\":1}}],[\"这样破坏了原子性\",{\"1\":{\"810\":1}}],[\"这样即使写请求会锁表或者锁记录\",{\"1\":{\"810\":1}}],[\"这样之后回滚时再把这些列\",{\"1\":{\"810\":1}}],[\"这样之后回滚时再把由这些内容组成的记录\",{\"1\":{\"810\":1}}],[\"这样之后回滚时只需要把这个主键值对应的记录\",{\"1\":{\"810\":1}}],[\"这样回滚时再把这些列\",{\"1\":{\"741\":1}}],[\"这样回滚时再把由这些内容组成的记录\",{\"1\":{\"741\":1}}],[\"这样回滚时只需要把这个主键值对应的记录\",{\"1\":{\"741\":1}}],[\"这样一来所有消息都会添加至同一个partition\",{\"1\":{\"720\":1}}],[\"这样一个连续并且尺寸固定的内存空间\",{\"1\":{\"217\":1}}],[\"这样子会增加gc的负担\",{\"1\":{\"409\":1}}],[\"这样子存储的好处是可以消除字节对齐带来的空间浪费\",{\"1\":{\"330\":1}}],[\"这样子下一次就可以从这个位置开始消费\",{\"1\":{\"163\":1}}],[\"这样可能导致每次连接传送的数据量增大\",{\"1\":{\"249\":1}}],[\"这样可以防止攻击用户反复用同一个id暴力攻击\",{\"1\":{\"930\":1}}],[\"这样可以大大保障正常用户的权益\",{\"1\":{\"927\":1}}],[\"这样可以明显地减少日志同步到磁盘的\",{\"1\":{\"810\":1}}],[\"这样可以至少节省\",{\"1\":{\"770\":1}}],[\"这样可以保证\",{\"1\":{\"756\":1,\"810\":1}}],[\"这样可以减少磁盘的寻道时间和旋转延迟\",{\"1\":{\"754\":1}}],[\"这样可以简化网络的设计和管理\",{\"1\":{\"249\":1}}],[\"这样可以集中管理数据的更新和读取\",{\"1\":{\"175\":1}}],[\"这样可以让消费者按照自身情况来控制消费速度\",{\"1\":{\"162\":1}}],[\"这样有助于提高故障排除的效率\",{\"1\":{\"249\":1}}],[\"这样的设计可以省却很多麻烦\",{\"1\":{\"918\":1,\"921\":1}}],[\"这样的批量插入数据的语句\",{\"1\":{\"820\":1}}],[\"这样的查询过程可以在索引结构中完成\",{\"1\":{\"813\":1}}],[\"这样的好处是向左读就是记录头信息\",{\"1\":{\"770\":1}}],[\"这样的好处是\",{\"1\":{\"770\":1}}],[\"这样的一来一回正是\",{\"1\":{\"237\":1}}],[\"这样的key占用了将近一半的内存\",{\"1\":{\"229\":1}}],[\"这样的目录\",{\"1\":{\"223\":1}}],[\"这样对系统的开销太大了\",{\"1\":{\"226\":1}}],[\"这样就会造成超卖\",{\"1\":{\"927\":1}}],[\"这样就有效的防止幻读现象的发生\",{\"1\":{\"820\":1}}],[\"这样就不会阻塞在一个操作上\",{\"1\":{\"888\":1}}],[\"这样就不用去遍历表里的记录\",{\"1\":{\"820\":1}}],[\"这样就不需要从根节点查询了\",{\"1\":{\"813\":1}}],[\"这样就没办法对\",{\"1\":{\"810\":1}}],[\"这样就使得多个阶段可以并发执行\",{\"1\":{\"810\":1}}],[\"这样就使得链表中相邻的页的物理位置也相邻\",{\"1\":{\"770\":1}}],[\"这样就保证了执行完\",{\"1\":{\"810\":1}}],[\"这样就保证了在事务期间读到的数据都是事务启动前的记录\",{\"1\":{\"743\":1,\"810\":1}}],[\"这样就造成两份日志之间的逻辑不一致\",{\"1\":{\"763\":1,\"810\":1}}],[\"这样就达到了我们的目的\",{\"1\":{\"720\":1}}],[\"这样就无法做到数据隔离的\",{\"1\":{\"520\":1}}],[\"这样就代表这一条tcp连接断开\",{\"1\":{\"226\":1}}],[\"这样就可以保证\",{\"1\":{\"810\":1}}],[\"这样就可以提高\",{\"1\":{\"770\":1}}],[\"这样就可以使用顺序\",{\"1\":{\"770\":1}}],[\"这样就可以划出来100个分区\",{\"1\":{\"723\":1}}],[\"这样就可以实现业务消息有序\",{\"1\":{\"720\":1}}],[\"这样就可以减少很多工作量\",{\"1\":{\"75\":1}}],[\"这样就可能出现一次请求变成多次请求\",{\"1\":{\"23\":1}}],[\"这样\",{\"1\":{\"217\":1,\"249\":1,\"462\":1,\"723\":1,\"810\":1,\"917\":1,\"921\":1}}],[\"这样整个机器都会显得卡顿\",{\"1\":{\"217\":1}}],[\"这样两个容器之间可以使用\",{\"1\":{\"125\":1}}],[\"这样容器之间就能够通过容器的\",{\"1\":{\"121\":1}}],[\"这样会造成业务停滞\",{\"1\":{\"820\":1}}],[\"这样会发生\",{\"1\":{\"817\":1}}],[\"这样会使投票结果与事实严重不符\",{\"1\":{\"23\":1}}],[\"这样会导致接口接收到用户重复提交的投票信息\",{\"1\":{\"23\":1}}],[\"没被淘汰的放入池子\",{\"1\":{\"906\":1}}],[\"没执行事务\",{\"1\":{\"820\":1}}],[\"没存储字段的完整值\",{\"1\":{\"813\":1}}],[\"没问题就没问题\",{\"1\":{\"469\":1}}],[\"没法做到自动切换\",{\"1\":{\"164\":1}}],[\"没有被选中\",{\"1\":{\"1006\":1}}],[\"没有找到\",{\"1\":{\"992\":1}}],[\"没有就查db\",{\"1\":{\"930\":1}}],[\"没有必要\",{\"1\":{\"927\":1}}],[\"没有银弹\",{\"1\":{\"927\":1}}],[\"没有回退指针\",{\"1\":{\"885\":1}}],[\"没有主机名的帐户名等效于\",{\"1\":{\"838\":1}}],[\"没有主动实现\",{\"1\":{\"813\":1}}],[\"没有索引下推的时候\",{\"1\":{\"817\":1}}],[\"没有索引下推的查询过程\",{\"1\":{\"813\":1}}],[\"没有参数\",{\"1\":{\"810\":1}}],[\"没有一致的公式\",{\"1\":{\"807\":1}}],[\"没有读取实际的行数据\",{\"1\":{\"807\":1}}],[\"没有像\",{\"1\":{\"730\":1}}],[\"没有重试机制\",{\"1\":{\"706\":1}}],[\"没有提交偏移量或者是一次失败了就不做了\",{\"1\":{\"706\":1}}],[\"没有\",{\"1\":{\"479\":1,\"516\":1,\"810\":2}}],[\"没有c++和java一样的显式继承关系\",{\"1\":{\"461\":1}}],[\"没有cookie还可以用别的方法\",{\"1\":{\"249\":1}}],[\"没有类这个概念\",{\"1\":{\"461\":1}}],[\"没有显示初始化\",{\"1\":{\"436\":1}}],[\"没有直接关系\",{\"1\":{\"434\":2}}],[\"没有逃逸\",{\"0\":{\"412\":1}}],[\"没有任何方法声明的接口称之为空接口\",{\"1\":{\"467\":1}}],[\"没有任何方法的接口为空接口\",{\"1\":{\"300\":1}}],[\"没有任何字符\",{\"1\":{\"351\":1}}],[\"没有任何上下文信息\",{\"1\":{\"249\":1}}],[\"没有缓冲区buf\",{\"1\":{\"263\":1}}],[\"没有停止进化\",{\"1\":{\"249\":1}}],[\"没有开启http长连接\",{\"1\":{\"237\":1}}],[\"没有最大并发连接的限制\",{\"1\":{\"226\":1}}],[\"没有可读性的二进制文件\",{\"1\":{\"952\":1}}],[\"没有可读\",{\"1\":{\"226\":1}}],[\"没有独立ip地址\",{\"1\":{\"124\":1}}],[\"没有办法一次性放入一台机器的内存中处理\",{\"1\":{\"79\":1}}],[\"没有绝对安全的加密\",{\"1\":{\"74\":1}}],[\"没有返回值\",{\"1\":{\"33\":1}}],[\"没有及时对用户做出提交成功响应\",{\"1\":{\"23\":1}}],[\"没啥用but安装了类\",{\"0\":{\"13\":1}}],[\"无时序性问题\",{\"1\":{\"930\":1}}],[\"无不干扰\",{\"1\":{\"924\":1}}],[\"无事发生\",{\"1\":{\"879\":1}}],[\"无序的字符串集合\",{\"1\":{\"870\":1}}],[\"无需额外建立唯一约束\",{\"1\":{\"813\":1}}],[\"无需再回表读取数据来进行判断\",{\"1\":{\"813\":1}}],[\"无需关心\",{\"1\":{\"807\":1}}],[\"无需创建新进程\",{\"1\":{\"646\":1}}],[\"无需对物理网络进行复杂设置\",{\"1\":{\"246\":1}}],[\"无符号右移\",{\"1\":{\"569\":1}}],[\"无限循环\",{\"1\":{\"531\":1}}],[\"无锁更新\",{\"1\":{\"524\":1}}],[\"无锁\",{\"1\":{\"516\":1}}],[\"无缓冲channel\",{\"0\":{\"257\":1}}],[\"无状态\",{\"1\":{\"249\":1}}],[\"无连接\",{\"1\":{\"249\":1}}],[\"无其他网卡\",{\"1\":{\"126\":1}}],[\"无\",{\"1\":{\"122\":2,\"924\":1}}],[\"无参构造函数\",{\"1\":{\"33\":1}}],[\"无法精准的对一段文字做分词\",{\"1\":{\"813\":1}}],[\"无法使用分组\",{\"1\":{\"813\":1}}],[\"无法利用索引\",{\"1\":{\"813\":1}}],[\"无法走索引\",{\"1\":{\"813\":2}}],[\"无法走联合索引\",{\"1\":{\"813\":1}}],[\"无法成功插入\",{\"1\":{\"783\":1}}],[\"无法发挥多partition的优势\",{\"1\":{\"720\":1}}],[\"无法处理的请求的责任\",{\"1\":{\"512\":1}}],[\"无法处理正常的用户请求\",{\"1\":{\"243\":1}}],[\"无法用\",{\"1\":{\"509\":1}}],[\"无法捕获\",{\"1\":{\"478\":1}}],[\"无法传输其他类型的文件\",{\"1\":{\"249\":1}}],[\"无法并发传输\",{\"1\":{\"240\":1}}],[\"无法响应正常请求\",{\"1\":{\"243\":1}}],[\"无法响应\",{\"1\":{\"240\":1}}],[\"无法识别这个绕回的报文\",{\"1\":{\"237\":1}}],[\"无法保证消息之间的先后顺序\",{\"1\":{\"161\":1}}],[\"无法看到主机上的进程\",{\"1\":{\"98\":1}}],[\"无法直接用于stl标准容器中\",{\"1\":{\"33\":1}}],[\"无法在短时间内迅速解决\",{\"1\":{\"20\":1}}],[\"无论\",{\"1\":{\"469\":1}}],[\"无论是使用注解还是xml配置\",{\"1\":{\"653\":1}}],[\"无论是否发生异常都会执行的代码\",{\"1\":{\"540\":1}}],[\"无论是对于请求还是响应\",{\"1\":{\"249\":1}}],[\"无论是正常关闭还是崩溃\",{\"1\":{\"165\":1}}],[\"无论是执行一次还是多次\",{\"1\":{\"23\":1}}],[\"无论基类函数是不是虚函数\",{\"1\":{\"33\":1}}],[\"无论执行一次还是多次\",{\"1\":{\"23\":1}}],[\"无论重读调用多少次\",{\"1\":{\"23\":1}}],[\"用官方的话来说就是足够快了\",{\"1\":{\"952\":1}}],[\"用官方的话说\",{\"1\":{\"952\":1}}],[\"用新的\",{\"1\":{\"952\":1}}],[\"用变种拉链法来解决哈希冲突\",{\"1\":{\"945\":1}}],[\"用变种拉链法来解决哈希冲突问题\",{\"1\":{\"319\":1}}],[\"用服务端还是客户端呢\",{\"1\":{\"930\":1}}],[\"用服务器的\",{\"1\":{\"249\":1}}],[\"用法\",{\"1\":{\"924\":1}}],[\"用法示例\",{\"1\":{\"229\":2}}],[\"用从节点顶包\",{\"1\":{\"916\":1,\"921\":1}}],[\"用完之后\",{\"1\":{\"910\":1,\"921\":1}}],[\"用完要记得释放指针\",{\"1\":{\"33\":1}}],[\"用分钟可以表示\",{\"1\":{\"903\":1}}],[\"用分段的方式\",{\"1\":{\"217\":1}}],[\"用了写时复制技术\",{\"1\":{\"952\":1}}],[\"用了\",{\"1\":{\"879\":1}}],[\"用拉链法解决\",{\"1\":{\"864\":1}}],[\"用唯一索引进行等值查询的时候\",{\"1\":{\"820\":1}}],[\"用字段的前几个字符作为索引\",{\"1\":{\"807\":1}}],[\"用的是头插法\",{\"1\":{\"864\":1}}],[\"用的多\",{\"1\":{\"727\":1}}],[\"用的少\",{\"1\":{\"727\":1}}],[\"用的时候快速定位到方法\",{\"1\":{\"307\":1}}],[\"用cas操作\",{\"1\":{\"516\":1}}],[\"用panic抛出异常\",{\"1\":{\"475\":1}}],[\"用protobuf描述如下\",{\"1\":{\"229\":1}}],[\"用局部变量\",{\"1\":{\"453\":1}}],[\"用make函数初始化一个channel\",{\"1\":{\"263\":1}}],[\"用对方的公钥来加密\",{\"1\":{\"249\":1}}],[\"用一个\",{\"1\":{\"249\":1}}],[\"用到的比较少\",{\"1\":{\"249\":1}}],[\"用大量的僵尸计算机\",{\"1\":{\"243\":1}}],[\"用途不同\",{\"1\":{\"810\":1}}],[\"用途\",{\"1\":{\"240\":1,\"249\":1,\"459\":1}}],[\"用tls1\",{\"1\":{\"240\":1}}],[\"用动态数组存储关注的fd\",{\"1\":{\"226\":1}}],[\"用\",{\"1\":{\"223\":1,\"249\":4,\"475\":1,\"810\":2,\"873\":1,\"879\":1,\"927\":1,\"930\":1}}],[\"用作段表的索引\",{\"1\":{\"217\":1}}],[\"用来指定日志级别\",{\"1\":{\"957\":1}}],[\"用来指定某个日志级别及以上级别输出调用堆栈\",{\"1\":{\"957\":1}}],[\"用来定义不同级别的日志输出方式\",{\"1\":{\"957\":1}}],[\"用来在日志打印时同时调用注册的钩子函数\",{\"1\":{\"957\":1}}],[\"用来描述有几个指针指向该对象\",{\"1\":{\"940\":1}}],[\"用来缓存磁盘中的数据\",{\"1\":{\"930\":1}}],[\"用来缓存内存中的数据\",{\"1\":{\"930\":1}}],[\"用来设置一个key的超时时间\",{\"1\":{\"911\":1,\"921\":1}}],[\"用来记录新的更新操作\",{\"1\":{\"810\":1}}],[\"用来检查接口变量的值是否实现了某个接口\",{\"1\":{\"469\":1}}],[\"用来简化内存管理并减少与指针相关的错误\",{\"1\":{\"459\":1}}],[\"用来针对互联网上加密数据传递\",{\"1\":{\"249\":1}}],[\"用来标识该session对象\",{\"1\":{\"249\":1}}],[\"用来存储\",{\"1\":{\"957\":1}}],[\"用来存储数据\",{\"1\":{\"885\":1}}],[\"用来存储数据大小\",{\"1\":{\"879\":1}}],[\"用来存储当前数据库的默认字符集和字符校验规则\",{\"1\":{\"770\":1}}],[\"用来存储某些程序的运行时信息和系统需要的一些信息\",{\"1\":{\"223\":1}}],[\"用来存储和分发\",{\"1\":{\"99\":1}}],[\"用来区分容器\",{\"1\":{\"139\":1}}],[\"用合适的数据结构记录窗口中的数据\",{\"1\":{\"88\":1}}],[\"用它作为图片的唯一标识\",{\"1\":{\"75\":1}}],[\"用访问修饰符划分访问权限\",{\"1\":{\"33\":1}}],[\"用于比对bcrypt哈希字符串和提供的密码明文文本是否匹配\",{\"1\":{\"1058\":1}}],[\"用于接收绑定的数据\",{\"1\":{\"1039\":1,\"1041\":1}}],[\"用于指定下载下来的文件名\",{\"1\":{\"1032\":1}}],[\"用于单个记录的全字段更新\",{\"1\":{\"997\":1}}],[\"用于后面的数据库读写操作\",{\"1\":{\"976\":1}}],[\"用于multi\",{\"1\":{\"944\":1}}],[\"用于内存淘汰\",{\"1\":{\"940\":1}}],[\"用于快速判某个元素是否存在于集合中\",{\"1\":{\"930\":1}}],[\"用于快速定位某条记录的大致位置\",{\"1\":{\"748\":1}}],[\"用于标识是否结束\",{\"1\":{\"879\":1}}],[\"用于正向遍历\",{\"1\":{\"879\":1}}],[\"用于在指定的\",{\"1\":{\"873\":1}}],[\"用于支持\",{\"1\":{\"810\":2}}],[\"用于支撑\",{\"1\":{\"810\":1}}],[\"用于控制单个线程内\",{\"1\":{\"810\":1}}],[\"用于控制编译过程和输出\",{\"1\":{\"392\":1}}],[\"用于记录和重放sql语句\",{\"1\":{\"810\":1}}],[\"用于记录最大的fd\",{\"1\":{\"226\":1}}],[\"用于重做已经提交的修改\",{\"1\":{\"810\":1}}],[\"用于撤销已经执行的修改\",{\"1\":{\"810\":1}}],[\"用于数据备份和主从复制\",{\"1\":{\"810\":1}}],[\"用于数据的复制和恢复\",{\"1\":{\"737\":1,\"810\":1}}],[\"用于掉电等故障恢复\",{\"1\":{\"810\":2}}],[\"用于事务回滚和\",{\"1\":{\"810\":1}}],[\"用于分析sql语句的执行计划\",{\"1\":{\"807\":1}}],[\"用于备份恢复\",{\"1\":{\"759\":1,\"810\":1}}],[\"用于输出图片等二进制数据\",{\"1\":{\"677\":1}}],[\"用于获取当前在线用户数\",{\"1\":{\"641\":1}}],[\"用于获取当前在线用户列表\",{\"1\":{\"641\":1}}],[\"用于获取当前活跃会话数\",{\"1\":{\"625\":1}}],[\"用于计算请求处理时间\",{\"1\":{\"626\":1}}],[\"用于依赖管理\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"用于对后续的\",{\"1\":{\"249\":1}}],[\"用于消息认证和产生随机数\",{\"1\":{\"249\":1}}],[\"用于将ip地址解析为物理mac地址\",{\"1\":{\"249\":1}}],[\"用于文件传输\",{\"1\":{\"249\":1}}],[\"用于电子邮件传输\",{\"1\":{\"249\":1}}],[\"用于网页访问\",{\"1\":{\"249\":1}}],[\"用于区分同一主机的不同应用程序的数据包\",{\"1\":{\"237\":1}}],[\"用于存储从请求头中绑定的数据\",{\"1\":{\"1043\":1}}],[\"用于存储绑定的数据\",{\"1\":{\"1039\":1,\"1041\":1}}],[\"用于存储条目的值\",{\"1\":{\"516\":1,\"522\":1}}],[\"用于存储键值对数据\",{\"1\":{\"319\":1}}],[\"用于存储被交换出去的内存页\",{\"1\":{\"217\":1}}],[\"用于存放通过epoll\",{\"1\":{\"226\":1}}],[\"用于运行用户态的应用程序\",{\"1\":{\"217\":1}}],[\"用于操作系统内核和内核模块\",{\"1\":{\"217\":1}}],[\"用于删除目录及其内容\",{\"1\":{\"202\":1}}],[\"用于虚函数\",{\"1\":{\"33\":1}}],[\"用于类\",{\"1\":{\"33\":1}}],[\"用于定义不可变的常量\",{\"1\":{\"33\":1}}],[\"用于解决引用计数中的环形引用问题\",{\"1\":{\"33\":1}}],[\"用于测量执行时间的宏\",{\"1\":{\"33\":1}}],[\"用lua脚本保证原子性\",{\"1\":{\"23\":1}}],[\"用户账户\",{\"1\":{\"846\":1}}],[\"用户授权\",{\"0\":{\"846\":1}}],[\"用户表中的性别字段\",{\"1\":{\"780\":1}}],[\"用户记录\",{\"1\":{\"748\":1}}],[\"用户2002就用分区key\",{\"1\":{\"723\":1}}],[\"用户先下单再支付\",{\"1\":{\"719\":1}}],[\"用户从\",{\"1\":{\"641\":1}}],[\"用户未登录\",{\"1\":{\"598\":1}}],[\"用户已登录或访问登录页面或静态资源\",{\"1\":{\"598\":1}}],[\"用户不存在\",{\"1\":{\"546\":1}}],[\"用户可以在redis\",{\"1\":{\"897\":1}}],[\"用户可以从任何主机连接\",{\"1\":{\"838\":1}}],[\"用户可以认为改\",{\"1\":{\"524\":1}}],[\"用户可隶属于多个组\",{\"1\":{\"190\":1}}],[\"用户验证\",{\"1\":{\"243\":1}}],[\"用户程序只有在文件描述符的状态发生变化时\",{\"1\":{\"226\":1}}],[\"用户程序每次调用epoll\",{\"1\":{\"226\":1}}],[\"用户进程会阻塞就是同步io\",{\"1\":{\"226\":1}}],[\"用户态\",{\"1\":{\"226\":1},\"2\":{\"222\":1}}],[\"用户态和核心态\",{\"1\":{\"220\":1}}],[\"用户空间的栈和堆区有什么区别\",{\"1\":{\"217\":1}}],[\"用户空间如何划分\",{\"1\":{\"217\":1}}],[\"用户空间中的每个进程都有其独立的虚拟地址空间\",{\"1\":{\"217\":1}}],[\"用户空间\",{\"1\":{\"217\":1}}],[\"用户组\",{\"1\":{\"208\":2}}],[\"用户组管理\",{\"0\":{\"208\":1}}],[\"用户和用户组管理\",{\"0\":{\"206\":1}}],[\"用户和组\",{\"1\":{\"190\":2}}],[\"用户登录\",{\"0\":{\"205\":1}}],[\"用户管理\",{\"0\":{\"207\":1,\"837\":1},\"2\":{\"192\":1}}],[\"用户的订单操作\",{\"1\":{\"719\":1}}],[\"用户的家目录会有下载\",{\"1\":{\"223\":1}}],[\"用户的家目录\",{\"1\":{\"223\":1}}],[\"用户的默认shell\",{\"1\":{\"190\":1}}],[\"用户的主目录路径\",{\"1\":{\"190\":1}}],[\"用户的描述信息\",{\"1\":{\"190\":1}}],[\"用户id算出来在哪个槽\",{\"1\":{\"723\":1}}],[\"用户id是10\",{\"1\":{\"723\":1}}],[\"用户id\",{\"1\":{\"190\":1}}],[\"用户名不能为空\",{\"1\":{\"546\":1}}],[\"用户名\",{\"1\":{\"190\":2,\"205\":1,\"207\":5,\"208\":2,\"836\":1,\"983\":2}}],[\"用户\",{\"1\":{\"190\":1,\"249\":1,\"637\":2,\"641\":3}}],[\"用户也可以通过增加\",{\"1\":{\"113\":1}}],[\"用户信息作为值存储在redis中进行键值内容校验如果该键存在且值匹配\",{\"1\":{\"23\":1}}],[\"用户购买商品下单\",{\"1\":{\"23\":1}}],[\"用户提交请求后立即禁用提交按钮\",{\"1\":{\"23\":1}}],[\"用hash结构存储qq号码\",{\"1\":{\"20\":1}}],[\"分级的日志记录\",{\"1\":{\"955\":1}}],[\"分开看\",{\"1\":{\"897\":1}}],[\"分\",{\"1\":{\"873\":1}}],[\"分组查询\",{\"0\":{\"1010\":1}}],[\"分组\",{\"1\":{\"823\":1}}],[\"分组的字段应建立索引\",{\"1\":{\"813\":1}}],[\"分组等工作\",{\"1\":{\"813\":1}}],[\"分组模式是\",{\"1\":{\"249\":1}}],[\"分词是需要时间的\",{\"1\":{\"813\":1}}],[\"分别进行了扫描\",{\"1\":{\"813\":1}}],[\"分别为select和from\",{\"1\":{\"817\":1}}],[\"分别为\",{\"1\":{\"770\":1}}],[\"分别是指三种\",{\"1\":{\"807\":1}}],[\"分别是6个字和100个字\",{\"1\":{\"770\":1}}],[\"分别是准备\",{\"1\":{\"764\":1}}],[\"分别是\",{\"1\":{\"757\":1,\"770\":1,\"810\":2,\"820\":2}}],[\"分两阶段来完成\",{\"1\":{\"765\":1,\"810\":1}}],[\"分两次分配内存\",{\"1\":{\"263\":1}}],[\"分库\",{\"1\":{\"727\":1}}],[\"分库分表架构\",{\"1\":{\"807\":1}}],[\"分库分表情况下的连接数配置\",{\"1\":{\"807\":1}}],[\"分库分表引发的问题\",{\"1\":{\"727\":1}}],[\"分库分表原理\",{\"1\":{\"727\":1}}],[\"分库分表\",{\"1\":{\"727\":1,\"807\":2},\"2\":{\"729\":1}}],[\"分表\",{\"1\":{\"727\":1}}],[\"分钟\",{\"1\":{\"691\":1,\"903\":1}}],[\"分析binlog实现同步的工作量是非常大的\",{\"1\":{\"930\":1}}],[\"分析两个事务执行过程中\",{\"1\":{\"820\":1}}],[\"分析和执行\",{\"1\":{\"817\":1}}],[\"分析用户行为模式\",{\"1\":{\"615\":1}}],[\"分析\",{\"1\":{\"453\":1}}],[\"分配空间\",{\"1\":{\"864\":1}}],[\"分配空间并标记\",{\"1\":{\"531\":1}}],[\"分配角色\",{\"1\":{\"852\":1}}],[\"分配队列\",{\"1\":{\"723\":1}}],[\"分配大对象\",{\"1\":{\"408\":1}}],[\"分配到工作线程上\",{\"1\":{\"384\":1}}],[\"分配\",{\"1\":{\"378\":1}}],[\"分配内存的顺序是按照声明的顺序\",{\"1\":{\"33\":1}}],[\"分配内存\",{\"1\":{\"33\":1}}],[\"分成\",{\"1\":{\"330\":1}}],[\"分为聚索引和二级索引\",{\"1\":{\"813\":1}}],[\"分为\",{\"1\":{\"249\":1,\"873\":1}}],[\"分层允许我们在不同层级上实施安全控制\",{\"1\":{\"249\":1}}],[\"分层模型促进了不同厂商和设备之间的标准化\",{\"1\":{\"249\":1}}],[\"分页查询\",{\"0\":{\"1008\":1}}],[\"分页场景如何优化\",{\"1\":{\"807\":1}}],[\"分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小\",{\"1\":{\"217\":1}}],[\"分页机制分配内存的最小单位是一页\",{\"1\":{\"217\":1}}],[\"分页机制下内存如何映射\",{\"1\":{\"217\":1}}],[\"分页机制\",{\"1\":{\"217\":1}}],[\"分段提交\",{\"1\":{\"727\":1}}],[\"分段的好处就是能产生连续的内存空间\",{\"1\":{\"217\":1}}],[\"分段管理的不足\",{\"1\":{\"217\":1}}],[\"分段机制下的虚拟地址\",{\"1\":{\"217\":1}}],[\"分隔\",{\"1\":{\"190\":2}}],[\"分区的副本数量必须小于等于broker的数量\",{\"1\":{\"177\":1}}],[\"分区的命名规则为主题名称后接\",{\"1\":{\"157\":1}}],[\"分区\",{\"1\":{\"172\":1}}],[\"分区和副本\",{\"0\":{\"172\":1}}],[\"分区均匀地分配给消费者\",{\"1\":{\"165\":1}}],[\"分区是按什么规则来分配给这些消费者的呢\",{\"1\":{\"165\":1}}],[\"分区是kafka中的一个重要概念\",{\"1\":{\"157\":1}}],[\"分区在物理上对应一个文件夹及文件夹下面的文件\",{\"1\":{\"157\":1}}],[\"分类\",{\"0\":{\"51\":1},\"1\":{\"243\":1,\"568\":1,\"813\":4}}],[\"分类及实现方式\",{\"1\":{\"49\":1}}],[\"分布式事务需要保证这些小操作要么全部成功\",{\"1\":{\"727\":1}}],[\"分布式事务是指\",{\"1\":{\"727\":1}}],[\"分布式事务问题\",{\"1\":{\"727\":1}}],[\"分布式更是\",{\"1\":{\"249\":1}}],[\"分布式拒绝服务\",{\"1\":{\"243\":1}}],[\"分布式id\",{\"2\":{\"94\":1}}],[\"分布式\",{\"0\":{\"91\":1}}],[\"分布式缓存\",{\"1\":{\"81\":1}}],[\"分布式存储\",{\"0\":{\"81\":1}}],[\"分布式问题\",{\"0\":{\"77\":1}}],[\"分布式系统的三困境\",{\"1\":{\"918\":1,\"921\":1}}],[\"分布式系统\",{\"2\":{\"25\":1,\"93\":1,\"94\":1,\"167\":1,\"187\":1,\"234\":1,\"920\":1,\"923\":1}}],[\"分布式锁特性\",{\"1\":{\"921\":1}}],[\"分布式锁是什么\",{\"1\":{\"921\":1}}],[\"分布式锁也就失去了意义\",{\"1\":{\"912\":1,\"921\":1}}],[\"分布式锁就是分布式场景下的锁\",{\"1\":{\"909\":1,\"921\":1}}],[\"分布式锁\",{\"1\":{\"23\":2,\"909\":1,\"912\":1,\"921\":3},\"2\":{\"923\":1}}],[\"分情况\",{\"1\":{\"23\":1}}],[\"分治法\",{\"1\":{\"20\":1},\"2\":{\"22\":1}}],[\"来的方便\",{\"1\":{\"957\":1}}],[\"来输出日志底层使用的已经是替换后的\",{\"1\":{\"957\":1}}],[\"来创建新的\",{\"1\":{\"957\":1}}],[\"来创建一个\",{\"1\":{\"957\":1}}],[\"来记录日志\",{\"1\":{\"957\":1}}],[\"来支持\",{\"1\":{\"957\":1}}],[\"来提高应用程序的可靠性\",{\"1\":{\"955\":1}}],[\"来提高数据库的读写性能\",{\"1\":{\"810\":1}}],[\"来加载\",{\"1\":{\"952\":1}}],[\"来判断\",{\"1\":{\"949\":1}}],[\"来找到对应的插入位置\",{\"1\":{\"945\":1}}],[\"来延续之前的迭代过程\",{\"1\":{\"870\":1}}],[\"来了\",{\"1\":{\"867\":1}}],[\"来存储密码\",{\"1\":{\"841\":1}}],[\"来确保更改立即生效\",{\"1\":{\"840\":1}}],[\"来确保多次提交的结果一致\",{\"1\":{\"23\":1}}],[\"来确定表之间的连接关系\",{\"1\":{\"823\":1}}],[\"来解除死锁状态\",{\"1\":{\"820\":1}}],[\"来解决\",{\"1\":{\"810\":1}}],[\"来保护记录的\",{\"1\":{\"820\":1}}],[\"来保证一致性\",{\"1\":{\"765\":1}}],[\"来保证事务的原子性\",{\"1\":{\"748\":1}}],[\"来保证服务器的身份是可信的\",{\"1\":{\"249\":1}}],[\"来申请自增\",{\"1\":{\"820\":1}}],[\"来申请内存而不是brk\",{\"1\":{\"217\":1}}],[\"来决定选择使用哪个索引\",{\"1\":{\"817\":1}}],[\"来完成\",{\"1\":{\"817\":1}}],[\"来跟踪和管理事务的状态\",{\"1\":{\"810\":1}}],[\"来接收主库的\",{\"1\":{\"810\":1}}],[\"来划分\",{\"1\":{\"810\":1}}],[\"来控制并发事务访问同一个记录时的行为就叫\",{\"1\":{\"786\":1}}],[\"来\",{\"1\":{\"770\":1,\"810\":1,\"933\":1}}],[\"来管理的\",{\"1\":{\"770\":1}}],[\"来进行回滚\",{\"1\":{\"740\":1,\"810\":1}}],[\"来实现自增\",{\"1\":{\"820\":1}}],[\"来实现的\",{\"1\":{\"743\":1,\"784\":1,\"810\":2}}],[\"来实现\",{\"1\":{\"730\":1,\"810\":1}}],[\"来实现上下文和状态的交互\",{\"1\":{\"249\":1}}],[\"来检查和添加消息id\",{\"1\":{\"714\":1}}],[\"来自\",{\"1\":{\"584\":1,\"626\":1}}],[\"来自协程的概念\",{\"1\":{\"378\":1}}],[\"来兜底完成\",{\"1\":{\"512\":1}}],[\"来返回一个error对象\",{\"1\":{\"472\":1}}],[\"来处理事件循环\",{\"1\":{\"897\":1}}],[\"来处理\",{\"1\":{\"458\":1}}],[\"来初始化\",{\"1\":{\"448\":1}}],[\"来执行\",{\"1\":{\"374\":1,\"810\":1}}],[\"来说\",{\"1\":{\"177\":1,\"770\":1}}],[\"来指定\",{\"1\":{\"126\":1}}],[\"来查看当前映射的端口配置\",{\"1\":{\"118\":1}}],[\"来查看容器是否正常工作\",{\"1\":{\"113\":1}}],[\"来比对\",{\"1\":{\"75\":1}}],[\"来定位目标值\",{\"1\":{\"41\":1}}],[\"来释放之前分配的内存\",{\"1\":{\"33\":1}}],[\"来分配足够的内存\",{\"1\":{\"33\":1}}],[\"来防止多个实例同时处理同一个请求\",{\"1\":{\"23\":1}}],[\"来防止重复操作\",{\"1\":{\"23\":1}}],[\"d号\",{\"1\":{\"986\":1}}],[\"dsn\",{\"1\":{\"976\":2,\"979\":1,\"980\":2}}],[\"dto\",{\"1\":{\"962\":2}}],[\"dpanic\",{\"1\":{\"956\":2,\"957\":2}}],[\"dml\",{\"1\":{\"829\":1,\"854\":1}}],[\"dcl\",{\"1\":{\"829\":1}}],[\"dc\",{\"1\":{\"770\":3}}],[\"d5\",{\"1\":{\"770\":1}}],[\"d9\",{\"1\":{\"770\":1}}],[\"d3\",{\"1\":{\"770\":1}}],[\"d1\",{\"1\":{\"770\":1}}],[\"d14d20507073e5743e607efd616571c834f1a914f903db6279b8de4b5ba3a45a\",{\"1\":{\"104\":1}}],[\"d6\",{\"1\":{\"770\":1}}],[\"dynamic行格式\",{\"1\":{\"770\":1}}],[\"dynamic\",{\"1\":{\"770\":8}}],[\"dynamic和\",{\"1\":{\"770\":1}}],[\"dynamicproxydemo\",{\"1\":{\"559\":1}}],[\"during\",{\"1\":{\"817\":1}}],[\"duration\",{\"1\":{\"957\":3}}],[\"duration<double\",{\"1\":{\"33\":1}}],[\"durability\",{\"1\":{\"774\":1}}],[\"dump\",{\"1\":{\"730\":2,\"761\":1,\"810\":2}}],[\"duplicates\",{\"1\":{\"770\":1}}],[\"duplicate\",{\"1\":{\"714\":1}}],[\"dbname\",{\"1\":{\"976\":2}}],[\"db\",{\"1\":{\"770\":2,\"807\":1,\"846\":2,\"943\":1,\"944\":1,\"962\":1,\"976\":2,\"978\":2,\"979\":1,\"980\":3,\"982\":1,\"985\":1,\"986\":1,\"988\":5,\"989\":2,\"990\":2,\"991\":1,\"992\":3,\"993\":2,\"994\":2,\"995\":1,\"997\":2,\"998\":3,\"999\":3,\"1001\":6,\"1002\":1,\"1003\":1,\"1004\":1,\"1005\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":2,\"1013\":1,\"1014\":4,\"1015\":6}}],[\"dbpassword\",{\"1\":{\"640\":3}}],[\"dbuser\",{\"1\":{\"624\":3,\"640\":3}}],[\"dburl\",{\"1\":{\"624\":3,\"640\":3}}],[\"ddl\",{\"1\":{\"829\":1,\"854\":1}}],[\"dd\",{\"1\":{\"770\":3}}],[\"ddd的更新\",{\"1\":{\"752\":1}}],[\"ddd\",{\"1\":{\"448\":1,\"962\":4}}],[\"ddos\",{\"1\":{\"243\":2}}],[\"d是字符串\",{\"1\":{\"442\":1}}],[\"disablestacktrace\",{\"1\":{\"957\":4}}],[\"disablecaller\",{\"1\":{\"957\":4}}],[\"distinct用法\",{\"1\":{\"1009\":1}}],[\"distinct\",{\"1\":{\"823\":1,\"829\":1,\"1009\":1}}],[\"disk\",{\"1\":{\"813\":2}}],[\"disposition响应头\",{\"1\":{\"1032\":1}}],[\"disposition\",{\"1\":{\"693\":1,\"1032\":1}}],[\"dispatcher\",{\"1\":{\"681\":3}}],[\"di\",{\"1\":{\"698\":1}}],[\"dirtylocked\",{\"1\":{\"531\":1}}],[\"dirtymap\",{\"1\":{\"512\":6,\"516\":1,\"518\":2,\"529\":1}}],[\"dirty\",{\"0\":{\"518\":1,\"519\":1,\"777\":1},\"1\":{\"512\":2,\"516\":5,\"518\":2,\"519\":4,\"520\":6,\"524\":4,\"525\":5,\"526\":2,\"527\":1,\"529\":8,\"530\":5,\"531\":10,\"532\":2}}],[\"directory\",{\"1\":{\"201\":4}}],[\"dicttype\",{\"1\":{\"942\":1}}],[\"dict+\",{\"1\":{\"941\":1}}],[\"dictrehash\",{\"1\":{\"864\":1}}],[\"dict\",{\"0\":{\"941\":1,\"942\":1},\"1\":{\"864\":2,\"894\":4,\"941\":5,\"942\":3,\"943\":4,\"944\":8,\"945\":1,\"946\":5}}],[\"dictentry\",{\"1\":{\"864\":3,\"944\":2,\"945\":1}}],[\"dictht\",{\"1\":{\"864\":3,\"942\":1}}],[\"dic\",{\"1\":{\"449\":1}}],[\"division\",{\"1\":{\"427\":1}}],[\"divide\",{\"1\":{\"427\":1,\"540\":2}}],[\"dhcp\",{\"1\":{\"249\":1}}],[\"dns解析过程通常是基于udp协议\",{\"1\":{\"243\":1}}],[\"dns污染是指向dns解析系统注入虚假的dns数据\",{\"1\":{\"243\":1}}],[\"dns劫持是指拦截或篡改用户的dns查询\",{\"1\":{\"243\":1}}],[\"dns\",{\"1\":{\"243\":5,\"249\":2},\"2\":{\"242\":1}}],[\"dll\",{\"1\":{\"223\":1}}],[\"drift\",{\"1\":{\"918\":2,\"921\":2}}],[\"driver\",{\"1\":{\"640\":1,\"975\":2}}],[\"drop\",{\"1\":{\"770\":1,\"820\":1,\"826\":2,\"829\":1,\"839\":1,\"846\":1,\"851\":1}}],[\"drawio\",{\"1\":{\"748\":1,\"944\":1}}],[\"dracula\",{\"1\":{\"5\":1}}],[\"drm\",{\"1\":{\"223\":1}}],[\"dao\",{\"1\":{\"962\":1}}],[\"databases\",{\"1\":{\"854\":1}}],[\"database\",{\"1\":{\"770\":4,\"846\":1,\"952\":1}}],[\"databaseconnectionpool\",{\"1\":{\"624\":4}}],[\"datadir\",{\"1\":{\"770\":2}}],[\"datasource\",{\"1\":{\"640\":7}}],[\"dataqsiz\",{\"1\":{\"265\":3}}],[\"data\",{\"0\":{\"1064\":1,\"1077\":1},\"1\":{\"226\":1,\"441\":1,\"471\":4,\"546\":2,\"820\":14,\"879\":2,\"940\":1,\"962\":5,\"993\":2,\"1021\":5,\"1041\":1}}],[\"datetime\",{\"1\":{\"820\":1}}],[\"date\",{\"1\":{\"210\":4,\"249\":4,\"652\":1,\"820\":3}}],[\"daemon\",{\"1\":{\"104\":1,\"123\":4}}],[\"d\",{\"1\":{\"33\":3,\"88\":5,\"104\":1,\"110\":1,\"113\":1,\"117\":5,\"119\":2,\"139\":1,\"145\":2,\"201\":1,\"207\":1,\"237\":1,\"249\":3,\"392\":1,\"442\":1,\"464\":1,\"469\":1,\"476\":1,\"515\":8,\"600\":2,\"775\":1,\"813\":4,\"976\":1}}],[\"domain\",{\"1\":{\"962\":1}}],[\"dotrace\",{\"1\":{\"666\":1}}],[\"dooptions\",{\"1\":{\"666\":1}}],[\"dohead\",{\"1\":{\"666\":1}}],[\"dodelete\",{\"1\":{\"666\":1}}],[\"doput\",{\"1\":{\"666\":1}}],[\"dopost\",{\"1\":{\"661\":1,\"666\":1,\"693\":1}}],[\"do结尾的请求\",{\"1\":{\"655\":1}}],[\"dofilter\",{\"1\":{\"584\":2,\"591\":4,\"596\":4,\"598\":2,\"599\":2,\"600\":2,\"601\":2,\"683\":2}}],[\"doget\",{\"1\":{\"652\":1,\"666\":1,\"689\":2}}],[\"dog\",{\"1\":{\"464\":3}}],[\"done\",{\"1\":{\"249\":1,\"367\":1,\"515\":4}}],[\"doctype\",{\"1\":{\"652\":1}}],[\"docs\",{\"1\":{\"249\":3}}],[\"dockerfile\",{\"1\":{\"962\":1}}],[\"docker常用命令详解\",{\"0\":{\"130\":1}}],[\"docker0\",{\"1\":{\"121\":2,\"122\":2,\"123\":2}}],[\"dockerd\",{\"1\":{\"102\":2,\"104\":3}}],[\"docker\",{\"0\":{\"96\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"105\":1,\"116\":1,\"129\":1,\"131\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1},\"1\":{\"99\":4,\"100\":1,\"101\":2,\"102\":4,\"104\":6,\"107\":1,\"108\":1,\"109\":1,\"110\":3,\"111\":1,\"113\":4,\"114\":1,\"117\":6,\"118\":1,\"119\":3,\"121\":5,\"122\":1,\"123\":9,\"124\":1,\"125\":2,\"126\":1,\"132\":3,\"135\":1,\"136\":4,\"137\":4,\"138\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":6,\"143\":4,\"145\":4,\"146\":1,\"147\":2,\"148\":1,\"149\":4,\"150\":1},\"2\":{\"127\":1,\"128\":1,\"151\":1,\"152\":1}}],[\"docker框架与核心原理\",{\"0\":{\"95\":1}}],[\"download=\",{\"1\":{\"1032\":1}}],[\"down\",{\"1\":{\"121\":1}}],[\"dokcer\",{\"0\":{\"122\":1},\"1\":{\"95\":1}}],[\"double\",{\"1\":{\"33\":6,\"460\":3,\"529\":1,\"531\":1,\"568\":1,\"638\":1}}],[\"do\",{\"1\":{\"33\":1,\"568\":1,\"655\":3,\"656\":1,\"962\":1}}],[\"debug输出\",{\"1\":{\"1027\":1}}],[\"debuglevel\",{\"1\":{\"957\":2}}],[\"debug\",{\"1\":{\"956\":1,\"957\":2,\"980\":1,\"1027\":1}}],[\"deadlock\",{\"1\":{\"820\":1}}],[\"demand\",{\"1\":{\"817\":1}}],[\"demo\",{\"0\":{\"367\":1},\"1\":{\"367\":1,\"373\":1,\"969\":3}}],[\"demo演示\",{\"0\":{\"366\":1}}],[\"del\",{\"1\":{\"867\":1,\"873\":2}}],[\"delay=\",{\"1\":{\"810\":1}}],[\"delay\",{\"1\":{\"810\":6,\"918\":2,\"921\":2}}],[\"delete的实现过程\",{\"1\":{\"33\":1}}],[\"delete\",{\"1\":{\"33\":10,\"249\":2,\"514\":1,\"515\":1,\"601\":1,\"741\":1,\"770\":2,\"810\":1,\"820\":1,\"829\":1,\"846\":1,\"999\":2}}],[\"delete请求\",{\"1\":{\"23\":1}}],[\"detect\",{\"1\":{\"820\":1}}],[\"detele\",{\"1\":{\"770\":1}}],[\"details\",{\"1\":{\"229\":1}}],[\"decrement\",{\"1\":{\"903\":1}}],[\"decrementandget\",{\"1\":{\"625\":1}}],[\"declaration\",{\"1\":{\"468\":1}}],[\"dependency>\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"derfer\",{\"1\":{\"476\":2}}],[\"derferrun\",{\"1\":{\"476\":1}}],[\"dequeue\",{\"1\":{\"265\":1}}],[\"development\",{\"1\":{\"956\":1,\"957\":10}}],[\"developer\",{\"1\":{\"249\":4,\"462\":1}}],[\"device\",{\"1\":{\"223\":1}}],[\"devices\",{\"1\":{\"223\":1}}],[\"dev\",{\"1\":{\"223\":5,\"957\":1}}],[\"devops\",{\"2\":{\"152\":1}}],[\"defrag\",{\"1\":{\"944\":1}}],[\"deferrun\",{\"1\":{\"477\":6}}],[\"defer\",{\"0\":{\"476\":1},\"1\":{\"367\":1,\"473\":3,\"475\":1,\"476\":1,\"477\":3,\"509\":1,\"515\":4,\"957\":6},\"2\":{\"296\":1}}],[\"defer函数的实际调用发生在包含它的函数返回前\",{\"1\":{\"294\":1}}],[\"defer函数的执行机制\",{\"0\":{\"294\":1}}],[\"defer的优化\",{\"0\":{\"293\":1}}],[\"defer可以直接在栈上分配\",{\"1\":{\"292\":1}}],[\"defer结构体在不同场景下有不同的分配策略\",{\"1\":{\"290\":1}}],[\"defer结构体的分配\",{\"0\":{\"290\":1}}],[\"defer内存分配方式\",{\"0\":{\"289\":1}}],[\"defer语句执行过程涉及注册和实际调用两个阶段\",{\"1\":{\"288\":1}}],[\"defer执行过程\",{\"0\":{\"288\":1}}],[\"defer在go语言运行时由特定的数据结构支持\",{\"1\":{\"287\":1}}],[\"defer底层数据结构\",{\"0\":{\"287\":1}}],[\"deflate\",{\"1\":{\"249\":2}}],[\"defaultquery\",{\"1\":{\"1035\":1}}],[\"defaultlineending\",{\"1\":{\"957\":3}}],[\"default\",{\"1\":{\"770\":8,\"820\":2,\"957\":2,\"980\":1,\"983\":3,\"992\":1,\"1024\":1,\"1031\":1,\"1040\":1}}],[\"defa\",{\"1\":{\"121\":1}}],[\"define宏定义\",{\"1\":{\"36\":1}}],[\"define\",{\"1\":{\"33\":3,\"36\":4,\"226\":1,\"873\":1}}],[\"desc\",{\"1\":{\"842\":1,\"988\":1,\"1007\":2}}],[\"description\",{\"1\":{\"130\":1}}],[\"destroy\",{\"1\":{\"584\":1,\"592\":1,\"662\":2,\"664\":1,\"683\":1}}],[\"destructor\",{\"1\":{\"33\":1}}],[\"des\",{\"1\":{\"73\":1}}],[\"通的\",{\"1\":{\"820\":1}}],[\"通道\",{\"1\":{\"456\":1}}],[\"通配符\",{\"1\":{\"190\":1}}],[\"通知消费者\",{\"1\":{\"165\":1}}],[\"通信顺序进程\",{\"1\":{\"254\":1}}],[\"通信过程也采用了简单的\",{\"1\":{\"249\":1}}],[\"通信\",{\"1\":{\"102\":1},\"2\":{\"268\":1}}],[\"通常的业务逻辑都在这下面\",{\"1\":{\"962\":1}}],[\"通常的形式是\",{\"1\":{\"249\":1}}],[\"通常业务都满足二八原则\",{\"1\":{\"930\":1}}],[\"通常来说\",{\"1\":{\"927\":1,\"930\":1}}],[\"通常可以做数据库存储的缓存\",{\"1\":{\"930\":1}}],[\"通常可以在\",{\"1\":{\"879\":1}}],[\"通常可以叫\",{\"1\":{\"249\":1}}],[\"通常情况下\",{\"1\":{\"807\":1}}],[\"通常有关于过滤聚合函数的结果\",{\"1\":{\"807\":1}}],[\"通常都是建议将字段设置为\",{\"1\":{\"770\":1}}],[\"通常只需要继承httpservlet并重写需要的方法\",{\"1\":{\"666\":1}}],[\"通常不直接生成响应\",{\"1\":{\"578\":1}}],[\"通常不应该被捕获\",{\"1\":{\"538\":1}}],[\"通常经过\",{\"1\":{\"249\":1}}],[\"通常涉及跨越多个网络和路由器\",{\"1\":{\"249\":1}}],[\"通常浏览器和操作系统中集成了\",{\"1\":{\"240\":1,\"249\":1}}],[\"通常body会有数据\",{\"1\":{\"240\":1}}],[\"通常称为页表缓存\",{\"1\":{\"217\":1}}],[\"通常登录名为\",{\"1\":{\"190\":1}}],[\"通常为0\",{\"1\":{\"92\":1}}],[\"通常\",{\"1\":{\"92\":1,\"249\":2,\"854\":1}}],[\"通常是奇数个\",{\"1\":{\"917\":1,\"921\":1}}],[\"通常是在\",{\"1\":{\"813\":1}}],[\"通常是数据库系统或应用程序中的一个组件\",{\"1\":{\"810\":1}}],[\"通常是最慢的\",{\"1\":{\"807\":1}}],[\"通常是tcp或udp\",{\"1\":{\"237\":1}}],[\"通常是一个固定的常量\",{\"1\":{\"723\":1}}],[\"通常是一个\",{\"1\":{\"190\":2}}],[\"通常是kafka集群中的一个broker\",{\"1\":{\"165\":1}}],[\"通常是\",{\"1\":{\"33\":2,\"813\":1}}],[\"通常是天然幂等的\",{\"1\":{\"23\":1}}],[\"通过golang\",{\"1\":{\"1058\":1}}],[\"通过尝试所有可能的字符组合来破解密码\",{\"1\":{\"1048\":1}}],[\"通过前文对\",{\"1\":{\"957\":1}}],[\"通过前端页面按钮禁用等方式防止用户重复提交\",{\"1\":{\"23\":1}}],[\"通过查看\",{\"1\":{\"957\":1}}],[\"通过查看这三个字段的值\",{\"1\":{\"807\":1}}],[\"通过配置指令关闭aof功能时\",{\"1\":{\"952\":1}}],[\"通过时间\",{\"1\":{\"918\":1,\"921\":1}}],[\"通过setnx加锁\",{\"1\":{\"910\":1,\"921\":1}}],[\"通过select\",{\"1\":{\"820\":1}}],[\"通过索引可以一次实现多个节点的跳跃\",{\"1\":{\"885\":1}}],[\"通过解析器对\",{\"1\":{\"817\":1}}],[\"通过创建唯一索引\",{\"1\":{\"813\":1}}],[\"通过延迟写\",{\"1\":{\"810\":1}}],[\"通过加锁虽然完美地解决了顺序一致性的问题\",{\"1\":{\"810\":1}}],[\"通过加读写锁的方式来避免并行访问\",{\"1\":{\"784\":1}}],[\"通过使用\",{\"1\":{\"810\":1}}],[\"通过主键索引树搜索获取\",{\"1\":{\"810\":2}}],[\"通过调用\",{\"1\":{\"810\":1}}],[\"通过执行计划\",{\"1\":{\"807\":1}}],[\"通过将多个列组合成一个索引来优化特定查询\",{\"1\":{\"807\":1}}],[\"通过将数据页首先写入缓冲池\",{\"1\":{\"754\":1}}],[\"通过将搜索空间染色为红蓝两部分\",{\"1\":{\"41\":1}}],[\"通过维护数据的多个版本来实现并发访问\",{\"1\":{\"743\":1}}],[\"通过存储引擎接口调用具体的存储引擎\",{\"1\":{\"734\":1}}],[\"通过估算不同执行计划的代价\",{\"1\":{\"734\":1}}],[\"通过mysql连接器处理后\",{\"1\":{\"734\":1}}],[\"通过make函数等\",{\"1\":{\"340\":1}}],[\"通过依赖注入和面向切面编程\",{\"1\":{\"697\":1}}],[\"通过命名约定控制顺序\",{\"1\":{\"608\":1}}],[\"通过class\",{\"1\":{\"553\":1}}],[\"通过connection\",{\"1\":{\"237\":1}}],[\"通过类的class属性\",{\"1\":{\"553\":1}}],[\"通过对象的getclass\",{\"1\":{\"553\":1}}],[\"通过无锁的\",{\"1\":{\"512\":1}}],[\"通过定义接口和实现接口的方式\",{\"1\":{\"463\":1}}],[\"通过词法分析\",{\"1\":{\"400\":1}}],[\"通过链表结构把bmap结构体连接起来\",{\"1\":{\"325\":1}}],[\"通过单个\",{\"1\":{\"249\":1}}],[\"通过一个叫服务器推送的机制来提前请求\",{\"1\":{\"249\":1}}],[\"通过协商结果来判断是否使用本地缓存\",{\"1\":{\"249\":1}}],[\"通过宿主机的网络连接\",{\"1\":{\"246\":1}}],[\"通过探测报文来检测连接状态\",{\"1\":{\"237\":1}}],[\"通过声明带有\",{\"1\":{\"229\":1}}],[\"通过在一个结构体中嵌入另一个匿名结构体\",{\"1\":{\"462\":1}}],[\"通过在输入字段插入恶意sql代码来操控数据库查询的攻击手段\",{\"1\":{\"243\":1}}],[\"通过在调用\",{\"1\":{\"229\":1}}],[\"通过在\",{\"1\":{\"229\":1}}],[\"通过在数据库表中设置唯一键来防止重复数据的插入\",{\"1\":{\"23\":1}}],[\"通过传递\",{\"1\":{\"229\":1}}],[\"通过回调函数内核会将其加入到这个就绪事件列表中\",{\"1\":{\"226\":1}}],[\"通过epoll\",{\"1\":{\"226\":1}}],[\"通过下标修改字节数组\",{\"1\":{\"356\":1}}],[\"通过下标关系表示节点间的父子关系\",{\"1\":{\"65\":1}}],[\"通过下面2个数据结构\",{\"1\":{\"226\":1}}],[\"通过系统调用mmap\",{\"1\":{\"217\":1}}],[\"通过多副本机制来实现容灾\",{\"1\":{\"169\":1}}],[\"通过\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"122\":1,\"217\":2,\"249\":1,\"398\":1,\"524\":1,\"742\":2,\"743\":1,\"763\":1,\"783\":2,\"784\":1,\"786\":1,\"810\":4,\"820\":1,\"876\":1,\"888\":1,\"957\":2}}],[\"通过这个字段可以定位到上一个节点的起始地址\",{\"1\":{\"879\":1}}],[\"通过这个唯一标识来判定图片是否在图库中\",{\"1\":{\"75\":1}}],[\"通过这两个信息就可以定位到一条消息\",{\"1\":{\"163\":1}}],[\"通过这种方式\",{\"1\":{\"92\":1,\"123\":1,\"810\":1}}],[\"通过哈希算法\",{\"1\":{\"75\":1,\"77\":1}}],[\"通过覆写赋值运算符\",{\"1\":{\"33\":1}}],[\"通过redis\",{\"1\":{\"23\":1}}],[\"通过新增一个\",{\"1\":{\"23\":1}}],[\"通过引入唯一请求id\",{\"1\":{\"23\":1}}],[\"gap\",{\"1\":{\"820\":12}}],[\"gateway\",{\"1\":{\"646\":1}}],[\"g9\",{\"1\":{\"373\":1}}],[\"g3\",{\"1\":{\"373\":2,\"374\":1}}],[\"g248\",{\"1\":{\"374\":1}}],[\"g258\",{\"1\":{\"374\":3}}],[\"g256\",{\"1\":{\"374\":4}}],[\"g257\",{\"1\":{\"374\":5}}],[\"g2\",{\"1\":{\"373\":3,\"374\":1}}],[\"g189\",{\"1\":{\"374\":1}}],[\"g188\",{\"1\":{\"374\":1}}],[\"g128\",{\"1\":{\"374\":1}}],[\"g129\",{\"1\":{\"374\":1}}],[\"g1\",{\"1\":{\"373\":5,\"374\":4}}],[\"g10\",{\"1\":{\"373\":3}}],[\"gm\",{\"0\":{\"381\":1}}],[\"gm符号概念\",{\"0\":{\"380\":1}}],[\"gm模型\",{\"0\":{\"379\":1}}],[\"gmp符号定义\",{\"0\":{\"383\":1}}],[\"gmp\",{\"0\":{\"384\":1,\"1065\":1},\"1\":{\"373\":1,\"374\":2},\"2\":{\"376\":1,\"386\":1}}],[\"gmp模型\",{\"0\":{\"366\":1,\"377\":1,\"382\":1}}],[\"gmt\",{\"1\":{\"249\":6}}],[\"gpt\",{\"1\":{\"813\":1}}],[\"gp1\",{\"1\":{\"374\":2}}],[\"gp\",{\"1\":{\"265\":8,\"374\":2}}],[\"gc\",{\"1\":{\"918\":2,\"921\":2}}],[\"gc卡顿等原因\",{\"1\":{\"912\":1,\"921\":1}}],[\"gcflags\",{\"1\":{\"409\":1}}],[\"gcflags=\",{\"1\":{\"398\":3,\"399\":1}}],[\"gcflags参数可以控制go编译器的行为\",{\"1\":{\"398\":1}}],[\"gcflags参数\",{\"0\":{\"398\":1}}],[\"gcm\",{\"1\":{\"249\":2}}],[\"gcc\",{\"1\":{\"26\":1},\"2\":{\"28\":1}}],[\"gcc与gdb工具使用指南\",{\"0\":{\"26\":1}}],[\"gzip\",{\"1\":{\"249\":3}}],[\"gb\",{\"1\":{\"237\":2,\"810\":1}}],[\"gecko\",{\"1\":{\"249\":2}}],[\"generatefrompassword\",{\"1\":{\"1058\":1,\"1059\":1}}],[\"generate\",{\"1\":{\"962\":1,\"965\":1}}],[\"genericservlet是一个抽象类\",{\"1\":{\"665\":1}}],[\"genericservlet抽象类\",{\"0\":{\"665\":1},\"1\":{\"667\":1}}],[\"genssa\",{\"1\":{\"394\":1}}],[\"gen\",{\"1\":{\"229\":3,\"962\":1}}],[\"gender\",{\"1\":{\"229\":3,\"983\":2,\"985\":1,\"986\":1,\"1001\":1,\"1005\":1,\"1010\":3}}],[\"gethashingcost\",{\"1\":{\"1059\":2}}],[\"getheadernames\",{\"1\":{\"671\":1}}],[\"getheader\",{\"1\":{\"671\":1,\"693\":1}}],[\"getpostform\",{\"1\":{\"1037\":1}}],[\"getpart\",{\"1\":{\"693\":1}}],[\"getparametermap\",{\"1\":{\"670\":1}}],[\"getparameternames\",{\"1\":{\"670\":1}}],[\"getparametervalues\",{\"1\":{\"670\":1}}],[\"getparameter\",{\"1\":{\"670\":1,\"687\":1,\"689\":2}}],[\"getpackage\",{\"1\":{\"555\":1}}],[\"getfilename\",{\"1\":{\"693\":2}}],[\"getfields\",{\"1\":{\"557\":1}}],[\"getbytes\",{\"1\":{\"687\":1}}],[\"getbigdata\",{\"1\":{\"429\":2}}],[\"getoutputstream\",{\"1\":{\"677\":1}}],[\"getonlineusercount\",{\"1\":{\"641\":1}}],[\"getonlineusers\",{\"1\":{\"641\":1}}],[\"getwriter\",{\"1\":{\"652\":1,\"677\":1,\"693\":1}}],[\"getters\",{\"1\":{\"637\":1}}],[\"getvalue\",{\"1\":{\"633\":3,\"634\":3,\"635\":3,\"641\":3}}],[\"getactivesessioncount\",{\"1\":{\"625\":1}}],[\"getattribute\",{\"1\":{\"598\":1,\"624\":1,\"626\":1,\"633\":1,\"634\":1,\"635\":1,\"641\":2}}],[\"getid\",{\"1\":{\"625\":2,\"634\":3,\"637\":2,\"638\":2,\"692\":1}}],[\"getinitparameter\",{\"1\":{\"590\":1,\"599\":1,\"624\":2,\"640\":3}}],[\"getinterfaces\",{\"1\":{\"555\":1,\"559\":1}}],[\"getlogger\",{\"1\":{\"600\":1}}],[\"getrequestdispatcher\",{\"1\":{\"681\":1}}],[\"getrequesturl\",{\"1\":{\"672\":1}}],[\"getrequesturi\",{\"1\":{\"584\":1,\"598\":1,\"600\":1,\"626\":2,\"635\":3,\"672\":1}}],[\"getremoteaddr\",{\"1\":{\"584\":1,\"626\":1}}],[\"getuser\",{\"1\":{\"559\":3}}],[\"getmodifiers\",{\"1\":{\"558\":1}}],[\"getmethod\",{\"1\":{\"584\":1,\"600\":1,\"626\":1}}],[\"getmethods\",{\"1\":{\"558\":1}}],[\"getmessage\",{\"1\":{\"540\":2,\"541\":1,\"542\":1,\"543\":1,\"640\":1,\"699\":3}}],[\"getdeclaredmethod\",{\"1\":{\"558\":2}}],[\"getdeclaredmethods\",{\"1\":{\"558\":1}}],[\"getdeclaredfield\",{\"1\":{\"557\":1}}],[\"getdeclaredfields\",{\"1\":{\"557\":1}}],[\"getdata\",{\"1\":{\"30\":3}}],[\"getcookies\",{\"1\":{\"673\":1}}],[\"getcontextpath\",{\"1\":{\"598\":1,\"672\":1}}],[\"getconstructor\",{\"1\":{\"556\":1}}],[\"getconstructors\",{\"1\":{\"556\":1}}],[\"getclassloader\",{\"1\":{\"559\":1}}],[\"getclass\",{\"1\":{\"553\":1,\"559\":2}}],[\"getservletpath\",{\"1\":{\"672\":1}}],[\"getservletinfo\",{\"1\":{\"664\":1}}],[\"getservletconfig\",{\"1\":{\"664\":1}}],[\"getservletcontext\",{\"1\":{\"590\":1,\"624\":2,\"633\":1,\"640\":1}}],[\"getservletrequest\",{\"1\":{\"626\":2,\"635\":7}}],[\"getsession\",{\"1\":{\"598\":1,\"625\":2,\"634\":4,\"637\":2,\"638\":2,\"641\":2,\"673\":1,\"691\":1,\"692\":3}}],[\"getsuperclass\",{\"1\":{\"555\":1}}],[\"getsimplename\",{\"1\":{\"555\":1}}],[\"getnamemethod\",{\"1\":{\"558\":3}}],[\"getname\",{\"1\":{\"555\":4,\"558\":1,\"559\":2,\"600\":1,\"633\":3,\"634\":3,\"635\":3,\"637\":2,\"641\":3}}],[\"getg\",{\"1\":{\"265\":1}}],[\"get开头\",{\"1\":{\"249\":1}}],[\"get\",{\"1\":{\"243\":1,\"249\":10,\"374\":1,\"557\":1,\"601\":1,\"625\":1,\"888\":2,\"957\":2,\"975\":2,\"1021\":3,\"1023\":1,\"1024\":1,\"1031\":1,\"1032\":1,\"1036\":1,\"1040\":1}}],[\"get请求带请求体\",{\"1\":{\"1037\":1}}],[\"get请求参数乱码\",{\"1\":{\"687\":1}}],[\"get请求\",{\"1\":{\"23\":1}}],[\"globrunqget\",{\"1\":{\"374\":1}}],[\"global\",{\"1\":{\"121\":1,\"374\":5,\"940\":1}}],[\"glossary\",{\"1\":{\"249\":3}}],[\"glibc\",{\"1\":{\"217\":1}}],[\"gg跳到文首\",{\"1\":{\"214\":1}}],[\"g\",{\"1\":{\"208\":2,\"214\":1,\"265\":2,\"373\":4,\"374\":12,\"381\":11,\"438\":2,\"442\":1,\"820\":7}}],[\"gshadow\",{\"1\":{\"190\":1}}],[\"gin的bind功能可以将http请求的各种数据格式\",{\"1\":{\"1038\":1}}],[\"gin也可以通过内置方法构造静态文件的路径\",{\"1\":{\"1033\":1}}],[\"gin提供了很多响应的方法\",{\"1\":{\"1028\":1}}],[\"gin框架详解\",{\"0\":{\"1018\":1}}],[\"gin\",{\"0\":{\"1022\":1,\"1023\":1,\"1028\":1},\"1\":{\"957\":1,\"1023\":2,\"1024\":4,\"1027\":2,\"1029\":1,\"1031\":2,\"1036\":1,\"1037\":1,\"1039\":1,\"1040\":5,\"1041\":1},\"2\":{\"1045\":1}}],[\"gif\",{\"1\":{\"249\":3}}],[\"gid\",{\"1\":{\"190\":3}}],[\"github\",{\"1\":{\"12\":1,\"955\":1,\"956\":1,\"957\":5,\"968\":1,\"1023\":1,\"1024\":1,\"1040\":1}}],[\"git\",{\"1\":{\"11\":1}}],[\"gitlens\",{\"1\":{\"11\":1}}],[\"git可视化\",{\"0\":{\"11\":1}}],[\"gnu\",{\"1\":{\"190\":1}}],[\"gonic\",{\"1\":{\"1023\":1,\"1024\":1,\"1040\":1}}],[\"gorm框架\",{\"1\":{\"975\":1}}],[\"gorm简介\",{\"0\":{\"974\":1}}],[\"gorm\",{\"0\":{\"973\":1},\"1\":{\"973\":2,\"974\":1,\"975\":4,\"976\":3,\"978\":4,\"979\":2,\"980\":5,\"983\":8,\"988\":1,\"992\":1,\"1013\":1,\"1014\":1},\"2\":{\"1017\":1}}],[\"goroutine\",{\"0\":{\"378\":1},\"1\":{\"265\":2,\"367\":1,\"378\":7,\"384\":2,\"511\":3,\"515\":2,\"516\":1,\"522\":1,\"529\":1}}],[\"goroutine是绑定在sudog中这个结构上的\",{\"1\":{\"261\":1}}],[\"gokit\",{\"1\":{\"957\":2}}],[\"goto\",{\"1\":{\"568\":1}}],[\"go库\",{\"2\":{\"493\":1}}],[\"go没有专门的枚举类型\",{\"1\":{\"441\":1}}],[\"go基础语法\",{\"0\":{\"432\":1}}],[\"go支持命名返回值\",{\"1\":{\"427\":1}}],[\"go支持多返回值\",{\"1\":{\"420\":1}}],[\"go多返回值原理\",{\"0\":{\"419\":1}}],[\"go的变量如果能在编译器编译过程中证明确认在函数返回后不会再被引用\",{\"1\":{\"407\":1}}],[\"go的输出文件\",{\"1\":{\"229\":1}}],[\"go内存逃逸\",{\"0\":{\"403\":1}}],[\"go编译器是一个高效的多阶段编译系统\",{\"1\":{\"400\":1}}],[\"go编译器会进行逃逸分析\",{\"1\":{\"399\":1}}],[\"go编译器提供了多种优化选项\",{\"1\":{\"397\":1}}],[\"go编译器提供了多种编译标记\",{\"1\":{\"392\":1}}],[\"go编译器的架构如下\",{\"1\":{\"394\":1}}],[\"go编译器原理\",{\"0\":{\"387\":1}}],[\"gofile\",{\"1\":{\"391\":1}}],[\"gomaxprocs\",{\"1\":{\"367\":1,\"373\":1,\"374\":3}}],[\"go对字符串的定义如下\",{\"1\":{\"351\":1}}],[\"go中参数传递都是值传递\",{\"1\":{\"454\":1}}],[\"go中没有一个关键字或者函数可以让变量被编译器分配到堆上\",{\"1\":{\"407\":1}}],[\"go中\",{\"1\":{\"351\":1}}],[\"go中map底层采用哈希表\",{\"1\":{\"319\":1}}],[\"go运行时会复用itab结构体\",{\"1\":{\"313\":1}}],[\"go源码解读\",{\"1\":{\"283\":1}}],[\"goparkunlock\",{\"1\":{\"265\":1}}],[\"go语言bcrypt加密详解\",{\"0\":{\"1046\":1}}],[\"go语言的strings包提供了丰富而强大的字符串处理功能\",{\"1\":{\"494\":1}}],[\"go语言的多返回值特性通过栈上分配的匿名结构体实现\",{\"1\":{\"430\":1}}],[\"go语言字符串处理\",{\"0\":{\"494\":1}}],[\"go语言字符串详解\",{\"0\":{\"349\":1}}],[\"go语言跟其他语言一样\",{\"1\":{\"442\":1}}],[\"go语言常用多返回值进行错误处理\",{\"1\":{\"425\":1}}],[\"go语言内存逃逸的场景\",{\"1\":{\"403\":1}}],[\"go语言提供了丰富的编译命令行工具\",{\"1\":{\"390\":1}}],[\"go语言提供了多种字符串拼接方式\",{\"1\":{\"362\":1}}],[\"go语言中使用bcrypt\",{\"0\":{\"1057\":1}}],[\"go语言中使用字面量来表示字符串有两种方式\",{\"1\":{\"361\":1}}],[\"go语言中切片的扩容规则如下\",{\"1\":{\"345\":1}}],[\"go语言中的map是一种哈希表实现\",{\"1\":{\"319\":1}}],[\"go语言中的接口是一种特殊的类型\",{\"1\":{\"298\":1}}],[\"go语言切片详解\",{\"0\":{\"336\":1}}],[\"go语言map详解\",{\"0\":{\"318\":1}}],[\"go语言接口详解\",{\"0\":{\"297\":1}}],[\"go语言defer机制详解\",{\"0\":{\"286\":1}}],[\"go语言标准库context\",{\"1\":{\"283\":1}}],[\"go语言context详解\",{\"0\":{\"269\":1}}],[\"go语言channel详解\",{\"0\":{\"253\":1}}],[\"go语言遵循csp并发编程模式\",{\"1\":{\"254\":1}}],[\"go文件放置的目录取决于编译器标志\",{\"1\":{\"229\":1}}],[\"go而创建的\",{\"1\":{\"229\":1}}],[\"goland很多库的源代码都会以空接口作为参数\",{\"1\":{\"467\":1}}],[\"golang\",{\"1\":{\"229\":1,\"266\":1,\"1059\":1}}],[\"goldendict\",{\"1\":{\"223\":1}}],[\"go1\",{\"1\":{\"229\":1}}],[\"google\",{\"1\":{\"229\":3,\"962\":1}}],[\"go是如何实现protobuf的编解码的\",{\"1\":{\"229\":1}}],[\"go\",{\"0\":{\"153\":1,\"378\":1,\"390\":1,\"393\":1,\"459\":1},\"1\":{\"229\":43,\"302\":2,\"333\":2,\"367\":1,\"378\":1,\"384\":1,\"391\":9,\"398\":6,\"399\":2,\"409\":2,\"423\":2,\"432\":1,\"452\":2,\"453\":1,\"458\":1,\"459\":2,\"460\":1,\"461\":2,\"462\":1,\"464\":1,\"466\":1,\"472\":1,\"496\":2,\"497\":2,\"503\":4,\"509\":1,\"510\":2,\"511\":2,\"512\":1,\"515\":4,\"520\":1,\"955\":2,\"957\":18,\"962\":20,\"965\":1,\"968\":2,\"973\":1,\"975\":3,\"1023\":1,\"1032\":4,\"1059\":1},\"2\":{\"267\":1,\"268\":1,\"284\":1,\"285\":1,\"295\":1,\"296\":1,\"316\":1,\"317\":1,\"334\":1,\"335\":1,\"347\":1,\"348\":1,\"364\":1,\"365\":1,\"375\":1,\"376\":1,\"385\":1,\"386\":1,\"401\":1,\"402\":1,\"418\":1,\"431\":1,\"492\":1,\"506\":1,\"507\":1,\"533\":1,\"958\":1,\"959\":1,\"971\":1,\"972\":1,\"1016\":1,\"1017\":1,\"1044\":1,\"1045\":1,\"1060\":1,\"1061\":1}}],[\"grammar\",{\"0\":{\"1067\":1}}],[\"grants\",{\"1\":{\"848\":1}}],[\"grant\",{\"1\":{\"829\":1,\"838\":1,\"846\":1}}],[\"greeter\",{\"1\":{\"962\":8}}],[\"greeting\",{\"1\":{\"654\":2}}],[\"grep\",{\"1\":{\"197\":1,\"198\":1,\"199\":1,\"211\":2}}],[\"grow\",{\"1\":{\"505\":2}}],[\"groupid>\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"groupdel\",{\"1\":{\"208\":1}}],[\"groupadd\",{\"1\":{\"208\":1}}],[\"groupname\",{\"1\":{\"190\":2}}],[\"group\",{\"1\":{\"121\":1,\"190\":2,\"757\":1,\"760\":1,\"767\":1,\"810\":9,\"823\":1,\"1010\":1}}],[\"grub\",{\"1\":{\"223\":1}}],[\"grpc服务监听\",{\"1\":{\"966\":1}}],[\"grpc\",{\"1\":{\"102\":1,\"962\":2,\"966\":1}}],[\"gdb\",{\"1\":{\"26\":1},\"2\":{\"28\":1}}],[\"唯一二级索引冲突\",{\"1\":{\"820\":2}}],[\"唯一性\",{\"1\":{\"813\":1}}],[\"唯一性问题\",{\"1\":{\"727\":1}}],[\"唯一性约束\",{\"1\":{\"23\":1}}],[\"唯一约束\",{\"1\":{\"714\":1}}],[\"唯一标识符\",{\"1\":{\"714\":1}}],[\"唯一标识符等\",{\"1\":{\"23\":1}}],[\"唯一标识\",{\"0\":{\"75\":1},\"2\":{\"94\":1}}],[\"唯一请求id\",{\"1\":{\"23\":1}}],[\"唯一索引查询数据时\",{\"1\":{\"813\":1}}],[\"唯一索引陷阱\",{\"1\":{\"813\":1}}],[\"唯一索引\",{\"1\":{\"23\":1,\"813\":1,\"820\":2}}],[\"唯一键\",{\"1\":{\"23\":1}}],[\"防sql注入\",{\"1\":{\"990\":1}}],[\"防御方式\",{\"1\":{\"243\":1}}],[\"防止同一时间大量数据过期现象发生\",{\"1\":{\"930\":1}}],[\"防止因为碰到连续的空位置导致主线程操作被阻塞\",{\"1\":{\"864\":1}}],[\"防止插入新的数据\",{\"1\":{\"820\":1}}],[\"防止其他线程对这个表结构做了变更\",{\"1\":{\"820\":1}}],[\"防止\",{\"1\":{\"807\":1}}],[\"防止会话固定攻击\",{\"1\":{\"692\":1}}],[\"防止会话固定攻击等\",{\"1\":{\"615\":1}}],[\"防止xss攻击\",{\"1\":{\"604\":1}}],[\"防止注入攻击\",{\"1\":{\"604\":1}}],[\"防止历史连接中的数据\",{\"1\":{\"237\":1}}],[\"防止该虚函数在子类中被重写\",{\"1\":{\"33\":1}}],[\"防止该类被继承\",{\"1\":{\"33\":1}}],[\"防止函数内部修改外部的值\",{\"1\":{\"30\":1}}],[\"防止用户重复点击\",{\"1\":{\"23\":1}}],[\"防止用户重复提交订单是典型的防重设计应用场景\",{\"1\":{\"23\":1}}],[\"防重token\",{\"1\":{\"23\":1}}],[\"防重token令牌\",{\"1\":{\"23\":1}}],[\"防重复提交机制\",{\"1\":{\"23\":1}}],[\"防重设计主要是为了防止重复操作或重复请求导致数据的重复处理或存储\",{\"1\":{\"23\":1}}],[\"防重设计\",{\"1\":{\"23\":2},\"2\":{\"25\":1}}],[\"防重设计与接口幂等性区别\",{\"1\":{\"23\":1}}],[\"防重设计与接口幂等设计\",{\"1\":{\"23\":1}}],[\"防重设计与接口幂等设计详解\",{\"0\":{\"23\":1}}],[\"在连接的时候带上\",{\"1\":{\"978\":1}}],[\"在proto文件同目录下生成\",{\"1\":{\"969\":1}}],[\"在重写过程中\",{\"1\":{\"952\":1}}],[\"在重做日志组中\",{\"1\":{\"810\":1}}],[\"在我看来\",{\"1\":{\"949\":1}}],[\"在组织形式上会有所差异\",{\"1\":{\"946\":1}}],[\"在全景图的\",{\"1\":{\"946\":1}}],[\"在更新mysql时\",{\"1\":{\"930\":1}}],[\"在更新时候需要额外操作redis\",{\"1\":{\"930\":1}}],[\"在流量大时\",{\"1\":{\"930\":1}}],[\"在cache\",{\"1\":{\"930\":1}}],[\"在写操作的时候\",{\"1\":{\"930\":1}}],[\"在写入数据主库的同时\",{\"1\":{\"730\":1}}],[\"在目前的微服务架构下\",{\"1\":{\"930\":1}}],[\"在计算机系统中\",{\"1\":{\"930\":1}}],[\"在投递kafka失败的情况下\",{\"1\":{\"927\":1}}],[\"在redis操作成功\",{\"1\":{\"927\":1}}],[\"在订阅者终端\",{\"1\":{\"924\":1}}],[\"在第三个终端\",{\"1\":{\"924\":1}}],[\"在第29行\",{\"1\":{\"311\":1}}],[\"在5台分布式机器上都加上锁\",{\"1\":{\"918\":1,\"921\":1}}],[\"在gc回来之后\",{\"1\":{\"918\":1,\"921\":1}}],[\"在go语言中\",{\"1\":{\"422\":1}}],[\"在真实的分布式场景中\",{\"1\":{\"912\":1,\"921\":1}}],[\"在遍历淘汰池时\",{\"1\":{\"906\":1}}],[\"在设置键过期时间的同时\",{\"1\":{\"882\":1}}],[\"在结构上没太大的区别\",{\"1\":{\"879\":1}}],[\"在触发扩容之后\",{\"1\":{\"864\":1}}],[\"在该记录上持有了\",{\"1\":{\"820\":1}}],[\"在隔离级别可重复读的情况下\",{\"1\":{\"820\":1}}],[\"在隔离级别是\",{\"1\":{\"820\":1}}],[\"在多次查询\",{\"1\":{\"820\":2}}],[\"在索引树找到第一条大于该查询记录的记录后\",{\"1\":{\"820\":1}}],[\"在索引树上定位到这一条记录后\",{\"1\":{\"820\":1}}],[\"在索引组织表中\",{\"1\":{\"813\":1}}],[\"在能使用记录锁或者间隙锁就能避免幻读现象的场景下\",{\"1\":{\"820\":1}}],[\"在此期间会生成一个\",{\"1\":{\"820\":1}}],[\"在此模型中\",{\"1\":{\"226\":2}}],[\"在此模式中\",{\"1\":{\"226\":3}}],[\"在插入二级索引记录时会遇到重复的唯一二级索引列值\",{\"1\":{\"820\":1}}],[\"在插入数据时\",{\"1\":{\"820\":1}}],[\"在插入时对数据进行了排序\",{\"1\":{\"813\":1}}],[\"在对表结构变更前\",{\"1\":{\"820\":1}}],[\"在对索引进行简单的表达式计算\",{\"1\":{\"813\":1}}],[\"在备库上执行了\",{\"1\":{\"820\":1}}],[\"在备库执行就会被当做多个事务分段自行\",{\"1\":{\"810\":1}}],[\"在备份数据库时就要使用全局锁的方法\",{\"1\":{\"820\":1}}],[\"在下图中执行计划\",{\"1\":{\"817\":1}}],[\"在下一次更新\",{\"1\":{\"525\":1}}],[\"在查询的时候\",{\"1\":{\"930\":1}}],[\"在查询语句最前面加个\",{\"1\":{\"817\":1}}],[\"在查询操作中\",{\"1\":{\"23\":1}}],[\"在词法分析\",{\"1\":{\"817\":1}}],[\"在分析之后\",{\"1\":{\"817\":1}}],[\"在分布式环境或内存不足时\",{\"1\":{\"638\":1}}],[\"在分布式系统中\",{\"1\":{\"23\":1}}],[\"在缓存中查不到\",{\"1\":{\"817\":1}}],[\"在缓存中查到\",{\"1\":{\"817\":1}}],[\"在代码里调用\",{\"1\":{\"817\":1}}],[\"在联合索引的情况下\",{\"1\":{\"813\":1}}],[\"在联合索引找到主键值后\",{\"1\":{\"813\":1}}],[\"在条件查询中\",{\"1\":{\"813\":2}}],[\"在条件允许的情况下\",{\"1\":{\"807\":1}}],[\"在特殊处理后\",{\"1\":{\"813\":1}}],[\"在特定条件下\",{\"1\":{\"292\":1}}],[\"在二级索引\",{\"1\":{\"813\":1,\"820\":1}}],[\"在数据量相同的情况下\",{\"1\":{\"813\":1}}],[\"在数据库中也没有取到\",{\"1\":{\"930\":1}}],[\"在数据库中设置唯一索引\",{\"1\":{\"23\":1}}],[\"在数据库层面\",{\"1\":{\"820\":1}}],[\"在数据库管理系统中\",{\"1\":{\"810\":1}}],[\"在数据库表只有一个\",{\"1\":{\"770\":1}}],[\"在叶子节点内用二分查找快速定位数据\",{\"1\":{\"813\":1}}],[\"在上面两个都没有的情况下\",{\"1\":{\"813\":1}}],[\"在上面的示例中\",{\"1\":{\"458\":1}}],[\"在上面的map底层结构图可以看到\",{\"1\":{\"330\":1}}],[\"在等待的过程中\",{\"1\":{\"810\":1}}],[\"在等待锁释放时被阻塞\",{\"1\":{\"511\":1}}],[\"在早期的\",{\"1\":{\"810\":1}}],[\"在崩溃恢复时检查事务的状态\",{\"1\":{\"810\":1}}],[\"在xa事务中\",{\"1\":{\"810\":1}}],[\"在持久化\",{\"1\":{\"810\":1}}],[\"在读数据时只读从库\",{\"1\":{\"810\":1}}],[\"在完成主从复制之后\",{\"1\":{\"810\":1}}],[\"在完成一条更新操作后\",{\"1\":{\"759\":1,\"810\":1}}],[\"在任何时间段突然崩溃\",{\"1\":{\"810\":1}}],[\"在任务调度系统中\",{\"1\":{\"719\":1}}],[\"在保证足够使用的范围内\",{\"1\":{\"807\":1}}],[\"在客户端做了连接限制\",{\"1\":{\"807\":1}}],[\"在做性能优化时\",{\"1\":{\"807\":1}}],[\"在聚合函数之后进行过滤\",{\"1\":{\"807\":1}}],[\"在创建表时\",{\"1\":{\"813\":1}}],[\"在创建联合索引时\",{\"1\":{\"807\":1}}],[\"在创建切片的时候\",{\"1\":{\"415\":1}}],[\"在可重复读隔离级别下\",{\"1\":{\"793\":1}}],[\"在记录的真实数据处只会保存该列的一部分数据\",{\"1\":{\"770\":1}}],[\"在算\",{\"1\":{\"770\":1}}],[\"在前面我也提到了\",{\"1\":{\"770\":1}}],[\"在前端和后端之间进行防重复提交的交互\",{\"1\":{\"23\":1}}],[\"在前端页面中\",{\"1\":{\"23\":1}}],[\"在存储数据的时候\",{\"1\":{\"770\":1}}],[\"在表中数据量大的时候\",{\"1\":{\"770\":1}}],[\"在两阶段提交中\",{\"1\":{\"810\":1}}],[\"在两阶段提交的流程基础上\",{\"1\":{\"766\":1,\"810\":1}}],[\"在两种状态间来回切换\",{\"1\":{\"220\":1}}],[\"在主库上也要提交这个事务\",{\"1\":{\"810\":1}}],[\"在主从架构中\",{\"1\":{\"763\":2,\"810\":2}}],[\"在主动断开方完成第四次挥手\",{\"1\":{\"237\":1}}],[\"在进行更新操作之前\",{\"1\":{\"753\":1}}],[\"在事务中执行一些\",{\"1\":{\"1015\":1}}],[\"在事务型数据库中\",{\"1\":{\"807\":1}}],[\"在事务提交的时候\",{\"1\":{\"760\":1,\"810\":1}}],[\"在事务提交时才会统一将该事务运行过程中的所有\",{\"1\":{\"810\":2}}],[\"在事务提交时\",{\"1\":{\"751\":1,\"752\":1,\"810\":1}}],[\"在事务没提交之前\",{\"1\":{\"740\":1,\"810\":1}}],[\"在启动事务时生成一个\",{\"1\":{\"743\":1}}],[\"在还没有提交事务之前\",{\"1\":{\"739\":1,\"810\":1}}],[\"在于这样做性能的扩展性就低了很多\",{\"1\":{\"720\":1}}],[\"在股票交易或银行转账等金融系统中\",{\"1\":{\"719\":1}}],[\"在需要的情况下\",{\"1\":{\"714\":1}}],[\"在需要同时返回多个值的场景下非常有用\",{\"1\":{\"426\":1}}],[\"在生产阶段要有重试和确认机制\",{\"1\":{\"709\":1}}],[\"在web\",{\"1\":{\"691\":1}}],[\"在web开发中\",{\"1\":{\"23\":1}}],[\"在实际开发中\",{\"1\":{\"666\":1}}],[\"在大型应用中\",{\"1\":{\"657\":1}}],[\"在大多数情况下\",{\"1\":{\"428\":1}}],[\"在线用户统计\",{\"0\":{\"641\":1}}],[\"在线支付场景\",{\"1\":{\"23\":1}}],[\"在servlet中\",{\"1\":{\"637\":1,\"638\":1}}],[\"在sec\",{\"1\":{\"351\":1}}],[\"在应用程序和数据库之间架设一个\",{\"1\":{\"807\":1}}],[\"在应用层自定义的二进制协议\",{\"1\":{\"710\":1}}],[\"在应用层通过连接id来维护\",{\"1\":{\"240\":1}}],[\"在应用关闭时释放资源\",{\"1\":{\"615\":1}}],[\"在应用启动时初始化资源\",{\"1\":{\"615\":1}}],[\"在filter中读取参数后\",{\"1\":{\"609\":1}}],[\"在filter中避免长时间运行的操作\",{\"1\":{\"603\":1}}],[\"在请求处理前后执行操作\",{\"1\":{\"591\":1}}],[\"在mysql中\",{\"1\":{\"810\":1}}],[\"在mysql中系统默认的设置是\",{\"1\":{\"810\":1}}],[\"在mysql表中为消息id创建一个唯一约束\",{\"1\":{\"714\":1}}],[\"在maven项目的pom\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"在module路径之外生成任何\",{\"1\":{\"229\":1}}],[\"在类的非静态成员不存在的时候静态方法就已经存在了\",{\"1\":{\"573\":1}}],[\"在类加载的时候就会分配内存\",{\"1\":{\"573\":1}}],[\"在一行行扫描的过程中\",{\"1\":{\"820\":1}}],[\"在一条更新语句执行完成后\",{\"1\":{\"810\":2}}],[\"在一些资料里\",{\"1\":{\"930\":1}}],[\"在一些场景下会退化成记录锁或间隙锁\",{\"1\":{\"820\":2}}],[\"在一些可以容忍数据库崩溃时丢失\",{\"1\":{\"810\":1}}],[\"在一些对数据安全性要求比较高的场景中\",{\"1\":{\"810\":1}}],[\"在一个事务获取到锁时才能进入\",{\"1\":{\"810\":1}}],[\"在一个事务内\",{\"1\":{\"778\":1,\"779\":1}}],[\"在一个事务在执行过程中\",{\"1\":{\"739\":1}}],[\"在一般情况下\",{\"1\":{\"770\":1}}],[\"在一定程度上解决了传统解释型语言执行效率低的问题\",{\"1\":{\"566\":1}}],[\"在一次\",{\"1\":{\"110\":1}}],[\"在一次会话中的所有请求都路由到同一个服务器上\",{\"1\":{\"77\":1}}],[\"在java中\",{\"1\":{\"537\":1,\"553\":1,\"566\":1}}],[\"在发生回滚时\",{\"1\":{\"810\":1}}],[\"在发生\",{\"1\":{\"525\":1}}],[\"在逻辑上已经删除了\",{\"1\":{\"524\":1}}],[\"在复制的过程中\",{\"1\":{\"520\":1}}],[\"在并发环境中需要额外同步\",{\"1\":{\"505\":1}}],[\"在循环中构建大字符串时\",{\"1\":{\"505\":1}}],[\"在tag中添加omitempty忽略空值\",{\"1\":{\"488\":1}}],[\"在执行完后\",{\"1\":{\"820\":1}}],[\"在执行完panic之后\",{\"1\":{\"478\":1}}],[\"在执行下面这条语句的时候\",{\"1\":{\"820\":1}}],[\"在执行的过程中\",{\"1\":{\"817\":1}}],[\"在执行查询过程中临时使用内存管理连接对象\",{\"1\":{\"817\":1}}],[\"在执行更新语句的过程中\",{\"1\":{\"810\":1}}],[\"在执行快照读\",{\"1\":{\"810\":1}}],[\"在执行时不需要转换\",{\"1\":{\"36\":1}}],[\"在64位系统上是64位的\",{\"1\":{\"460\":1}}],[\"在32位系统上是32位的\",{\"1\":{\"460\":1}}],[\"在函数内部\",{\"1\":{\"458\":1}}],[\"在函数内部返回一个局部变量指针\",{\"1\":{\"408\":1}}],[\"在初始化时以属性\",{\"1\":{\"447\":1}}],[\"在不发生内存逃逸的情况下\",{\"1\":{\"439\":1}}],[\"在编译期间很难确定参数具体类型\",{\"1\":{\"414\":1}}],[\"在编译预处理时\",{\"1\":{\"36\":1}}],[\"在某些情况下\",{\"1\":{\"405\":1,\"813\":1}}],[\"在栈里声明临时变量分配内存\",{\"1\":{\"405\":1}}],[\"在接着调度\",{\"1\":{\"374\":1}}],[\"在运行时创建对象实例\",{\"1\":{\"551\":1}}],[\"在运行时\",{\"1\":{\"373\":1}}],[\"在程序中加入recover机制\",{\"1\":{\"478\":1}}],[\"在程序中加上extern\",{\"1\":{\"33\":1}}],[\"在程序第28行\",{\"1\":{\"311\":1}}],[\"在通信过程中全部使用对称加密的\",{\"1\":{\"249\":1}}],[\"在通信建立前采用非对称加密的方式交换\",{\"1\":{\"249\":1}}],[\"在通过sink\",{\"1\":{\"52\":1}}],[\"在新\",{\"1\":{\"249\":1}}],[\"在传输层\",{\"1\":{\"249\":1}}],[\"在osi模型中\",{\"1\":{\"249\":1}}],[\"在这部分非常适合讲索引下推\",{\"1\":{\"817\":1}}],[\"在这个间隙锁中\",{\"1\":{\"820\":1}}],[\"在这个时刻\",{\"1\":{\"793\":1}}],[\"在这个方法中\",{\"1\":{\"591\":1}}],[\"在这种模式下\",{\"1\":{\"246\":1}}],[\"在这里进行一些初始化的操作\",{\"1\":{\"226\":2}}],[\"在短时间内\",{\"1\":{\"243\":1}}],[\"在解析过程可能会发生劫持\",{\"1\":{\"243\":1}}],[\"在本地浏览器缓存就有这个资源\",{\"1\":{\"240\":1}}],[\"在时刻\",{\"1\":{\"237\":1}}],[\"在服务端大量出现的原因\",{\"1\":{\"237\":1}}],[\"在以上基本影响外\",{\"1\":{\"237\":1}}],[\"在调用protoc时\",{\"1\":{\"229\":1}}],[\"在你的环境变量中\",{\"1\":{\"229\":1}}],[\"在使用上不如\",{\"1\":{\"957\":1}}],[\"在使用write\",{\"1\":{\"930\":1}}],[\"在使用weak\",{\"1\":{\"33\":1}}],[\"在使用\",{\"1\":{\"820\":3}}],[\"在使用分组和排序时\",{\"1\":{\"813\":1}}],[\"在使用的时候会存在差别\",{\"1\":{\"813\":1}}],[\"在使用多返回值时\",{\"1\":{\"430\":1}}],[\"在使用参数化查询的情况下\",{\"1\":{\"243\":1}}],[\"在使用编译器编译后\",{\"1\":{\"229\":1}}],[\"在内核里使用红黑树来跟踪进程所有待检测的fd\",{\"1\":{\"226\":1}}],[\"在内存里的存储形式为\",{\"1\":{\"940\":1}}],[\"在内存中是怎么存储的\",{\"1\":{\"894\":1}}],[\"在内存中都对应的缓存空间\",{\"1\":{\"810\":1}}],[\"在内存中修改\",{\"1\":{\"753\":1}}],[\"在内存修改该\",{\"1\":{\"810\":1}}],[\"在内存访问方面\",{\"1\":{\"217\":1}}],[\"在内存分配成功后\",{\"1\":{\"33\":1}}],[\"在轮询中时刻更新即可\",{\"1\":{\"226\":1}}],[\"在命令行里可以直接输入使用的命令\",{\"1\":{\"223\":1}}],[\"在桌面版的\",{\"1\":{\"223\":1}}],[\"在文件映射区域\",{\"1\":{\"217\":1}}],[\"在文件映射区分配一块内存\",{\"1\":{\"217\":1}}],[\"在堆上\",{\"1\":{\"217\":1}}],[\"在lua脚本中调用redis的多个命令\",{\"1\":{\"927\":1}}],[\"在linux系统上\",{\"1\":{\"835\":1}}],[\"在linux中\",{\"1\":{\"237\":1}}],[\"在linux操作系统中\",{\"1\":{\"217\":1}}],[\"在leader副本挂掉的时候follower副本有机会被选举为新的leader副本从而保证分区的可用性\",{\"1\":{\"170\":1}}],[\"在\",{\"1\":{\"190\":1,\"217\":3,\"223\":1,\"226\":1,\"229\":1,\"249\":5,\"381\":1,\"384\":1,\"442\":1,\"453\":1,\"458\":2,\"461\":1,\"464\":1,\"466\":1,\"479\":2,\"524\":1,\"525\":2,\"741\":3,\"744\":1,\"748\":2,\"765\":1,\"770\":2,\"789\":1,\"810\":9,\"813\":3,\"817\":1,\"820\":5,\"836\":1,\"841\":1,\"864\":2,\"870\":1,\"879\":1,\"894\":1,\"897\":1,\"906\":1,\"927\":1,\"937\":1,\"941\":1,\"946\":1,\"952\":1,\"955\":1,\"956\":1,\"957\":1}}],[\"在再平衡过程中\",{\"1\":{\"165\":1}}],[\"在kafka中存储的阶段\",{\"1\":{\"713\":1}}],[\"在kafka中\",{\"1\":{\"156\":1}}],[\"在宿主机上创建两个虚拟网络接口设备\",{\"1\":{\"123\":1}}],[\"在宿主机虚拟一个docker\",{\"1\":{\"121\":1}}],[\"在用户态下运\",{\"1\":{\"220\":1}}],[\"在用\",{\"1\":{\"110\":1}}],[\"在容器创建时使用\",{\"1\":{\"125\":1}}],[\"在容器中管理数据主要有两种方式\",{\"1\":{\"105\":1}}],[\"在容器内部\",{\"1\":{\"98\":1}}],[\"在每次读取数据时\",{\"1\":{\"796\":1}}],[\"在每次请求中生成唯一的请求id\",{\"1\":{\"23\":1}}],[\"在每台机器都完成了对各自所负责的那部分数据中的关键词的统计处理之后\",{\"1\":{\"79\":1}}],[\"在整个数据处理的前期准备阶段\",{\"1\":{\"79\":1}}],[\"在1tb的日志文件里记录了用户的搜索关键词\",{\"1\":{\"79\":1}}],[\"在合成一个完整的文件\",{\"1\":{\"76\":1}}],[\"在预处理阶段进行\",{\"1\":{\"36\":1}}],[\"在预处理的时候\",{\"1\":{\"36\":1}}],[\"在成员函数声明前加上const关键字\",{\"1\":{\"33\":1}}],[\"在自己实现拷贝赋值的时候\",{\"1\":{\"33\":1}}],[\"在析构函数调用完成后\",{\"1\":{\"33\":1}}],[\"在db层加上我们之前的三种方案进行兜底\",{\"1\":{\"23\":1}}],[\"在业务逻辑中设置状态标识\",{\"1\":{\"23\":1}}],[\"在业务逻辑层面通过各种手段\",{\"1\":{\"23\":1}}],[\"在处理请求时首先检查该id是否已经处理过\",{\"1\":{\"23\":1}}],[\"在电商系统中\",{\"1\":{\"23\":1,\"719\":1}}],[\"在字节的第几位\",{\"1\":{\"20\":1}}],[\"其由四部分组成\",{\"1\":{\"1056\":1}}],[\"其本质上是定义了多个\",{\"1\":{\"957\":1}}],[\"其典型的应用场景就是快速判断一个key是否存在于某容器\",{\"1\":{\"930\":1}}],[\"其它锁想获取\",{\"1\":{\"918\":1,\"921\":1}}],[\"其持有的锁也能够被兜底释放\",{\"1\":{\"909\":1,\"921\":1}}],[\"其二进制编码由内容数据的类型和内容数据的字节长度两部分组成\",{\"1\":{\"879\":1}}],[\"其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集\",{\"1\":{\"820\":1}}],[\"其特点是只有在可能发生冲突时才加锁\",{\"1\":{\"820\":1}}],[\"其一是两个间隙锁的间隙区间完全一样\",{\"1\":{\"820\":1}}],[\"其具体含义如下\",{\"1\":{\"813\":1}}],[\"其指向每一个分组内的最后一条记录\",{\"1\":{\"748\":1}}],[\"其适用于关键业务场景\",{\"1\":{\"705\":1}}],[\"其实本质还是aof\",{\"1\":{\"949\":1}}],[\"其实可能库存已经扣减成功\",{\"1\":{\"927\":1}}],[\"其实不是全局真正的最久未访问\",{\"1\":{\"906\":1}}],[\"其实分成了三个部分来存储\",{\"1\":{\"770\":1}}],[\"其实是需要分析具体瓶颈在哪里\",{\"1\":{\"930\":1}}],[\"其实是有序的\",{\"1\":{\"870\":1}}],[\"其实是包含\",{\"1\":{\"770\":1}}],[\"其实是从\",{\"1\":{\"307\":1}}],[\"其实就是一个sds数据\",{\"1\":{\"952\":1}}],[\"其实就是\",{\"1\":{\"770\":1}}],[\"其实变长字段字节数列表不是必须的\",{\"1\":{\"770\":1}}],[\"其实正是由\",{\"1\":{\"190\":1}}],[\"其生命周期和作用域很可能不局限于某个具体的函数\",{\"1\":{\"258\":1}}],[\"其允许服务器在客户端缓存中填充数据\",{\"1\":{\"249\":1}}],[\"其移除了重复和传输重复数据的成本\",{\"1\":{\"249\":1}}],[\"其后跟目标资源的路径\",{\"1\":{\"249\":1}}],[\"其存在时间是长期的\",{\"1\":{\"249\":1}}],[\"其存在时间是短暂的\",{\"1\":{\"249\":1}}],[\"其导入路径为\",{\"1\":{\"229\":1}}],[\"其可执行文件一般就在以下几个位置\",{\"1\":{\"223\":1}}],[\"其余的是follower的副本\",{\"1\":{\"170\":1}}],[\"其中包含两个哈希表\",{\"1\":{\"942\":1}}],[\"其中包含了\",{\"1\":{\"770\":1}}],[\"其中一个方式就是收集写操作并在某一时间点\",{\"1\":{\"930\":1}}],[\"其中一个是leader的副本\",{\"1\":{\"170\":1}}],[\"其中某些用户可能具有相同的权限\",{\"1\":{\"850\":1}}],[\"其中有2个keyword\",{\"1\":{\"817\":1}}],[\"其中有些是重复的\",{\"1\":{\"20\":1}}],[\"其中根节点和中间节点\",{\"1\":{\"813\":1}}],[\"其中第1位二进制位表示字符长度大于127字节\",{\"1\":{\"770\":1}}],[\"其中\",{\"1\":{\"119\":1,\"223\":1,\"458\":1,\"770\":1,\"820\":1,\"956\":1,\"957\":2}}],[\"其元素都是指针类型\",{\"1\":{\"33\":1}}],[\"其他几个常用的配置项说明如下\",{\"1\":{\"957\":1}}],[\"其他扫描到的记录\",{\"1\":{\"820\":3}}],[\"其他事务无法删除该记录\",{\"1\":{\"820\":1}}],[\"其他事务插入\",{\"1\":{\"820\":1}}],[\"其他事务既不可以对该记录加\",{\"1\":{\"820\":1}}],[\"其他事务也可以继续对该记录加\",{\"1\":{\"820\":1}}],[\"其他事务的如果要向该表插入语句都会被阻塞\",{\"1\":{\"820\":1}}],[\"其他索引无需进行维护\",{\"1\":{\"813\":1}}],[\"其他\",{\"1\":{\"770\":1}}],[\"其他方法省略\",{\"1\":{\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1}}],[\"其他异常\",{\"1\":{\"540\":1}}],[\"其他运算符\",{\"1\":{\"442\":1}}],[\"其他情况都是分配到堆上\",{\"1\":{\"407\":1}}],[\"其他函数不能进行访问\",{\"1\":{\"405\":1}}],[\"其他消息类型\",{\"1\":{\"229\":1}}],[\"其他的副本是从副本\",{\"1\":{\"180\":1}}],[\"其他的如文件系统\",{\"1\":{\"125\":1}}],[\"其他的sql就不会生效\",{\"1\":{\"23\":1}}],[\"其他没有抢到锁的请求都统统不执行\",{\"1\":{\"23\":1}}],[\"其结果都是相同的\",{\"1\":{\"23\":1}}],[\"其核心目的是\",{\"1\":{\"23\":1}}],[\"将来密码系统为了应对更大的计算能力而增加哈希成本时\",{\"1\":{\"1058\":1}}],[\"将文件内容写入名为\",{\"1\":{\"1037\":1}}],[\"将查询的内容放入\",{\"1\":{\"990\":1}}],[\"将查询结果去重\",{\"1\":{\"823\":1}}],[\"将列定义为唯一键\",{\"1\":{\"983\":1}}],[\"将列定义为主键\",{\"1\":{\"983\":1}}],[\"将日志输出到多个位置\",{\"1\":{\"957\":1}}],[\"将日志记录器设为开发模式\",{\"1\":{\"957\":1}}],[\"将错误输出到\",{\"1\":{\"957\":1}}],[\"将当前状态保存为rdb二进制内容\",{\"1\":{\"949\":1}}],[\"将整型中对应位置设置为1\",{\"1\":{\"930\":1}}],[\"将字符串用多个hash函数映射不同的二进制位置\",{\"1\":{\"930\":1}}],[\"将字典的偏移索引\",{\"1\":{\"864\":1}}],[\"将结果存储在客户端\",{\"1\":{\"930\":1}}],[\"将这条消息记录在磁盘上\",{\"1\":{\"927\":1}}],[\"将库存名额加载到了redis\",{\"1\":{\"927\":1}}],[\"将抢和购解耦\",{\"1\":{\"927\":1}}],[\"将回包放入客户端输出缓冲区\",{\"1\":{\"897\":1}}],[\"将事件分发给不同的处理器\",{\"1\":{\"888\":1}}],[\"将事务设置为\",{\"1\":{\"810\":1}}],[\"将参数全部转义\",{\"1\":{\"990\":1}}],[\"将参数\",{\"1\":{\"820\":1}}],[\"将该记录的索引中的\",{\"1\":{\"820\":2}}],[\"将完成记录返回给\",{\"1\":{\"817\":1}}],[\"将完整的记录返回给\",{\"1\":{\"817\":2}}],[\"将导致\",{\"1\":{\"817\":1}}],[\"将多个字段之间按优先级顺序组合\",{\"1\":{\"813\":1}}],[\"将需要排序的数据分成\",{\"1\":{\"813\":1}}],[\"将需要监视的\",{\"1\":{\"226\":1}}],[\"将筛选出来的记录\",{\"1\":{\"813\":1}}],[\"将自动生成一个隐式自增\",{\"1\":{\"813\":1}}],[\"将处于文件系统中\",{\"1\":{\"810\":2}}],[\"将绿色这一组事务执行过程中产生的\",{\"1\":{\"810\":1}}],[\"将写操作从\",{\"1\":{\"810\":1}}],[\"将页加载到\",{\"1\":{\"810\":1}}],[\"将外链接转成内连接\",{\"1\":{\"807\":1}}],[\"将最常用于查询条件且选择性最高的列放在前面\",{\"1\":{\"807\":1}}],[\"将其拆成高16\",{\"1\":{\"903\":1}}],[\"将其整体读入内存\",{\"1\":{\"770\":1}}],[\"将其写到\",{\"1\":{\"759\":1}}],[\"将其作为请求属性传递给后续组件\",{\"1\":{\"609\":1}}],[\"将缓存在操作系统中\",{\"1\":{\"810\":1}}],[\"将缓存在\",{\"1\":{\"756\":1,\"810\":1}}],[\"将所有数据恢复到最新的状态\",{\"1\":{\"752\":1,\"810\":1}}],[\"将所有需要监听的socket添加到epfd中\",{\"1\":{\"226\":1}}],[\"将本次对这个页修改后的数据状态以\",{\"1\":{\"751\":1}}],[\"将每个哈希槽映射到一个特定的消息队列\",{\"1\":{\"723\":1}}],[\"将哈希值取模哈希槽的数量\",{\"1\":{\"723\":1}}],[\"将业务所有消息都指定同一个分区key\",{\"1\":{\"720\":1}}],[\"将已消费的消息id存储在redis的set数据结构中\",{\"1\":{\"714\":1}}],[\"将已连接的\",{\"1\":{\"226\":1}}],[\"将应用打包为war文件\",{\"1\":{\"659\":1}}],[\"将响应发送回客户端\",{\"1\":{\"647\":1}}],[\"将资源存储在servletcontext中\",{\"1\":{\"624\":1}}],[\"将新值交换到\",{\"1\":{\"531\":1}}],[\"将新的\",{\"1\":{\"531\":1}}],[\"将新的描述符添加到读描述符集合中\",{\"1\":{\"226\":1}}],[\"将原本为\",{\"1\":{\"525\":1}}],[\"将会处于一种不稳定的状态\",{\"1\":{\"520\":1}}],[\"将被\",{\"1\":{\"479\":1}}],[\"将返回值结果返回\",{\"1\":{\"477\":1}}],[\"将go源代码转换为可执行文件\",{\"1\":{\"400\":1}}],[\"将发送的goroutine绑定到sudog上\",{\"1\":{\"264\":1}}],[\"将待发送数据直接copy到此处\",{\"1\":{\"264\":1}}],[\"将公钥公布给外界\",{\"1\":{\"249\":1}}],[\"将复杂的网络通信任务分解为更小\",{\"1\":{\"249\":1}}],[\"将一个请求通过手段放大几十倍\",{\"1\":{\"243\":1}}],[\"将一级页表分为\",{\"1\":{\"217\":1}}],[\"将域名解析到攻击者控制的恶意服务器\",{\"1\":{\"243\":1}}],[\"将数据写入aof缓存中\",{\"1\":{\"952\":1}}],[\"将数据缓存\",{\"1\":{\"930\":1}}],[\"将数据页从磁盘读入到\",{\"1\":{\"810\":2}}],[\"将数据源存储在servletcontext中\",{\"1\":{\"640\":1}}],[\"将数据拷贝到channel中\",{\"1\":{\"264\":1}}],[\"将数据从内核拷贝到用户空间\",{\"1\":{\"226\":1}}],[\"将数据和代码捆绑在一起避免外界干扰和不确定性访问\",{\"1\":{\"33\":1}}],[\"将客户端socket加入到集合中\",{\"1\":{\"226\":1}}],[\"将此\",{\"1\":{\"226\":1}}],[\"将就绪的数据从内核拷贝到用户空间时\",{\"1\":{\"226\":1}}],[\"将指针放在寄存器\",{\"1\":{\"217\":1}}],[\"将它们从物理内存中移出\",{\"1\":{\"217\":1}}],[\"将堆顶指针向高地址移动\",{\"1\":{\"217\":1}}],[\"将内存数据同步到磁盘\",{\"1\":{\"204\":2}}],[\"将分区按照范围分配给消费者\",{\"1\":{\"165\":1}}],[\"将\",{\"1\":{\"123\":2,\"518\":1,\"524\":1,\"531\":1,\"756\":1,\"765\":3,\"767\":1,\"810\":12,\"813\":1,\"817\":2,\"840\":1,\"897\":1,\"1031\":1}}],[\"将取得的哈希值与服务器列表的大小进行取模运算\",{\"1\":{\"77\":1}}],[\"将任意长度的二进制值串映射为固定长度的二进制值串\",{\"1\":{\"70\":1}}],[\"将<iostream>文件的代码替换掉\",{\"1\":{\"36\":1}}],[\"将头文件\",{\"1\":{\"36\":1}}],[\"将耗费一定的时间和空间\",{\"1\":{\"33\":1}}],[\"将号码\",{\"1\":{\"20\":1}}],[\"将二进制位数组中的对应值设置为\",{\"1\":{\"20\":1}}],[\"|aaaaaaaaaaaa\",{\"1\":{\"770\":1}}],[\"|aaaaaaaaaaaaaaaa|\",{\"1\":{\"770\":2}}],[\"|hello\",{\"1\":{\"770\":1}}],[\"|hhhhh\",{\"1\":{\"770\":2}}],[\"|s\",{\"1\":{\"770\":1}}],[\"|supremum2\",{\"1\":{\"770\":1}}],[\"|supremum\",{\"1\":{\"770\":1}}],[\"|ello\",{\"1\":{\"770\":1}}],[\"||\",{\"1\":{\"33\":2,\"46\":1,\"265\":1,\"546\":1,\"598\":6}}],[\"|\",{\"1\":{\"20\":1,\"104\":6,\"197\":1,\"198\":1,\"199\":1,\"211\":2,\"246\":4,\"423\":8,\"444\":1,\"667\":3,\"770\":110,\"817\":6,\"820\":8,\"826\":1}}],[\"比现有级别低\",{\"1\":{\"957\":1}}],[\"比原来少了\",{\"1\":{\"903\":1}}],[\"比广泛用于内存的数据结构\",{\"1\":{\"813\":1}}],[\"比\",{\"1\":{\"810\":1}}],[\"比例控制在机器内存的\",{\"1\":{\"807\":1}}],[\"比同步从库的\",{\"1\":{\"730\":1}}],[\"比较函数\",{\"1\":{\"942\":1}}],[\"比较适合的场景是数据不过期场景\",{\"1\":{\"930\":1}}],[\"比较出名的消息队列\",{\"1\":{\"924\":1}}],[\"比较常见是\",{\"1\":{\"810\":1}}],[\"比较方便\",{\"1\":{\"770\":2}}],[\"比较高\",{\"1\":{\"710\":1}}],[\"比较长\",{\"1\":{\"368\":1}}],[\"比较笨的办法就是\",{\"1\":{\"75\":1}}],[\"比如生产环境下\",{\"1\":{\"957\":1}}],[\"比如同一个key的set操作\",{\"1\":{\"952\":1}}],[\"比如数据源为\",{\"1\":{\"930\":1}}],[\"比如数据库负载低的时候\",{\"1\":{\"930\":1}}],[\"比如先写入了redis\",{\"1\":{\"930\":1}}],[\"比如给mysql当缓存就是常见的玩法\",{\"1\":{\"930\":1}}],[\"比如库存用完\",{\"1\":{\"927\":1}}],[\"比如双十一0点抢10000个苹果折扣手机\",{\"1\":{\"927\":1}}],[\"比如发生gc\",{\"1\":{\"918\":1,\"921\":1}}],[\"比如为每个节点配置哨兵模式\",{\"1\":{\"917\":1,\"921\":1}}],[\"比如redis的redlock\",{\"1\":{\"917\":1,\"921\":1}}],[\"比如多台不同机器上的进程\",{\"1\":{\"909\":1,\"921\":1}}],[\"比如选了\",{\"1\":{\"906\":1}}],[\"比如分布式锁\",{\"1\":{\"882\":1}}],[\"比如列表中有三个元素\",{\"1\":{\"867\":1}}],[\"比如一个key\",{\"1\":{\"903\":1}}],[\"比如一个事务执行了\",{\"1\":{\"820\":1}}],[\"比如一主二从的集群\",{\"1\":{\"730\":1,\"761\":1,\"810\":1}}],[\"比如下图\",{\"1\":{\"820\":1}}],[\"比如下图的\",{\"1\":{\"817\":1}}],[\"比如下面这个顺序的场景\",{\"1\":{\"820\":1}}],[\"比如下面这条\",{\"1\":{\"813\":1}}],[\"比如下面的查询语句\",{\"1\":{\"813\":1}}],[\"比如在表里面有多个索引的时候\",{\"1\":{\"817\":1}}],[\"比如删除根节点中的数据\",{\"1\":{\"813\":1}}],[\"比如对\",{\"1\":{\"810\":1}}],[\"比如执行批量\",{\"1\":{\"810\":1}}],[\"比如你用了\",{\"1\":{\"810\":1}}],[\"比如你可以看到\",{\"1\":{\"223\":1}}],[\"比如这一条\",{\"1\":{\"810\":1}}],[\"比如这条待执行的\",{\"1\":{\"735\":1}}],[\"比如游戏战力排名\",{\"1\":{\"807\":1}}],[\"比如全部都是\",{\"1\":{\"770\":1}}],[\"比如拳套还没有带好\",{\"1\":{\"764\":1,\"810\":1}}],[\"比如原来9个分区\",{\"1\":{\"723\":1}}],[\"比如最简单的\",{\"1\":{\"723\":1}}],[\"比如消息是记录某个客户的减肥记录\",{\"1\":{\"723\":1}}],[\"比如网络波动\",{\"1\":{\"713\":1}}],[\"比如网上投票\",{\"1\":{\"23\":1}}],[\"比如需要访问\",{\"1\":{\"527\":1}}],[\"比如结构体中的关联实体\",{\"1\":{\"488\":1}}],[\"比如当\",{\"1\":{\"381\":1,\"810\":1}}],[\"比如当前有一个商品记录\",{\"1\":{\"23\":1}}],[\"比如百度的证书\",{\"1\":{\"249\":1}}],[\"比如5对4取模\",{\"1\":{\"249\":1}}],[\"比如检查某个文件是否存在\",{\"1\":{\"249\":1}}],[\"比如有很多条语句\",{\"1\":{\"760\":1,\"810\":1}}],[\"比如有\",{\"1\":{\"243\":1}}],[\"比如有该内存块的大小\",{\"1\":{\"217\":1}}],[\"比如c\",{\"1\":{\"229\":1}}],[\"比如const\",{\"1\":{\"33\":1}}],[\"比如初始化数据和socket等\",{\"1\":{\"226\":2}}],[\"比如视频传输\",{\"1\":{\"226\":1}}],[\"比如上图的\",{\"1\":{\"223\":1}}],[\"比如经常听说某同学的\",{\"1\":{\"223\":1}}],[\"比如包管理工具\",{\"1\":{\"223\":1}}],[\"比如控制一个页的读写权限\",{\"1\":{\"217\":1}}],[\"比如硬盘上的\",{\"1\":{\"217\":1}}],[\"比如只有1个broker\",{\"1\":{\"177\":1}}],[\"比如topica\",{\"1\":{\"157\":1}}],[\"比如用户信息\",{\"1\":{\"930\":1}}],[\"比如用户1001就用分区key\",{\"1\":{\"723\":1}}],[\"比如用户安装的应用程序\",{\"1\":{\"223\":1}}],[\"比如用户可以放置一些程序到本地目录中\",{\"1\":{\"113\":1}}],[\"比如用户快速点击按钮的情况\",{\"1\":{\"23\":1}}],[\"比如说程序崩溃\",{\"1\":{\"223\":1}}],[\"比如说我的\",{\"1\":{\"223\":2}}],[\"比如说我们可以查看当前操作系统的版本\",{\"1\":{\"223\":1}}],[\"比如说我在电脑上插入一个\",{\"1\":{\"223\":1}}],[\"比如说镜像列表\",{\"1\":{\"223\":1}}],[\"比如说这个文件\",{\"1\":{\"223\":1}}],[\"比如说\",{\"1\":{\"88\":1,\"217\":1,\"223\":3}}],[\"比如轮询\",{\"1\":{\"77\":1}}],[\"比如\",{\"1\":{\"75\":2,\"140\":1,\"145\":1,\"223\":1,\"226\":1,\"237\":2,\"249\":1,\"460\":1,\"719\":1,\"722\":1,\"723\":1,\"741\":1,\"748\":1,\"759\":1,\"770\":1,\"810\":3,\"813\":2,\"817\":3,\"820\":5,\"870\":1,\"873\":1,\"879\":1,\"885\":1,\"888\":1,\"924\":2,\"1035\":1}}],[\"比如图片名称\",{\"1\":{\"75\":1}}],[\"比如递归\",{\"1\":{\"33\":1}}],[\"比如现在有一堆号码\",{\"1\":{\"20\":1}}],[\"比comate处理能力强\",{\"1\":{\"12\":1}}],[\"5w\",{\"1\":{\"927\":1}}],[\"5d\",{\"1\":{\"770\":1}}],[\"5个字母\",{\"1\":{\"770\":1}}],[\"58\",{\"1\":{\"370\":1,\"371\":1,\"957\":1}}],[\"57\",{\"1\":{\"370\":1,\"371\":1,\"957\":5}}],[\"56\",{\"1\":{\"370\":1,\"371\":1}}],[\"54\",{\"1\":{\"370\":1,\"371\":1}}],[\"547fa7e369ef56031dd3bff2ace9fc0832eb251a\",{\"1\":{\"249\":1}}],[\"52\",{\"1\":{\"370\":1,\"371\":1}}],[\"521\",{\"1\":{\"20\":1}}],[\"512等\",{\"1\":{\"1054\":1}}],[\"512m\",{\"1\":{\"873\":1}}],[\"512\",{\"1\":{\"867\":1,\"870\":1,\"879\":2}}],[\"51\",{\"1\":{\"370\":1,\"371\":1,\"957\":1}}],[\"5^943\",{\"1\":{\"249\":1}}],[\"5^7\",{\"1\":{\"249\":1}}],[\"59+08\",{\"1\":{\"957\":5}}],[\"5969841\",{\"1\":{\"957\":1}}],[\"5969741\",{\"1\":{\"957\":1}}],[\"5969589\",{\"1\":{\"957\":1}}],[\"5967638\",{\"1\":{\"957\":1}}],[\"59\",{\"1\":{\"249\":1,\"370\":1,\"371\":1}}],[\"55\",{\"1\":{\"249\":1,\"370\":1,\"371\":1}}],[\"5xx\",{\"1\":{\"249\":2}}],[\"53\",{\"1\":{\"243\":1,\"370\":1,\"371\":1}}],[\"50个多字节文字\",{\"1\":{\"770\":1}}],[\"50个字母\",{\"1\":{\"770\":1}}],[\"50\",{\"1\":{\"249\":5,\"370\":1,\"371\":1,\"491\":1,\"640\":1,\"693\":2,\"770\":3,\"820\":1}}],[\"504\",{\"1\":{\"240\":1}}],[\"503\",{\"1\":{\"240\":1}}],[\"502\",{\"1\":{\"240\":1}}],[\"501\",{\"1\":{\"240\":1}}],[\"500w\",{\"1\":{\"727\":1}}],[\"500\",{\"1\":{\"240\":1,\"864\":1}}],[\"500类\",{\"1\":{\"240\":1}}],[\"5000\",{\"1\":{\"117\":9}}],[\"5b06d0d14b3312e589a411dd9ae15589dc9321f771e5615b7ae26e85017de080\",{\"1\":{\"145\":1}}],[\"5b\",{\"1\":{\"121\":1}}],[\"5\",{\"0\":{\"78\":1,\"143\":1,\"149\":1,\"165\":1,\"178\":1,\"199\":1,\"209\":1,\"266\":1,\"283\":1,\"294\":1,\"312\":1,\"313\":1,\"314\":1,\"346\":1,\"362\":1,\"363\":1,\"400\":1,\"417\":1,\"430\":1,\"439\":1,\"449\":1,\"450\":1,\"458\":1,\"469\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"627\":1,\"636\":1,\"637\":1,\"638\":1,\"668\":1,\"669\":1,\"670\":1,\"671\":1,\"672\":1,\"673\":1,\"674\":1,\"675\":1,\"676\":1,\"677\":1,\"678\":1,\"743\":1,\"755\":1,\"758\":1,\"759\":1,\"760\":1,\"761\":1,\"767\":1,\"790\":1,\"791\":1,\"792\":1,\"793\":1,\"794\":1,\"795\":1,\"804\":1,\"842\":1,\"853\":1,\"854\":1,\"855\":1,\"992\":1,\"996\":1,\"997\":1,\"998\":1,\"999\":1,\"1000\":1,\"1001\":1,\"1002\":1,\"1003\":1,\"1004\":1,\"1005\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1009\":2,\"1010\":1,\"1011\":1,\"1012\":1,\"1033\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1,\"1043\":2},\"1\":{\"20\":1,\"30\":3,\"33\":7,\"226\":3,\"229\":1,\"240\":1,\"249\":30,\"353\":1,\"369\":1,\"370\":1,\"371\":1,\"442\":1,\"458\":1,\"470\":1,\"483\":3,\"491\":1,\"543\":1,\"640\":1,\"751\":1,\"770\":5,\"793\":7,\"807\":2,\"810\":5,\"813\":7,\"817\":7,\"820\":18,\"841\":2,\"864\":1,\"867\":1,\"870\":1,\"873\":1,\"876\":1,\"879\":8,\"906\":2,\"930\":1,\"952\":1,\"994\":2}}],[\"8bit\",{\"1\":{\"879\":1}}],[\"8b\",{\"1\":{\"770\":1}}],[\"8d\",{\"1\":{\"770\":1}}],[\"8或更高版本\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"8字节\",{\"1\":{\"441\":2}}],[\"89\",{\"1\":{\"370\":1,\"371\":1}}],[\"8859\",{\"1\":{\"687\":1}}],[\"88\",{\"1\":{\"370\":1,\"371\":1,\"491\":2}}],[\"8888\",{\"1\":{\"226\":2}}],[\"87\",{\"1\":{\"370\":1,\"371\":1}}],[\"86\",{\"1\":{\"370\":1,\"371\":1}}],[\"85\",{\"1\":{\"370\":1,\"371\":1}}],[\"84\",{\"1\":{\"370\":1,\"371\":1}}],[\"83\",{\"1\":{\"370\":1,\"371\":1}}],[\"82\",{\"1\":{\"370\":1,\"371\":1}}],[\"81是逆序存储\",{\"1\":{\"770\":1}}],[\"81\",{\"1\":{\"370\":1,\"371\":1,\"770\":2}}],[\"815453382\",{\"1\":{\"33\":1}}],[\"8编码的文本\",{\"1\":{\"351\":1}}],[\"8古\",{\"1\":{\"249\":1}}],[\"8g\",{\"1\":{\"217\":1}}],[\"8000\",{\"1\":{\"966\":2}}],[\"8080\",{\"1\":{\"249\":1,\"659\":1,\"1021\":1,\"1024\":1,\"1026\":2,\"1031\":1,\"1040\":1}}],[\"80\",{\"1\":{\"117\":1,\"249\":1,\"370\":1,\"371\":1,\"813\":1,\"930\":1}}],[\"8\",{\"0\":{\"442\":1,\"459\":1,\"460\":1,\"1012\":1},\"1\":{\"20\":7,\"33\":3,\"43\":1,\"217\":1,\"249\":12,\"369\":1,\"370\":1,\"371\":1,\"442\":1,\"469\":2,\"599\":1,\"652\":1,\"675\":1,\"687\":3,\"688\":2,\"734\":1,\"770\":3,\"807\":1,\"810\":1,\"817\":7,\"820\":2,\"867\":1,\"870\":1,\"873\":2,\"876\":1,\"900\":2,\"903\":5,\"940\":1}}],[\"亿的二进制位数组\",{\"1\":{\"20\":1}}],[\"亿\",{\"1\":{\"20\":2}}],[\"=n\",{\"1\":{\"810\":1}}],[\"=range\",{\"1\":{\"452\":2}}],[\"=943\",{\"1\":{\"249\":1}}],[\"=$\",{\"1\":{\"229\":1}}],[\"=>\",{\"1\":{\"33\":2}}],[\"==>\",{\"1\":{\"829\":11}}],[\"==\",{\"1\":{\"33\":2,\"46\":1,\"226\":6,\"265\":7,\"307\":1,\"374\":1,\"425\":1,\"427\":1,\"531\":2,\"546\":2,\"957\":3,\"1059\":1}}],[\"=\",{\"0\":{\"369\":1,\"370\":1,\"371\":1},\"1\":{\"20\":5,\"23\":9,\"30\":24,\"33\":22,\"46\":7,\"88\":4,\"226\":43,\"229\":31,\"237\":1,\"249\":23,\"265\":22,\"344\":6,\"353\":1,\"367\":3,\"373\":1,\"374\":14,\"410\":4,\"412\":3,\"413\":3,\"415\":4,\"423\":1,\"425\":2,\"426\":5,\"427\":2,\"436\":2,\"438\":3,\"440\":5,\"441\":3,\"442\":11,\"447\":1,\"448\":2,\"449\":1,\"452\":1,\"453\":12,\"458\":2,\"460\":1,\"462\":1,\"466\":2,\"468\":3,\"469\":3,\"470\":2,\"471\":1,\"476\":2,\"477\":5,\"483\":5,\"487\":3,\"489\":3,\"490\":3,\"491\":3,\"497\":1,\"500\":1,\"502\":1,\"503\":1,\"505\":5,\"510\":5,\"511\":5,\"514\":1,\"515\":10,\"529\":5,\"530\":2,\"531\":18,\"532\":7,\"540\":1,\"541\":3,\"542\":3,\"553\":4,\"555\":1,\"556\":4,\"557\":6,\"558\":8,\"559\":5,\"565\":2,\"584\":6,\"586\":6,\"590\":2,\"596\":4,\"598\":9,\"599\":4,\"600\":7,\"601\":1,\"624\":7,\"625\":5,\"626\":12,\"633\":11,\"634\":14,\"635\":21,\"637\":8,\"638\":6,\"640\":7,\"641\":8,\"652\":1,\"654\":4,\"670\":4,\"671\":2,\"672\":4,\"673\":2,\"677\":2,\"681\":1,\"687\":1,\"689\":2,\"692\":1,\"693\":8,\"699\":1,\"717\":1,\"723\":2,\"735\":2,\"756\":3,\"760\":2,\"763\":6,\"765\":2,\"770\":13,\"793\":7,\"807\":3,\"810\":21,\"813\":18,\"817\":6,\"820\":28,\"840\":2,\"864\":3,\"879\":2,\"903\":1,\"906\":1,\"939\":2,\"957\":15,\"976\":9,\"978\":1,\"979\":1,\"980\":4,\"985\":2,\"986\":2,\"988\":1,\"989\":1,\"990\":3,\"991\":2,\"992\":3,\"993\":3,\"997\":1,\"1001\":2,\"1003\":2,\"1005\":1,\"1008\":4,\"1014\":7,\"1015\":9,\"1021\":1,\"1024\":1,\"1030\":3,\"1031\":1,\"1035\":3,\"1036\":1,\"1037\":9,\"1039\":1,\"1040\":2,\"1041\":1,\"1042\":1,\"1059\":7}}],[\"最显著的特点\",{\"1\":{\"956\":1}}],[\"最常见的方式是限购\",{\"1\":{\"927\":1}}],[\"最简单的一种方式\",{\"1\":{\"916\":1,\"921\":1}}],[\"最简化版本有一个问题\",{\"1\":{\"911\":1,\"921\":1}}],[\"最简化版本\",{\"0\":{\"910\":1},\"1\":{\"921\":1}}],[\"最不频繁淘汰算法\",{\"1\":{\"903\":1}}],[\"最外层是一个\",{\"1\":{\"864\":1}}],[\"最开始\",{\"1\":{\"810\":1}}],[\"最小的事务id\",{\"1\":{\"787\":1}}],[\"最多可以容纳的数据长度是\",{\"1\":{\"873\":1}}],[\"最多只能有\",{\"1\":{\"807\":1}}],[\"最多能存储的数据计算方式就不一样了\",{\"1\":{\"770\":1}}],[\"最多丢失一个事务的\",{\"1\":{\"760\":1,\"810\":1}}],[\"最多一次\",{\"1\":{\"705\":1}}],[\"最高\",{\"1\":{\"710\":1}}],[\"最高位是符号位\",{\"1\":{\"92\":1}}],[\"最基本的异常处理结构\",{\"1\":{\"540\":1}}],[\"最下面的\",{\"1\":{\"512\":1}}],[\"最下面两层可以一起叫\",{\"1\":{\"249\":1}}],[\"最好使用varchar\",{\"1\":{\"770\":1}}],[\"最好放在\",{\"1\":{\"381\":1}}],[\"最好将token放置在headers中\",{\"1\":{\"23\":1}}],[\"最关键的是\",{\"1\":{\"378\":1}}],[\"最详细的源码剖析\",{\"1\":{\"266\":1}}],[\"最初版本的\",{\"1\":{\"249\":1}}],[\"最大的问题还是连锁更新导致性能不稳定\",{\"1\":{\"879\":1}}],[\"最大的本地队列长度256\",{\"1\":{\"374\":1}}],[\"最大元素个数是\",{\"1\":{\"867\":1}}],[\"最大化组提交的效率\",{\"1\":{\"810\":1}}],[\"最大连接数按公式\",{\"1\":{\"807\":1}}],[\"最大连接数\",{\"1\":{\"807\":1}}],[\"最大长度\",{\"1\":{\"770\":1}}],[\"最大取值就是\",{\"1\":{\"770\":1}}],[\"最大取值多少\",{\"1\":{\"770\":1}}],[\"最大值\",{\"1\":{\"770\":1}}],[\"最大值时\",{\"1\":{\"770\":3}}],[\"最大能允许存储的字节数\",{\"1\":{\"770\":1}}],[\"最大最小记录\",{\"1\":{\"748\":1}}],[\"最大报文存活时长\",{\"1\":{\"237\":1}}],[\"最大多少人连接\",{\"1\":{\"226\":1}}],[\"最大可用虚拟内存有\",{\"1\":{\"217\":1}}],[\"最大可用虚拟内存只有\",{\"1\":{\"217\":1}}],[\"最大qq号码\",{\"1\":{\"20\":1}}],[\"最近最久未使用\",{\"1\":{\"906\":1}}],[\"最近未被访问的内存页\",{\"1\":{\"217\":1}}],[\"最近被访问过的内存页\",{\"1\":{\"217\":1}}],[\"最后实际上还是在周期函数来检查和触发的\",{\"1\":{\"952\":1}}],[\"最后替代原有的aof文件\",{\"1\":{\"949\":1}}],[\"最后再进行释放\",{\"1\":{\"913\":1,\"921\":1}}],[\"最后再返回用户空间\",{\"1\":{\"217\":1}}],[\"最后起作用的就是访问计数\",{\"1\":{\"903\":1}}],[\"最后合并各组的查询结果\",{\"1\":{\"823\":1}}],[\"最后进入\",{\"1\":{\"810\":1}}],[\"最后第三条记录\",{\"1\":{\"770\":1}}],[\"最后压力都给到了同一个partition\",{\"1\":{\"720\":1}}],[\"最后遍历得到的值\",{\"1\":{\"453\":1}}],[\"最后一个参数就是过期时间的值\",{\"1\":{\"911\":1,\"921\":1}}],[\"最后一个\",{\"1\":{\"879\":1}}],[\"最后一个返回值为错误信息\",{\"1\":{\"425\":1}}],[\"最后一层以外的每一层都是满的\",{\"1\":{\"61\":1}}],[\"最后一层的节点左边都是满的\",{\"1\":{\"61\":1}}],[\"最后生成目标机器码\",{\"1\":{\"395\":1}}],[\"最后创建的\",{\"1\":{\"373\":1}}],[\"最后\",{\"1\":{\"249\":1,\"374\":1,\"840\":1}}],[\"最后比较\",{\"1\":{\"240\":1,\"249\":1}}],[\"最后将数据通过\",{\"1\":{\"888\":1}}],[\"最后将\",{\"1\":{\"240\":1,\"249\":1}}],[\"最后调用\",{\"1\":{\"226\":1}}],[\"最后说\",{\"1\":{\"223\":1}}],[\"最后是序列号\",{\"1\":{\"92\":1}}],[\"最后整个结构体的大小必须是里面变量类型最大值的整数倍\",{\"1\":{\"33\":1}}],[\"最终为\",{\"1\":{\"930\":1}}],[\"最终正确的数据因为时序性被覆盖了\",{\"1\":{\"930\":1}}],[\"最终在某个时间点上\",{\"1\":{\"864\":1}}],[\"最终实现主从的数据一致性\",{\"1\":{\"810\":1}}],[\"最终用二进制来表示是的\",{\"1\":{\"770\":1}}],[\"最终写入同一个binlog文件\",{\"1\":{\"760\":2}}],[\"最终的结果集通过网络传输返回给客户端\",{\"1\":{\"734\":1}}],[\"最终对主库造成较大的压力\",{\"1\":{\"730\":1}}],[\"最终一致性\",{\"1\":{\"727\":1}}],[\"最终得到整个\",{\"1\":{\"79\":1}}],[\"最终得到的值就是应该被路由到的服务器编号\",{\"1\":{\"77\":1}}],[\"最终\",{\"1\":{\"33\":1}}],[\"最佳实践\",{\"0\":{\"602\":1},\"1\":{\"505\":1,\"1032\":1},\"2\":{\"19\":1,\"726\":1}}],[\"不想看到gin默认的那些debug输出\",{\"1\":{\"1027\":1}}],[\"不方便的地方\",{\"0\":{\"1020\":1}}],[\"不修改\",{\"1\":{\"982\":1}}],[\"不修改原结构体忽略空值字段\",{\"0\":{\"490\":1}}],[\"不删除\",{\"1\":{\"982\":1}}],[\"不满意\",{\"1\":{\"957\":1}}],[\"不满足\",{\"1\":{\"870\":1}}],[\"不记录日志调用位置\",{\"1\":{\"957\":1}}],[\"不建议\",{\"1\":{\"952\":1}}],[\"不断膨胀\",{\"1\":{\"952\":1}}],[\"不主动刷盘\",{\"1\":{\"952\":1}}],[\"不光通过key的过期时间兜底\",{\"1\":{\"930\":1}}],[\"不光写入broker10上的topic\",{\"1\":{\"177\":1}}],[\"不知道里面到底有没有缓存\",{\"1\":{\"930\":1}}],[\"不至于让\",{\"1\":{\"927\":1}}],[\"不发货会被投诉\",{\"1\":{\"927\":1}}],[\"不支持至少一次语意\",{\"1\":{\"924\":1}}],[\"不支持持久化\",{\"1\":{\"924\":1}}],[\"不支持\",{\"1\":{\"924\":1}}],[\"不支持并发的读写操作\",{\"1\":{\"509\":1}}],[\"不该归零么\",{\"1\":{\"903\":1}}],[\"不淘汰\",{\"1\":{\"900\":1}}],[\"不驱逐任何东西\",{\"1\":{\"900\":1}}],[\"不友好\",{\"1\":{\"882\":1}}],[\"不特殊处理任何一个字符\",{\"1\":{\"873\":1}}],[\"不堪重负\",{\"1\":{\"864\":1}}],[\"不然一直不动\",{\"1\":{\"864\":1}}],[\"不然会出现主库写请求锁行\",{\"1\":{\"730\":1}}],[\"不然会内存泄漏\",{\"1\":{\"33\":1}}],[\"不登录直接恢复\",{\"1\":{\"855\":1}}],[\"不锁下界\",{\"1\":{\"820\":1}}],[\"不连续\",{\"1\":{\"820\":1}}],[\"不连续的哦\",{\"1\":{\"217\":1}}],[\"不必等插入语句执行完\",{\"1\":{\"820\":1}}],[\"不使用索引下推\",{\"1\":{\"817\":1}}],[\"不使用多路复用时\",{\"1\":{\"226\":1}}],[\"不符合查询条件即跳过该记录\",{\"1\":{\"817\":1}}],[\"不好的地方\",{\"1\":{\"873\":1}}],[\"不好\",{\"1\":{\"813\":1}}],[\"不仅仅是侵害了正常用户的权益\",{\"1\":{\"927\":1}}],[\"不仅可以保存文本数据\",{\"1\":{\"873\":1}}],[\"不仅给行记录加上了行锁\",{\"1\":{\"820\":1}}],[\"不仅能利用索引有序性\",{\"1\":{\"813\":1}}],[\"不仅复制slice结构体\",{\"1\":{\"346\":1}}],[\"不存放实际数据\",{\"1\":{\"813\":1}}],[\"不存在就直接返回\",{\"1\":{\"930\":1}}],[\"不存在时\",{\"1\":{\"873\":1}}],[\"不存在才插入记录\",{\"1\":{\"820\":1}}],[\"不存在数据丢失的风险\",{\"1\":{\"810\":1}}],[\"不存在\",{\"1\":{\"770\":1,\"820\":4}}],[\"不存在于\",{\"1\":{\"531\":1}}],[\"不存在引用传递\",{\"1\":{\"454\":1}}],[\"不存在幂等性问题\",{\"1\":{\"23\":1}}],[\"不再需要人工介入\",{\"1\":{\"916\":1,\"921\":1}}],[\"不再以\",{\"1\":{\"873\":1}}],[\"不再锁住提交事务的整个过程\",{\"1\":{\"810\":1}}],[\"不再可读\",{\"1\":{\"249\":1}}],[\"不管是\",{\"1\":{\"957\":1}}],[\"不管是时刻\",{\"1\":{\"810\":1}}],[\"不管redis\",{\"1\":{\"930\":2}}],[\"不管怎样\",{\"1\":{\"927\":1}}],[\"不管用户请求的是什么域名\",{\"1\":{\"243\":1}}],[\"不包含\",{\"1\":{\"770\":1}}],[\"不包含域名\",{\"1\":{\"672\":1}}],[\"不如去掉以节省空间\",{\"1\":{\"770\":1}}],[\"不固定的\",{\"1\":{\"770\":1}}],[\"不刷盘\",{\"1\":{\"767\":1,\"810\":1}}],[\"不\",{\"1\":{\"760\":1,\"810\":1}}],[\"不一定是个数多\",{\"1\":{\"867\":1}}],[\"不一定要将文件名与包名定成一个名称\",{\"1\":{\"434\":1}}],[\"不一样\",{\"1\":{\"753\":1}}],[\"不在解析器中\",{\"1\":{\"817\":1}}],[\"不在\",{\"1\":{\"744\":1,\"789\":1}}],[\"不在最后加分号\",{\"1\":{\"33\":1}}],[\"不重要\",{\"1\":{\"924\":1}}],[\"不重复产生影响才是目的\",{\"1\":{\"712\":1}}],[\"不重置为\",{\"1\":{\"520\":1}}],[\"不等待broker的确认消息\",{\"1\":{\"710\":1}}],[\"不变\",{\"1\":{\"682\":1}}],[\"不直接处理请求\",{\"1\":{\"614\":1}}],[\"不调用chain\",{\"1\":{\"591\":1}}],[\"不应捕获\",{\"1\":{\"538\":1}}],[\"不强制处理\",{\"1\":{\"538\":1}}],[\"不适合多写的场景\",{\"1\":{\"527\":1}}],[\"不把自己置\",{\"1\":{\"520\":1}}],[\"不让程序core\",{\"1\":{\"478\":1}}],[\"不用开持久化\",{\"1\":{\"952\":1}}],[\"不用去背具体编码\",{\"1\":{\"879\":1}}],[\"不用要\",{\"1\":{\"879\":1}}],[\"不用从主库拿数据\",{\"1\":{\"730\":1}}],[\"不用用来做等值判断\",{\"1\":{\"472\":1}}],[\"不用额外存储\",{\"1\":{\"20\":1}}],[\"不允许指针算术\",{\"1\":{\"459\":1}}],[\"不允许中间跳开\",{\"1\":{\"448\":1}}],[\"不行\",{\"1\":{\"438\":1,\"807\":1}}],[\"不得不分配到堆上\",{\"1\":{\"408\":1}}],[\"不设置就是默认等于\",{\"1\":{\"373\":1}}],[\"不复制底层数组\",{\"1\":{\"342\":1}}],[\"不足\",{\"1\":{\"930\":2}}],[\"不足而阻塞的\",{\"1\":{\"259\":1}}],[\"不足之处\",{\"1\":{\"217\":2}}],[\"不安全的缺陷\",{\"1\":{\"249\":1}}],[\"不要把提交\",{\"1\":{\"810\":1}}],[\"不要使用缩写法\",{\"1\":{\"807\":1}}],[\"不要使用like左模糊和全模糊查询\",{\"1\":{\"807\":1}}],[\"不要在条件查询=前对字段做任何运算\",{\"1\":{\"807\":1}}],[\"不要在日志中记录敏感信息\",{\"1\":{\"604\":1}}],[\"不要盲目使用变量的指针作为函数参数\",{\"1\":{\"417\":1}}],[\"不要混淆\",{\"1\":{\"249\":1}}],[\"不要返回普通局部变量的引用\",{\"1\":{\"30\":1}}],[\"不占用主机的ip\",{\"1\":{\"246\":1}}],[\"不占用内存地址\",{\"1\":{\"20\":1}}],[\"不显示表明\",{\"1\":{\"229\":1}}],[\"不需要做额外操作\",{\"1\":{\"930\":1}}],[\"不需要持久化\",{\"1\":{\"924\":1}}],[\"不需要消费组\",{\"1\":{\"924\":1}}],[\"不需要ack\",{\"1\":{\"924\":2}}],[\"不需要显示调用\",{\"1\":{\"820\":1}}],[\"不需要回表\",{\"1\":{\"813\":2}}],[\"不需要再去访问实际的数据行\",{\"1\":{\"813\":1}}],[\"不需要finally块来关闭资源\",{\"1\":{\"541\":1}}],[\"不需要加锁到\",{\"1\":{\"524\":1}}],[\"不需要站点和应用做出改变\",{\"1\":{\"249\":1}}],[\"不需要像更多复杂的算法\",{\"1\":{\"813\":1}}],[\"不需要像\",{\"1\":{\"226\":1}}],[\"不需要进行\",{\"1\":{\"124\":1}}],[\"不过redis已经有成熟的解决方案\",{\"1\":{\"916\":1,\"921\":1}}],[\"不过可以有多条记录的唯一二级索引列的值同时为null\",{\"1\":{\"820\":1}}],[\"不过尽量避免在使用\",{\"1\":{\"820\":1}}],[\"不过起码能索引下推\",{\"1\":{\"813\":1}}],[\"不过在内存修改该\",{\"1\":{\"810\":2}}],[\"不过就是对写入性能影响太大\",{\"1\":{\"810\":1}}],[\"不过\",{\"1\":{\"810\":2,\"813\":1,\"820\":1}}],[\"不过带来的性能收益越大\",{\"1\":{\"807\":1}}],[\"不过考虑一个极端的场景\",{\"1\":{\"770\":1}}],[\"不过一般来说\",{\"1\":{\"223\":1}}],[\"不过指向的是一个int类型的数组\",{\"1\":{\"33\":1}}],[\"不同点\",{\"1\":{\"930\":1}}],[\"不同版本处理方式也不一样\",{\"1\":{\"813\":1}}],[\"不同核心在不同线程之间反复切换执行\",{\"1\":{\"807\":1}}],[\"不同行格式存储方式存在差异\",{\"1\":{\"770\":1}}],[\"不同存储引擎保存的文件不一样\",{\"1\":{\"770\":1}}],[\"不同类型零值不一样\",{\"1\":{\"436\":1}}],[\"不同状态的channel\",{\"1\":{\"263\":1}}],[\"不同\",{\"1\":{\"217\":1,\"1054\":1}}],[\"不同的场景\",{\"1\":{\"820\":1}}],[\"不同的操作\",{\"1\":{\"810\":1}}],[\"不同的存储引擎支持的索引类型也不相同\",{\"1\":{\"817\":1}}],[\"不同的存储引擎共用一个\",{\"1\":{\"817\":1}}],[\"不同的存储引擎\",{\"1\":{\"770\":1}}],[\"不同的servlet不应配置相同的url模式\",{\"1\":{\"657\":1}}],[\"不同的键值对之间使用空格分隔\",{\"1\":{\"484\":1}}],[\"不同的字符串拼接方式在性能上有所差异\",{\"1\":{\"363\":1}}],[\"不同的是\",{\"1\":{\"223\":1}}],[\"不同的\",{\"1\":{\"217\":1,\"873\":1}}],[\"不同进程间的用户空间是相互隔离的\",{\"1\":{\"217\":1}}],[\"不同消费组可以同一时间消费同一个主题\",{\"1\":{\"164\":1}}],[\"不同消费者可以在同一时间对同一主题进行消费\",{\"1\":{\"161\":1}}],[\"不保存退出\",{\"1\":{\"214\":1}}],[\"不指定用户名则更改当前账户\",{\"1\":{\"207\":1}}],[\"不提示警告\",{\"1\":{\"202\":1}}],[\"不列出目录内的文件数据\",{\"1\":{\"201\":1}}],[\"不可为空\",{\"1\":{\"983\":1}}],[\"不可忽视的\",{\"1\":{\"891\":1}}],[\"不可强占用\",{\"1\":{\"820\":1}}],[\"不可重复读\",{\"0\":{\"778\":1}}],[\"不可见\",{\"1\":{\"744\":2,\"789\":2}}],[\"不可靠\",{\"1\":{\"710\":1}}],[\"不可共享\",{\"1\":{\"682\":1}}],[\"不可被修改\",{\"1\":{\"440\":1}}],[\"不可以使用\",{\"1\":{\"810\":1}}],[\"不可以直接对\",{\"1\":{\"460\":1}}],[\"不可以用于全局变量的声明和赋值\",{\"1\":{\"438\":1}}],[\"不可以修改\",{\"1\":{\"30\":1}}],[\"不可变的消息序列\",{\"1\":{\"157\":1,\"172\":1}}],[\"不是固定的\",{\"1\":{\"906\":1}}],[\"不是并行\",{\"1\":{\"888\":1}}],[\"不是唯一二级索引\",{\"1\":{\"820\":1}}],[\"不是意向锁\",{\"1\":{\"820\":2}}],[\"不是在解析器里做的\",{\"1\":{\"817\":1}}],[\"不是的\",{\"1\":{\"810\":3}}],[\"不是一列\",{\"1\":{\"770\":1}}],[\"不是一种紧凑的行格式\",{\"1\":{\"770\":1}}],[\"不是一成不变的\",{\"1\":{\"181\":1}}],[\"不是本文开头讨论\",{\"1\":{\"747\":1}}],[\"不是\",{\"1\":{\"476\":1,\"867\":1,\"879\":1,\"952\":1}}],[\"不是轮询的方式\",{\"1\":{\"226\":1}}],[\"不是说消费了就没有了\",{\"1\":{\"156\":1}}],[\"不是整数倍空出内存\",{\"1\":{\"33\":1}}],[\"不带参数\",{\"1\":{\"36\":1}}],[\"不代表函数为不被实现的函数\",{\"1\":{\"33\":1}}],[\"不进行类型检查\",{\"1\":{\"33\":1}}],[\"不推荐把字段定义在接口中\",{\"1\":{\"464\":1}}],[\"不推荐\",{\"1\":{\"33\":1,\"429\":1,\"505\":1}}],[\"不能忍受数据丢失\",{\"1\":{\"930\":1}}],[\"不能超卖\",{\"1\":{\"927\":1}}],[\"不能释放别人的锁\",{\"1\":{\"912\":1,\"921\":1}}],[\"不能把其他竞争者持有的锁给释放了\",{\"1\":{\"909\":1,\"921\":1}}],[\"不能把interface\",{\"1\":{\"468\":1}}],[\"不能重复\",{\"1\":{\"885\":1}}],[\"不能用\",{\"1\":{\"879\":1}}],[\"不能走索引\",{\"1\":{\"813\":1}}],[\"不能再被路由使用了\",{\"1\":{\"1033\":1}}],[\"不能再执行新的更新操作\",{\"1\":{\"810\":1}}],[\"不能再编译阶段确定\",{\"1\":{\"416\":1}}],[\"不能有空格\",{\"1\":{\"249\":1}}],[\"不能删除正在运行的容器\",{\"1\":{\"142\":1}}],[\"不能连接宿主机以外的其他设备\",{\"1\":{\"125\":1}}],[\"不能通过\",{\"1\":{\"523\":1}}],[\"不能通过这个指针修改它所指向的整数\",{\"1\":{\"33\":1}}],[\"不能通过常引用\",{\"1\":{\"30\":1}}],[\"不能出现参数个数和类型均相同\",{\"1\":{\"33\":1}}],[\"不能\",{\"1\":{\"33\":1}}],[\"不能为空\",{\"1\":{\"33\":1}}],[\"不能够做到完全幂等性保证\",{\"1\":{\"23\":1}}],[\"不会过滤零值\",{\"1\":{\"1003\":1}}],[\"不会输出\",{\"1\":{\"957\":1}}],[\"不会阻塞主进程\",{\"1\":{\"952\":1}}],[\"不会同时开启\",{\"1\":{\"903\":1}}],[\"不会淘汰已有数据\",{\"1\":{\"900\":1}}],[\"不会限制内存使用\",{\"1\":{\"900\":1}}],[\"不会导致溢出问题\",{\"1\":{\"873\":1}}],[\"不会导致数据的改变\",{\"1\":{\"33\":1}}],[\"不会冲突\",{\"1\":{\"820\":1}}],[\"不会和行级的共享锁和独占锁发生冲突\",{\"1\":{\"820\":1}}],[\"不会因为数据或表结构的更新\",{\"1\":{\"820\":1}}],[\"不会因为多次调用而导致不一样的结果\",{\"1\":{\"23\":1}}],[\"不会有任务影响\",{\"1\":{\"910\":1,\"921\":1}}],[\"不会有\",{\"1\":{\"817\":1}}],[\"不会有碎片\",{\"1\":{\"33\":1}}],[\"不会再远程调用\",{\"1\":{\"930\":1}}],[\"不会再走到查询缓存这个阶段了\",{\"1\":{\"817\":1}}],[\"不会再执行业务逻辑\",{\"1\":{\"23\":1}}],[\"不会调用\",{\"1\":{\"810\":1}}],[\"不会出现前后两次查询的结果集不同\",{\"1\":{\"820\":2}}],[\"不会出现\",{\"1\":{\"810\":1}}],[\"不会出现半成功的状态\",{\"1\":{\"764\":1,\"810\":1}}],[\"不会相互干扰\",{\"1\":{\"774\":1}}],[\"不会结束在中间某个环节\",{\"1\":{\"774\":1}}],[\"不会覆盖以前的日志\",{\"1\":{\"759\":1,\"810\":1}}],[\"不会记录查询类的操作\",{\"1\":{\"759\":1,\"810\":1}}],[\"不会立即将脏页写入磁盘\",{\"1\":{\"747\":1,\"810\":3}}],[\"不会传递给下一个filter或目标资源\",{\"1\":{\"591\":1}}],[\"不会\",{\"1\":{\"525\":1,\"820\":1}}],[\"不会与服务器保持长时间的连接状态\",{\"1\":{\"249\":1}}],[\"不会认为是相同的连接\",{\"1\":{\"237\":1}}],[\"不会随着fd数目的增加效率下降\",{\"1\":{\"226\":1}}],[\"不会一直轮询占用cpu资源\",{\"1\":{\"226\":1}}],[\"不会就是异步io\",{\"1\":{\"226\":1}}],[\"不会复制物理内存\",{\"1\":{\"217\":1}}],[\"不会自动增长\",{\"1\":{\"217\":1}}],[\"不会启动新的进程\",{\"1\":{\"149\":1}}],[\"不会影响镜像\",{\"1\":{\"106\":1}}],[\"不会执行\",{\"1\":{\"36\":1}}],[\"不会为b单独开辟一个内存空间\",{\"1\":{\"30\":1}}],[\"值和一个布尔值\",{\"1\":{\"1037\":1}}],[\"值为\",{\"1\":{\"820\":5,\"957\":3}}],[\"值不应该过长\",{\"1\":{\"813\":1}}],[\"值较长的字段\",{\"1\":{\"807\":1}}],[\"值在\",{\"1\":{\"789\":1}}],[\"值大于等于\",{\"1\":{\"789\":1}}],[\"值小于\",{\"1\":{\"789\":1}}],[\"值的唯一列作为聚簇索引的索引键\",{\"1\":{\"813\":1}}],[\"值的列\",{\"1\":{\"770\":1}}],[\"值的方式完成\",{\"1\":{\"447\":1}}],[\"值都放到记录的真实数据中会比较浪费空间\",{\"1\":{\"770\":1}}],[\"值列表至少占用\",{\"1\":{\"770\":1}}],[\"值列表了\",{\"1\":{\"770\":1}}],[\"值列表也不是必须的\",{\"1\":{\"770\":1}}],[\"值列表都填充完毕后\",{\"1\":{\"770\":1}}],[\"值列表用十六进制表示是\",{\"1\":{\"770\":2}}],[\"值列表的\",{\"1\":{\"770\":1}}],[\"值列表的信息也需要逆序存放\",{\"1\":{\"770\":1}}],[\"值列表是怎样存储的\",{\"1\":{\"770\":1}}],[\"值列表必须用整数个字节的位表示\",{\"1\":{\"770\":1}}],[\"值列表\",{\"1\":{\"770\":11}}],[\"值列表初始化\",{\"0\":{\"448\":1}}],[\"值<事务readview\",{\"1\":{\"744\":1}}],[\"值<=记录的\",{\"1\":{\"744\":1}}],[\"值>=记录的\",{\"1\":{\"744\":1}}],[\"值用双引号括起来\",{\"1\":{\"484\":1}}],[\"值用字符\",{\"1\":{\"249\":1}}],[\"值是\",{\"1\":{\"249\":1}}],[\"值加密\",{\"1\":{\"240\":1,\"249\":1}}],[\"值得一提的是\",{\"1\":{\"223\":1}}],[\"值传递意味着每次函数调用时都会\",{\"1\":{\"455\":1}}],[\"值传递时\",{\"1\":{\"454\":1}}],[\"值传递\",{\"1\":{\"33\":2}}],[\"值\",{\"1\":{\"20\":1,\"240\":3,\"249\":3,\"524\":1,\"525\":1,\"744\":2,\"770\":4,\"789\":2,\"820\":1,\"1037\":1}}],[\"数学和加密函数等\",{\"1\":{\"817\":1}}],[\"数量较多的时候\",{\"1\":{\"527\":1}}],[\"数值类型\",{\"1\":{\"436\":1}}],[\"数字越大生成bcrypt的速度越慢\",{\"1\":{\"1056\":1}}],[\"数字\",{\"1\":{\"813\":2}}],[\"数字型\",{\"1\":{\"440\":1}}],[\"数字签名是什么\",{\"1\":{\"249\":1}}],[\"数字证书签发\",{\"1\":{\"249\":1}}],[\"数字证书\",{\"1\":{\"249\":1}}],[\"数组里的数据\",{\"1\":{\"873\":1}}],[\"数组的哪个索引上面\",{\"1\":{\"864\":1}}],[\"数组的虚拟地址是连续的\",{\"1\":{\"217\":1}}],[\"数组的物理空间连续\",{\"1\":{\"217\":1}}],[\"数组的引用\",{\"1\":{\"30\":1}}],[\"数组结构\",{\"0\":{\"65\":1}}],[\"数组实现可以方便地定位最底层的最右节点\",{\"1\":{\"55\":1}}],[\"数组\",{\"0\":{\"55\":1},\"1\":{\"328\":1,\"452\":1},\"2\":{\"348\":1}}],[\"数组大小为10\",{\"1\":{\"33\":1}}],[\"数组索引下标\",{\"1\":{\"20\":1}}],[\"数据对象\",{\"1\":{\"938\":1}}],[\"数据源与缓存的数据不一致\",{\"1\":{\"930\":1}}],[\"数据服务会自己来根据情况查询缓存或者数据库\",{\"1\":{\"930\":1}}],[\"数据稍微多些\",{\"1\":{\"906\":1}}],[\"数据稍多\",{\"1\":{\"867\":1}}],[\"数据更新\",{\"1\":{\"903\":1}}],[\"数据重要\",{\"1\":{\"900\":1}}],[\"数据自动消失\",{\"1\":{\"882\":1}}],[\"数据内容\",{\"1\":{\"879\":1}}],[\"数据节点\",{\"1\":{\"879\":1}}],[\"数据总量\",{\"1\":{\"879\":1}}],[\"数据类型\",{\"1\":{\"858\":1},\"2\":{\"860\":1,\"863\":1,\"869\":1,\"872\":1,\"875\":1,\"878\":1}}],[\"数据类型转换规则\",{\"1\":{\"813\":1}}],[\"数据以及下划线\",{\"1\":{\"829\":1}}],[\"数据控制语言\",{\"1\":{\"829\":1}}],[\"数据操作语言\",{\"1\":{\"829\":1}}],[\"数据定义语言\",{\"1\":{\"829\":1}}],[\"数据量大的时候更加\",{\"1\":{\"906\":1}}],[\"数据量小于\",{\"1\":{\"879\":1}}],[\"数据量越大时效果越明显\",{\"1\":{\"813\":1}}],[\"数据量太大\",{\"1\":{\"20\":1}}],[\"数据表的查询速度直线提升\",{\"1\":{\"813\":1}}],[\"数据表中的行记录是用\",{\"1\":{\"770\":1}}],[\"数据和索引分开存储\",{\"1\":{\"813\":1}}],[\"数据即索引\",{\"1\":{\"813\":3}}],[\"数据不一致的问题\",{\"1\":{\"820\":1}}],[\"数据不就不一致了\",{\"1\":{\"810\":1}}],[\"数据不能为空\",{\"1\":{\"546\":1}}],[\"数据安全性和写入性能是熊掌不可得兼的\",{\"1\":{\"810\":1}}],[\"数据安全性\",{\"1\":{\"810\":1}}],[\"数据也要写磁盘\",{\"1\":{\"810\":1}}],[\"数据存储和读写\",{\"1\":{\"800\":1}}],[\"数据存在\",{\"1\":{\"523\":1}}],[\"数据满足完整性约束\",{\"1\":{\"774\":1}}],[\"数据页存放了用户的记录以及各种信息\",{\"1\":{\"813\":1}}],[\"数据页的结构\",{\"1\":{\"770\":1}}],[\"数据页的写入通常是随机写入\",{\"1\":{\"754\":1}}],[\"数据页和\",{\"1\":{\"745\":1,\"810\":1}}],[\"数据页\",{\"1\":{\"745\":1,\"770\":4,\"810\":3}}],[\"数据共享\",{\"1\":{\"682\":1}}],[\"数据转换\",{\"1\":{\"579\":1}}],[\"数据在逻辑上不存在\",{\"1\":{\"523\":1}}],[\"数据隔离\",{\"1\":{\"520\":1}}],[\"数据链路层\",{\"1\":{\"249\":1}}],[\"数据就被认为是过期数据\",{\"1\":{\"882\":1}}],[\"数据就会发生丢失\",{\"1\":{\"810\":1}}],[\"数据就会丢失\",{\"1\":{\"730\":1,\"761\":1,\"952\":1}}],[\"数据就放在报文的\",{\"1\":{\"249\":1}}],[\"数据就不会丢失\",{\"1\":{\"176\":1}}],[\"数据的排序完全依赖于索引\",{\"1\":{\"813\":1}}],[\"数据的\",{\"1\":{\"813\":1}}],[\"数据的场景中\",{\"1\":{\"810\":1}}],[\"数据的读取顺序等信息\",{\"1\":{\"807\":1}}],[\"数据的双向流转\",{\"1\":{\"526\":1}}],[\"数据的浪费\",{\"1\":{\"249\":1}}],[\"数据的存储\",{\"1\":{\"20\":1}}],[\"数据被序列化为一种紧凑\",{\"1\":{\"229\":1}}],[\"数据长短\",{\"1\":{\"226\":2}}],[\"数据\",{\"1\":{\"226\":2,\"873\":1,\"894\":2}}],[\"数据流类型\",{\"1\":{\"226\":1}}],[\"数据段\",{\"1\":{\"217\":2,\"770\":1}}],[\"数据是按照索引第一列排序\",{\"1\":{\"813\":1}}],[\"数据是比较独立的\",{\"1\":{\"723\":1}}],[\"数据是直接往leader写入\",{\"1\":{\"180\":1}}],[\"数据是存储在partition这个级别的\",{\"1\":{\"157\":1}}],[\"数据持久化过程\",{\"1\":{\"177\":1}}],[\"数据卷是一个可供一个或多个容器使用\",{\"1\":{\"106\":1}}],[\"数据卷\",{\"0\":{\"106\":1},\"1\":{\"105\":1,\"106\":4,\"110\":3},\"2\":{\"128\":1}}],[\"数据管理\",{\"0\":{\"105\":1}}],[\"数据分片\",{\"0\":{\"78\":1}}],[\"数据检验\",{\"0\":{\"76\":1}}],[\"数据加密标准\",{\"1\":{\"73\":1}}],[\"数据库名\",{\"1\":{\"976\":1}}],[\"数据库端口\",{\"1\":{\"976\":1}}],[\"数据库地址\",{\"1\":{\"976\":1}}],[\"数据库id\",{\"1\":{\"944\":1}}],[\"数据库结构\",{\"1\":{\"894\":2}}],[\"数据库设计\",{\"2\":{\"860\":1}}],[\"数据库维护\",{\"2\":{\"857\":1}}],[\"数据库管理\",{\"2\":{\"857\":1}}],[\"数据库时自动安装\",{\"1\":{\"854\":1}}],[\"数据库备份与恢复\",{\"0\":{\"853\":1}}],[\"数据库级别\",{\"1\":{\"847\":1}}],[\"数据库服务器中导出数据库结构和数据\",{\"1\":{\"854\":1}}],[\"数据库服务器来说\",{\"1\":{\"850\":1}}],[\"数据库服务器\",{\"1\":{\"846\":1}}],[\"数据库服务器不会将参数的内容视为sql指令的一部份来处理\",{\"1\":{\"243\":1}}],[\"数据库和表的名称可以使用英文\",{\"1\":{\"829\":1}}],[\"数据库会自动给主键赋值递增的值\",{\"1\":{\"820\":1}}],[\"数据库引擎可能会通过索引的叶子节点获取非索引列的值\",{\"1\":{\"813\":1}}],[\"数据库引擎可能需要访问实际的数据行来获取非索引列的值\",{\"1\":{\"813\":1}}],[\"数据库引擎可以直接在索引的非叶子节点中获取所需数据\",{\"1\":{\"813\":1}}],[\"数据库允许多个并发事务同时对其数据进行读写和修改的能力\",{\"1\":{\"774\":1}}],[\"数据库保持一致性状态\",{\"1\":{\"774\":1}}],[\"数据库原理\",{\"2\":{\"772\":1}}],[\"数据库的文件结构不一样\",{\"1\":{\"770\":1}}],[\"数据库表中的记录都是按行\",{\"1\":{\"770\":1}}],[\"数据库表\",{\"1\":{\"770\":1}}],[\"数据库文件存放目录\",{\"1\":{\"770\":1}}],[\"数据库日志\",{\"2\":{\"769\":1}}],[\"数据库系统只需确保\",{\"1\":{\"751\":1}}],[\"数据库架构\",{\"2\":{\"729\":1}}],[\"数据库\",{\"1\":{\"770\":1},\"2\":{\"728\":1,\"731\":1,\"768\":1,\"771\":1,\"797\":1,\"805\":1,\"808\":1,\"811\":1,\"814\":1,\"818\":1,\"821\":1,\"824\":1,\"827\":1,\"830\":1,\"856\":1,\"859\":1,\"862\":1,\"865\":1,\"868\":1,\"871\":1,\"874\":1,\"877\":1,\"880\":1,\"883\":1,\"886\":1,\"889\":1,\"892\":1,\"895\":1,\"898\":1,\"901\":1,\"904\":1,\"907\":1,\"919\":1,\"922\":1,\"925\":1,\"928\":1,\"931\":1,\"934\":1,\"947\":1,\"950\":1,\"953\":1}}],[\"数据库连接数配置\",{\"1\":{\"807\":1}}],[\"数据库连接数过多\",{\"1\":{\"807\":1}}],[\"数据库连接数\",{\"1\":{\"807\":1}}],[\"数据库连接池已关闭\",{\"1\":{\"640\":1}}],[\"数据库连接池初始化成功\",{\"1\":{\"640\":1}}],[\"数据库连接\",{\"0\":{\"975\":1},\"1\":{\"474\":1}}],[\"数据库负载以及数据库连接池负载极高\",{\"1\":{\"243\":1}}],[\"数据库唯一性约束\",{\"1\":{\"23\":1}}],[\"数据库层面通过设置唯一键来防止重复数据的插入\",{\"1\":{\"23\":1}}],[\"数据结构\",{\"1\":{\"226\":1,\"813\":1,\"879\":1,\"885\":1,\"942\":1},\"2\":{\"22\":1,\"56\":1,\"66\":1,\"67\":1,\"89\":1,\"267\":1,\"316\":1,\"334\":1,\"347\":1,\"364\":1,\"863\":1,\"866\":1,\"869\":1,\"872\":1,\"875\":1,\"878\":1,\"881\":1,\"887\":1,\"948\":1}}],[\"0666\",{\"1\":{\"1037\":1}}],[\"06\",{\"1\":{\"957\":2}}],[\"0644\",{\"1\":{\"957\":2}}],[\"0之后默认打开aof混合持久化模式也能看出\",{\"1\":{\"949\":1}}],[\"0之后默认是打开的\",{\"1\":{\"949\":1}}],[\"0之后只要aof配置开启\",{\"1\":{\"949\":1}}],[\"0a\",{\"1\":{\"770\":1}}],[\"05和0a分别对应字符串的长度5和10\",{\"1\":{\"770\":1}}],[\"05\",{\"1\":{\"770\":1,\"813\":1}}],[\"0b\",{\"1\":{\"770\":2}}],[\"0表示普通记录\",{\"1\":{\"770\":1}}],[\"04\",{\"1\":{\"770\":3}}],[\"01\",{\"1\":{\"770\":22,\"820\":3}}],[\"01authfilter\",{\"1\":{\"608\":1}}],[\"0+的文件上传功能\",{\"1\":{\"693\":1}}],[\"0以下\",{\"1\":{\"687\":1}}],[\"08\",{\"1\":{\"249\":2,\"770\":8}}],[\"0d0a\",{\"1\":{\"249\":1}}],[\"0~1023\",{\"1\":{\"226\":1}}],[\"0复用一个进程\",{\"1\":{\"226\":1}}],[\"0描述符准备好数据时\",{\"1\":{\"226\":1}}],[\"0描述符\",{\"1\":{\"226\":1}}],[\"0多路复用\",{\"1\":{\"226\":1}}],[\"0操作的完成\",{\"1\":{\"226\":1}}],[\"0操作的数据还没有准备好\",{\"1\":{\"226\":1}}],[\"0操作后\",{\"1\":{\"226\":1}}],[\"0操作\",{\"1\":{\"226\":2}}],[\"0操作时\",{\"1\":{\"226\":1}}],[\"0模型\",{\"1\":{\"226\":1}}],[\"03\",{\"1\":{\"210\":1,\"770\":7,\"820\":1,\"957\":12}}],[\"0008\",{\"1\":{\"813\":1}}],[\"0004\",{\"1\":{\"813\":2}}],[\"000010\",{\"1\":{\"879\":1}}],[\"0000001\",{\"1\":{\"879\":1}}],[\"00000001\",{\"1\":{\"879\":1}}],[\"0000c220\",{\"1\":{\"770\":1}}],[\"0000c210\",{\"1\":{\"770\":1}}],[\"0000c200\",{\"1\":{\"770\":1}}],[\"0000c1f0\",{\"1\":{\"770\":1}}],[\"0000c1e0\",{\"1\":{\"770\":1}}],[\"0000c1d0\",{\"1\":{\"770\":2}}],[\"0000c1c0\",{\"1\":{\"770\":2}}],[\"0000c1b0\",{\"1\":{\"770\":2}}],[\"0000c1a0\",{\"1\":{\"770\":2}}],[\"0000c190\",{\"1\":{\"770\":2}}],[\"0000c180\",{\"1\":{\"770\":2}}],[\"0000c170\",{\"1\":{\"770\":2}}],[\"0000c160\",{\"1\":{\"770\":2}}],[\"0000c150\",{\"1\":{\"770\":2}}],[\"0000c140\",{\"1\":{\"770\":2}}],[\"0000c130\",{\"1\":{\"770\":2}}],[\"0000c120\",{\"1\":{\"770\":2}}],[\"0000c110\",{\"1\":{\"770\":2}}],[\"0000c100\",{\"1\":{\"770\":2}}],[\"0000c0f0\",{\"1\":{\"770\":2}}],[\"0000c0e0\",{\"1\":{\"770\":2}}],[\"0000c0d0\",{\"1\":{\"770\":2}}],[\"0000c0c0\",{\"1\":{\"770\":3}}],[\"0000c0b0\",{\"1\":{\"770\":3}}],[\"0000c0a0\",{\"1\":{\"770\":2}}],[\"0000c090\",{\"1\":{\"770\":2}}],[\"0000c080\",{\"1\":{\"770\":2}}],[\"0000c070\",{\"1\":{\"770\":2}}],[\"0000c060\",{\"1\":{\"770\":2}}],[\"0000\",{\"1\":{\"223\":1}}],[\"001\",{\"1\":{\"708\":1}}],[\"00\",{\"1\":{\"147\":3,\"223\":2,\"249\":1,\"770\":175,\"817\":2,\"820\":2,\"957\":9}}],[\"09\",{\"1\":{\"147\":1,\"770\":1}}],[\"02logfilter\",{\"1\":{\"608\":1}}],[\"02\",{\"1\":{\"121\":1,\"210\":1,\"223\":1,\"770\":6,\"820\":1}}],[\"0x20\",{\"1\":{\"770\":1}}],[\"0x06\",{\"1\":{\"770\":1}}],[\"0x04\",{\"1\":{\"770\":1}}],[\"0x00\",{\"1\":{\"770\":1}}],[\"0x0000000001c82c20\",{\"1\":{\"33\":1}}],[\"0x03\",{\"1\":{\"770\":1}}],[\"0x01\",{\"1\":{\"770\":1}}],[\"0xffe8\",{\"1\":{\"456\":1}}],[\"0xfff0\",{\"1\":{\"456\":2}}],[\"0x7fffebca9fc0\",{\"1\":{\"33\":1}}],[\"0x7fffebca9fb0\",{\"1\":{\"33\":1}}],[\"0x7fffed0c3ed0\",{\"1\":{\"33\":1}}],[\"0x7fffed0c3ec0\",{\"1\":{\"33\":1}}],[\"0\",{\"1\":{\"20\":2,\"33\":9,\"36\":1,\"46\":1,\"88\":2,\"117\":6,\"121\":1,\"147\":1,\"190\":1,\"217\":1,\"223\":1,\"226\":37,\"229\":3,\"240\":3,\"249\":20,\"265\":9,\"307\":2,\"374\":3,\"415\":1,\"426\":2,\"427\":1,\"436\":1,\"442\":4,\"446\":1,\"453\":1,\"458\":1,\"487\":1,\"505\":2,\"510\":2,\"511\":2,\"515\":6,\"530\":2,\"532\":1,\"540\":1,\"543\":1,\"583\":1,\"623\":1,\"625\":1,\"638\":3,\"651\":1,\"658\":2,\"710\":1,\"723\":1,\"734\":1,\"756\":1,\"760\":1,\"770\":20,\"780\":1,\"810\":14,\"813\":3,\"817\":10,\"820\":15,\"864\":9,\"867\":1,\"873\":8,\"876\":1,\"879\":4,\"885\":2,\"891\":2,\"897\":1,\"900\":1,\"903\":1,\"906\":1,\"940\":1,\"942\":1,\"944\":2,\"976\":4,\"986\":1,\"1002\":2,\"1003\":2,\"1026\":6,\"1029\":1,\"1040\":4}}],[\">文件下载<\",{\"1\":{\"1032\":1}}],[\">=\",{\"1\":{\"957\":1}}],[\">>>\",{\"1\":{\"569\":1}}],[\">><<\",{\"1\":{\"569\":1}}],[\">>\",{\"1\":{\"444\":1}}],[\"><\",{\"1\":{\"249\":1}}],[\">对象的引用计数\",{\"1\":{\"33\":1}}],[\">sayhello\",{\"1\":{\"33\":2}}],[\">\",{\"0\":{\"518\":1,\"519\":1},\"1\":{\"20\":1,\"33\":2,\"46\":1,\"209\":1,\"217\":1,\"265\":2,\"344\":7,\"373\":8,\"374\":12,\"394\":4,\"423\":1,\"426\":1,\"479\":6,\"483\":2,\"487\":1,\"519\":1,\"524\":1,\"525\":2,\"526\":1,\"527\":1,\"529\":1,\"530\":1,\"531\":1,\"543\":1,\"553\":3,\"555\":3,\"556\":3,\"557\":1,\"558\":1,\"600\":1,\"658\":1,\"670\":1,\"691\":1,\"722\":1,\"734\":4,\"751\":1,\"760\":1,\"770\":6,\"794\":2,\"807\":10,\"810\":3,\"813\":7,\"817\":5,\"820\":2,\"900\":8,\"930\":3,\"962\":1,\"979\":1,\"1001\":1,\"1004\":1,\"1012\":2}}],[\"呢\",{\"1\":{\"20\":1,\"918\":1,\"921\":1,\"942\":1}}],[\"如json\",{\"1\":{\"1038\":1}}],[\"如燕\",{\"1\":{\"1001\":2}}],[\"如创建的id\",{\"1\":{\"985\":1}}],[\"如创建时间\",{\"1\":{\"625\":1}}],[\"如生产环境日志输出的时间格式为\",{\"1\":{\"957\":1}}],[\"如30秒\",{\"1\":{\"930\":1}}],[\"如发起为id为\",{\"1\":{\"930\":1}}],[\"如空\",{\"1\":{\"879\":1}}],[\"如某个用户关注了哪些公众号\",{\"1\":{\"870\":1}}],[\"如上面事务\",{\"1\":{\"820\":1}}],[\"如上图右边部分\",{\"1\":{\"240\":1,\"249\":1}}],[\"如上图左边部分\",{\"1\":{\"240\":1,\"249\":1}}],[\"如此往复\",{\"1\":{\"817\":2}}],[\"如此一来\",{\"1\":{\"123\":1,\"918\":1,\"921\":1}}],[\"如存储过程\",{\"1\":{\"817\":1}}],[\"如日期\",{\"1\":{\"817\":1}}],[\"如日志记录\",{\"1\":{\"705\":1}}],[\"如关键点3所提到的\",{\"1\":{\"760\":1}}],[\"如关闭资源等\",{\"1\":{\"638\":1}}],[\"如关闭数据库连接\",{\"1\":{\"615\":1,\"662\":1}}],[\"如金融交易处理\",{\"1\":{\"705\":1}}],[\"如事件通知\",{\"1\":{\"705\":1}}],[\"如复选框\",{\"1\":{\"670\":1}}],[\"如复杂的数据库查询\",{\"1\":{\"603\":1}}],[\"如建立数据库连接\",{\"1\":{\"662\":1}}],[\"如数据库\",{\"1\":{\"647\":1}}],[\"如数据库连接池\",{\"1\":{\"615\":1}}],[\"如重新建立连接等\",{\"1\":{\"638\":1}}],[\"如用户鉴权校验\",{\"1\":{\"930\":1}}],[\"如用户权限变更\",{\"1\":{\"615\":1}}],[\"如用户登录\",{\"1\":{\"615\":1}}],[\"如应用启动\",{\"1\":{\"612\":1}}],[\"如使用数字前缀\",{\"1\":{\"608\":1}}],[\"如密码\",{\"1\":{\"604\":1}}],[\"如添加头信息\",{\"1\":{\"591\":1}}],[\"如添加属性\",{\"1\":{\"591\":1}}],[\"如ip的存储可以使用int而并非varchar\",{\"1\":{\"807\":1}}],[\"如ip地址\",{\"1\":{\"579\":1}}],[\"如ip地址分配\",{\"1\":{\"246\":1}}],[\"如innodb\",{\"1\":{\"734\":1}}],[\"如intellij\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"如tomcat\",{\"1\":{\"581\":1,\"617\":1,\"649\":1,\"659\":1}}],[\"如会话验证\",{\"1\":{\"579\":1}}],[\"如请求参数的编码转换\",{\"1\":{\"579\":1}}],[\"如servletcontext\",{\"1\":{\"614\":1}}],[\"如servlet\",{\"1\":{\"578\":1,\"594\":1,\"596\":1}}],[\"如spring\",{\"1\":{\"552\":1,\"644\":1}}],[\"如更新或使用本地缓存\",{\"1\":{\"249\":1}}],[\"如http头部字段比较\",{\"1\":{\"496\":1}}],[\"如http\",{\"1\":{\"249\":1}}],[\"如测试环境\",{\"1\":{\"246\":1}}],[\"如\",{\"1\":{\"209\":2,\"211\":1,\"474\":1,\"655\":2,\"656\":3,\"714\":1,\"855\":1,\"957\":1,\"979\":1}}],[\"如下过程\",{\"1\":{\"810\":1}}],[\"如下图\",{\"1\":{\"177\":1,\"770\":1,\"810\":7,\"820\":1}}],[\"如下例子就是开启了混合持久化的\",{\"1\":{\"949\":1}}],[\"如下例子\",{\"1\":{\"23\":1}}],[\"如分配\",{\"1\":{\"122\":1}}],[\"如分布式锁\",{\"1\":{\"23\":1}}],[\"如一个乘法语句的操作\",{\"1\":{\"36\":1}}],[\"如果请求是application\",{\"1\":{\"1041\":2}}],[\"如果获取文件头出现错误\",{\"1\":{\"1037\":1}}],[\"如果获取锁的服务挂掉了\",{\"1\":{\"911\":1,\"921\":1}}],[\"如果只想某些语句显示日志\",{\"1\":{\"980\":1}}],[\"如果只关联一个字段为单列索引\",{\"1\":{\"826\":1}}],[\"如果传入的\",{\"1\":{\"957\":1}}],[\"如果考虑主从同步\",{\"1\":{\"952\":1}}],[\"如果同时启用了\",{\"1\":{\"949\":1}}],[\"如果从更高层面来看\",{\"1\":{\"949\":1}}],[\"如果从这个视角来看\",{\"1\":{\"949\":1}}],[\"如果从存储层查不到数据则不写入缓存\",{\"1\":{\"930\":1}}],[\"如果更新mysql成功\",{\"1\":{\"930\":1}}],[\"如果第二条对应的更新先执行\",{\"1\":{\"930\":1}}],[\"如果第一步判断的时候还有库存\",{\"1\":{\"927\":1}}],[\"如果读请求非常频繁\",{\"1\":{\"930\":1}}],[\"如果业务本身对数据非常重视\",{\"1\":{\"952\":1}}],[\"如果业务本身只是缓存数据且并不是海量访问\",{\"1\":{\"952\":1}}],[\"如果业务场景希望重启之后数据还在\",{\"1\":{\"952\":1}}],[\"如果业务有需要\",{\"1\":{\"930\":1}}],[\"如果业务用mysql做存储\",{\"1\":{\"715\":1}}],[\"如果生产者将消息发送到这个频道\",{\"1\":{\"924\":1}}],[\"如果消费失败\",{\"1\":{\"924\":1}}],[\"如果消息顺序错乱\",{\"1\":{\"719\":1}}],[\"如果消息id已存在\",{\"1\":{\"714\":1}}],[\"如果消息类型是用来远程通信的\",{\"1\":{\"229\":1}}],[\"如果竞争者a\",{\"1\":{\"918\":1,\"921\":1}}],[\"如果挂了2台redis\",{\"1\":{\"917\":1,\"921\":1}}],[\"如果剩余时间已经为0\",{\"1\":{\"917\":1,\"921\":1}}],[\"如果超过一半失败\",{\"1\":{\"917\":1,\"921\":1}}],[\"如果超过了这个参数规定的大小\",{\"1\":{\"810\":1}}],[\"如果对可读性没有太大执念\",{\"1\":{\"949\":1}}],[\"如果对数据的可靠要求比较强\",{\"1\":{\"924\":1}}],[\"如果对一致性的要求高一些\",{\"1\":{\"917\":1,\"921\":1}}],[\"如果对于客户而言\",{\"1\":{\"723\":1}}],[\"如果redis挂掉了\",{\"1\":{\"915\":1,\"921\":1}}],[\"如果上一次访问时间很久\",{\"1\":{\"903\":1}}],[\"如果用秒作为精度\",{\"1\":{\"903\":1}}],[\"如果用户使用非常简单的密码例如password或123456\",{\"1\":{\"1056\":1}}],[\"如果用户有全局权限\",{\"1\":{\"840\":1}}],[\"如果用户存在于不同的主机上\",{\"1\":{\"840\":1}}],[\"如果用户名和密码都对了\",{\"1\":{\"817\":1}}],[\"如果用户名或密码不对\",{\"1\":{\"817\":1}}],[\"如果用户已登录\",{\"1\":{\"641\":1}}],[\"如果用户程序没有处理完这个事件\",{\"1\":{\"226\":1}}],[\"如果用户分配的内存大于\",{\"1\":{\"217\":1}}],[\"如果用户分配的内存小于\",{\"1\":{\"217\":1}}],[\"如果内存到达\",{\"1\":{\"900\":1}}],[\"如果内存交换的时候\",{\"1\":{\"217\":1}}],[\"如果大于\",{\"1\":{\"897\":1}}],[\"如果为\",{\"1\":{\"897\":1}}],[\"如果设置了过期时间\",{\"1\":{\"894\":1,\"946\":1}}],[\"如果某个时间段比较多的\",{\"1\":{\"882\":1}}],[\"如果某个程序崩溃了\",{\"1\":{\"223\":1}}],[\"如果前一个节点\",{\"1\":{\"879\":1}}],[\"如果字符串的长度增加需要重新分别内存\",{\"1\":{\"873\":1}}],[\"如果集群元素都是整数\",{\"1\":{\"870\":1}}],[\"如果找不到\",{\"1\":{\"854\":1}}],[\"如果找不到对应的键或值不匹配\",{\"1\":{\"23\":1}}],[\"如果删除的用户在删除之前已经登录了一个会话\",{\"1\":{\"839\":1}}],[\"如果省略它\",{\"1\":{\"838\":1}}],[\"如果关联多个字段即为联合索引或组合索引\",{\"1\":{\"826\":1}}],[\"如果唯一二级索引重复\",{\"1\":{\"820\":1}}],[\"如果主键索引重复\",{\"1\":{\"820\":1}}],[\"如果主键是自增类型\",{\"1\":{\"807\":1}}],[\"如果已加间隙锁\",{\"1\":{\"820\":2}}],[\"如果已经出现过了\",{\"1\":{\"79\":1}}],[\"如果表中最后一个记录的\",{\"1\":{\"820\":2}}],[\"如果锁状态是等待状态\",{\"1\":{\"820\":3}}],[\"如果可以考虑\",{\"1\":{\"820\":1}}],[\"如果可以预估最终字符串长度\",{\"1\":{\"505\":1}}],[\"如果此时服务器没有执行\",{\"1\":{\"864\":1}}],[\"如果此时服务端向客户端返回执行失败的过程中\",{\"1\":{\"23\":1}}],[\"如果此时有大量该表的\",{\"1\":{\"820\":1}}],[\"如果成立\",{\"1\":{\"817\":1}}],[\"如果成立则将其发送给客户端\",{\"1\":{\"817\":2}}],[\"如果成员变量是使用static修饰的\",{\"1\":{\"571\":1}}],[\"如果符合则发送给客户端\",{\"1\":{\"817\":1}}],[\"如果没问题就会构建出\",{\"1\":{\"817\":1}}],[\"如果没有消息\",{\"1\":{\"924\":1}}],[\"如果没有尾巴节点\",{\"1\":{\"879\":1}}],[\"如果没有使用\",{\"1\":{\"820\":1}}],[\"如果没有使用static修饰\",{\"1\":{\"571\":1}}],[\"如果没有\",{\"1\":{\"820\":1}}],[\"如果没有主键\",{\"1\":{\"813\":1}}],[\"如果没有就回滚事务\",{\"1\":{\"810\":1}}],[\"如果没有自己还没有准备好\",{\"1\":{\"764\":1,\"810\":1}}],[\"如果没有指定filtername属性\",{\"1\":{\"595\":1}}],[\"如果没有指定\",{\"1\":{\"229\":1}}],[\"如果没有被清空\",{\"1\":{\"223\":1}}],[\"如果刚缓存了一个查询结果很大的数据\",{\"1\":{\"817\":1}}],[\"如果之前执行过这一条命令\",{\"1\":{\"817\":1}}],[\"如果之前没出现过\",{\"1\":{\"79\":1}}],[\"如果长连接累计很多\",{\"1\":{\"817\":1}}],[\"如果空闲连接超过了这个时间\",{\"1\":{\"817\":1}}],[\"如果服务端已经启动\",{\"1\":{\"817\":1}}],[\"如果服务端没有启动\",{\"1\":{\"817\":1}}],[\"如果确认不会利用该字段排序\",{\"1\":{\"813\":1}}],[\"如果较长的字段要建立索引\",{\"1\":{\"813\":1}}],[\"如果创建了一个\",{\"1\":{\"813\":1}}],[\"如果规则是\",{\"1\":{\"813\":2}}],[\"如果走具体是哪些字段能走\",{\"1\":{\"813\":1}}],[\"如果条件不成立\",{\"1\":{\"817\":1}}],[\"如果条件判断字段\",{\"1\":{\"813\":1}}],[\"如果条件限制是\",{\"1\":{\"20\":1}}],[\"如果非索引列也包含在select语句中\",{\"1\":{\"813\":1}}],[\"如果setnx获取锁之后\",{\"1\":{\"911\":1,\"921\":1}}],[\"如果select的列既包含索引列\",{\"1\":{\"813\":1}}],[\"如果servlet尚未加载\",{\"1\":{\"661\":1}}],[\"如果节点饱和\",{\"1\":{\"813\":1}}],[\"如果想在日志后面追加\",{\"1\":{\"957\":1}}],[\"如果想关闭查询缓存\",{\"1\":{\"817\":1}}],[\"如果想提升\",{\"1\":{\"810\":1}}],[\"如果想要在最终的序列化结果中去掉空值字段\",{\"0\":{\"488\":1}}],[\"如果想要在序列化时忽略这些没有值的字段时\",{\"1\":{\"487\":1}}],[\"如果事务的数量提前达到了\",{\"1\":{\"810\":1}}],[\"如果事务readview\",{\"1\":{\"744\":2}}],[\"如果说间隙锁锁住的是一个区间\",{\"1\":{\"820\":2}}],[\"如果说\",{\"1\":{\"810\":1}}],[\"如果说cookie是客户端行为\",{\"1\":{\"249\":1}}],[\"如果存在时间过久\",{\"1\":{\"882\":1}}],[\"如果存在\",{\"1\":{\"810\":1}}],[\"如果存在允许\",{\"1\":{\"770\":1}}],[\"如果出现半成功的状态\",{\"1\":{\"810\":1}}],[\"如果出现了错误或者用户执\",{\"1\":{\"810\":1}}],[\"如果出现了前后两次查询的记录数量不一样\",{\"1\":{\"779\":1}}],[\"如果记录之间加有间隙锁\",{\"1\":{\"820\":1}}],[\"如果记录是存在的\",{\"1\":{\"817\":1}}],[\"如果记录是不存在的\",{\"1\":{\"817\":1}}],[\"如果记录不在\",{\"1\":{\"810\":2}}],[\"如果记录的\",{\"1\":{\"744\":2,\"789\":5}}],[\"如果能容少量事务的\",{\"1\":{\"810\":1}}],[\"如果type字段显示的是all或者index\",{\"1\":{\"807\":1}}],[\"如果tcp连接因任何原因断开\",{\"1\":{\"237\":1}}],[\"如果看到using\",{\"1\":{\"807\":2}}],[\"如果key存在\",{\"1\":{\"910\":1,\"921\":1}}],[\"如果key存在于read中\",{\"1\":{\"531\":1}}],[\"如果key不存在\",{\"1\":{\"910\":1,\"921\":1}}],[\"如果key是null\",{\"1\":{\"807\":1}}],[\"如果实际存储数据小于n字节\",{\"1\":{\"770\":1}}],[\"如果最大长度超过255\",{\"1\":{\"770\":1}}],[\"如果最后判断客户端无心跳\",{\"1\":{\"226\":1}}],[\"如果采用的是\",{\"1\":{\"770\":1}}],[\"如果变长字段允许存储的最大字节数大于\",{\"1\":{\"770\":1}}],[\"如果变长字段允许存储的最大字节数小于等于\",{\"1\":{\"770\":1}}],[\"如果变量从栈上逃逸\",{\"1\":{\"405\":1}}],[\"如果既没有指定主键\",{\"1\":{\"770\":1}}],[\"如果我们想对学生表\",{\"1\":{\"820\":1}}],[\"如果我们想使用联合索引中尽可能多的列\",{\"1\":{\"813\":1}}],[\"如果我们输入的\",{\"1\":{\"817\":1}}],[\"如果我们仅仅按照第二列搜索\",{\"1\":{\"813\":1}}],[\"如果我们每次在事务执行过程中\",{\"1\":{\"810\":1}}],[\"如果我们建表的时候指定了主键或者唯一约束列\",{\"1\":{\"770\":1}}],[\"如果我要访问\",{\"1\":{\"223\":1}}],[\"如果把这些\",{\"1\":{\"770\":1}}],[\"如果任何一位拳击手\",{\"1\":{\"764\":1,\"810\":1}}],[\"如果两位拳击手\",{\"1\":{\"764\":1,\"810\":1}}],[\"如果觉得自己准备好了\",{\"1\":{\"764\":1,\"810\":1}}],[\"如果数据库的引擎支持的事务支持\",{\"1\":{\"820\":1}}],[\"如果数据库系统在事务的提交过程中崩溃\",{\"1\":{\"810\":1}}],[\"如果数据存在于\",{\"1\":{\"747\":2,\"810\":2}}],[\"如果数据还没有准备好\",{\"1\":{\"226\":1}}],[\"如果每次在事务执行过程中\",{\"1\":{\"739\":1}}],[\"如果查询条件是以下这几种\",{\"1\":{\"813\":2}}],[\"如果查询条件没有使用到某个列\",{\"1\":{\"813\":1}}],[\"如果查询中包含了索引列和其他非索引列\",{\"1\":{\"813\":1}}],[\"如果查询只涉及到建立主键索引或者二级索引的列\",{\"1\":{\"813\":1}}],[\"如果查询语句使用了二级索引\",{\"1\":{\"813\":1}}],[\"如果查询的order\",{\"1\":{\"807\":1}}],[\"如果查询缓存开启且命中缓存\",{\"1\":{\"734\":1}}],[\"如果查询参数\",{\"1\":{\"249\":1}}],[\"如果再加一层\",{\"1\":{\"715\":1}}],[\"如果重复请求过多\",{\"1\":{\"715\":1}}],[\"如果acks=all\",{\"1\":{\"710\":1}}],[\"如果必须使用\",{\"1\":{\"689\":1}}],[\"如果多个filter需要执行相同的操作\",{\"1\":{\"603\":1}}],[\"如果处理时间超过阈值\",{\"1\":{\"600\":1}}],[\"如果处理过则直接返回结果\",{\"1\":{\"23\":1}}],[\"如果指定了filtername属性\",{\"1\":{\"595\":1}}],[\"如果不在\",{\"1\":{\"930\":1}}],[\"如果不是\",{\"1\":{\"982\":1}}],[\"如果不是需要常驻的数据\",{\"1\":{\"882\":1}}],[\"如果不是则跳过\",{\"1\":{\"817\":1}}],[\"如果不够会自动扩容\",{\"1\":{\"873\":1}}],[\"如果不符合则跳过该记录\",{\"1\":{\"817\":1}}],[\"如果不存在\",{\"1\":{\"810\":1}}],[\"如果不一样的话就把更新前的记录和更新后的记录都当作参数传给\",{\"1\":{\"810\":2}}],[\"如果不小心整个数据库的数据被删除了\",{\"1\":{\"810\":1}}],[\"如果不允许为null\",{\"1\":{\"770\":1}}],[\"如果不满足可见行\",{\"1\":{\"743\":1,\"810\":1}}],[\"如果不调用chain\",{\"1\":{\"591\":1}}],[\"如果不使用\",{\"1\":{\"226\":1}}],[\"如果操作成功\",{\"1\":{\"531\":1}}],[\"如果entry被移除\",{\"1\":{\"531\":1}}],[\"如果这里能算\",{\"1\":{\"930\":1}}],[\"如果这个锁不可能发生冲突\",{\"1\":{\"820\":1}}],[\"如果这个字段非空\",{\"1\":{\"807\":1}}],[\"如果这样的话\",{\"1\":{\"770\":1}}],[\"如果这时候来了一个写\",{\"1\":{\"519\":1}}],[\"如果这条数据还没被消费掉\",{\"1\":{\"256\":1}}],[\"如果无法解决再交给\",{\"1\":{\"512\":1}}],[\"如果是aof\",{\"1\":{\"952\":1}}],[\"如果是appendfsync\",{\"1\":{\"952\":1}}],[\"如果是为了相对更可靠的数据记录\",{\"1\":{\"949\":1}}],[\"如果是考虑到对redis核心处理性能的影响\",{\"1\":{\"949\":1}}],[\"如果是只有原始链表\",{\"1\":{\"885\":1}}],[\"如果是聚合函数\",{\"1\":{\"823\":1}}],[\"如果是记录锁的话\",{\"1\":{\"820\":1}}],[\"如果是两个订单号一样的请求同时进来\",{\"1\":{\"820\":1}}],[\"如果是则将记录发给客户的\",{\"1\":{\"817\":1}}],[\"如果是查询语句\",{\"1\":{\"817\":1}}],[\"如果是以页为单位来分配存储空间\",{\"1\":{\"770\":1}}],[\"如果是更新操作\",{\"1\":{\"753\":1,\"810\":2}}],[\"如果是\",{\"1\":{\"748\":1,\"813\":1,\"820\":2,\"870\":1,\"879\":2}}],[\"如果是http请求\",{\"1\":{\"626\":2,\"635\":3}}],[\"如果是碰见了\",{\"1\":{\"479\":1}}],[\"如果是消费者订阅了对应的主题\",{\"1\":{\"156\":1}}],[\"如果直至\",{\"1\":{\"479\":1}}],[\"如果在插入数据的时候\",{\"1\":{\"820\":1}}],[\"如果在插入新记录时\",{\"1\":{\"820\":1}}],[\"如果在\",{\"1\":{\"813\":1,\"930\":1}}],[\"如果在这一步完成后数据库崩溃\",{\"1\":{\"810\":2}}],[\"如果在这个过程中有并发访问\",{\"1\":{\"520\":1}}],[\"如果在持久化\",{\"1\":{\"810\":1}}],[\"如果在将\",{\"1\":{\"763\":2,\"810\":2}}],[\"如果在过程中遇到了最近的recover\",{\"1\":{\"479\":1}}],[\"如果在使用这种方式的基础上想要保证严格意义上的幂等性\",{\"1\":{\"23\":1}}],[\"如果ok这个返回值不接受\",{\"1\":{\"469\":1}}],[\"如果osr列表内的follower副本与leader副本保持了同步\",{\"1\":{\"182\":1}}],[\"如果函数外部存在引用\",{\"1\":{\"406\":1}}],[\"如果函数外部没有引用\",{\"1\":{\"406\":1}}],[\"如果频繁进行\",{\"1\":{\"405\":1}}],[\"如果切片容量不足\",{\"1\":{\"337\":1}}],[\"如果该接口对应的动态类型没有实现接口的所有方法\",{\"1\":{\"307\":1}}],[\"如果发现有个人\",{\"1\":{\"265\":1}}],[\"如果有新的\",{\"1\":{\"906\":1}}],[\"如果有bgsave\",{\"1\":{\"864\":1}}],[\"如果有的话\",{\"1\":{\"820\":1}}],[\"如果有的属性不写\",{\"1\":{\"447\":1}}],[\"如果有就意味着表里已经有记录被加了独占锁\",{\"1\":{\"820\":1}}],[\"如果有就提交事务\",{\"1\":{\"810\":1}}],[\"如果有其他线程执行了\",{\"1\":{\"820\":1}}],[\"如果有其他线程要更改该表的结构\",{\"1\":{\"820\":1}}],[\"如果有其他事务在\",{\"1\":{\"783\":1}}],[\"如果有主键\",{\"1\":{\"813\":1}}],[\"如果有多个字段的话\",{\"1\":{\"770\":1}}],[\"如果有\",{\"1\":{\"656\":3}}],[\"如果有剩余空间\",{\"1\":{\"264\":1}}],[\"如果有指针变量的话是需要自己实现深拷贝的\",{\"1\":{\"33\":1}}],[\"如果char字段有唯一索引\",{\"1\":{\"770\":1}}],[\"如果channel队列满了\",{\"1\":{\"257\":1}}],[\"如果consumer消费超时\",{\"1\":{\"23\":1}}],[\"如果双方都验证加密和解密没问题\",{\"1\":{\"249\":1}}],[\"如果一样的话就不进行后续更新流程\",{\"1\":{\"810\":2}}],[\"如果一样则是\",{\"1\":{\"249\":1}}],[\"如果一致\",{\"1\":{\"807\":1}}],[\"如果一直到主函数\",{\"1\":{\"479\":1}}],[\"如果一个字符串所有hash函数映射的值都存在\",{\"1\":{\"930\":1}}],[\"如果一个事务获取了\",{\"1\":{\"820\":2}}],[\"如果一个数据页存不了一条记录\",{\"1\":{\"770\":1}}],[\"如果一个函数返回了一个变量的引用\",{\"1\":{\"407\":1}}],[\"如果一个指定的offset被确认\",{\"1\":{\"163\":1}}],[\"如果一个消费者\",{\"1\":{\"161\":2}}],[\"如果队首的请求因为处理的太慢耽误了时间\",{\"1\":{\"249\":1}}],[\"如果值相同\",{\"1\":{\"240\":1,\"249\":1}}],[\"如果值传递的对象是类对象\",{\"1\":{\"33\":1}}],[\"如果给定的成本小于mincost\",{\"1\":{\"1058\":1}}],[\"如果给定的\",{\"1\":{\"229\":1}}],[\"如果给定\",{\"1\":{\"229\":1}}],[\"如果需要精确控制filter的执行顺序\",{\"1\":{\"595\":1}}],[\"如果需要返回大型数据结构\",{\"1\":{\"429\":1}}],[\"如果需要更多内容\",{\"1\":{\"378\":1}}],[\"如果需要\",{\"1\":{\"229\":1}}],[\"如果未指定路径标志\",{\"1\":{\"229\":1}}],[\"如果i\",{\"1\":{\"226\":1}}],[\"如果修改用户的应用程序配置\",{\"1\":{\"223\":1}}],[\"如果修改系统配置\",{\"1\":{\"223\":1}}],[\"如果使用char\",{\"1\":{\"770\":1}}],[\"如果使用的二进制位个数不足整数个字节\",{\"1\":{\"770\":1}}],[\"如果使用了许多互联网服务器\",{\"1\":{\"243\":1}}],[\"如果使用\",{\"1\":{\"223\":1,\"588\":1,\"627\":1,\"658\":1}}],[\"如果你对每个密码使用唯一的盐\",{\"1\":{\"1052\":1}}],[\"如果你对我封装日志包感兴趣\",{\"1\":{\"957\":1}}],[\"如果你对默认的\",{\"1\":{\"957\":1}}],[\"如果你用惯了\",{\"1\":{\"957\":1}}],[\"如果你自主选择开启\",{\"1\":{\"952\":1}}],[\"如果你判断的时候是ok的\",{\"1\":{\"918\":1,\"921\":1}}],[\"如果你正在使用不同的发行版或mysql版本\",{\"1\":{\"835\":1}}],[\"如果你想在json序列化\",{\"1\":{\"486\":1}}],[\"如果你有一个指向\",{\"1\":{\"459\":1}}],[\"如果你写了一个脚本\",{\"1\":{\"223\":1}}],[\"如果你的编辑器意外崩溃\",{\"1\":{\"223\":1}}],[\"如果你需要调试应用程序\",{\"1\":{\"223\":1}}],[\"如果你要修改一些系统程序的配置\",{\"1\":{\"223\":1}}],[\"如果你在容器内\",{\"1\":{\"113\":1}}],[\"如果物理内存仍然不足\",{\"1\":{\"217\":1}}],[\"如果段内偏移量是合法的\",{\"1\":{\"217\":1}}],[\"如果特定业务需要\",{\"1\":{\"176\":1}}],[\"如果\",{\"0\":{\"374\":1},\"1\":{\"176\":1,\"229\":1,\"237\":1,\"265\":1,\"367\":1,\"520\":1,\"529\":1,\"530\":1,\"531\":4,\"739\":1,\"744\":1,\"810\":8,\"813\":1,\"820\":11,\"838\":1,\"864\":1,\"906\":1}}],[\"如果要定制\",{\"1\":{\"957\":1}}],[\"如果要求极高\",{\"1\":{\"930\":1}}],[\"如果要备份多个数据库\",{\"1\":{\"854\":1}}],[\"如果要释放全局锁\",{\"1\":{\"820\":1}}],[\"如果要在查询时对记录加行级锁\",{\"1\":{\"820\":1}}],[\"如果要在查询时对记录加行锁\",{\"1\":{\"820\":2}}],[\"如果要在网络上相互发送密文\",{\"1\":{\"249\":1}}],[\"如果要在海量的图库中\",{\"1\":{\"75\":1}}],[\"如果要强制删除\",{\"1\":{\"142\":1}}],[\"如果容器希望外部访问能够访问到\",{\"1\":{\"121\":1}}],[\"如果x是nil接口值\",{\"1\":{\"469\":1}}],[\"如果x已经定义过了则编译程序段2的语句\",{\"1\":{\"36\":1}}],[\"如果x没有被宏定义过\",{\"1\":{\"36\":1}}],[\"如果子函数执行的操作比较多\",{\"1\":{\"36\":1}}],[\"如果尝试拷贝一个unique\",{\"1\":{\"33\":1}}],[\"如果原来的指针所指向的资源释放了\",{\"1\":{\"33\":1}}],[\"如果浮点数a\",{\"1\":{\"33\":1}}],[\"如redis\",{\"1\":{\"23\":1}}],[\"如uuid\",{\"1\":{\"23\":2,\"714\":1}}],[\"如何开启\",{\"1\":{\"952\":1}}],[\"如何区别是否有aof混合持久化的数据\",{\"1\":{\"949\":1}}],[\"如何解析mysql的binlog\",{\"1\":{\"930\":1}}],[\"如何解决长连接占用内存的问题\",{\"1\":{\"817\":1}}],[\"如何解决\",{\"1\":{\"739\":1}}],[\"如何理解\",{\"1\":{\"913\":1,\"921\":1}}],[\"如何避免死锁\",{\"1\":{\"820\":1}}],[\"如何选择索引\",{\"1\":{\"813\":1}}],[\"如何选举\",{\"0\":{\"183\":1}}],[\"如何回滚\",{\"1\":{\"810\":1}}],[\"如何定位一条查询慢\",{\"1\":{\"807\":1}}],[\"如何定位号码在数组中的位置\",{\"1\":{\"20\":1}}],[\"如何成为一位写优质sql语句的绝顶高手\",{\"1\":{\"807\":2}}],[\"如何保证\",{\"0\":{\"775\":1}}],[\"如何保证事务的持久性\",{\"1\":{\"752\":1}}],[\"如何保证消息有序\",{\"0\":{\"718\":1}}],[\"如何保证消息准确消费一次\",{\"0\":{\"716\":1}}],[\"如何保证消息不重复\",{\"0\":{\"712\":1}}],[\"如何保证消息不丢失\",{\"0\":{\"707\":1}}],[\"如何记录\",{\"1\":{\"810\":1}}],[\"如何记录这个\",{\"1\":{\"752\":1}}],[\"如何记录和回滚\",{\"0\":{\"741\":1}}],[\"如何刷盘的\",{\"0\":{\"745\":1}}],[\"如何知道版本的可见性\",{\"1\":{\"743\":1}}],[\"如何设计一个对外安全的接口\",{\"1\":{\"243\":1}}],[\"如何分配虚拟内存\",{\"1\":{\"217\":2}}],[\"如何快速判断图片是否在图库中\",{\"0\":{\"80\":1}}],[\"如何快速判断一个手机号是否存在\",{\"1\":{\"20\":1}}],[\"如何统计\",{\"0\":{\"79\":1}}],[\"如何检验文件块的安全\",{\"1\":{\"76\":1}}],[\"如何实现\",{\"1\":{\"33\":1}}],[\"如何判断可见性\",{\"1\":{\"744\":1}}],[\"如何判断号码对应的二进制位是否为\",{\"1\":{\"20\":1}}],[\"如何判断一个qq号是否存在\",{\"1\":{\"20\":2}}],[\"如何将二进制位设置为\",{\"1\":{\"20\":1}}],[\"如何表示qq号码\",{\"1\":{\"20\":1}}],[\"如何对慢查询\",{\"1\":{\"807\":1}}],[\"如何对100亿url查重\",{\"1\":{\"20\":1}}],[\"如何对他们进行排序\",{\"1\":{\"20\":1}}],[\"如何找到出现频率最高的100个单词\",{\"1\":{\"20\":1}}],[\"≈\",{\"1\":{\"20\":3}}],[\"vldb\",{\"1\":{\"952\":1}}],[\"v的实体\",{\"1\":{\"516\":1}}],[\"v2\",{\"1\":{\"456\":2,\"968\":1}}],[\"view\",{\"0\":{\"787\":1},\"1\":{\"784\":5,\"789\":6,\"791\":2,\"796\":1,\"810\":7,\"820\":3}}],[\"vim\",{\"1\":{\"214\":1,\"223\":1},\"2\":{\"216\":1}}],[\"vim编辑器命令详解\",{\"0\":{\"214\":1}}],[\"virtual\",{\"1\":{\"33\":5}}],[\"vmlinuz\",{\"1\":{\"220\":1}}],[\"vm1\",{\"1\":{\"125\":2}}],[\"vmware\",{\"1\":{\"124\":1},\"2\":{\"248\":1}}],[\"vxlan\",{\"1\":{\"122\":1}}],[\"vethaqi2qt\",{\"1\":{\"123\":1}}],[\"veth1\",{\"1\":{\"123\":2}}],[\"veth0\",{\"1\":{\"123\":4}}],[\"veth\",{\"1\":{\"122\":1,\"123\":5}}],[\"version=\",{\"1\":{\"658\":1}}],[\"version>\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"version+1\",{\"1\":{\"23\":1}}],[\"version\",{\"1\":{\"23\":6,\"132\":1,\"452\":2,\"453\":1,\"743\":1}}],[\"v\",{\"1\":{\"110\":1,\"113\":2,\"423\":1,\"426\":5,\"436\":1,\"437\":5,\"453\":10,\"483\":3,\"487\":1,\"489\":1,\"490\":1,\"491\":2,\"523\":4,\"527\":1,\"529\":4,\"531\":9,\"532\":2,\"873\":1,\"891\":1,\"894\":2,\"940\":1,\"943\":1,\"944\":1,\"945\":3}}],[\"v1\",{\"1\":{\"104\":1,\"453\":3,\"456\":1,\"962\":1,\"969\":3}}],[\"val\",{\"1\":{\"469\":4}}],[\"validate\",{\"1\":{\"962\":2}}],[\"validateage\",{\"1\":{\"543\":2}}],[\"valid\",{\"1\":{\"121\":1}}],[\"value对写为key\",{\"1\":{\"930\":1}}],[\"values\",{\"1\":{\"770\":5,\"820\":2}}],[\"valueunbound\",{\"1\":{\"637\":1}}],[\"valuebound\",{\"1\":{\"637\":1}}],[\"value>\",{\"1\":{\"588\":1}}],[\"value>info<\",{\"1\":{\"588\":1}}],[\"value2\",{\"1\":{\"484\":1,\"514\":1}}],[\"value1\",{\"1\":{\"484\":1,\"514\":1}}],[\"value这样key和value一起存储的\",{\"1\":{\"330\":1}}],[\"valuectx用于在context中存储和传递键值对\",{\"1\":{\"282\":1}}],[\"valuectx\",{\"0\":{\"282\":1}}],[\"value\",{\"1\":{\"20\":3,\"30\":1,\"46\":4,\"229\":1,\"249\":3,\"436\":1,\"440\":1,\"452\":3,\"468\":1,\"469\":1,\"512\":2,\"514\":4,\"515\":6,\"516\":1,\"521\":1,\"524\":1,\"529\":2,\"531\":7,\"532\":1,\"586\":1,\"633\":6,\"634\":6,\"635\":9,\"770\":2,\"817\":3,\"873\":5,\"894\":1,\"910\":1,\"911\":1,\"921\":1,\"937\":2,\"939\":1,\"941\":1,\"944\":2,\"946\":2,\"957\":7}}],[\"varchar类型对于短字符串\",{\"1\":{\"770\":1}}],[\"varchar在innodb底层是如何存储的\",{\"1\":{\"770\":1}}],[\"varchar如何存储\",{\"1\":{\"770\":1}}],[\"varchar会占用额外的1~2字节来存储字符串长度\",{\"1\":{\"770\":1}}],[\"varchar是65535\",{\"1\":{\"770\":1}}],[\"varchar和char在存储引擎层的区别\",{\"1\":{\"770\":1}}],[\"varchar和char在mysql层的区别\",{\"1\":{\"770\":1}}],[\"varchar和char的区别主要有\",{\"1\":{\"770\":1}}],[\"varchar\",{\"1\":{\"770\":24,\"983\":6}}],[\"variadic\",{\"1\":{\"458\":1}}],[\"variables\",{\"1\":{\"770\":2,\"817\":1,\"836\":1}}],[\"variable\",{\"1\":{\"223\":1,\"468\":2,\"770\":2,\"817\":1}}],[\"vary\",{\"1\":{\"249\":1}}],[\"var\",{\"1\":{\"88\":2,\"104\":4,\"223\":5,\"435\":1,\"436\":1,\"437\":3,\"460\":1,\"466\":3,\"468\":3,\"469\":1,\"471\":1,\"476\":1,\"477\":1,\"483\":1,\"491\":1,\"505\":2,\"515\":2,\"770\":5,\"980\":1,\"986\":1,\"988\":1,\"989\":1,\"990\":1,\"991\":1,\"992\":1,\"993\":2,\"994\":1,\"997\":1,\"998\":1,\"999\":1,\"1001\":1,\"1007\":1,\"1008\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":1,\"1014\":1,\"1015\":1,\"1030\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1}}],[\"vol\",{\"1\":{\"109\":1,\"110\":2,\"111\":1,\"113\":1}}],[\"volume\",{\"1\":{\"107\":1,\"108\":1,\"109\":1,\"111\":1}}],[\"volumes\",{\"1\":{\"105\":1}}],[\"volatile\",{\"1\":{\"33\":2,\"900\":5,\"906\":2}}],[\"void\",{\"1\":{\"30\":8,\"33\":3,\"540\":1,\"541\":1,\"542\":2,\"543\":2,\"546\":1,\"555\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":3,\"568\":1,\"584\":3,\"590\":1,\"591\":1,\"592\":1,\"596\":2,\"598\":1,\"599\":2,\"600\":1,\"601\":1,\"624\":2,\"625\":2,\"626\":2,\"633\":3,\"634\":3,\"635\":3,\"637\":2,\"638\":2,\"640\":2,\"641\":5,\"652\":1,\"662\":3,\"683\":3,\"684\":2,\"689\":2,\"693\":1,\"699\":1,\"700\":1,\"940\":1,\"942\":1}}],[\"vsname\",{\"1\":{\"813\":1}}],[\"vs\",{\"1\":{\"11\":1}}],[\"vscode\",{\"0\":{\"2\":1,\"3\":1},\"1\":{\"6\":1,\"13\":1,\"223\":2},\"2\":{\"14\":1,\"15\":1,\"480\":1,\"481\":1}}],[\"问题关键在于\",{\"1\":{\"912\":1,\"921\":1}}],[\"问题来了\",{\"1\":{\"770\":1}}],[\"问题的解决方案\",{\"1\":{\"763\":1}}],[\"问题的场景复现\",{\"1\":{\"763\":1}}],[\"问题背景\",{\"1\":{\"757\":1,\"930\":3}}],[\"问题解答\",{\"0\":{\"372\":1}}],[\"问题\",{\"1\":{\"145\":1,\"217\":2,\"374\":1,\"807\":1,\"810\":1,\"927\":2}}],[\"问题分析\",{\"1\":{\"23\":1}}],[\"问题变形\",{\"1\":{\"20\":1}}],[\"问题思路\",{\"1\":{\"20\":3}}],[\"问题场景\",{\"1\":{\"20\":1}}],[\"问题拆解\",{\"1\":{\"20\":2}}],[\"方案选型\",{\"1\":{\"930\":1}}],[\"方向三\",{\"1\":{\"930\":1}}],[\"方向二\",{\"1\":{\"930\":1}}],[\"方向一\",{\"1\":{\"930\":1}}],[\"方式解决了幻读\",{\"1\":{\"783\":2}}],[\"方式3\",{\"1\":{\"553\":1}}],[\"方式2\",{\"1\":{\"553\":1}}],[\"方式1\",{\"1\":{\"553\":1}}],[\"方式\",{\"1\":{\"249\":1,\"453\":2,\"1037\":2}}],[\"方式二\",{\"1\":{\"149\":1,\"217\":1}}],[\"方式一\",{\"1\":{\"149\":1,\"217\":1}}],[\"方便后续模块读取表名\",{\"1\":{\"817\":1}}],[\"方便大家理解\",{\"1\":{\"817\":1}}],[\"方便程序的修改\",{\"1\":{\"36\":1}}],[\"方便测试\",{\"1\":{\"33\":1}}],[\"方便定位\",{\"1\":{\"10\":1}}],[\"方法来实现\",{\"1\":{\"957\":1}}],[\"方法来构建\",{\"1\":{\"957\":1}}],[\"方法创建\",{\"1\":{\"957\":1}}],[\"方法可以将一个\",{\"1\":{\"957\":1}}],[\"方法签名如下\",{\"1\":{\"957\":1}}],[\"方法处理客户端请求\",{\"1\":{\"662\":1}}],[\"方法初始化servlet\",{\"1\":{\"661\":1}}],[\"方法进行清理操作\",{\"1\":{\"592\":1}}],[\"方法进行初始化\",{\"1\":{\"590\":1}}],[\"方法和变量修饰符\",{\"1\":{\"568\":1}}],[\"方法操作\",{\"0\":{\"558\":1}}],[\"方法声明可能抛出的检查型异常\",{\"1\":{\"542\":1}}],[\"方法会创建一个异常对象并交给运行时系统处理\",{\"1\":{\"537\":1}}],[\"方法不会阻塞其他方法的执行\",{\"1\":{\"532\":1}}],[\"方法不保证遍历期间\",{\"1\":{\"532\":1}}],[\"方法得到\",{\"1\":{\"529\":1}}],[\"方法根据\",{\"1\":{\"529\":1}}],[\"方法重写\",{\"0\":{\"464\":1}}],[\"方法是绑定在某种类型的变量上的函数\",{\"1\":{\"460\":1}}],[\"方法是传递一个或多个\",{\"1\":{\"229\":1}}],[\"方法\",{\"0\":{\"572\":1},\"1\":{\"20\":1,\"33\":1,\"249\":1,\"553\":2,\"591\":2,\"629\":2,\"630\":2,\"631\":2,\"661\":1,\"662\":2,\"665\":1,\"666\":1,\"957\":1}}],[\"堆表的组织结构中\",{\"1\":{\"813\":1}}],[\"堆表中的数据无序存放\",{\"1\":{\"813\":1}}],[\"堆表\",{\"1\":{\"813\":2}}],[\"堆分配内存\",{\"1\":{\"405\":1}}],[\"堆上分配\",{\"0\":{\"291\":1}}],[\"堆的数据需要通过指针访问\",{\"1\":{\"217\":1}}],[\"堆则受虚拟内存大小影响\",{\"1\":{\"217\":1}}],[\"堆是手动申请和释放\",{\"1\":{\"217\":1}}],[\"堆和文件映射段的内存是动态分配的\",{\"1\":{\"217\":1}}],[\"堆和栈的区别\",{\"1\":{\"33\":1}}],[\"堆段\",{\"1\":{\"217\":1}}],[\"堆由程序员分配\",{\"1\":{\"33\":1}}],[\"堆需要手动申请和释放\",{\"1\":{\"33\":1}}],[\"堆\",{\"1\":{\"20\":1,\"217\":1},\"2\":{\"57\":1}}],[\"href=\",{\"1\":{\"1032\":1}}],[\"hy000\",{\"1\":{\"817\":1}}],[\"h$ip\",{\"1\":{\"817\":1}}],[\"hhhhh|\",{\"1\":{\"770\":1}}],[\"hhhhhhhhhh\",{\"1\":{\"770\":1}}],[\"h|\",{\"1\":{\"770\":1}}],[\"hmap真正存储数据的是buckets指向的bmap\",{\"1\":{\"328\":1}}],[\"hmap是map的主要数据结构\",{\"1\":{\"326\":1}}],[\"hmap是一个结构体\",{\"1\":{\"325\":1}}],[\"hmap结构体\",{\"0\":{\"326\":1}}],[\"hchan\",{\"1\":{\"265\":1}}],[\"hchan类型的数据结构\",{\"1\":{\"258\":1}}],[\"h2\",{\"1\":{\"240\":2,\"249\":2}}],[\"h1>\",{\"1\":{\"652\":1}}],[\"h1\",{\"1\":{\"240\":2,\"249\":2}}],[\"hpack算法压缩http报文的头部\",{\"1\":{\"240\":1}}],[\"ht\",{\"1\":{\"864\":13,\"876\":1,\"942\":1}}],[\"html的第三个参数是可以向html中传递数据\",{\"1\":{\"1031\":1}}],[\"html等等\",{\"1\":{\"1028\":1}}],[\"html>\",{\"1\":{\"249\":2,\"652\":2}}],[\"html\",{\"0\":{\"1031\":1},\"1\":{\"249\":8,\"599\":1,\"652\":1,\"675\":1,\"688\":1,\"1031\":4}}],[\"html里的编码转义是完全不同的\",{\"1\":{\"249\":1}}],[\"http服务监听\",{\"1\":{\"966\":1}}],[\"httpbody\",{\"1\":{\"962\":1}}],[\"http和grpc实例的创建和配置\",{\"1\":{\"962\":1}}],[\"httponly\",{\"1\":{\"692\":1}}],[\"httpresponse\",{\"1\":{\"598\":2,\"601\":5}}],[\"httprequest\",{\"1\":{\"584\":3,\"598\":4,\"600\":3,\"626\":5}}],[\"http2\",{\"1\":{\"249\":1}}],[\"http无状态协议\",{\"1\":{\"249\":1}}],[\"httpservlet扩展了genericservlet\",{\"1\":{\"666\":1}}],[\"httpservlet抽象类\",{\"0\":{\"666\":1},\"1\":{\"667\":1}}],[\"httpservlet\",{\"1\":{\"652\":2,\"662\":1,\"689\":2,\"693\":1}}],[\"httpservletresponse接口表示服务器的http响应\",{\"1\":{\"674\":1}}],[\"httpservletresponse\",{\"0\":{\"674\":1},\"1\":{\"598\":2,\"601\":2,\"652\":2,\"662\":1,\"676\":2,\"689\":2,\"693\":1}}],[\"httpservletrequest接口表示客户端的http请求\",{\"1\":{\"669\":1}}],[\"httpservletrequest\",{\"0\":{\"669\":1},\"1\":{\"584\":3,\"598\":2,\"600\":2,\"626\":7,\"635\":10,\"652\":2,\"662\":1,\"689\":2,\"693\":1}}],[\"httpsessionbindingevent\",{\"1\":{\"634\":4,\"637\":3,\"641\":3}}],[\"httpsessionbindinglistener不需要在web\",{\"1\":{\"637\":1}}],[\"httpsessionbindinglistener\",{\"0\":{\"637\":1},\"1\":{\"620\":1,\"637\":2}}],[\"httpsessionevent\",{\"1\":{\"625\":3,\"638\":3,\"641\":2}}],[\"httpsessionactivationlistener用于监听会话的钝化\",{\"1\":{\"638\":1}}],[\"httpsessionactivationlistener\",{\"0\":{\"638\":1},\"1\":{\"620\":1,\"638\":2}}],[\"httpsessionattributelistener\",{\"0\":{\"634\":1},\"1\":{\"620\":1,\"634\":2,\"641\":1}}],[\"httpsessionlistener的生命周期与httpsession的生命周期相关\",{\"1\":{\"630\":1}}],[\"httpsessionlistener生命周期\",{\"0\":{\"630\":1}}],[\"httpsessionlistener\",{\"1\":{\"620\":1,\"625\":2,\"641\":1}}],[\"httpsession相关监听器\",{\"0\":{\"620\":1}}],[\"httpsession和servletrequest的创建\",{\"1\":{\"614\":1}}],[\"httpsession\",{\"1\":{\"598\":1,\"625\":3,\"641\":1,\"673\":1,\"692\":1}}],[\"https\",{\"1\":{\"240\":1,\"249\":10,\"957\":9},\"2\":{\"242\":1}}],[\"http保活负责管理http请求\",{\"1\":{\"237\":1}}],[\"http长连接也会失效\",{\"1\":{\"237\":1}}],[\"http长连接的保活实际上是由两部分组成的\",{\"1\":{\"237\":1}}],[\"http长连接的请求数量设置过小\",{\"1\":{\"237\":1}}],[\"http长连接保活\",{\"1\":{\"237\":1}}],[\"http长连接\",{\"1\":{\"237\":1}}],[\"http\",{\"0\":{\"1019\":1},\"1\":{\"237\":1,\"240\":6,\"249\":64,\"584\":1,\"625\":3,\"626\":1,\"634\":2,\"635\":1,\"637\":2,\"638\":2,\"652\":3,\"658\":4,\"659\":1,\"962\":3,\"966\":1,\"1021\":5,\"1035\":1,\"1059\":3},\"2\":{\"242\":1}}],[\"htons\",{\"1\":{\"226\":2}}],[\"hex\",{\"1\":{\"770\":2}}],[\"hexdump\",{\"1\":{\"770\":1}}],[\"height\",{\"1\":{\"470\":3}}],[\"head>\",{\"1\":{\"652\":1}}],[\"headernames\",{\"1\":{\"671\":1}}],[\"headers\",{\"1\":{\"601\":1}}],[\"header和payload的信息不做加密\",{\"1\":{\"249\":1}}],[\"header头部信息\",{\"1\":{\"249\":1}}],[\"header\",{\"0\":{\"1043\":1},\"1\":{\"249\":8,\"879\":1,\"1032\":2}}],[\"head\",{\"1\":{\"226\":1,\"249\":4}}],[\"held\",{\"1\":{\"374\":1}}],[\"help\",{\"1\":{\"132\":1,\"391\":1}}],[\"hello和hhhhhhhhhh\",{\"1\":{\"770\":1}}],[\"hello<\",{\"1\":{\"658\":1}}],[\"helloservlet<\",{\"1\":{\"658\":1}}],[\"helloservlet\",{\"1\":{\"652\":1,\"654\":1}}],[\"helloserver\",{\"1\":{\"226\":1}}],[\"helloworld\",{\"1\":{\"226\":1,\"962\":1,\"969\":3}}],[\"hello\",{\"0\":{\"1024\":1},\"1\":{\"33\":1,\"211\":1,\"249\":4,\"438\":2,\"462\":1,\"497\":1,\"499\":4,\"500\":4,\"505\":1,\"553\":1,\"652\":1,\"654\":3,\"655\":2,\"656\":1,\"659\":1,\"677\":1,\"699\":1,\"770\":2,\"867\":1,\"873\":2,\"1024\":1}}],[\"handler\",{\"1\":{\"1059\":2}}],[\"handlefunc\",{\"1\":{\"1021\":1}}],[\"handshake\",{\"1\":{\"249\":2}}],[\"having\",{\"1\":{\"807\":2,\"823\":1}}],[\"ha\",{\"1\":{\"442\":3}}],[\"halt\",{\"1\":{\"204\":1}}],[\"halt等命令会自动执行sync\",{\"1\":{\"204\":1}}],[\"hashpassword\",{\"1\":{\"1059\":2}}],[\"hashing\",{\"1\":{\"1059\":1}}],[\"hashedpassword\",{\"1\":{\"1059\":2}}],[\"hashed\",{\"1\":{\"1056\":1}}],[\"hash加密\",{\"1\":{\"1051\":1}}],[\"hash运算\",{\"1\":{\"945\":1}}],[\"hashtable\",{\"1\":{\"864\":7,\"870\":3,\"876\":1,\"944\":2}}],[\"hashtable底层结构\",{\"1\":{\"864\":1}}],[\"hash类型详解\",{\"0\":{\"861\":1}}],[\"hash索引\",{\"1\":{\"813\":1}}],[\"hashset<>\",{\"1\":{\"641\":1}}],[\"hash值是一分为二使用的\",{\"1\":{\"330\":1}}],[\"hash冲突概率小\",{\"1\":{\"72\":1}}],[\"hash存储结构\",{\"1\":{\"20\":1}}],[\"hash结构\",{\"1\":{\"20\":1}}],[\"hash\",{\"1\":{\"20\":1,\"240\":6,\"249\":6,\"307\":3,\"723\":3,\"807\":1,\"861\":1,\"864\":6,\"888\":1,\"930\":1,\"937\":1,\"945\":1,\"1059\":8},\"2\":{\"863\":1}}],[\"hook\",{\"1\":{\"957\":1}}],[\"hooks\",{\"1\":{\"956\":1,\"957\":3}}],[\"hobbies\",{\"1\":{\"670\":1}}],[\"hobby\",{\"1\":{\"487\":3,\"488\":3,\"489\":13,\"670\":1}}],[\"home\",{\"1\":{\"190\":1,\"207\":1,\"209\":1,\"211\":1,\"223\":4}}],[\"hostname\",{\"1\":{\"838\":6}}],[\"host标头\",{\"1\":{\"249\":1}}],[\"host最大的优势就是网络性能比较好\",{\"1\":{\"124\":1}}],[\"host\",{\"0\":{\"124\":1},\"1\":{\"122\":1,\"124\":4,\"125\":1,\"226\":1,\"246\":1,\"249\":7,\"842\":2,\"843\":1,\"846\":1,\"976\":2}}],[\"hub\",{\"1\":{\"99\":1}}],[\"h中的内容替换到\",{\"1\":{\"36\":1}}],[\"h>\",{\"1\":{\"33\":1}}],[\"h\",{\"1\":{\"33\":3,\"204\":2,\"391\":1,\"438\":2,\"442\":1,\"836\":1,\"970\":1,\"1029\":1,\"1039\":1,\"1040\":1,\"1041\":1}}],[\"hibernate等\",{\"1\":{\"552\":1}}],[\"hide\",{\"1\":{\"33\":1}}],[\"high\",{\"0\":{\"1073\":1},\"1\":{\"33\":2,\"46\":5}}],[\"hi\",{\"1\":{\"0\":1}}],[\"blpop\",{\"1\":{\"924\":1,\"944\":1}}],[\"bloom\",{\"1\":{\"930\":1}}],[\"bloomfilter就类似于一个hash\",{\"1\":{\"930\":1}}],[\"blobs\",{\"1\":{\"770\":2}}],[\"blob\",{\"1\":{\"770\":2}}],[\"blocking\",{\"1\":{\"944\":1}}],[\"block\",{\"1\":{\"265\":4,\"813\":2}}],[\"bgrewriteaof\",{\"1\":{\"864\":2}}],[\"bgsave\",{\"1\":{\"864\":1,\"952\":4}}],[\"bcrypt\",{\"1\":{\"1058\":3,\"1059\":4},\"2\":{\"1061\":1}}],[\"bcrypt包只提供了三个函数\",{\"1\":{\"1058\":1}}],[\"bcrypt包提供使用bcrypt函数\",{\"1\":{\"1058\":1}}],[\"bcrypt包介绍\",{\"0\":{\"1058\":1}}],[\"bcrypt哈希组成\",{\"1\":{\"1056\":1}}],[\"bcrypt哈希由多个部分组成\",{\"1\":{\"1056\":1}}],[\"bcrypt哈希字符串的组成\",{\"0\":{\"1056\":1}}],[\"bcrypt加密原理\",{\"0\":{\"1055\":1}}],[\"bcda\",{\"1\":{\"813\":2}}],[\"bcad\",{\"1\":{\"813\":1}}],[\"bca\",{\"1\":{\"813\":2}}],[\"bc\",{\"1\":{\"813\":2}}],[\"bc都无法走索引\",{\"1\":{\"813\":1}}],[\"b=100\",{\"1\":{\"813\":1}}],[\"b=3\",{\"1\":{\"813\":1}}],[\"b=2\",{\"1\":{\"36\":1,\"813\":6}}],[\"b>2\",{\"1\":{\"813\":2}}],[\"btree\",{\"1\":{\"770\":1,\"820\":1}}],[\"b+索引\",{\"1\":{\"813\":1}}],[\"b+tree索引\",{\"1\":{\"813\":1}}],[\"b+tree\",{\"1\":{\"807\":1}}],[\"b+树有序的\",{\"1\":{\"813\":1}}],[\"b+树有些许变化\",{\"1\":{\"813\":1}}],[\"b+树只是一种存储的数据结构\",{\"1\":{\"813\":1}}],[\"b+树中\",{\"1\":{\"813\":1}}],[\"b+树中走索引覆盖\",{\"1\":{\"813\":1}}],[\"b+树种获得实际数据行\",{\"1\":{\"813\":1}}],[\"b+树找到主键值\",{\"1\":{\"813\":1}}],[\"b+树所有叶子节点之间有一个链表进行连接\",{\"1\":{\"813\":1}}],[\"b+树可以比\",{\"1\":{\"813\":1}}],[\"b+树稍快\",{\"1\":{\"813\":1}}],[\"b+树的节点内是数据页\",{\"1\":{\"813\":1}}],[\"b+树的非叶子节点能存放更多索引\",{\"1\":{\"813\":1}}],[\"b+树的非叶子节点不存放实际数据\",{\"1\":{\"813\":1}}],[\"b+树的分裂\",{\"1\":{\"813\":1}}],[\"b+树的叶子节点之间使用双向链表连接\",{\"1\":{\"813\":1}}],[\"b+树都是从高度为\",{\"1\":{\"813\":1}}],[\"b+树每一个节点内容是一个数据页\",{\"1\":{\"813\":1}}],[\"b+树组成\",{\"1\":{\"813\":1}}],[\"b+树\",{\"1\":{\"807\":1,\"813\":5,\"817\":1},\"2\":{\"815\":1}}],[\"b+树索引组织过程\",{\"1\":{\"813\":1}}],[\"b+树索引特点\",{\"1\":{\"813\":1}}],[\"b+树索引结构\",{\"1\":{\"813\":1}}],[\"b+树索引\",{\"1\":{\"803\":1,\"813\":2}}],[\"b+\",{\"1\":{\"770\":4,\"813\":8,\"817\":6}}],[\"bbb数据页\",{\"1\":{\"752\":1}}],[\"by子句与索引列对应\",{\"1\":{\"807\":1}}],[\"by\",{\"1\":{\"427\":1,\"813\":1,\"823\":2,\"829\":1,\"838\":2,\"843\":1,\"988\":2}}],[\"bytedata\",{\"1\":{\"1037\":2}}],[\"byte切片转化为string\",{\"0\":{\"358\":1}}],[\"byte转化会发生一次内存拷贝\",{\"1\":{\"357\":1}}],[\"byte的相互转换\",{\"0\":{\"356\":1}}],[\"bytes\",{\"1\":{\"249\":1,\"1059\":2}}],[\"byte\",{\"1\":{\"20\":2,\"491\":1,\"568\":1,\"1059\":5}}],[\"byteindex\",{\"1\":{\"20\":3}}],[\"benefit\",{\"1\":{\"952\":1}}],[\"behind的最大特点\",{\"1\":{\"930\":1}}],[\"behind而言\",{\"1\":{\"930\":1}}],[\"behind\",{\"1\":{\"930\":5}}],[\"begin\",{\"1\":{\"760\":1,\"785\":2,\"810\":2,\"820\":8,\"1015\":2}}],[\"beforesleep\",{\"1\":{\"897\":1}}],[\"before\",{\"1\":{\"559\":1}}],[\"be\",{\"1\":{\"374\":1,\"425\":1,\"957\":1}}],[\"between\",{\"1\":{\"9\":1,\"829\":1}}],[\"bmap显示存储了8个tophash值\",{\"1\":{\"330\":1}}],[\"bmap结构体\",{\"0\":{\"328\":1}}],[\"basis\",{\"0\":{\"1070\":1,\"1074\":1,\"1080\":1}}],[\"bash的主要作者\",{\"1\":{\"190\":1}}],[\"bash\",{\"1\":{\"141\":1,\"149\":1,\"190\":5}}],[\"bak\",{\"1\":{\"855\":2}}],[\"bac\",{\"1\":{\"813\":1}}],[\"backoff\",{\"1\":{\"957\":8}}],[\"back\",{\"0\":{\"1063\":1},\"1\":{\"930\":1}}],[\"backwaid\",{\"1\":{\"885\":1}}],[\"backup\",{\"1\":{\"854\":2}}],[\"backgroundsave\",{\"1\":{\"952\":1}}],[\"background\",{\"1\":{\"249\":1,\"952\":1}}],[\"backlight\",{\"1\":{\"223\":1}}],[\"ba\",{\"1\":{\"813\":2}}],[\"banana\",{\"1\":{\"502\":3,\"503\":2}}],[\"batch\",{\"1\":{\"374\":1}}],[\"bazel\",{\"1\":{\"229\":1}}],[\"baz\",{\"1\":{\"229\":3}}],[\"bar\",{\"1\":{\"229\":7}}],[\"bss\",{\"1\":{\"217\":1}}],[\"bsearch\",{\"1\":{\"46\":1}}],[\"bucket\",{\"1\":{\"944\":1}}],[\"bucket数组的元素为bmap结构体\",{\"1\":{\"325\":1}}],[\"bulk\",{\"1\":{\"873\":1}}],[\"businessexception\",{\"1\":{\"545\":4,\"546\":1}}],[\"busybox2\",{\"1\":{\"119\":1}}],[\"busybox\",{\"1\":{\"104\":3,\"119\":1}}],[\"builder是非线程安全的\",{\"1\":{\"505\":1}}],[\"builder而不是+运算符\",{\"1\":{\"505\":1}}],[\"builder\",{\"0\":{\"505\":1},\"1\":{\"505\":13}}],[\"build命令时\",{\"1\":{\"396\":1}}],[\"build\",{\"1\":{\"391\":1,\"398\":3,\"399\":1,\"409\":1,\"957\":6}}],[\"builtin\",{\"1\":{\"351\":2}}],[\"but\",{\"1\":{\"374\":1}}],[\"buzz\",{\"1\":{\"229\":8}}],[\"buffe\",{\"1\":{\"747\":1}}],[\"bufferpool\",{\"0\":{\"736\":1},\"1\":{\"747\":3,\"748\":7,\"753\":2}}],[\"bufferedreader\",{\"1\":{\"541\":2,\"542\":2}}],[\"buffer编译器会将生成的go代码输出到命令行参数go\",{\"1\":{\"229\":1}}],[\"buffer编译器将生成\",{\"1\":{\"229\":1}}],[\"buffer编译器才能找到它\",{\"1\":{\"229\":1}}],[\"buffers\",{\"1\":{\"817\":1}}],[\"buffers使用指南\",{\"1\":{\"229\":1}}],[\"buffers详解\",{\"0\":{\"229\":1}}],[\"buffer\",{\"0\":{\"746\":1,\"747\":1,\"748\":1,\"749\":1,\"756\":1},\"1\":{\"217\":2,\"229\":2,\"745\":1,\"747\":2,\"751\":4,\"752\":1,\"753\":5,\"754\":1,\"755\":5,\"756\":7,\"763\":1,\"810\":55,\"813\":1,\"817\":1,\"927\":1,\"957\":1}}],[\"buf\",{\"1\":{\"226\":14,\"259\":1,\"873\":1,\"952\":2}}],[\"bob\",{\"1\":{\"558\":1}}],[\"boolean\",{\"1\":{\"568\":1,\"598\":3,\"983\":1}}],[\"bool类型\",{\"1\":{\"436\":1}}],[\"bool\",{\"1\":{\"265\":2,\"455\":1,\"469\":1,\"496\":1,\"497\":2,\"514\":1,\"515\":1,\"516\":1,\"529\":1,\"531\":2,\"532\":1,\"957\":7,\"983\":1,\"1059\":1}}],[\"boot是spring框架的扩展\",{\"1\":{\"700\":1}}],[\"boot\",{\"0\":{\"700\":1},\"1\":{\"220\":1,\"223\":1}}],[\"bootstrap\",{\"1\":{\"177\":1}}],[\"body>\",{\"1\":{\"652\":1}}],[\"body\",{\"1\":{\"249\":4}}],[\"bourne\",{\"1\":{\"190\":6}}],[\"brpop\",{\"1\":{\"924\":1}}],[\"br\",{\"1\":{\"249\":2}}],[\"break\",{\"1\":{\"226\":1,\"532\":1,\"568\":1}}],[\"brk\",{\"1\":{\"217\":4}}],[\"brightness\",{\"1\":{\"223\":1}}],[\"brian\",{\"1\":{\"190\":1}}],[\"bridged\",{\"1\":{\"246\":1}}],[\"bridge\",{\"0\":{\"123\":1},\"1\":{\"119\":2,\"122\":2}}],[\"broker11\",{\"1\":{\"177\":2}}],[\"broker10\",{\"1\":{\"177\":2}}],[\"broker\",{\"1\":{\"157\":1,\"172\":1,\"176\":2}}],[\"brd\",{\"1\":{\"121\":2}}],[\"bigint\",{\"1\":{\"979\":1}}],[\"bigstruct\",{\"1\":{\"429\":2}}],[\"biz\",{\"1\":{\"962\":5}}],[\"bilibili\",{\"1\":{\"246\":1,\"315\":1}}],[\"binpath=\",{\"1\":{\"836\":1}}],[\"binlog与\",{\"1\":{\"765\":1}}],[\"binlog文件\",{\"1\":{\"737\":1}}],[\"binlog\",{\"0\":{\"758\":1,\"759\":1,\"760\":1,\"761\":1},\"1\":{\"730\":9,\"735\":1,\"737\":4,\"759\":8,\"760\":15,\"761\":9,\"763\":9,\"765\":7,\"766\":1,\"767\":4,\"802\":1,\"807\":1,\"810\":161,\"820\":7},\"2\":{\"769\":1,\"812\":1}}],[\"bin目录中的文件都是可执行的二进制文件\",{\"1\":{\"223\":1}}],[\"bin是\",{\"1\":{\"223\":1}}],[\"bind\",{\"0\":{\"1038\":1},\"1\":{\"105\":1,\"226\":2,\"888\":1}}],[\"bin\",{\"1\":{\"104\":1,\"141\":1,\"149\":1,\"190\":1,\"223\":11,\"836\":1,\"854\":2}}],[\"binary的缩写\",{\"1\":{\"223\":2}}],[\"binary\",{\"1\":{\"104\":1,\"229\":1}}],[\"bits\",{\"1\":{\"903\":1,\"940\":3}}],[\"bitsmap\",{\"1\":{\"226\":1}}],[\"bitindex\",{\"1\":{\"20\":3}}],[\"bit\",{\"1\":{\"20\":1,\"770\":1,\"879\":3}}],[\"bitmap\",{\"1\":{\"20\":5},\"2\":{\"22\":1}}],[\"b不想等\",{\"1\":{\"33\":1}}],[\"b就是num的别名\",{\"1\":{\"30\":1}}],[\"b去接收它的返回值\",{\"1\":{\"30\":1}}],[\"b只是a的一个别名\",{\"1\":{\"30\":1}}],[\"b\",{\"1\":{\"30\":12,\"33\":4,\"36\":5,\"229\":2,\"423\":3,\"427\":3,\"440\":2,\"441\":2,\"442\":3,\"446\":1,\"466\":5,\"468\":1,\"483\":3,\"487\":2,\"489\":2,\"490\":2,\"496\":1,\"540\":2,\"770\":2,\"793\":3,\"794\":1,\"810\":3,\"813\":22,\"820\":32,\"912\":1,\"921\":1}}],[\"巧用数据结构\",{\"1\":{\"20\":1}}],[\"+fileheader\",{\"1\":{\"1037\":1}}],[\"+0000\",{\"1\":{\"957\":2}}],[\"+∞\",{\"1\":{\"820\":12}}],[\"+6\",{\"1\":{\"817\":1}}],[\"+=\",{\"1\":{\"458\":1,\"505\":1,\"1014\":1,\"1015\":1}}],[\"+1\",{\"1\":{\"226\":2}}],[\"++\",{\"1\":{\"88\":1}}],[\"++i\",{\"1\":{\"33\":4,\"226\":3}}],[\"+\",{\"0\":{\"743\":1,\"912\":1},\"1\":{\"20\":2,\"23\":3,\"46\":2,\"210\":2,\"226\":1,\"249\":3,\"330\":1,\"374\":4,\"423\":8,\"475\":1,\"509\":1,\"527\":1,\"540\":3,\"541\":1,\"542\":1,\"543\":2,\"546\":1,\"555\":8,\"556\":1,\"557\":1,\"558\":3,\"559\":5,\"565\":4,\"584\":7,\"590\":1,\"598\":1,\"599\":1,\"625\":4,\"626\":9,\"633\":11,\"634\":17,\"635\":28,\"637\":12,\"638\":4,\"640\":1,\"641\":14,\"652\":2,\"667\":3,\"692\":2,\"693\":2,\"717\":1,\"743\":1,\"770\":29,\"807\":2,\"810\":4,\"813\":5,\"817\":10,\"820\":14,\"873\":1,\"879\":1,\"903\":1,\"921\":1,\"976\":1,\"1037\":1}}],[\"五元组\",{\"1\":{\"237\":1}}],[\"五\",{\"0\":{\"13\":1,\"160\":1,\"517\":1,\"718\":1},\"1\":{\"217\":1,\"730\":1}}],[\"体验蛮好还\",{\"1\":{\"12\":1}}],[\"百度\",{\"1\":{\"12\":1}}],[\"四种隔离级别的实现方式\",{\"0\":{\"784\":1}}],[\"四种隔离级别\",{\"0\":{\"782\":1}}],[\"四种方式\",{\"1\":{\"139\":1}}],[\"四次挥手\",{\"1\":{\"237\":1,\"249\":2,\"817\":2}}],[\"四\",{\"0\":{\"12\":1,\"116\":1,\"159\":1,\"185\":1,\"516\":1,\"716\":1},\"1\":{\"23\":1,\"217\":1,\"237\":1,\"240\":1,\"727\":1,\"730\":1}}],[\"4种经典限流算法讲解\",{\"1\":{\"933\":1}}],[\"4a\",{\"1\":{\"770\":5}}],[\"4=200个字节的数据\",{\"1\":{\"770\":1}}],[\"4=1\",{\"1\":{\"249\":2}}],[\"49\",{\"1\":{\"370\":1,\"371\":1}}],[\"49000~49900\",{\"1\":{\"117\":1}}],[\"48\",{\"1\":{\"370\":1,\"371\":1}}],[\"45\",{\"1\":{\"370\":1,\"371\":1,\"817\":1,\"885\":1}}],[\"44921\",{\"1\":{\"957\":1}}],[\"44\",{\"1\":{\"370\":1,\"371\":1,\"873\":1}}],[\"443\",{\"1\":{\"249\":1}}],[\"41\",{\"1\":{\"370\":1,\"371\":1,\"770\":1}}],[\"4147\",{\"1\":{\"104\":1}}],[\"46\",{\"1\":{\"249\":1,\"370\":1,\"371\":1}}],[\"4xx\",{\"1\":{\"249\":2}}],[\"40\",{\"1\":{\"370\":1,\"371\":1}}],[\"404\",{\"1\":{\"240\":1,\"676\":1,\"1062\":1}}],[\"403\",{\"1\":{\"240\":1}}],[\"400\",{\"1\":{\"240\":1}}],[\"400类\",{\"1\":{\"240\":1}}],[\"400mb\",{\"1\":{\"217\":1}}],[\"4096\",{\"1\":{\"226\":1}}],[\"40亿\",{\"1\":{\"20\":1}}],[\"40亿qq号存储位置\",{\"1\":{\"20\":1}}],[\"40亿个qq号\",{\"1\":{\"20\":2}}],[\"4mb\",{\"1\":{\"217\":1}}],[\"4gb\",{\"1\":{\"217\":2,\"900\":1}}],[\"4kb\",{\"1\":{\"217\":2}}],[\"47\",{\"1\":{\"147\":1,\"370\":1,\"371\":1}}],[\"42\",{\"1\":{\"121\":1,\"370\":1,\"371\":1}}],[\"438824\",{\"1\":{\"957\":1}}],[\"43\",{\"1\":{\"20\":3,\"370\":1,\"371\":1}}],[\"4个字节的最大无符号整数\",{\"1\":{\"20\":1}}],[\"4byte\",{\"1\":{\"20\":1}}],[\"4\",{\"0\":{\"11\":1,\"77\":1,\"104\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":2,\"137\":1,\"142\":1,\"144\":1,\"145\":1,\"146\":1,\"147\":1,\"148\":2,\"149\":1,\"150\":1,\"164\":1,\"175\":1,\"177\":1,\"183\":1,\"198\":1,\"206\":1,\"207\":1,\"208\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"282\":2,\"293\":1,\"303\":1,\"308\":1,\"309\":1,\"310\":1,\"311\":1,\"328\":1,\"333\":1,\"343\":1,\"344\":1,\"345\":1,\"361\":1,\"397\":1,\"398\":1,\"399\":1,\"415\":1,\"416\":1,\"428\":1,\"429\":1,\"438\":1,\"447\":1,\"448\":1,\"457\":1,\"468\":1,\"476\":1,\"504\":1,\"505\":1,\"525\":1,\"532\":1,\"543\":1,\"558\":1,\"559\":1,\"571\":1,\"588\":1,\"593\":1,\"594\":1,\"595\":1,\"596\":1,\"601\":1,\"626\":1,\"632\":1,\"633\":1,\"634\":1,\"635\":1,\"657\":1,\"658\":1,\"663\":1,\"664\":1,\"665\":1,\"666\":1,\"667\":2,\"673\":1,\"678\":1,\"693\":1,\"711\":1,\"742\":1,\"750\":1,\"751\":1,\"752\":1,\"753\":1,\"754\":2,\"755\":1,\"756\":1,\"757\":1,\"766\":1,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"789\":1,\"803\":1,\"841\":1,\"849\":1,\"850\":1,\"851\":1,\"852\":1,\"915\":1,\"945\":1,\"946\":1,\"984\":1,\"985\":1,\"986\":1,\"987\":1,\"988\":1,\"989\":1,\"990\":1,\"991\":2,\"992\":1,\"993\":2,\"994\":2,\"995\":2,\"996\":1,\"997\":1,\"998\":1,\"999\":1,\"1005\":1,\"1008\":1,\"1032\":1,\"1034\":1,\"1035\":1,\"1036\":1,\"1037\":1,\"1042\":1,\"1054\":1,\"1057\":1,\"1058\":1,\"1059\":1},\"1\":{\"20\":1,\"23\":1,\"30\":1,\"33\":6,\"121\":1,\"217\":1,\"226\":4,\"229\":2,\"237\":1,\"240\":2,\"249\":37,\"344\":3,\"369\":1,\"370\":1,\"371\":1,\"442\":1,\"458\":1,\"469\":1,\"470\":1,\"658\":2,\"748\":1,\"751\":1,\"770\":2,\"794\":1,\"807\":1,\"810\":1,\"813\":1,\"820\":7,\"867\":1,\"870\":1,\"873\":1,\"876\":1,\"879\":1,\"885\":1,\"888\":1,\"891\":1,\"903\":1,\"906\":1,\"921\":1,\"927\":1,\"939\":1,\"940\":2,\"952\":1,\"989\":1,\"1008\":2}}],[\"cfg\",{\"1\":{\"957\":2}}],[\"cb414的博客\",{\"1\":{\"952\":1}}],[\"cbo\",{\"1\":{\"813\":1}}],[\"cb\",{\"1\":{\"813\":1}}],[\"cba\",{\"1\":{\"813\":1}}],[\"c=123\",{\"1\":{\"813\":1}}],[\"c=1\",{\"1\":{\"813\":1}}],[\"c=3\",{\"1\":{\"813\":7}}],[\"c=max\",{\"1\":{\"36\":1}}],[\"c5\",{\"1\":{\"770\":1}}],[\"c3\",{\"1\":{\"770\":1}}],[\"cj\",{\"1\":{\"640\":1}}],[\"csdn博客\",{\"1\":{\"930\":1,\"952\":1}}],[\"css\",{\"1\":{\"598\":1}}],[\"csh\",{\"1\":{\"190\":1}}],[\"custom\",{\"1\":{\"957\":2}}],[\"customer\",{\"1\":{\"723\":1}}],[\"cutset\",{\"1\":{\"500\":1}}],[\"currentuser\",{\"1\":{\"637\":2}}],[\"currentactivesessions\",{\"1\":{\"625\":4}}],[\"currenttimemillis\",{\"1\":{\"584\":2,\"600\":2,\"625\":1,\"626\":2}}],[\"current\",{\"1\":{\"226\":1,\"842\":1,\"848\":1}}],[\"cursor\",{\"1\":{\"944\":1}}],[\"cursorblinking\",{\"1\":{\"3\":1}}],[\"cursorsmoothcaretanimation\",{\"1\":{\"3\":1}}],[\"c1\",{\"1\":{\"491\":5}}],[\"circle\",{\"1\":{\"463\":2,\"470\":3}}],[\"cipher\",{\"1\":{\"249\":4}}],[\"cgoimport\",{\"1\":{\"392\":1}}],[\"c^e\",{\"1\":{\"249\":1}}],[\"c^d\",{\"1\":{\"249\":2}}],[\"c为加密后的密文\",{\"1\":{\"249\":1}}],[\"cn\",{\"1\":{\"249\":3,\"957\":9,\"974\":1}}],[\"ccc偏移量\",{\"1\":{\"752\":1}}],[\"cc\",{\"1\":{\"243\":1}}],[\"cern\",{\"1\":{\"249\":2}}],[\"certificate\",{\"1\":{\"240\":3,\"249\":4}}],[\"centos\",{\"1\":{\"138\":2,\"141\":1,\"145\":1}}],[\"ctl方法向epoll对象中添加进来的事件\",{\"1\":{\"226\":1}}],[\"ctl\",{\"1\":{\"226\":13}}],[\"ctrl+p+q\",{\"1\":{\"141\":1}}],[\"crypto\",{\"1\":{\"1058\":1,\"1059\":1}}],[\"crash\",{\"1\":{\"810\":5}}],[\"crashes应该就是\",{\"1\":{\"223\":1}}],[\"crc32\",{\"1\":{\"723\":1}}],[\"creat\",{\"1\":{\"826\":1}}],[\"creator\",{\"1\":{\"744\":1,\"787\":1}}],[\"creationtime\",{\"1\":{\"625\":1}}],[\"create接收的是一个指针\",{\"1\":{\"985\":1}}],[\"create|os\",{\"1\":{\"957\":2}}],[\"create就创建了多线程\",{\"1\":{\"897\":1}}],[\"created\",{\"1\":{\"134\":1}}],[\"create\",{\"1\":{\"107\":1,\"119\":1,\"177\":1,\"226\":4,\"249\":1,\"770\":4,\"813\":2,\"820\":4,\"826\":6,\"829\":1,\"836\":1,\"838\":3,\"843\":1,\"851\":1,\"979\":1,\"983\":1,\"985\":1,\"986\":1,\"1015\":1}}],[\"crud\",{\"0\":{\"514\":1},\"1\":{\"820\":4}}],[\"crlf\",{\"1\":{\"249\":1}}],[\"c语言malloc\",{\"1\":{\"217\":1}}],[\"c语言和c均使用\",{\"1\":{\"30\":1}}],[\"cab\",{\"1\":{\"813\":1}}],[\"cart\",{\"1\":{\"638\":4}}],[\"card\",{\"1\":{\"491\":3}}],[\"card0\",{\"1\":{\"223\":2}}],[\"cause\",{\"1\":{\"545\":4}}],[\"cas的监视键\",{\"1\":{\"944\":1}}],[\"cast\",{\"1\":{\"813\":1}}],[\"cas交换值\",{\"1\":{\"531\":2}}],[\"cas在\",{\"1\":{\"531\":1}}],[\"cas\",{\"1\":{\"512\":2,\"524\":3,\"526\":1}}],[\"case\",{\"0\":{\"450\":1},\"1\":{\"450\":1,\"568\":1,\"992\":1}}],[\"can\",{\"1\":{\"957\":1}}],[\"cannot\",{\"1\":{\"425\":1,\"468\":1}}],[\"cancelctx实现了可取消的context\",{\"1\":{\"280\":1}}],[\"cancelctx\",{\"0\":{\"280\":1}}],[\"canceler接口用于实现上下文取消功能\",{\"1\":{\"277\":1}}],[\"canceler接口\",{\"0\":{\"277\":1}}],[\"capitallevelencoder\",{\"1\":{\"957\":1}}],[\"cap\",{\"1\":{\"338\":1,\"344\":3}}],[\"ca\",{\"1\":{\"240\":6,\"249\":13,\"813\":1}}],[\"callerkey\",{\"1\":{\"957\":3}}],[\"caller\",{\"1\":{\"957\":8}}],[\"called\",{\"1\":{\"33\":2,\"466\":4}}],[\"call\",{\"1\":{\"229\":1}}],[\"cache\",{\"1\":{\"217\":2,\"223\":1,\"249\":3,\"675\":2,\"756\":2,\"759\":2,\"760\":8,\"765\":1,\"767\":1,\"770\":2,\"810\":26,\"817\":3,\"930\":11,\"962\":1}}],[\"catch\",{\"0\":{\"540\":1},\"1\":{\"540\":2,\"541\":1,\"542\":1,\"543\":1,\"553\":1,\"556\":1,\"557\":1,\"558\":1,\"568\":1,\"640\":1}}],[\"cat\",{\"1\":{\"209\":1,\"211\":1}}],[\"cdn\",{\"1\":{\"249\":1}}],[\"cd\",{\"1\":{\"201\":1}}],[\"cpds\",{\"1\":{\"640\":10}}],[\"cpu核心数\",{\"1\":{\"807\":1}}],[\"cpu资源等等\",{\"1\":{\"237\":1}}],[\"cpu\",{\"1\":{\"217\":3,\"220\":4,\"223\":1,\"243\":1,\"265\":1,\"373\":1,\"381\":1,\"770\":2,\"807\":2,\"813\":2,\"873\":1,\"882\":2,\"891\":1,\"930\":1,\"957\":1}}],[\"cp\",{\"1\":{\"150\":1,\"202\":1,\"209\":2}}],[\"cpp\",{\"1\":{\"33\":2,\"211\":1}}],[\"cpp的拓展\",{\"1\":{\"30\":1}}],[\"cmd\",{\"1\":{\"147\":1,\"229\":1,\"962\":1,\"968\":1}}],[\"c文件中\",{\"1\":{\"36\":1}}],[\"c文件\",{\"1\":{\"36\":1}}],[\"c调用c++函数\",{\"1\":{\"33\":1}}],[\"c\",{\"1\":{\"33\":6,\"88\":3,\"100\":1,\"147\":1,\"190\":2,\"217\":1,\"249\":3,\"265\":32,\"441\":2,\"442\":3,\"463\":3,\"470\":5,\"693\":1,\"770\":1,\"775\":1,\"813\":20,\"817\":1,\"820\":4,\"873\":2,\"918\":1,\"921\":1,\"957\":1,\"1024\":2,\"1029\":1,\"1031\":2,\"1032\":3,\"1035\":3,\"1036\":2,\"1037\":7,\"1039\":2,\"1040\":3,\"1041\":2,\"1042\":1}}],[\"checkpasswordhash\",{\"1\":{\"1059\":2}}],[\"checkpoint\",{\"1\":{\"810\":6}}],[\"checkwritehook\",{\"1\":{\"957\":1}}],[\"checked\",{\"1\":{\"538\":1}}],[\"check\",{\"1\":{\"394\":1,\"529\":1,\"531\":1,\"810\":1,\"957\":2}}],[\"chet\",{\"1\":{\"190\":1}}],[\"chunked\",{\"1\":{\"249\":1}}],[\"chrome\",{\"1\":{\"223\":2}}],[\"chrono\",{\"1\":{\"33\":3,\"249\":1}}],[\"chain\",{\"1\":{\"578\":1,\"584\":2,\"591\":2,\"596\":4,\"598\":2,\"599\":2,\"600\":2,\"601\":2,\"683\":2}}],[\"chanmsg\",{\"1\":{\"924\":1}}],[\"chan\",{\"1\":{\"436\":1,\"924\":2}}],[\"chanbuf\",{\"1\":{\"265\":1}}],[\"chanrecv\",{\"1\":{\"265\":1}}],[\"chansend函数\",{\"1\":{\"264\":1}}],[\"channel\",{\"1\":{\"266\":1,\"924\":3},\"2\":{\"268\":1}}],[\"channel读取\",{\"0\":{\"265\":1}}],[\"channel写入\",{\"0\":{\"264\":1}}],[\"channel初始化\",{\"0\":{\"263\":1}}],[\"channel操作\",{\"0\":{\"262\":1}}],[\"channel用make创建初始化会在堆上分配一个runtime\",{\"1\":{\"258\":1}}],[\"channel根据缓冲区大小可以分为两类\",{\"1\":{\"255\":1}}],[\"channel的数据结构\",{\"0\":{\"258\":1}}],[\"channel的分类\",{\"0\":{\"255\":1}}],[\"channel的存在\",{\"1\":{\"254\":1}}],[\"channel和select的搭配使用以及调度器对goroutine的调度\",{\"1\":{\"254\":1}}],[\"channel是go语言并发编程的核心概念之一\",{\"1\":{\"254\":1}}],[\"channel简介\",{\"0\":{\"254\":1}}],[\"change\",{\"1\":{\"201\":1,\"249\":3}}],[\"char字段是不是一无是处呢\",{\"1\":{\"770\":1}}],[\"char填充空格可能导致浪费存储空间\",{\"1\":{\"770\":1}}],[\"char如何存储\",{\"1\":{\"770\":1}}],[\"char会用空格填充至指定长度\",{\"1\":{\"770\":1}}],[\"char会将尾随空格去掉\",{\"1\":{\"770\":1}}],[\"char是255\",{\"1\":{\"770\":1}}],[\"character\",{\"1\":{\"770\":2}}],[\"characterencodingfilter\",{\"1\":{\"599\":1}}],[\"charset=\",{\"1\":{\"599\":1}}],[\"charset=utf8mb4\",{\"1\":{\"770\":2,\"976\":1}}],[\"charset=utf\",{\"1\":{\"249\":1,\"652\":1,\"675\":1,\"688\":1}}],[\"chars\",{\"1\":{\"497\":1}}],[\"char和varchar都会存储字符串长度\",{\"1\":{\"770\":1}}],[\"char和varchar存储对比\",{\"1\":{\"770\":1}}],[\"char和\",{\"1\":{\"33\":1}}],[\"char\",{\"1\":{\"30\":1,\"33\":7,\"226\":6,\"568\":1,\"770\":8}}],[\"cluster\",{\"1\":{\"927\":1}}],[\"clustered\",{\"1\":{\"813\":1}}],[\"clazz\",{\"1\":{\"555\":9}}],[\"class>\",{\"1\":{\"588\":1,\"627\":3,\"658\":1}}],[\"class>com\",{\"1\":{\"588\":1,\"627\":3,\"658\":1}}],[\"class的文件\",{\"1\":{\"566\":1}}],[\"classnotfoundexception\",{\"1\":{\"553\":1}}],[\"class3\",{\"1\":{\"553\":1}}],[\"class2\",{\"1\":{\"553\":1}}],[\"class1\",{\"1\":{\"553\":1}}],[\"class<\",{\"1\":{\"553\":3,\"555\":3,\"556\":1,\"557\":1,\"558\":1}}],[\"class对象是反射的入口点\",{\"1\":{\"553\":1}}],[\"class\",{\"1\":{\"33\":5,\"540\":1,\"541\":1,\"542\":1,\"543\":1,\"545\":2,\"546\":1,\"553\":2,\"555\":1,\"556\":4,\"557\":2,\"558\":3,\"559\":3,\"568\":1,\"584\":1,\"596\":2,\"598\":1,\"599\":1,\"600\":2,\"601\":1,\"624\":1,\"625\":1,\"626\":1,\"633\":1,\"634\":1,\"635\":1,\"637\":1,\"638\":1,\"640\":1,\"641\":1,\"652\":1,\"662\":1,\"683\":1,\"684\":1,\"689\":2,\"693\":1,\"699\":2,\"700\":2,\"813\":7}}],[\"closed\",{\"1\":{\"265\":3}}],[\"close\",{\"1\":{\"226\":2,\"542\":1,\"624\":1,\"640\":1}}],[\"closesocket\",{\"1\":{\"226\":4}}],[\"clock\",{\"1\":{\"33\":2,\"918\":2,\"921\":2,\"940\":1,\"957\":3}}],[\"cli进行生成\",{\"1\":{\"969\":1}}],[\"cli工具使用\",{\"0\":{\"967\":1}}],[\"cli\",{\"1\":{\"101\":1,\"968\":1}}],[\"clientaddr\",{\"1\":{\"226\":3}}],[\"client\",{\"1\":{\"10\":1,\"249\":7,\"897\":3,\"969\":1}}],[\"c的风格\",{\"1\":{\"30\":1}}],[\"c++预编译详解\",{\"0\":{\"36\":1}}],[\"c++11\",{\"1\":{\"33\":1}}],[\"c++智能指针的本质就是避免悬空指针的产生\",{\"1\":{\"33\":1}}],[\"c++引入了智能指针\",{\"1\":{\"33\":1}}],[\"c++调用c函数\",{\"1\":{\"33\":1}}],[\"c++的内存分区\",{\"1\":{\"33\":1}}],[\"c++基础知识复习\",{\"0\":{\"33\":1}}],[\"c++风格\",{\"1\":{\"30\":1}}],[\"c++特性\",{\"1\":{\"30\":1}}],[\"c++特性详解\",{\"0\":{\"30\":1}}],[\"c++\",{\"0\":{\"29\":1},\"2\":{\"27\":1,\"28\":1,\"31\":1,\"32\":1,\"34\":1,\"35\":1,\"37\":1,\"38\":1}}],[\"column\",{\"1\":{\"983\":2}}],[\"colorful\",{\"1\":{\"980\":1}}],[\"col\",{\"1\":{\"826\":3}}],[\"collections\",{\"1\":{\"641\":2}}],[\"cost\",{\"1\":{\"813\":20,\"1056\":1,\"1058\":1,\"1059\":7}}],[\"covering\",{\"1\":{\"813\":1}}],[\"core\",{\"1\":{\"957\":5}}],[\"corsfilter\",{\"1\":{\"601\":1}}],[\"cors\",{\"0\":{\"601\":1}}],[\"corrupted\",{\"1\":{\"265\":1}}],[\"corruption\",{\"1\":{\"33\":1}}],[\"coordinator\",{\"1\":{\"764\":1,\"810\":1}}],[\"cookies\",{\"1\":{\"673\":1}}],[\"cookie与url重写\",{\"1\":{\"249\":1}}],[\"cookie总是保存在客户端中\",{\"1\":{\"249\":1}}],[\"cookie\",{\"1\":{\"249\":13,\"673\":1,\"692\":1}}],[\"cooperativestickyassignor\",{\"1\":{\"165\":1}}],[\"comment\",{\"1\":{\"983\":5}}],[\"committed\",{\"1\":{\"782\":1}}],[\"commit\",{\"1\":{\"756\":5,\"760\":1,\"764\":1,\"765\":5,\"767\":5,\"810\":44,\"820\":4,\"829\":1,\"1015\":2}}],[\"commons\",{\"1\":{\"693\":1}}],[\"common\",{\"1\":{\"646\":1}}],[\"communicating\",{\"1\":{\"254\":1}}],[\"combopooleddatasource\",{\"1\":{\"640\":5}}],[\"compressed\",{\"1\":{\"770\":6}}],[\"compact\",{\"1\":{\"770\":16}}],[\"comparehashandpassword\",{\"1\":{\"1058\":1,\"1059\":1}}],[\"compareandswap\",{\"1\":{\"531\":2}}],[\"compare\",{\"1\":{\"496\":2,\"813\":1}}],[\"completed\",{\"1\":{\"515\":1}}],[\"compile帮助\",{\"1\":{\"391\":1}}],[\"compile\",{\"1\":{\"391\":2,\"423\":1}}],[\"com\",{\"1\":{\"229\":7,\"249\":1,\"556\":1,\"557\":1,\"558\":1,\"584\":1,\"624\":1,\"625\":1,\"626\":1,\"633\":1,\"634\":1,\"635\":1,\"637\":2,\"638\":1,\"640\":1,\"652\":1,\"957\":4,\"968\":1,\"985\":1,\"1001\":2,\"1005\":1,\"1023\":1,\"1024\":1,\"1040\":1}}],[\"comate\",{\"1\":{\"12\":2}}],[\"conf\",{\"1\":{\"949\":1,\"952\":2,\"962\":3}}],[\"conf配置文件中开启\",{\"1\":{\"897\":1}}],[\"configs\",{\"1\":{\"962\":1,\"966\":1}}],[\"config>\",{\"1\":{\"691\":2}}],[\"config\",{\"1\":{\"104\":1,\"223\":3,\"662\":2,\"664\":1,\"957\":12,\"962\":1,\"966\":2,\"978\":2,\"979\":1,\"980\":3}}],[\"concurrency\",{\"1\":{\"743\":1}}],[\"concurrent\",{\"1\":{\"510\":1,\"625\":1}}],[\"condition\",{\"1\":{\"451\":3,\"813\":1,\"817\":1}}],[\"continue\",{\"1\":{\"532\":1,\"568\":1}}],[\"contains函数使用了boyer\",{\"1\":{\"497\":1}}],[\"containsany\",{\"1\":{\"497\":2}}],[\"contains\",{\"1\":{\"497\":2}}],[\"container\",{\"0\":{\"125\":1},\"1\":{\"121\":3,\"122\":1,\"123\":3,\"125\":1}}],[\"containerd\",{\"1\":{\"102\":1,\"103\":4,\"104\":14}}],[\"contextpath\",{\"1\":{\"672\":1}}],[\"contextattributelistener\",{\"1\":{\"633\":1}}],[\"contextdestroyed\",{\"1\":{\"624\":1,\"640\":1,\"684\":1}}],[\"contextinitialized\",{\"1\":{\"624\":1,\"640\":1,\"684\":1}}],[\"context\",{\"1\":{\"590\":1,\"624\":6,\"640\":5,\"1024\":1,\"1031\":1,\"1036\":1,\"1037\":1,\"1040\":1},\"2\":{\"285\":1}}],[\"context进阶\",{\"1\":{\"283\":1}}],[\"context实现类型\",{\"0\":{\"278\":1}}],[\"context接口定义了四个必须实现的方法\",{\"1\":{\"276\":1}}],[\"context接口\",{\"0\":{\"276\":1}}],[\"context包提供了以下几个方法用于创建和操作context\",{\"1\":{\"274\":1}}],[\"context有四种基本实现类型\",{\"1\":{\"273\":1}}],[\"context的核心接口定义\",{\"1\":{\"272\":1}}],[\"context的底层实现\",{\"0\":{\"271\":1}}],[\"context在底层用到了2个接口\",{\"1\":{\"271\":1}}],[\"context是go语言中用于控制goroutine的一种机制\",{\"1\":{\"270\":1}}],[\"context简介\",{\"0\":{\"270\":1}}],[\"contentdisp\",{\"1\":{\"693\":2}}],[\"content\",{\"1\":{\"249\":9,\"601\":1,\"693\":1,\"1032\":3}}],[\"control\",{\"1\":{\"249\":3,\"601\":4,\"675\":1,\"743\":1}}],[\"connfd\",{\"1\":{\"226\":3}}],[\"connects\",{\"1\":{\"843\":2}}],[\"connectors\",{\"1\":{\"817\":1}}],[\"connectionpool\",{\"1\":{\"624\":2}}],[\"connections\",{\"1\":{\"249\":1,\"817\":2}}],[\"connection\",{\"1\":{\"237\":1,\"249\":3,\"817\":6}}],[\"connect\",{\"1\":{\"226\":2,\"249\":1}}],[\"console\",{\"1\":{\"957\":2}}],[\"consistent\",{\"1\":{\"785\":2}}],[\"consistency\",{\"1\":{\"774\":1}}],[\"consumer\",{\"0\":{\"160\":1},\"1\":{\"156\":1,\"711\":1}}],[\"const中每新增加一行常量声明将使iota计数一次\",{\"1\":{\"442\":1}}],[\"const关键字\",{\"1\":{\"33\":1}}],[\"constructors\",{\"1\":{\"556\":2}}],[\"constructor<\",{\"1\":{\"556\":2}}],[\"constructorreflection\",{\"1\":{\"556\":1}}],[\"constructor\",{\"1\":{\"33\":1,\"556\":2}}],[\"const\",{\"1\":{\"30\":2,\"33\":5,\"440\":4,\"441\":1,\"442\":5,\"568\":1,\"807\":1,\"817\":3,\"1030\":1}}],[\"copy函数复制的数据数量取决于两个切片的len的最小值\",{\"1\":{\"346\":1}}],[\"copy\",{\"1\":{\"33\":3,\"202\":1,\"223\":1,\"520\":1,\"525\":3,\"952\":1}}],[\"copilot\",{\"1\":{\"12\":2}}],[\"counter\",{\"1\":{\"903\":1}}],[\"count\",{\"1\":{\"33\":1,\"497\":2,\"503\":1,\"727\":1,\"807\":1,\"810\":3,\"870\":1,\"992\":1,\"1010\":3}}],[\"cout\",{\"1\":{\"33\":18}}],[\"cout<<value<<\",{\"1\":{\"30\":1}}],[\"cout<<\",{\"1\":{\"30\":2,\"226\":3}}],[\"codemap\",{\"1\":{\"1030\":1}}],[\"codesnap\",{\"1\":{\"13\":1}}],[\"code\",{\"1\":{\"11\":1,\"770\":2,\"1021\":3,\"1029\":1,\"1030\":4}}],[\"备份数据库\",{\"0\":{\"854\":1}}],[\"备份数据库的工具是\",{\"1\":{\"820\":1}}],[\"备份期间业务依然可以对数据进行更新操作\",{\"1\":{\"820\":1}}],[\"备份就会花费很多的时间\",{\"1\":{\"820\":1}}],[\"备主\",{\"1\":{\"810\":1}}],[\"备注\",{\"1\":{\"10\":1}}],[\"备忘\",{\"1\":{\"10\":1}}],[\"3g\",{\"1\":{\"900\":1}}],[\"3~4\",{\"1\":{\"813\":2}}],[\"3f\",{\"1\":{\"770\":1}}],[\"3表示最大记录\",{\"1\":{\"770\":1}}],[\"3表示sex呢\",{\"1\":{\"229\":1}}],[\"3pc\",{\"1\":{\"727\":1}}],[\"3999\",{\"1\":{\"638\":1}}],[\"39\",{\"1\":{\"370\":1,\"371\":1,\"873\":1}}],[\"38\",{\"1\":{\"370\":1,\"371\":1}}],[\"37\",{\"1\":{\"370\":1,\"371\":1}}],[\"36\",{\"1\":{\"370\":1,\"371\":1,\"770\":1,\"885\":1}}],[\"3600\",{\"1\":{\"104\":4,\"601\":1}}],[\"35\",{\"1\":{\"370\":1,\"371\":1,\"885\":2}}],[\"34\",{\"1\":{\"249\":1,\"370\":1,\"371\":1}}],[\"3306\",{\"1\":{\"976\":2}}],[\"33\",{\"1\":{\"249\":1,\"370\":1,\"371\":1,\"448\":1}}],[\"31\",{\"1\":{\"249\":2,\"370\":1,\"371\":1}}],[\"3xx\",{\"1\":{\"249\":2}}],[\"3w\",{\"1\":{\"237\":1}}],[\"32\",{\"1\":{\"217\":4,\"237\":1,\"249\":1,\"370\":1,\"371\":1,\"770\":2,\"807\":2,\"873\":5,\"885\":1,\"900\":1,\"983\":2}}],[\"32位\",{\"1\":{\"33\":1}}],[\"30分钟\",{\"1\":{\"691\":1}}],[\"3077\",{\"1\":{\"249\":2}}],[\"304\",{\"1\":{\"240\":1}}],[\"302\",{\"1\":{\"240\":1}}],[\"301\",{\"1\":{\"240\":1}}],[\"30s\",{\"1\":{\"237\":1}}],[\"30\",{\"1\":{\"121\":1,\"249\":1,\"370\":1,\"371\":1,\"556\":1,\"807\":1}}],[\"300s\",{\"1\":{\"952\":1}}],[\"300类\",{\"1\":{\"240\":1}}],[\"3000\",{\"1\":{\"117\":1}}],[\"300\",{\"1\":{\"30\":1,\"75\":1,\"807\":1}}],[\"3\",{\"0\":{\"10\":1,\"45\":1,\"46\":1,\"62\":1,\"76\":1,\"99\":1,\"103\":1,\"106\":1,\"112\":1,\"119\":1,\"136\":1,\"138\":1,\"139\":1,\"140\":1,\"141\":2,\"142\":1,\"143\":1,\"147\":1,\"163\":1,\"174\":1,\"176\":1,\"182\":1,\"197\":1,\"203\":1,\"204\":1,\"205\":1,\"258\":1,\"259\":1,\"261\":1,\"265\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"281\":1,\"289\":1,\"290\":1,\"291\":1,\"292\":2,\"302\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":2,\"308\":1,\"327\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":2,\"339\":1,\"340\":1,\"341\":1,\"342\":2,\"355\":1,\"356\":1,\"357\":1,\"382\":1,\"383\":1,\"384\":1,\"393\":1,\"394\":1,\"395\":1,\"396\":2,\"408\":1,\"409\":1,\"411\":1,\"414\":2,\"415\":1,\"424\":1,\"425\":1,\"426\":1,\"427\":2,\"437\":1,\"443\":1,\"444\":1,\"445\":2,\"446\":2,\"453\":1,\"456\":1,\"464\":1,\"467\":1,\"473\":1,\"475\":1,\"501\":1,\"502\":1,\"503\":1,\"520\":1,\"524\":1,\"531\":1,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"554\":1,\"555\":1,\"556\":1,\"557\":2,\"558\":1,\"566\":1,\"570\":1,\"573\":1,\"585\":1,\"586\":1,\"587\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":2,\"596\":1,\"600\":1,\"605\":1,\"609\":1,\"621\":1,\"622\":1,\"623\":1,\"624\":1,\"625\":2,\"626\":1,\"627\":1,\"628\":1,\"629\":1,\"630\":1,\"631\":2,\"635\":1,\"653\":1,\"654\":1,\"655\":1,\"656\":2,\"657\":1,\"659\":1,\"660\":1,\"661\":1,\"662\":1,\"666\":1,\"672\":1,\"677\":1,\"684\":1,\"690\":1,\"691\":1,\"692\":1,\"710\":1,\"715\":1,\"721\":1,\"722\":1,\"723\":1,\"724\":2,\"736\":1,\"737\":1,\"738\":1,\"739\":1,\"740\":1,\"741\":2,\"742\":1,\"743\":1,\"744\":1,\"745\":1,\"746\":2,\"747\":2,\"748\":2,\"749\":3,\"750\":1,\"751\":1,\"752\":1,\"753\":2,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1,\"759\":1,\"760\":1,\"761\":2,\"762\":1,\"763\":1,\"764\":1,\"765\":2,\"766\":1,\"767\":1,\"779\":1,\"780\":1,\"781\":1,\"782\":1,\"783\":1,\"784\":2,\"785\":1,\"789\":1,\"795\":1,\"802\":1,\"840\":1,\"845\":1,\"846\":1,\"847\":1,\"848\":2,\"852\":1,\"913\":1,\"914\":1,\"939\":1,\"940\":1,\"943\":1,\"944\":1,\"966\":1,\"967\":1,\"968\":1,\"969\":1,\"970\":2,\"980\":1,\"981\":1,\"982\":1,\"983\":1,\"987\":1,\"988\":1,\"989\":1,\"990\":2,\"991\":1,\"992\":1,\"999\":1,\"1004\":1,\"1007\":1,\"1025\":1,\"1028\":1,\"1029\":1,\"1030\":1,\"1031\":2,\"1032\":1,\"1033\":1,\"1037\":1,\"1041\":1,\"1053\":1,\"1055\":1,\"1056\":1},\"1\":{\"20\":9,\"23\":6,\"30\":1,\"33\":5,\"101\":1,\"217\":5,\"226\":6,\"229\":5,\"240\":5,\"243\":4,\"249\":81,\"265\":2,\"344\":2,\"369\":1,\"370\":1,\"371\":1,\"441\":1,\"442\":1,\"451\":1,\"452\":1,\"453\":2,\"458\":2,\"463\":1,\"470\":2,\"477\":1,\"503\":1,\"693\":1,\"708\":1,\"743\":1,\"751\":1,\"770\":6,\"794\":1,\"807\":1,\"810\":3,\"813\":2,\"820\":6,\"867\":3,\"870\":2,\"873\":2,\"876\":1,\"879\":2,\"885\":1,\"921\":3,\"924\":1,\"927\":1,\"930\":2,\"939\":1,\"952\":2,\"957\":8,\"994\":2,\"1024\":1,\"1032\":4}}],[\"pkg\",{\"1\":{\"957\":1}}],[\"pthread\",{\"1\":{\"897\":2}}],[\"ptr指针本身是常量\",{\"1\":{\"33\":1}}],[\"ptr指针所指向的整数是常量\",{\"1\":{\"33\":1}}],[\"ptr指向由shared\",{\"1\":{\"33\":1}}],[\"ptr循环引用的问题\",{\"1\":{\"33\":1}}],[\"ptr之前\",{\"1\":{\"33\":1}}],[\"ptr不会修改引用计数\",{\"1\":{\"33\":1}}],[\"ptr不保证其指向的内存一定有效\",{\"1\":{\"33\":1}}],[\"ptr不支持普通的拷贝和赋值操作\",{\"1\":{\"33\":1}}],[\"ptr被销毁后\",{\"1\":{\"33\":1}}],[\"ptr引用该对象\",{\"1\":{\"33\":1}}],[\"ptr管理的对象\",{\"1\":{\"33\":1}}],[\"ptr使用\",{\"1\":{\"33\":1}}],[\"ptr时\",{\"1\":{\"33\":2}}],[\"ptr始终拥有其指向的资源\",{\"1\":{\"33\":1}}],[\"ptr采用独享所有权语义\",{\"1\":{\"33\":1}}],[\"ptr\",{\"1\":{\"33\":6,\"940\":2}}],[\"px\",{\"1\":{\"873\":1}}],[\"p$port\",{\"1\":{\"817\":1}}],[\"pluggable\",{\"1\":{\"817\":1}}],[\"pdf\",{\"1\":{\"807\":1}}],[\"phantom\",{\"0\":{\"779\":1}}],[\"phone手机号字段的值\",{\"1\":{\"826\":1}}],[\"phone\",{\"1\":{\"770\":5,\"813\":1,\"826\":2}}],[\"p>\",{\"1\":{\"652\":1}}],[\"p2\",{\"1\":{\"483\":5}}],[\"p1\",{\"1\":{\"483\":2}}],[\"pp\",{\"1\":{\"374\":4}}],[\"ppid\",{\"1\":{\"147\":1}}],[\"pq\",{\"1\":{\"249\":1}}],[\"png\",{\"1\":{\"249\":2,\"598\":1}}],[\"pb\",{\"1\":{\"229\":9,\"962\":5}}],[\"pci0000\",{\"1\":{\"223\":1}}],[\"pwd\",{\"1\":{\"201\":1}}],[\"pseudo\",{\"1\":{\"820\":1}}],[\"ps发现centos停止了\",{\"1\":{\"145\":1}}],[\"ps\",{\"1\":{\"140\":1,\"142\":2,\"195\":1,\"196\":1,\"249\":1,\"820\":3}}],[\"pstree\",{\"1\":{\"104\":1}}],[\"p或\",{\"1\":{\"121\":1}}],[\"py\",{\"1\":{\"110\":1,\"113\":1}}],[\"python\",{\"1\":{\"110\":1,\"113\":1,\"223\":1}}],[\"pos\",{\"1\":{\"810\":5}}],[\"postform\",{\"1\":{\"1037\":1}}],[\"postgresql\",{\"1\":{\"813\":1}}],[\"postgresql提供的计算公式\",{\"1\":{\"807\":1}}],[\"post请求也可以有\",{\"1\":{\"1035\":1}}],[\"post请求参数乱码\",{\"1\":{\"687\":1}}],[\"post请求的幂等性\",{\"1\":{\"23\":1}}],[\"post方法\",{\"1\":{\"249\":1}}],[\"post\",{\"1\":{\"249\":7,\"451\":2,\"601\":1,\"1037\":1}}],[\"postman\",{\"1\":{\"10\":1}}],[\"pool的奥妙\",{\"1\":{\"749\":1}}],[\"pool后\",{\"1\":{\"747\":1}}],[\"pool\",{\"0\":{\"746\":1,\"747\":1,\"748\":1,\"749\":1},\"1\":{\"624\":5,\"745\":1,\"747\":3,\"751\":4,\"752\":1,\"753\":2,\"754\":1,\"763\":1,\"810\":35,\"817\":2,\"956\":1}}],[\"point\",{\"1\":{\"810\":1}}],[\"pointer\",{\"0\":{\"460\":1},\"1\":{\"265\":1,\"460\":2,\"516\":3,\"522\":2,\"742\":2,\"743\":1,\"770\":3,\"788\":1,\"810\":3}}],[\"points\",{\"1\":{\"229\":1}}],[\"pollrdnorm\",{\"1\":{\"226\":3}}],[\"pollfd\",{\"1\":{\"226\":3}}],[\"poll使用示例\",{\"1\":{\"226\":1}}],[\"poll和\",{\"1\":{\"226\":1}}],[\"poll\",{\"1\":{\"162\":1,\"226\":8}}],[\"port\",{\"1\":{\"118\":1,\"226\":2,\"249\":1,\"976\":2}}],[\"pop\",{\"1\":{\"52\":1,\"374\":2,\"924\":1}}],[\"pending\",{\"1\":{\"897\":1}}],[\"persistence\",{\"0\":{\"1081\":1}}],[\"personobj\",{\"1\":{\"556\":2}}],[\"personclass\",{\"1\":{\"556\":3,\"557\":5,\"558\":6}}],[\"person\",{\"1\":{\"229\":1,\"462\":9,\"483\":4,\"485\":1,\"486\":1,\"556\":1,\"557\":4,\"558\":4}}],[\"performance\",{\"1\":{\"820\":9}}],[\"performancemonitorfilter\",{\"1\":{\"600\":2}}],[\"per\",{\"1\":{\"770\":2}}],[\"peek\",{\"1\":{\"52\":1}}],[\"pets\",{\"1\":{\"13\":1}}],[\"ping\",{\"1\":{\"243\":1}}],[\"pip\",{\"1\":{\"223\":2}}],[\"pid\",{\"1\":{\"147\":1,\"223\":1}}],[\"pi\",{\"1\":{\"33\":1}}],[\"publish\",{\"1\":{\"924\":1}}],[\"publicuser\",{\"1\":{\"490\":2}}],[\"public\",{\"1\":{\"33\":5,\"249\":1,\"540\":3,\"541\":2,\"542\":3,\"543\":3,\"545\":8,\"546\":3,\"555\":2,\"556\":2,\"557\":2,\"558\":3,\"559\":6,\"568\":1,\"584\":4,\"590\":1,\"591\":1,\"592\":1,\"596\":4,\"598\":2,\"599\":3,\"600\":2,\"601\":2,\"624\":3,\"625\":4,\"626\":3,\"633\":4,\"634\":4,\"635\":4,\"637\":4,\"638\":3,\"640\":3,\"641\":8,\"652\":1,\"662\":3,\"683\":4,\"684\":3,\"689\":2,\"693\":1,\"699\":6,\"700\":2}}],[\"pub\",{\"1\":{\"924\":2}}],[\"purge\",{\"1\":{\"249\":1}}],[\"put\",{\"1\":{\"249\":7,\"601\":1}}],[\"put请求\",{\"1\":{\"23\":1}}],[\"pull\",{\"0\":{\"136\":1},\"1\":{\"136\":3,\"138\":1,\"249\":1}}],[\"push\",{\"1\":{\"52\":1}}],[\"p\",{\"1\":{\"30\":3,\"33\":10,\"110\":1,\"113\":1,\"117\":10,\"121\":1,\"139\":5,\"196\":1,\"249\":1,\"367\":1,\"373\":8,\"374\":11,\"462\":2,\"516\":2,\"522\":2,\"531\":7,\"817\":1,\"836\":2,\"840\":1,\"879\":1,\"918\":1,\"921\":1}}],[\"preamble5\",{\"1\":{\"949\":1}}],[\"prelen\",{\"1\":{\"879\":1}}],[\"prevlen\",{\"1\":{\"879\":12}}],[\"previous\",{\"1\":{\"531\":4}}],[\"prepare\",{\"1\":{\"764\":1,\"765\":4,\"767\":1,\"810\":20,\"817\":3}}],[\"prefix\",{\"1\":{\"500\":1,\"1056\":1}}],[\"preferred\",{\"1\":{\"121\":1}}],[\"pre\",{\"1\":{\"249\":3}}],[\"principle\",{\"0\":{\"1075\":1,\"1078\":1}}],[\"printmessage\",{\"1\":{\"699\":1}}],[\"printwriter\",{\"1\":{\"652\":2,\"677\":1}}],[\"printstacktrace\",{\"1\":{\"553\":1,\"556\":1,\"557\":1,\"558\":1,\"640\":1}}],[\"printstu\",{\"1\":{\"30\":4}}],[\"printarea\",{\"1\":{\"470\":3}}],[\"println\",{\"1\":{\"367\":1,\"410\":1,\"423\":1,\"441\":1,\"453\":2,\"458\":2,\"460\":1,\"462\":1,\"464\":2,\"466\":2,\"467\":1,\"470\":1,\"471\":2,\"477\":3,\"496\":2,\"497\":3,\"499\":2,\"500\":2,\"502\":2,\"503\":2,\"511\":5,\"514\":2,\"515\":1,\"540\":4,\"541\":2,\"542\":2,\"543\":2,\"555\":9,\"556\":2,\"557\":1,\"558\":3,\"559\":4,\"584\":4,\"590\":1,\"591\":2,\"592\":1,\"596\":4,\"624\":4,\"625\":4,\"626\":2,\"633\":3,\"634\":3,\"635\":6,\"637\":2,\"638\":2,\"640\":3,\"641\":4,\"652\":10,\"662\":3,\"677\":1,\"683\":2,\"684\":2,\"693\":1,\"699\":1,\"976\":1,\"989\":2,\"990\":1,\"991\":1,\"992\":2,\"993\":2,\"994\":1,\"1001\":6,\"1002\":1,\"1003\":1,\"1004\":1,\"1005\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":1,\"1014\":2,\"1021\":1,\"1035\":1,\"1036\":1,\"1037\":7,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1}}],[\"print\",{\"1\":{\"201\":1}}],[\"printf\",{\"1\":{\"88\":1,\"226\":3,\"469\":1,\"476\":1,\"483\":4,\"487\":2,\"489\":2,\"490\":2,\"491\":2,\"514\":1,\"515\":2}}],[\"printint\",{\"1\":{\"30\":2}}],[\"privdata\",{\"1\":{\"942\":1}}],[\"priv2\",{\"1\":{\"847\":1}}],[\"priv1\",{\"1\":{\"847\":1}}],[\"privilege\",{\"1\":{\"846\":5,\"847\":1}}],[\"privileges\",{\"1\":{\"840\":2}}],[\"private\",{\"1\":{\"33\":1,\"559\":1,\"568\":1,\"571\":1,\"599\":1,\"600\":1,\"625\":1,\"637\":3,\"638\":3,\"640\":1,\"641\":1,\"689\":1,\"693\":1,\"699\":1}}],[\"primarykey\",{\"1\":{\"983\":2}}],[\"primary\",{\"1\":{\"770\":3,\"817\":1,\"820\":1,\"983\":1}}],[\"price\",{\"1\":{\"23\":2}}],[\"pro\",{\"1\":{\"826\":1}}],[\"profession\",{\"1\":{\"826\":2}}],[\"profile\",{\"1\":{\"489\":10,\"656\":2}}],[\"production\",{\"1\":{\"957\":4}}],[\"product\",{\"1\":{\"638\":1,\"655\":1,\"817\":4}}],[\"producer将消息发送到kafka集群中的目标分区的leader节点\",{\"1\":{\"710\":1}}],[\"producer发送消息\",{\"1\":{\"710\":1}}],[\"producer发送消息给broker后\",{\"1\":{\"710\":2}}],[\"producer才会收到确认\",{\"1\":{\"710\":1}}],[\"producer也就无法重试和确认信息是否发送成功\",{\"1\":{\"710\":1}}],[\"producer的\",{\"1\":{\"709\":1}}],[\"producer是消息的源头\",{\"1\":{\"156\":1}}],[\"producer负责创建消息并将其发送到kafka服务器\",{\"1\":{\"156\":1}}],[\"producer\",{\"0\":{\"158\":1},\"1\":{\"23\":1,\"156\":1}}],[\"protected\",{\"1\":{\"568\":1,\"652\":1,\"662\":1,\"689\":2,\"693\":1}}],[\"proto文件操作\",{\"0\":{\"969\":1}}],[\"proto文件中带有example\",{\"1\":{\"229\":1}}],[\"proto文件中\",{\"1\":{\"229\":2}}],[\"proto=example\",{\"1\":{\"229\":2}}],[\"proto输入文件会产生一个位于protos\",{\"1\":{\"229\":1}}],[\"protos\",{\"1\":{\"229\":9}}],[\"protoc\",{\"1\":{\"229\":6}}],[\"protocol\",{\"0\":{\"229\":1},\"1\":{\"229\":8}}],[\"proto2\",{\"1\":{\"229\":1}}],[\"proto3\",{\"1\":{\"229\":1}}],[\"proto\",{\"1\":{\"229\":37,\"962\":7,\"969\":6}}],[\"protobuf将协议保存在\",{\"1\":{\"229\":1}}],[\"protobuf通过定义\",{\"1\":{\"229\":1}}],[\"protobuf\",{\"1\":{\"229\":8},\"2\":{\"231\":1}}],[\"proxy\",{\"1\":{\"559\":6}}],[\"pros\",{\"1\":{\"229\":2}}],[\"procedure\",{\"1\":{\"229\":1}}],[\"processlist\",{\"1\":{\"817\":1,\"836\":1,\"842\":1}}],[\"processingtime\",{\"1\":{\"600\":4,\"626\":2}}],[\"processbusinesslogic\",{\"1\":{\"546\":1}}],[\"process\",{\"1\":{\"223\":2,\"254\":1,\"918\":2,\"921\":2}}],[\"proc是\",{\"1\":{\"223\":1}}],[\"proc\",{\"1\":{\"223\":3}}],[\"project为module前缀\",{\"1\":{\"229\":1}}],[\"projects\",{\"1\":{\"9\":1}}],[\"project\",{\"1\":{\"9\":1,\"229\":6}}],[\"pattern\",{\"1\":{\"930\":4}}],[\"pattern>\",{\"1\":{\"588\":2,\"658\":2}}],[\"path=src\",{\"1\":{\"229\":2}}],[\"paths=source\",{\"1\":{\"229\":1}}],[\"paths=import\",{\"1\":{\"229\":1}}],[\"path环境变量里\",{\"1\":{\"223\":1}}],[\"path\",{\"1\":{\"10\":1,\"229\":1,\"249\":2,\"541\":2,\"542\":2,\"836\":1,\"854\":1}}],[\"passwordhashinghandler\",{\"1\":{\"1059\":1}}],[\"password=<password>\",{\"1\":{\"854\":1,\"855\":1}}],[\"password语法\",{\"1\":{\"841\":1}}],[\"password\",{\"1\":{\"490\":5,\"838\":1,\"841\":2,\"976\":2,\"1059\":11}}],[\"passwd\",{\"1\":{\"190\":2,\"207\":1}}],[\"painc\",{\"0\":{\"478\":1},\"1\":{\"479\":1}}],[\"pair\",{\"1\":{\"122\":1,\"123\":3}}],[\"panic的传递\",{\"0\":{\"479\":1}}],[\"panic\",{\"0\":{\"475\":1},\"1\":{\"478\":1,\"479\":8,\"956\":2,\"957\":2,\"976\":1}}],[\"payload\",{\"1\":{\"249\":1}}],[\"paws\",{\"1\":{\"237\":1}}],[\"package\",{\"1\":{\"229\":4,\"367\":1,\"410\":1,\"412\":1,\"413\":1,\"415\":1,\"423\":1,\"441\":1,\"458\":1,\"460\":1,\"466\":1,\"469\":1,\"470\":1,\"471\":1,\"477\":3,\"510\":1,\"511\":1,\"515\":1,\"568\":1,\"584\":1,\"624\":1,\"625\":1,\"626\":1,\"633\":1,\"634\":1,\"635\":1,\"637\":1,\"638\":1,\"652\":1,\"957\":5,\"1021\":1,\"1024\":1,\"1040\":1,\"1059\":1}}],[\"package在你的\",{\"1\":{\"229\":1}}],[\"packages\",{\"1\":{\"229\":1}}],[\"paging\",{\"1\":{\"217\":1}}],[\"pages\",{\"1\":{\"217\":2}}],[\"page\",{\"1\":{\"217\":1,\"678\":1,\"756\":2,\"760\":1,\"765\":1,\"770\":2,\"810\":11,\"930\":1,\"1008\":2}}],[\"parsetime=true\",{\"1\":{\"976\":1}}],[\"parse\",{\"1\":{\"734\":1}}],[\"parser\",{\"1\":{\"394\":1,\"817\":1}}],[\"party\",{\"1\":{\"962\":1}}],[\"participant\",{\"1\":{\"764\":1,\"810\":1}}],[\"partition0\",{\"1\":{\"177\":5}}],[\"partitions\",{\"1\":{\"177\":1}}],[\"partition\",{\"1\":{\"157\":2,\"172\":1}}],[\"part\",{\"1\":{\"693\":4}}],[\"parammap\",{\"1\":{\"670\":1}}],[\"paramnames\",{\"1\":{\"670\":1}}],[\"param>\",{\"1\":{\"588\":2}}],[\"parameter\",{\"1\":{\"458\":1,\"465\":3}}],[\"parameters\",{\"1\":{\"33\":2}}],[\"param\",{\"1\":{\"265\":3,\"588\":2,\"1036\":1}}],[\"pause\",{\"1\":{\"33\":1,\"918\":2,\"921\":2}}],[\"palettes\",{\"1\":{\"8\":1}}],[\"使开发者能够更加便捷地操作数据库\",{\"1\":{\"973\":1}}],[\"使开发人员不再需要定义样板化的配置\",{\"1\":{\"700\":1}}],[\"使\",{\"1\":{\"810\":1}}],[\"使当前会话失效\",{\"1\":{\"692\":1}}],[\"使go的并发变得简单快捷\",{\"1\":{\"254\":1}}],[\"使下列等式成立\",{\"1\":{\"249\":1}}],[\"使得\",{\"1\":{\"810\":1}}],[\"使得mysql能够高效地处理各种查询请求\",{\"1\":{\"734\":1}}],[\"使得程序可以\",{\"1\":{\"551\":1}}],[\"使得外部结构体可以直接访问这些字段和方法\",{\"1\":{\"462\":1}}],[\"使得报文能够加密传输\",{\"1\":{\"249\":1}}],[\"使得它们能够无缝协作\",{\"1\":{\"249\":1}}],[\"使协议变得非常灵活\",{\"1\":{\"249\":1}}],[\"使浏览器能了解请求执行成功或失败\",{\"1\":{\"249\":1}}],[\"使其在网络\",{\"1\":{\"888\":1}}],[\"使其能够从后往前遍历\",{\"1\":{\"879\":1}}],[\"使其访问特定的ip地址\",{\"1\":{\"243\":1}}],[\"使其显示为网络上的物理设备\",{\"1\":{\"122\":1}}],[\"使用bcrypt进行哈希等等\",{\"1\":{\"1056\":1}}],[\"使用包含常见密码的字典尝试破解密码\",{\"1\":{\"1048\":1}}],[\"使用包装器类\",{\"1\":{\"609\":1}}],[\"使用shouldbind方法将请求数据绑定到user结构体\",{\"1\":{\"1041\":1}}],[\"使用shouldbinduri方法将uri路径参数绑定到user结构体\",{\"1\":{\"1040\":1}}],[\"使用shouldbindquery方法将url查询参数绑定到user结构体\",{\"1\":{\"1039\":1}}],[\"使用strings\",{\"1\":{\"505\":2}}],[\"使用loadhtmlglob加载一个目录下的所有html文件\",{\"1\":{\"1031\":1}}],[\"使用结构体查询\",{\"1\":{\"1002\":1}}],[\"使用指针是为了存空值\",{\"1\":{\"982\":1,\"983\":1}}],[\"使用指针传参需要开辟内存\",{\"1\":{\"33\":1}}],[\"使用彩色打印\",{\"1\":{\"980\":1}}],[\"使用gorm\",{\"1\":{\"1012\":1}}],[\"使用gorm的标签进行修改\",{\"1\":{\"983\":1}}],[\"使用gorm需要先下载\",{\"1\":{\"975\":1}}],[\"使用grow方法预分配内存\",{\"1\":{\"505\":1}}],[\"使用proto格式生成\",{\"1\":{\"962\":1}}],[\"使用依赖倒置的原则\",{\"1\":{\"962\":1}}],[\"使用依赖注入\",{\"1\":{\"699\":1}}],[\"使用internal避免错误引用\",{\"1\":{\"962\":1}}],[\"使用redis的过期时间\",{\"1\":{\"930\":1}}],[\"使用redis的原子操作\",{\"1\":{\"714\":1}}],[\"使用完成之后\",{\"1\":{\"917\":1,\"921\":1}}],[\"使用标准的\",{\"1\":{\"906\":1}}],[\"使用频率最低的\",{\"1\":{\"903\":1}}],[\"使用近似lfu对任何键进行驱逐\",{\"1\":{\"900\":1}}],[\"使用近似lfu进行驱逐\",{\"1\":{\"900\":1}}],[\"使用近似lru对任何键进行驱逐\",{\"1\":{\"900\":1}}],[\"使用近似lru进行驱逐\",{\"1\":{\"900\":1}}],[\"使用单线程\",{\"1\":{\"888\":1}}],[\"使用概率均衡的死了来决定新插入节点的层数\",{\"1\":{\"885\":1}}],[\"使用flush\",{\"1\":{\"840\":1}}],[\"使用file\",{\"1\":{\"425\":1}}],[\"使用管理员权限登录到mysql服务器\",{\"1\":{\"840\":1}}],[\"使用长连接后可能会占用内存增多\",{\"1\":{\"817\":1}}],[\"使用广泛\",{\"1\":{\"813\":1}}],[\"使用xid\",{\"1\":{\"810\":1}}],[\"使用了索引下推后\",{\"1\":{\"817\":1}}],[\"使用了索引下推功能\",{\"1\":{\"813\":1}}],[\"使用了\",{\"1\":{\"810\":2,\"820\":1}}],[\"使用了多路复用\",{\"1\":{\"226\":1}}],[\"使用参数化查询\",{\"1\":{\"807\":1}}],[\"使用合适的逻辑运算符\",{\"1\":{\"807\":1}}],[\"使用等价变化规则\",{\"1\":{\"807\":1}}],[\"使用数据库的监控工具来识别和删除长时间未被查询使用的索引\",{\"1\":{\"807\":1}}],[\"使用索引扫描来做排序\",{\"1\":{\"807\":1}}],[\"使用hexdump命令查看\",{\"1\":{\"770\":1}}],[\"使用与存储引擎一样的基本单位\",{\"1\":{\"748\":1}}],[\"使用哈希函数计算客户\",{\"1\":{\"723\":1}}],[\"使用事务来确保多个操作的原子性\",{\"1\":{\"714\":1}}],[\"使用apache\",{\"1\":{\"693\":1}}],[\"使用atomicinteger保证线程安全\",{\"1\":{\"625\":1}}],[\"使用默认servlet\",{\"1\":{\"656\":1}}],[\"使用注解时\",{\"1\":{\"608\":1}}],[\"使用初始化参数或外部配置文件\",{\"1\":{\"605\":1}}],[\"使用缓存\",{\"1\":{\"603\":1,\"730\":1}}],[\"使用web\",{\"1\":{\"595\":1,\"608\":1}}],[\"使用动态代理\",{\"1\":{\"559\":1}}],[\"使用构造函数创建对象\",{\"1\":{\"556\":1}}],[\"使用自定义异常\",{\"0\":{\"546\":1}}],[\"使用方法以及实践\",{\"1\":{\"535\":1,\"549\":1}}],[\"使用同一个底层\",{\"1\":{\"520\":1}}],[\"使用两个\",{\"1\":{\"512\":1}}],[\"使用+运算符\",{\"1\":{\"505\":1}}],[\"使用分隔符连接字符串切片\",{\"1\":{\"503\":1}}],[\"使用omitempty\",{\"0\":{\"488\":1}}],[\"使用json\",{\"0\":{\"485\":1},\"1\":{\"485\":1,\"486\":1}}],[\"使用场景\",{\"0\":{\"474\":1,\"475\":1},\"1\":{\"876\":1}}],[\"使用以下命令查看汇编代码\",{\"1\":{\"423\":1}}],[\"使用命令\",{\"1\":{\"409\":1,\"817\":1}}],[\"使用对应编译器\",{\"1\":{\"396\":1}}],[\"使用的字段是connection\",{\"1\":{\"249\":1}}],[\"使用户访问错误的ip地址\",{\"1\":{\"243\":1}}],[\"使用epoll获取网络事件\",{\"1\":{\"226\":1}}],[\"使用示例\",{\"0\":{\"1059\":1},\"1\":{\"226\":1,\"637\":1,\"638\":1}}],[\"使用固定长度的\",{\"1\":{\"226\":1}}],[\"使用kafka\",{\"1\":{\"177\":1}}],[\"使用消费者组的优势\",{\"1\":{\"164\":1}}],[\"使用交互式运行\",{\"1\":{\"139\":1}}],[\"使用一个新的\",{\"1\":{\"957\":1}}],[\"使用一个序列号来保证id的唯一性\",{\"1\":{\"92\":1}}],[\"使用一个长度为41位的时间戳\",{\"1\":{\"92\":1}}],[\"使用带参数的宏定义可完成函数调用的功能\",{\"1\":{\"36\":1}}],[\"使用引用传递不需要创建临时变量\",{\"1\":{\"33\":1}}],[\"使用\",{\"0\":{\"586\":1,\"654\":1},\"1\":{\"8\":1,\"33\":2,\"110\":1,\"113\":1,\"118\":1,\"121\":1,\"124\":1,\"126\":1,\"217\":1,\"249\":2,\"460\":1,\"516\":1,\"522\":1,\"587\":1,\"595\":1,\"714\":1,\"810\":2,\"813\":1,\"873\":2,\"879\":2,\"888\":1,\"900\":1,\"924\":1,\"927\":1,\"957\":1,\"990\":1}}],[\"使代码建议不会被片段补全中断\",{\"1\":{\"3\":1}}],[\"搭配\",{\"1\":{\"8\":1}}],[\"ii7lgdybuaio8vrebl2cashrn0euqhqtmohxh\",{\"1\":{\"1059\":1}}],[\"i+1\",{\"1\":{\"986\":1}}],[\"i++\",{\"1\":{\"33\":2,\"367\":1,\"415\":1,\"505\":2,\"510\":2,\"511\":2,\"515\":3,\"986\":1}}],[\"ib\",{\"1\":{\"757\":7,\"810\":7}}],[\"ibdata1\",{\"1\":{\"770\":1}}],[\"ibd\",{\"1\":{\"751\":1,\"770\":7}}],[\"ignorerecordnotfounderror\",{\"1\":{\"980\":1}}],[\"ignore或\",{\"1\":{\"714\":1}}],[\"ignore\",{\"1\":{\"714\":1}}],[\"illegalargumentexception\",{\"1\":{\"543\":3}}],[\"icmp\",{\"1\":{\"243\":2,\"249\":1}}],[\"icons\",{\"1\":{\"6\":2}}],[\"icon\",{\"1\":{\"5\":1}}],[\"implements\",{\"1\":{\"559\":2,\"584\":1,\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"624\":1,\"625\":1,\"626\":1,\"633\":1,\"634\":1,\"635\":1,\"637\":1,\"638\":1,\"640\":1,\"641\":1,\"683\":1,\"684\":1,\"699\":1}}],[\"import\",{\"1\":{\"229\":2,\"367\":1,\"410\":1,\"441\":1,\"458\":1,\"460\":1,\"466\":1,\"469\":1,\"470\":1,\"471\":1,\"477\":3,\"511\":1,\"515\":1,\"559\":3,\"568\":1,\"584\":4,\"624\":4,\"625\":5,\"626\":5,\"633\":3,\"634\":3,\"635\":4,\"637\":3,\"638\":3,\"652\":7,\"957\":5,\"1021\":1,\"1024\":1,\"1040\":1,\"1059\":1}}],[\"img\",{\"1\":{\"249\":1}}],[\"image\",{\"1\":{\"134\":1,\"139\":1,\"249\":2}}],[\"images\",{\"0\":{\"134\":1},\"1\":{\"134\":1,\"137\":1,\"708\":1}}],[\"i<nfds\",{\"1\":{\"226\":1}}],[\"i=0\",{\"1\":{\"226\":1}}],[\"iso8601timeencoder\",{\"1\":{\"957\":2}}],[\"iso8601\",{\"1\":{\"957\":2}}],[\"isolation\",{\"1\":{\"774\":1}}],[\"iso\",{\"1\":{\"687\":1}}],[\"isloginpage\",{\"1\":{\"598\":2}}],[\"isloggedin\",{\"1\":{\"598\":2}}],[\"isstaticresource\",{\"1\":{\"598\":2}}],[\"isstatic\",{\"1\":{\"558\":1}}],[\"isselect\",{\"1\":{\"265\":1}}],[\"isset\",{\"1\":{\"226\":2}}],[\"ispublic\",{\"1\":{\"558\":1}}],[\"isarray\",{\"1\":{\"555\":1}}],[\"isenum\",{\"1\":{\"555\":1}}],[\"isempty\",{\"1\":{\"546\":1,\"599\":1}}],[\"isinterface\",{\"1\":{\"555\":1}}],[\"is\",{\"1\":{\"265\":1,\"462\":1,\"469\":4,\"476\":2,\"558\":2,\"829\":1}}],[\"isr\",{\"0\":{\"182\":1,\"183\":1},\"1\":{\"181\":5}}],[\"iterators\",{\"1\":{\"942\":1}}],[\"item\",{\"1\":{\"693\":5}}],[\"items\",{\"1\":{\"638\":1,\"693\":2}}],[\"itabtable是go运行时管理itab的数据结构\",{\"1\":{\"314\":1}}],[\"itabtable实现\",{\"0\":{\"314\":1}}],[\"itab复用\",{\"0\":{\"313\":1}}],[\"itab缓存机制\",{\"0\":{\"312\":1}}],[\"itab\",{\"1\":{\"307\":3}}],[\"itab字段含义\",{\"1\":{\"307\":1}}],[\"itab结构是非空接口实现的核心\",{\"1\":{\"307\":1}}],[\"itab结构详解\",{\"0\":{\"307\":1}}],[\"it\",{\"1\":{\"119\":1,\"139\":1,\"141\":1,\"149\":1,\"425\":1}}],[\"iothreadmain\",{\"1\":{\"897\":1}}],[\"iota为\",{\"1\":{\"442\":4}}],[\"iota\",{\"0\":{\"442\":1},\"1\":{\"442\":9}}],[\"io异常\",{\"1\":{\"542\":1}}],[\"ioexception\",{\"1\":{\"538\":1,\"541\":1,\"542\":2,\"584\":2,\"591\":1,\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"652\":2,\"662\":1,\"683\":1,\"693\":1}}],[\"io密集型的时候用非阻塞io\",{\"1\":{\"226\":1}}],[\"io多路复用的\",{\"1\":{\"226\":1}}],[\"io多路复用\",{\"1\":{\"226\":1}}],[\"io\",{\"1\":{\"104\":1,\"136\":1,\"584\":1,\"637\":1,\"638\":1,\"652\":2,\"755\":1,\"810\":1,\"813\":6,\"888\":8,\"891\":2,\"897\":8,\"975\":2,\"1037\":1}}],[\"ip模型都使用tcp和udp协议\",{\"1\":{\"249\":1}}],[\"ip模型在实践中被证明更为灵活和可靠\",{\"1\":{\"249\":1}}],[\"ip模型通常不区分这些层次\",{\"1\":{\"249\":1}}],[\"ip模型通常有4层\",{\"1\":{\"249\":1}}],[\"ip模型比osi模型更早被广泛采用\",{\"1\":{\"249\":1}}],[\"ip模型是为了在实际网络中应用而设计的\",{\"1\":{\"249\":1}}],[\"ip模型中\",{\"1\":{\"249\":1}}],[\"ip模型中称为互联网层\",{\"1\":{\"249\":1}}],[\"ip模型中有直接对应的层次\",{\"1\":{\"249\":1}}],[\"ip协议就位于这一层\",{\"1\":{\"249\":1}}],[\"ip只是利用\",{\"1\":{\"249\":1}}],[\"ip地址分配\",{\"1\":{\"246\":1}}],[\"ip地址为\",{\"1\":{\"226\":1}}],[\"ip黑名单\",{\"1\":{\"243\":1}}],[\"ip报文在网络中允许经过的最大路由数\",{\"1\":{\"237\":1}}],[\"ipproto\",{\"1\":{\"226\":1}}],[\"ipv4\",{\"1\":{\"226\":3}}],[\"iptable\",{\"1\":{\"122\":1}}],[\"ip\",{\"1\":{\"77\":1,\"121\":5,\"122\":6,\"124\":1,\"125\":2,\"126\":2,\"139\":1,\"237\":4,\"249\":13},\"2\":{\"228\":1,\"251\":1}}],[\"iphone\",{\"1\":{\"23\":1,\"817\":2}}],[\"ifc的结构如下图\",{\"1\":{\"311\":1}}],[\"ifc的结构如下\",{\"1\":{\"311\":1}}],[\"ifndef\",{\"1\":{\"36\":2}}],[\"ifndef防止头文件的重复包含和编译\",{\"1\":{\"36\":1}}],[\"if和\",{\"1\":{\"36\":1}}],[\"if\",{\"0\":{\"449\":1},\"1\":{\"33\":1,\"36\":2,\"46\":3,\"88\":1,\"226\":17,\"265\":10,\"374\":4,\"425\":2,\"426\":2,\"427\":1,\"449\":1,\"483\":2,\"487\":1,\"489\":1,\"490\":1,\"491\":1,\"514\":1,\"515\":1,\"529\":3,\"530\":1,\"531\":11,\"532\":4,\"543\":2,\"546\":3,\"598\":1,\"599\":1,\"600\":1,\"624\":1,\"626\":3,\"635\":3,\"640\":1,\"641\":4,\"693\":1,\"838\":2,\"976\":1,\"1014\":2,\"1015\":2,\"1037\":1}}],[\"i\",{\"1\":{\"33\":4,\"190\":1,\"197\":1,\"202\":1,\"226\":23,\"367\":5,\"391\":1,\"392\":1,\"415\":4,\"442\":1,\"453\":3,\"468\":3,\"505\":4,\"510\":7,\"511\":9,\"515\":15,\"531\":2,\"555\":2,\"755\":1,\"766\":1,\"767\":1,\"770\":4,\"775\":1,\"810\":13,\"817\":1,\"957\":1,\"986\":2}}],[\"id列\",{\"1\":{\"1006\":1}}],[\"id列表\",{\"1\":{\"787\":1}}],[\"id<=0的直接拦截\",{\"1\":{\"930\":1}}],[\"id<记录的\",{\"1\":{\"744\":1}}],[\"id做基础校验\",{\"1\":{\"930\":1}}],[\"idle\",{\"1\":{\"906\":1}}],[\"idx\",{\"1\":{\"813\":1,\"826\":5}}],[\"id=3\",{\"1\":{\"820\":1}}],[\"id=123\",{\"1\":{\"1036\":1}}],[\"id=1\",{\"1\":{\"810\":2}}],[\"id=\",{\"1\":{\"794\":1}}],[\"id是必需的\",{\"1\":{\"770\":1}}],[\"id不是必需的\",{\"1\":{\"770\":1}}],[\"ids\",{\"1\":{\"744\":4,\"787\":1,\"789\":3}}],[\"identified\",{\"1\":{\"838\":2,\"843\":1}}],[\"identifier\",{\"1\":{\"249\":1,\"440\":1,\"810\":1}}],[\"idea\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"ide\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"id以及offset\",{\"1\":{\"163\":1}}],[\"id\",{\"1\":{\"23\":3,\"77\":1,\"92\":1,\"122\":1,\"134\":1,\"190\":1,\"223\":1,\"249\":1,\"447\":2,\"491\":4,\"559\":3,\"723\":3,\"727\":2,\"735\":1,\"742\":2,\"743\":1,\"744\":12,\"763\":4,\"765\":1,\"770\":11,\"787\":3,\"788\":3,\"789\":10,\"793\":9,\"794\":2,\"807\":1,\"810\":15,\"813\":11,\"817\":9,\"820\":35,\"873\":1,\"943\":1,\"944\":1,\"982\":1,\"988\":2,\"991\":1,\"1010\":1,\"1013\":2,\"1036\":2,\"1040\":5}}],[\"inno\",{\"1\":{\"807\":1}}],[\"innodb引擎才支持事务\",{\"1\":{\"1013\":1}}],[\"innodb引擎层\",{\"1\":{\"747\":1}}],[\"innodb会跳过加锁环节\",{\"1\":{\"820\":1}}],[\"innodb同样保存了字符长度\",{\"1\":{\"770\":1}}],[\"innodb存储引擎支持多种行格式\",{\"1\":{\"770\":1}}],[\"innodb存储引擎的逻辑存储结构大致如下图\",{\"1\":{\"770\":1}}],[\"innodb存储引擎详解\",{\"0\":{\"770\":1}}],[\"innodb中磁盘与内存的交互基本单位\",{\"1\":{\"748\":1}}],[\"innodb\",{\"0\":{\"775\":1},\"1\":{\"737\":1,\"739\":1,\"741\":1,\"748\":4,\"751\":2,\"753\":4,\"755\":1,\"756\":6,\"757\":1,\"765\":2,\"767\":1,\"770\":20,\"793\":1,\"810\":48,\"813\":10,\"817\":8,\"820\":20},\"2\":{\"772\":1}}],[\"increaselevel\",{\"1\":{\"957\":1}}],[\"increment\",{\"1\":{\"770\":2,\"820\":5}}],[\"incrementandget\",{\"1\":{\"625\":1}}],[\"inc\",{\"1\":{\"820\":12}}],[\"incldude<iostream>这一行代码\",{\"1\":{\"36\":1}}],[\"incldude<iostream>\",{\"1\":{\"36\":1}}],[\"include\",{\"1\":{\"33\":7,\"36\":1,\"681\":1}}],[\"infra层\",{\"1\":{\"962\":1}}],[\"infimum\",{\"1\":{\"770\":2}}],[\"inf\",{\"1\":{\"588\":1,\"627\":1,\"658\":1}}],[\"infoln\",{\"1\":{\"957\":3}}],[\"infolevel\",{\"1\":{\"957\":5}}],[\"infof\",{\"1\":{\"957\":3}}],[\"infow\",{\"1\":{\"957\":1}}],[\"informational\",{\"1\":{\"249\":1}}],[\"info\",{\"1\":{\"104\":1,\"132\":1,\"586\":1,\"600\":1,\"956\":1,\"957\":30,\"966\":3,\"980\":2,\"983\":1}}],[\"invocationhandler\",{\"1\":{\"559\":2}}],[\"invoke\",{\"1\":{\"558\":2,\"559\":2}}],[\"invalidate\",{\"1\":{\"692\":1}}],[\"invaliduserexception\",{\"1\":{\"545\":4,\"546\":3}}],[\"invalid\",{\"1\":{\"226\":2}}],[\"initialfields\",{\"1\":{\"957\":4}}],[\"initial\",{\"1\":{\"957\":1}}],[\"initthreadedio来初始化多线程\",{\"1\":{\"897\":1}}],[\"initparams\",{\"1\":{\"586\":1}}],[\"init\",{\"1\":{\"451\":2,\"584\":1,\"588\":1,\"590\":1,\"599\":1,\"662\":2,\"664\":1,\"683\":1}}],[\"index表示全索引扫描\",{\"1\":{\"807\":1}}],[\"indexof\",{\"1\":{\"693\":1}}],[\"index\",{\"1\":{\"412\":3,\"413\":3,\"452\":1,\"807\":2,\"813\":4,\"817\":2,\"820\":5,\"826\":17,\"864\":1,\"1021\":1,\"1031\":2}}],[\"indent\",{\"1\":{\"8\":3}}],[\"insert\",{\"1\":{\"714\":2,\"741\":1,\"770\":5,\"810\":1,\"820\":21,\"829\":1,\"846\":1}}],[\"instance\",{\"1\":{\"658\":1}}],[\"instanceof\",{\"1\":{\"568\":1,\"626\":2,\"635\":3,\"640\":1}}],[\"install\",{\"1\":{\"229\":1,\"968\":1}}],[\"inspect\",{\"1\":{\"109\":1,\"114\":1,\"148\":1}}],[\"inaddr\",{\"1\":{\"226\":1}}],[\"inactive\",{\"1\":{\"217\":1}}],[\"in结构体方便填写\",{\"1\":{\"226\":1}}],[\"inet\",{\"1\":{\"121\":1,\"226\":8}}],[\"int16\",{\"1\":{\"879\":1}}],[\"intset\",{\"1\":{\"870\":5}}],[\"into\",{\"1\":{\"770\":5,\"820\":2}}],[\"intandstringdemo\",{\"1\":{\"491\":1}}],[\"int64\",{\"1\":{\"483\":1,\"485\":1,\"486\":1,\"491\":1,\"879\":1}}],[\"intention\",{\"1\":{\"820\":1}}],[\"internal\",{\"1\":{\"962\":1,\"969\":1}}],[\"interval\",{\"1\":{\"952\":1}}],[\"interfce\",{\"1\":{\"472\":1}}],[\"interfaces\",{\"1\":{\"555\":2}}],[\"interfacename\",{\"1\":{\"465\":1}}],[\"interfacetype结构\",{\"0\":{\"308\":1}}],[\"interfacetype\",{\"1\":{\"307\":2}}],[\"interface\",{\"0\":{\"299\":1},\"1\":{\"463\":1,\"465\":1,\"466\":2,\"467\":1,\"468\":2,\"469\":1,\"470\":1,\"471\":3,\"514\":1,\"515\":1,\"559\":1,\"646\":1,\"699\":1,\"817\":1,\"956\":1,\"957\":4,\"980\":1},\"2\":{\"317\":1}}],[\"inter\",{\"1\":{\"307\":1}}],[\"intellij\",{\"1\":{\"223\":1}}],[\"intellisense\",{\"1\":{\"10\":1}}],[\"intel\",{\"1\":{\"223\":1,\"249\":2}}],[\"int32>\",{\"1\":{\"229\":1}}],[\"int32\",{\"1\":{\"229\":2,\"374\":3,\"879\":1}}],[\"int\",{\"1\":{\"30\":29,\"33\":41,\"36\":9,\"46\":3,\"88\":2,\"226\":28,\"367\":1,\"410\":2,\"412\":1,\"413\":1,\"415\":1,\"423\":2,\"426\":3,\"427\":2,\"437\":1,\"441\":1,\"447\":3,\"453\":3,\"455\":1,\"458\":7,\"459\":2,\"460\":3,\"467\":1,\"468\":3,\"469\":1,\"477\":4,\"496\":1,\"497\":1,\"502\":1,\"503\":1,\"510\":2,\"511\":2,\"515\":3,\"516\":1,\"540\":4,\"543\":1,\"556\":1,\"558\":1,\"559\":2,\"625\":3,\"641\":1,\"770\":5,\"813\":1,\"820\":2,\"873\":3,\"879\":2,\"940\":1,\"942\":2,\"944\":1,\"957\":6,\"979\":1,\"994\":1,\"999\":1,\"1009\":1,\"1010\":2,\"1013\":1,\"1021\":1,\"1030\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1,\"1043\":1,\"1059\":1}}],[\"in\",{\"1\":{\"11\":1,\"33\":1,\"226\":6,\"468\":1,\"770\":3,\"807\":1,\"817\":1,\"820\":5,\"829\":2,\"957\":2,\"995\":1,\"1001\":1}}],[\"编号\",{\"1\":{\"943\":1,\"944\":1}}],[\"编码配置\",{\"1\":{\"957\":1}}],[\"编码类型里还包含\",{\"1\":{\"879\":1}}],[\"编码类型\",{\"1\":{\"879\":2}}],[\"编码的条件之一是数据对象的数量小于\",{\"1\":{\"879\":1}}],[\"编码的字符串执行任何修改指令\",{\"1\":{\"873\":1}}],[\"编码的字符串对象实际上时只读的\",{\"1\":{\"873\":1}}],[\"编码的两次降低为一次\",{\"1\":{\"873\":1}}],[\"编码时\",{\"1\":{\"870\":1}}],[\"编码选择\",{\"1\":{\"867\":1}}],[\"编码方式\",{\"1\":{\"867\":1,\"870\":1,\"876\":1}}],[\"编码层优化\",{\"1\":{\"807\":1}}],[\"编码是\",{\"1\":{\"770\":1}}],[\"编码转换等功能的理想选择\",{\"1\":{\"576\":1}}],[\"编码\",{\"1\":{\"249\":1,\"870\":1,\"879\":1}}],[\"编辑器存放临时文件的地方\",{\"1\":{\"223\":1}}],[\"编辑器\",{\"2\":{\"216\":1}}],[\"编辑器中的平滑滚动效果\",{\"1\":{\"3\":1}}],[\"编写的\",{\"1\":{\"190\":1}}],[\"编译依赖包\",{\"1\":{\"396\":1}}],[\"编译并执行go源码\",{\"1\":{\"391\":1}}],[\"编译标记说明\",{\"0\":{\"392\":1}}],[\"编译标记\",{\"1\":{\"391\":2}}],[\"编译go源码\",{\"1\":{\"391\":1}}],[\"编译命令解析\",{\"0\":{\"390\":1}}],[\"编译过程主要包括词法分析\",{\"1\":{\"389\":1}}],[\"编译原理\",{\"2\":{\"37\":1,\"401\":1,\"402\":1}}],[\"编译器在生成代码时会进行以下操作\",{\"1\":{\"462\":1}}],[\"编译器在运行的时候会调用该文件\",{\"1\":{\"229\":1}}],[\"编译器可以根据变量的值来推断类型\",{\"1\":{\"440\":1}}],[\"编译器可以有效地优化\",{\"1\":{\"428\":1}}],[\"编译器会在外部结构体中创建同名的方法\",{\"1\":{\"462\":1}}],[\"编译器会在外部结构体中创建相同名字的字段\",{\"1\":{\"462\":1}}],[\"编译器会将所有返回值封装为一个结构体返回\",{\"1\":{\"422\":1}}],[\"编译器会分析代码的特征和生命周期\",{\"1\":{\"407\":1}}],[\"编译器会自动创建嵌套的输出子目录\",{\"1\":{\"229\":1}}],[\"编译器用于决定变量分配到堆上还是栈上的一种行为\",{\"1\":{\"404\":1}}],[\"编译器命令行流程\",{\"0\":{\"396\":1}}],[\"编译器架构\",{\"0\":{\"393\":1}}],[\"编译器工作流程\",{\"0\":{\"389\":1}}],[\"编译器将高级语言代码转换为机器可执行的指令\",{\"1\":{\"388\":1}}],[\"编译器将从\",{\"1\":{\"229\":1}}],[\"编译器基础知识\",{\"0\":{\"388\":1}}],[\"编译器为每个\",{\"1\":{\"229\":1}}],[\"编译器需要借助一个插件来根据提供的\",{\"1\":{\"229\":1}}],[\"编译器调用\",{\"1\":{\"229\":1}}],[\"编译器\",{\"1\":{\"565\":1},\"2\":{\"28\":1,\"402\":1}}],[\"编程大致的工作流程\",{\"1\":{\"226\":1}}],[\"编程\",{\"1\":{\"226\":1}}],[\"编程语言\",{\"2\":{\"31\":1,\"34\":1}}],[\"编程类\",{\"0\":{\"7\":1}}],[\"三类\",{\"1\":{\"820\":1}}],[\"三个字段都可以走索引\",{\"1\":{\"813\":1}}],[\"三个衡量指标\",{\"1\":{\"807\":1}}],[\"三种过期键清除策略\",{\"1\":{\"882\":1}}],[\"三种执行过程\",{\"1\":{\"817\":1}}],[\"三种主从同步模式\",{\"1\":{\"761\":1}}],[\"三种日志系统\",{\"1\":{\"810\":1}}],[\"三种日志的主要作用\",{\"0\":{\"737\":1}}],[\"三种日志\",{\"0\":{\"736\":1}}],[\"三阶段提交协议\",{\"1\":{\"727\":1}}],[\"三大部分组成\",{\"1\":{\"249\":1}}],[\"三次握手建立连接\",{\"1\":{\"817\":1}}],[\"三次握手之后\",{\"1\":{\"249\":1}}],[\"三次握手之后便可进行\",{\"1\":{\"249\":1}}],[\"三次握手\",{\"1\":{\"237\":1,\"249\":2,\"817\":3}}],[\"三\",{\"0\":{\"7\":1,\"105\":1,\"158\":1,\"184\":1,\"372\":1,\"513\":1,\"572\":1,\"712\":1},\"1\":{\"23\":2,\"217\":1,\"237\":2,\"240\":1,\"243\":1,\"727\":2,\"730\":1}}],[\"好\",{\"1\":{\"813\":5}}],[\"好处是能能往左往右遍历\",{\"1\":{\"813\":1}}],[\"好文章\",{\"1\":{\"432\":1}}],[\"好不容易写的东西全没了\",{\"1\":{\"223\":1}}],[\"好看好看好看好看\",{\"1\":{\"6\":1}}],[\"好用好看好玩的vscode插件\",{\"1\":{\"2\":1}}],[\"eq\",{\"1\":{\"807\":2}}],[\"equals\",{\"1\":{\"546\":1,\"641\":3}}],[\"equalfold适用于不区分大小写的场景\",{\"1\":{\"496\":1}}],[\"equalfold\",{\"1\":{\"496\":2}}],[\"e6af9b\",{\"1\":{\"770\":1}}],[\"e6\",{\"1\":{\"770\":156}}],[\"ee\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"eclipse\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"echo\",{\"1\":{\"209\":3}}],[\"e是字符串\",{\"1\":{\"442\":1}}],[\"errrecordnotfound\",{\"1\":{\"992\":1}}],[\"err\",{\"1\":{\"425\":2,\"427\":2,\"467\":1,\"483\":8,\"487\":4,\"489\":4,\"490\":4,\"491\":4,\"640\":1,\"976\":3,\"978\":1,\"979\":1,\"980\":2,\"992\":3,\"1014\":8,\"1015\":4,\"1037\":8,\"1039\":2,\"1040\":2,\"1041\":2,\"1042\":2,\"1059\":4}}],[\"error=\",{\"1\":{\"976\":1}}],[\"errorlevel\",{\"1\":{\"957\":1}}],[\"erroroutput\",{\"1\":{\"957\":1}}],[\"erroroutputpaths\",{\"1\":{\"957\":8}}],[\"errorf\",{\"1\":{\"472\":1}}],[\"error是\",{\"1\":{\"472\":1}}],[\"errors\",{\"1\":{\"425\":1,\"427\":1}}],[\"errorstatus\",{\"1\":{\"229\":1}}],[\"error\",{\"0\":{\"472\":1},\"1\":{\"33\":1,\"226\":3,\"249\":2,\"425\":1,\"427\":1,\"429\":2,\"467\":1,\"472\":4,\"509\":1,\"510\":1,\"538\":2,\"817\":1,\"956\":1,\"957\":26,\"962\":3,\"976\":1,\"992\":2,\"1014\":3,\"1015\":2,\"1059\":1}}],[\"embeddedprefix\",{\"1\":{\"983\":2}}],[\"embedded\",{\"1\":{\"983\":2}}],[\"embstr编码的字符串对象同样只需要调用一次内存释放函数\",{\"1\":{\"873\":1}}],[\"embstr编码将创建字符串对象所需的内存分配次数从\",{\"1\":{\"873\":1}}],[\"embstr\",{\"1\":{\"873\":9}}],[\"email\",{\"1\":{\"487\":3,\"488\":2,\"489\":8,\"637\":4,\"826\":4,\"982\":1,\"983\":2,\"985\":3,\"986\":2,\"1001\":2,\"1005\":1}}],[\"emp\",{\"1\":{\"462\":2}}],[\"employee\",{\"1\":{\"462\":3}}],[\"empty\",{\"1\":{\"425\":1,\"820\":2,\"957\":1}}],[\"emptyctx是一个最基本的context实现\",{\"1\":{\"279\":1}}],[\"emptyctx\",{\"0\":{\"279\":1}}],[\"emoji\",{\"1\":{\"6\":1}}],[\"e\",{\"1\":{\"237\":1,\"249\":3,\"442\":1,\"529\":4,\"531\":11,\"532\":2,\"540\":4,\"541\":2,\"542\":2,\"543\":2,\"553\":2,\"556\":2,\"557\":2,\"558\":2,\"640\":3}}],[\"enabled\",{\"1\":{\"957\":1}}],[\"engine=innodb\",{\"1\":{\"820\":1,\"1013\":1}}],[\"engines\",{\"1\":{\"817\":1}}],[\"engine\",{\"1\":{\"770\":2,\"813\":4}}],[\"enrty\",{\"0\":{\"521\":1}}],[\"entry是共享的\",{\"1\":{\"531\":1}}],[\"entry\",{\"0\":{\"522\":1,\"523\":1},\"1\":{\"512\":3,\"516\":4,\"520\":1,\"521\":1,\"522\":1,\"526\":1,\"531\":3,\"879\":18,\"957\":1}}],[\"env\",{\"1\":{\"391\":1}}],[\"env命令查看$gopath\",{\"1\":{\"229\":1}}],[\"enqueue\",{\"1\":{\"265\":1}}],[\"encipherframework\",{\"0\":{\"1087\":1}}],[\"encodecaller\",{\"1\":{\"957\":3}}],[\"encodeduration\",{\"1\":{\"957\":3}}],[\"encodetime\",{\"1\":{\"957\":5}}],[\"encodelevel\",{\"1\":{\"957\":4}}],[\"encoderconfig\",{\"1\":{\"957\":14}}],[\"encodingparam\",{\"1\":{\"599\":4}}],[\"encoding\",{\"1\":{\"249\":5,\"599\":6,\"873\":2,\"879\":7,\"938\":2,\"940\":2,\"957\":7,\"1021\":1}}],[\"encrypted\",{\"1\":{\"249\":2}}],[\"en\",{\"1\":{\"249\":5,\"1059\":1}}],[\"enumeration<string>\",{\"1\":{\"670\":1,\"671\":1}}],[\"enumallowalias\",{\"1\":{\"229\":1}}],[\"enum\",{\"1\":{\"229\":4}}],[\"endswith\",{\"1\":{\"598\":6}}],[\"endtime\",{\"1\":{\"584\":2,\"600\":2,\"626\":2}}],[\"endif\",{\"1\":{\"36\":4}}],[\"end\",{\"0\":{\"1063\":1},\"1\":{\"33\":2}}],[\"endl\",{\"1\":{\"33\":17}}],[\"everysec策略\",{\"1\":{\"952\":1}}],[\"everysec\",{\"1\":{\"952\":1}}],[\"eventloop\",{\"1\":{\"897\":1}}],[\"event\",{\"1\":{\"226\":3,\"633\":10,\"634\":13,\"635\":16,\"637\":6,\"641\":10}}],[\"eventpoll\",{\"1\":{\"226\":4}}],[\"events\",{\"1\":{\"226\":8}}],[\"evaluate\",{\"1\":{\"813\":1}}],[\"ev\",{\"1\":{\"226\":4}}],[\"epochtimeencoder\",{\"1\":{\"957\":2}}],[\"epoch\",{\"1\":{\"957\":2}}],[\"epoll只能工作在\",{\"1\":{\"226\":1}}],[\"epoll缺点\",{\"1\":{\"226\":1}}],[\"epoll的效率就会远远高于select和poll\",{\"1\":{\"226\":1}}],[\"epoll的优点\",{\"1\":{\"226\":1}}],[\"epollout\",{\"1\":{\"226\":1}}],[\"epollin\",{\"1\":{\"226\":1}}],[\"epoll对象\",{\"1\":{\"226\":1}}],[\"epoll\",{\"1\":{\"226\":33}}],[\"epoll这类\",{\"1\":{\"226\":1}}],[\"epoll都是这种模型的实现\",{\"1\":{\"226\":1}}],[\"ep\",{\"1\":{\"265\":7}}],[\"epfd\",{\"1\":{\"226\":11}}],[\"eps\",{\"1\":{\"33\":1}}],[\"edp\",{\"1\":{\"223\":1}}],[\"editor\",{\"1\":{\"3\":5}}],[\"ebp\",{\"1\":{\"217\":1}}],[\"etag\",{\"1\":{\"249\":1}}],[\"etcd\",{\"1\":{\"917\":1,\"921\":1}}],[\"etc\",{\"1\":{\"190\":6,\"223\":4}}],[\"eth0\",{\"1\":{\"123\":4}}],[\"ether\",{\"1\":{\"121\":1}}],[\"ex表示增加了过期时间\",{\"1\":{\"911\":1,\"921\":1}}],[\"ex\",{\"1\":{\"873\":1,\"911\":1}}],[\"exists\",{\"1\":{\"829\":1,\"838\":2}}],[\"exit\",{\"1\":{\"141\":1}}],[\"extr\",{\"1\":{\"817\":1}}],[\"extra=using\",{\"1\":{\"813\":1}}],[\"extra\",{\"1\":{\"807\":1}}],[\"extra这三个字段的含义及如何通过它们来判断sql语句是否使用了索引\",{\"1\":{\"807\":1}}],[\"exta\",{\"1\":{\"817\":1}}],[\"extent\",{\"1\":{\"770\":4}}],[\"extends\",{\"1\":{\"545\":2,\"568\":1,\"652\":1,\"662\":1,\"689\":2,\"693\":1}}],[\"extern\",{\"1\":{\"33\":5}}],[\"exactly\",{\"1\":{\"705\":1}}],[\"examineclass\",{\"1\":{\"555\":1}}],[\"example\",{\"1\":{\"229\":2,\"542\":1,\"556\":1,\"557\":1,\"558\":1,\"584\":1,\"588\":1,\"624\":1,\"625\":1,\"626\":1,\"627\":3,\"633\":1,\"634\":1,\"635\":1,\"637\":2,\"638\":1,\"652\":1,\"658\":1}}],[\"exprire\",{\"1\":{\"882\":1}}],[\"explain是mysql中一个非常有用的命令\",{\"1\":{\"807\":1}}],[\"explain\",{\"1\":{\"807\":1,\"813\":1,\"817\":1}}],[\"expunged状态下的entry\",{\"1\":{\"531\":1}}],[\"expunged状态设计\",{\"1\":{\"526\":1}}],[\"expunged\",{\"0\":{\"525\":1},\"1\":{\"523\":1,\"525\":3,\"531\":3}}],[\"expires\",{\"0\":{\"946\":1},\"1\":{\"249\":2,\"894\":4,\"943\":1,\"944\":2,\"946\":6}}],[\"exceptionhandlingdemo\",{\"1\":{\"540\":1}}],[\"exception\",{\"1\":{\"538\":3,\"540\":1,\"545\":1,\"556\":1,\"557\":1,\"558\":1,\"640\":1}}],[\"except\",{\"1\":{\"453\":1,\"957\":1}}],[\"exchange\",{\"1\":{\"249\":2}}],[\"execute\",{\"1\":{\"817\":1}}],[\"exec\",{\"1\":{\"149\":2,\"944\":1}}],[\"ef\",{\"1\":{\"121\":1}}],[\"elastic\",{\"1\":{\"813\":1}}],[\"elapsed\",{\"1\":{\"33\":2}}],[\"ele\",{\"1\":{\"885\":1}}],[\"element\",{\"1\":{\"879\":4}}],[\"elems\",{\"1\":{\"503\":1}}],[\"elem\",{\"1\":{\"265\":1}}],[\"elemtype\",{\"1\":{\"265\":3}}],[\"election来决定是否从osr中选举出leader\",{\"1\":{\"183\":1}}],[\"else\",{\"1\":{\"46\":3,\"226\":4,\"514\":1,\"531\":2,\"546\":1,\"598\":1,\"635\":3}}],[\"esp\",{\"1\":{\"33\":1,\"217\":1}}],[\"easily\",{\"1\":{\"9\":1}}],[\"2^24\",{\"1\":{\"906\":1}}],[\"2^64\",{\"1\":{\"867\":1}}],[\"2^32\",{\"1\":{\"20\":1,\"237\":1,\"867\":1}}],[\"2～3\",{\"1\":{\"810\":1}}],[\"2gb\",{\"1\":{\"810\":1}}],[\"2>\",{\"1\":{\"810\":1}}],[\"2c对应十进制的300\",{\"1\":{\"770\":1}}],[\"2c\",{\"1\":{\"770\":3}}],[\"2a\",{\"1\":{\"770\":2}}],[\"2表示最小记录\",{\"1\":{\"770\":1}}],[\"2表示age\",{\"1\":{\"229\":1}}],[\"2pc\",{\"1\":{\"727\":1,\"810\":1}}],[\"2次其实都发到了broker\",{\"1\":{\"713\":1}}],[\"2次\",{\"1\":{\"682\":1}}],[\"29\",{\"1\":{\"370\":1,\"371\":1,\"957\":1}}],[\"28800\",{\"1\":{\"817\":1}}],[\"28880秒\",{\"1\":{\"817\":1}}],[\"28\",{\"1\":{\"370\":1,\"371\":1,\"470\":1,\"770\":3}}],[\"283\",{\"1\":{\"249\":2}}],[\"26\",{\"1\":{\"370\":1,\"371\":1,\"470\":1}}],[\"229\",{\"1\":{\"370\":1,\"371\":1}}],[\"228\",{\"1\":{\"370\":1,\"371\":1}}],[\"227\",{\"1\":{\"370\":1,\"371\":1}}],[\"226\",{\"1\":{\"370\":1,\"371\":1}}],[\"225\",{\"1\":{\"370\":1,\"371\":1}}],[\"224\",{\"1\":{\"370\":1,\"371\":1}}],[\"223\",{\"1\":{\"370\":1,\"371\":1}}],[\"222\",{\"1\":{\"370\":1,\"371\":1}}],[\"221\",{\"1\":{\"370\":1,\"371\":1}}],[\"220\",{\"1\":{\"370\":1,\"371\":1}}],[\"22\",{\"1\":{\"249\":1,\"370\":1,\"371\":1,\"432\":1,\"452\":2,\"453\":1,\"820\":1,\"957\":1,\"997\":1}}],[\"239\",{\"1\":{\"370\":1,\"371\":1}}],[\"238\",{\"1\":{\"370\":1,\"371\":1}}],[\"237\",{\"1\":{\"370\":1,\"371\":1}}],[\"236\",{\"1\":{\"370\":1,\"371\":1}}],[\"235\",{\"1\":{\"370\":1,\"371\":1}}],[\"234\",{\"1\":{\"370\":1,\"371\":1}}],[\"233\",{\"1\":{\"370\":1,\"371\":1}}],[\"232\",{\"1\":{\"370\":1,\"371\":1}}],[\"231\",{\"1\":{\"370\":1,\"371\":1}}],[\"230\",{\"1\":{\"370\":1,\"371\":1}}],[\"23\",{\"1\":{\"249\":2,\"370\":1,\"371\":1,\"998\":1,\"1001\":1,\"1004\":1}}],[\"27\",{\"1\":{\"249\":1,\"370\":1,\"371\":1}}],[\"219\",{\"1\":{\"370\":1,\"371\":1}}],[\"21844\",{\"1\":{\"770\":1}}],[\"218\",{\"1\":{\"370\":1,\"371\":1}}],[\"217\",{\"1\":{\"370\":1,\"371\":1}}],[\"216\",{\"1\":{\"370\":1,\"371\":1}}],[\"215\",{\"1\":{\"370\":1,\"371\":1}}],[\"214\",{\"1\":{\"370\":1,\"371\":1}}],[\"213\",{\"1\":{\"370\":1,\"371\":1}}],[\"212\",{\"1\":{\"370\":1,\"371\":1}}],[\"211\",{\"1\":{\"370\":1,\"371\":1}}],[\"210\",{\"1\":{\"370\":1,\"371\":1}}],[\"21\",{\"1\":{\"249\":1,\"370\":1,\"371\":1,\"957\":1,\"985\":1,\"986\":1,\"1056\":1}}],[\"2xx\",{\"1\":{\"249\":2}}],[\"2rtt\",{\"1\":{\"240\":1}}],[\"2msl时长内\",{\"1\":{\"237\":1}}],[\"2msl\",{\"1\":{\"237\":2}}],[\"2dd\",{\"1\":{\"214\":1}}],[\"2yy\",{\"1\":{\"214\":1}}],[\"25个字符\",{\"1\":{\"1056\":1}}],[\"25+08\",{\"1\":{\"957\":2}}],[\"254\",{\"1\":{\"370\":1,\"371\":1,\"879\":7}}],[\"253\",{\"1\":{\"370\":1,\"371\":1}}],[\"252\",{\"1\":{\"370\":1,\"371\":1}}],[\"251\",{\"1\":{\"370\":1,\"371\":1}}],[\"250\",{\"1\":{\"370\":1,\"371\":1}}],[\"25\",{\"1\":{\"370\":1,\"371\":1,\"813\":1,\"885\":1,\"1035\":1}}],[\"258\",{\"0\":{\"371\":1,\"374\":1},\"1\":{\"367\":1,\"371\":1,\"374\":4}}],[\"257\",{\"0\":{\"370\":1,\"374\":1},\"1\":{\"367\":1,\"371\":1,\"374\":5}}],[\"256\",{\"1\":{\"226\":6,\"370\":1,\"371\":1,\"374\":1,\"1054\":1}}],[\"25eb9d70b2b4\",{\"1\":{\"147\":1}}],[\"255\",{\"1\":{\"121\":2,\"370\":1,\"371\":1,\"770\":2,\"879\":1}}],[\"249\",{\"1\":{\"370\":1,\"371\":1}}],[\"248\",{\"1\":{\"370\":1,\"371\":1}}],[\"247\",{\"1\":{\"370\":1,\"371\":1}}],[\"246\",{\"1\":{\"370\":1,\"371\":1}}],[\"245\",{\"1\":{\"370\":1,\"371\":1}}],[\"244\",{\"1\":{\"370\":1,\"371\":1}}],[\"243\",{\"1\":{\"370\":1,\"371\":1}}],[\"242\",{\"1\":{\"370\":1,\"371\":1}}],[\"241\",{\"1\":{\"370\":1,\"371\":1}}],[\"240\",{\"1\":{\"370\":1,\"371\":1}}],[\"24\",{\"1\":{\"121\":1,\"370\":1,\"371\":1,\"903\":1}}],[\"20实践应用经验\",{\"1\":{\"708\":1}}],[\"209\",{\"1\":{\"370\":1,\"371\":1}}],[\"208\",{\"1\":{\"370\":1,\"371\":1}}],[\"207\",{\"1\":{\"370\":1,\"371\":1}}],[\"205\",{\"1\":{\"370\":1,\"371\":1}}],[\"203\",{\"1\":{\"370\":1,\"371\":1}}],[\"2023\",{\"1\":{\"957\":12}}],[\"20240603010701\",{\"1\":{\"767\":1}}],[\"20240603005031\",{\"1\":{\"765\":1}}],[\"20240603001559\",{\"1\":{\"760\":1}}],[\"20240424173111\",{\"1\":{\"478\":1}}],[\"20240424155622\",{\"1\":{\"444\":1}}],[\"20240424155614\",{\"1\":{\"443\":1}}],[\"20240127155408\",{\"1\":{\"917\":1}}],[\"20240127155359\",{\"1\":{\"916\":1}}],[\"20240127155324\",{\"1\":{\"912\":1}}],[\"20240127155314\",{\"1\":{\"911\":1}}],[\"20240127155257\",{\"1\":{\"910\":1}}],[\"20240115164427\",{\"1\":{\"414\":1}}],[\"20240115164413\",{\"1\":{\"413\":1}}],[\"20240131144909\",{\"1\":{\"383\":1}}],[\"20240131144616\",{\"1\":{\"380\":1}}],[\"202\",{\"1\":{\"370\":1,\"371\":1}}],[\"2022\",{\"1\":{\"210\":1}}],[\"2013\",{\"1\":{\"817\":1}}],[\"201\",{\"1\":{\"370\":1,\"371\":1}}],[\"2015\",{\"1\":{\"249\":1}}],[\"2016\",{\"1\":{\"249\":3}}],[\"20100101\",{\"1\":{\"249\":2}}],[\"206\",{\"1\":{\"240\":1,\"370\":1,\"371\":1}}],[\"2048\",{\"1\":{\"723\":1}}],[\"204\",{\"1\":{\"240\":1,\"370\":1,\"371\":1}}],[\"20shift+g\",{\"1\":{\"214\":1}}],[\"200是http的状态码\",{\"1\":{\"1029\":1}}],[\"2001\",{\"1\":{\"658\":1}}],[\"200类\",{\"1\":{\"240\":1}}],[\"200\",{\"1\":{\"30\":1,\"240\":1,\"249\":4,\"370\":1,\"371\":1,\"676\":1,\"794\":1,\"1021\":1,\"1024\":1,\"1029\":1,\"1031\":1,\"1039\":1,\"1040\":1,\"1041\":1}}],[\"20\",{\"1\":{\"30\":1,\"33\":2,\"210\":1,\"226\":1,\"249\":1,\"370\":1,\"371\":1,\"410\":1,\"460\":1,\"470\":1,\"770\":51,\"807\":1,\"817\":3,\"873\":1,\"927\":1,\"957\":1}}],[\"2\",{\"0\":{\"6\":1,\"8\":1,\"9\":2,\"10\":1,\"11\":1,\"42\":1,\"43\":1,\"44\":2,\"52\":1,\"53\":1,\"54\":1,\"55\":2,\"61\":1,\"63\":1,\"64\":1,\"65\":2,\"71\":1,\"72\":1,\"75\":2,\"76\":1,\"77\":1,\"78\":1,\"81\":1,\"87\":1,\"88\":1,\"98\":1,\"101\":1,\"102\":2,\"103\":1,\"104\":1,\"112\":1,\"118\":1,\"133\":1,\"134\":1,\"135\":2,\"136\":1,\"137\":1,\"140\":1,\"146\":1,\"162\":1,\"171\":1,\"172\":1,\"173\":2,\"174\":1,\"175\":1,\"181\":1,\"196\":1,\"200\":1,\"201\":1,\"202\":2,\"205\":1,\"208\":1,\"255\":1,\"256\":1,\"257\":2,\"261\":1,\"264\":1,\"271\":1,\"272\":1,\"273\":2,\"274\":1,\"277\":1,\"280\":1,\"288\":1,\"291\":1,\"299\":1,\"300\":1,\"301\":2,\"302\":1,\"303\":1,\"306\":1,\"311\":1,\"314\":1,\"321\":1,\"324\":1,\"325\":1,\"326\":2,\"327\":1,\"328\":1,\"331\":1,\"338\":1,\"341\":1,\"345\":1,\"352\":1,\"353\":1,\"354\":1,\"357\":1,\"379\":1,\"380\":1,\"381\":2,\"384\":1,\"390\":1,\"391\":1,\"392\":2,\"395\":1,\"399\":1,\"406\":1,\"407\":1,\"411\":1,\"421\":1,\"422\":1,\"423\":2,\"426\":1,\"434\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"442\":1,\"444\":1,\"448\":1,\"450\":1,\"452\":1,\"455\":1,\"460\":1,\"463\":1,\"466\":1,\"474\":1,\"475\":1,\"479\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":2,\"503\":1,\"511\":1,\"515\":1,\"519\":1,\"523\":1,\"530\":1,\"538\":1,\"539\":1,\"540\":1,\"541\":2,\"542\":1,\"543\":1,\"546\":1,\"552\":1,\"553\":1,\"556\":1,\"565\":1,\"568\":1,\"569\":2,\"570\":1,\"571\":1,\"579\":1,\"580\":1,\"581\":1,\"582\":2,\"583\":2,\"584\":3,\"585\":2,\"586\":2,\"587\":3,\"588\":2,\"591\":1,\"595\":1,\"599\":1,\"604\":1,\"608\":1,\"615\":1,\"616\":1,\"617\":1,\"618\":2,\"619\":2,\"620\":3,\"621\":2,\"622\":1,\"623\":1,\"624\":2,\"625\":1,\"626\":1,\"627\":1,\"630\":1,\"634\":1,\"638\":1,\"641\":1,\"647\":1,\"648\":1,\"649\":1,\"650\":2,\"651\":2,\"652\":3,\"653\":2,\"654\":2,\"655\":3,\"656\":2,\"657\":2,\"658\":2,\"659\":1,\"662\":1,\"665\":1,\"671\":1,\"674\":1,\"675\":1,\"676\":2,\"677\":1,\"678\":1,\"682\":1,\"683\":1,\"688\":1,\"689\":1,\"692\":1,\"706\":1,\"709\":1,\"714\":1,\"720\":1,\"723\":1,\"735\":1,\"738\":1,\"739\":1,\"740\":2,\"741\":1,\"742\":1,\"743\":1,\"744\":1,\"745\":1,\"748\":1,\"752\":1,\"760\":1,\"764\":1,\"776\":1,\"777\":1,\"778\":2,\"779\":1,\"780\":1,\"783\":1,\"788\":1,\"792\":1,\"793\":1,\"794\":2,\"801\":1,\"836\":1,\"837\":1,\"838\":1,\"839\":2,\"840\":1,\"841\":1,\"842\":1,\"843\":1,\"844\":1,\"847\":1,\"851\":1,\"855\":1,\"912\":1,\"938\":1,\"941\":1,\"942\":2,\"944\":1,\"946\":1,\"957\":1,\"963\":1,\"964\":1,\"965\":2,\"966\":1,\"969\":1,\"975\":1,\"976\":1,\"977\":2,\"978\":2,\"979\":3,\"980\":2,\"983\":1,\"986\":1,\"989\":1,\"995\":1,\"998\":1,\"1003\":1,\"1006\":1,\"1015\":1,\"1021\":1,\"1022\":1,\"1023\":1,\"1024\":2,\"1025\":1,\"1030\":1,\"1036\":1,\"1040\":1,\"1049\":1,\"1050\":1,\"1051\":1,\"1052\":2,\"1053\":1,\"1054\":1,\"1059\":1},\"1\":{\"20\":4,\"23\":10,\"30\":1,\"33\":6,\"36\":1,\"46\":1,\"177\":2,\"217\":31,\"226\":5,\"229\":6,\"237\":1,\"240\":6,\"243\":1,\"249\":68,\"344\":4,\"369\":1,\"370\":1,\"371\":1,\"374\":4,\"423\":1,\"442\":3,\"448\":1,\"451\":1,\"452\":2,\"453\":12,\"458\":2,\"460\":1,\"476\":2,\"477\":1,\"479\":1,\"497\":1,\"502\":1,\"693\":1,\"723\":1,\"743\":1,\"756\":1,\"757\":1,\"764\":1,\"770\":8,\"807\":2,\"810\":15,\"813\":7,\"820\":10,\"864\":7,\"867\":3,\"870\":2,\"873\":4,\"876\":1,\"879\":2,\"885\":1,\"891\":1,\"913\":2,\"921\":4,\"924\":1,\"927\":1,\"930\":1,\"938\":1,\"942\":1,\"952\":1,\"983\":1,\"989\":1,\"991\":1,\"1008\":3,\"1024\":1,\"1037\":1}}],[\"蛮多人用\",{\"1\":{\"5\":1}}],[\"也很少使用后端返回模板\",{\"1\":{\"1031\":1}}],[\"也很容易带来错误\",{\"1\":{\"850\":1}}],[\"也最简单的方式\",{\"1\":{\"927\":1}}],[\"也许会说\",{\"1\":{\"918\":1,\"921\":1}}],[\"也许需要适时清理一下\",{\"1\":{\"223\":1}}],[\"也许需要你手动删除一下\",{\"1\":{\"223\":1}}],[\"也插入\",{\"1\":{\"820\":1}}],[\"也属于间隙锁\",{\"1\":{\"820\":2}}],[\"也包含间隙锁\",{\"1\":{\"820\":1}}],[\"也包含其他非索引列\",{\"1\":{\"813\":1}}],[\"也执行了同样的\",{\"1\":{\"820\":1}}],[\"也叫组合索引\",{\"1\":{\"813\":1}}],[\"也要把数据占用的大小存起\",{\"1\":{\"770\":1}}],[\"也要保证一次性写入\",{\"1\":{\"760\":1,\"810\":1}}],[\"也没有丢失数据的风险\",{\"1\":{\"810\":1}}],[\"也没有关系\",{\"1\":{\"765\":1,\"810\":1}}],[\"也没有状态码或错误代码\",{\"1\":{\"249\":1}}],[\"也有外部\",{\"1\":{\"765\":1,\"810\":1}}],[\"也有自己的缓存\",{\"1\":{\"755\":1,\"810\":1}}],[\"也有可能对应多个整数\",{\"1\":{\"352\":1}}],[\"也意味着\",{\"1\":{\"743\":1,\"810\":1}}],[\"也会更新缓存\",{\"1\":{\"930\":1}}],[\"也会进行\",{\"1\":{\"864\":1}}],[\"也会安装为一个服务\",{\"1\":{\"836\":1}}],[\"也会释放所有表锁\",{\"1\":{\"820\":1}}],[\"也会限制本线程接下来的读写操作\",{\"1\":{\"820\":1}}],[\"也会被\",{\"1\":{\"810\":1}}],[\"也会自动隐式开启事务\",{\"1\":{\"739\":1}}],[\"也会跟着一起变化\",{\"1\":{\"476\":1}}],[\"也会相当于快照一样保存那个地址\",{\"1\":{\"476\":1}}],[\"也会分配到堆上\",{\"1\":{\"408\":1}}],[\"也会算到这\",{\"1\":{\"374\":1}}],[\"也造成了很差的局部性\",{\"1\":{\"381\":1}}],[\"也放到全局队列\",{\"1\":{\"374\":1}}],[\"也不用用\",{\"1\":{\"927\":1}}],[\"也不算限制\",{\"1\":{\"879\":1}}],[\"也不能用\",{\"1\":{\"879\":1}}],[\"也不能修改\",{\"1\":{\"820\":1}}],[\"也不可以对该记录加\",{\"1\":{\"820\":1}}],[\"也不可无障碍的手动创建\",{\"1\":{\"249\":1}}],[\"也不是直接写入磁盘的\",{\"1\":{\"755\":1,\"810\":1}}],[\"也不需要使用\",{\"1\":{\"637\":1}}],[\"也不存在于\",{\"1\":{\"531\":1}}],[\"也不会影响备份数据库时的\",{\"1\":{\"820\":1}}],[\"也不会影响已经存在连接的权限\",{\"1\":{\"817\":1}}],[\"也不会影响读请求的执行\",{\"1\":{\"810\":1}}],[\"也不会丢失数据\",{\"1\":{\"810\":1}}],[\"也不会被重复发送\",{\"1\":{\"705\":1}}],[\"也不会被数据库运行\",{\"1\":{\"243\":1}}],[\"也不会再继续执行\",{\"1\":{\"479\":1}}],[\"也不一定要一致\",{\"1\":{\"434\":1}}],[\"也称为主键索引\",{\"1\":{\"807\":1}}],[\"也称\",{\"1\":{\"249\":1}}],[\"也需要开启tcp\",{\"1\":{\"237\":1}}],[\"也跟\",{\"1\":{\"226\":1}}],[\"也常称为事件驱动i\",{\"1\":{\"226\":1}}],[\"也是缓存中有\",{\"1\":{\"930\":1}}],[\"也是免不了一场麻烦的\",{\"1\":{\"927\":1}}],[\"也是\",{\"1\":{\"885\":1}}],[\"也是可以对记录加共享锁和独占锁的\",{\"1\":{\"820\":1}}],[\"也是可能被持久化到磁盘的\",{\"1\":{\"810\":1}}],[\"也是直接写在\",{\"1\":{\"810\":1}}],[\"也是聚簇的意思\",{\"1\":{\"807\":1}}],[\"也是成功\",{\"1\":{\"240\":1}}],[\"也是存放可执行文件的\",{\"1\":{\"223\":1}}],[\"也是存放可执行文件\",{\"1\":{\"223\":1}}],[\"也是不错的\",{\"1\":{\"5\":1}}],[\"也可用手动提交\",{\"1\":{\"711\":1}}],[\"也可能导致消息重复消费\",{\"1\":{\"706\":1}}],[\"也可能出现\",{\"1\":{\"223\":1}}],[\"也可以将这些配置项写入到\",{\"1\":{\"957\":1}}],[\"也可以主动配置\",{\"1\":{\"900\":1}}],[\"也可以分秒和毫秒\",{\"1\":{\"882\":1}}],[\"也可以为一个用户赋予多个不同的角色\",{\"1\":{\"850\":1}}],[\"也可以是某个数据库中的所有对象\",{\"1\":{\"846\":1}}],[\"也可以是一个名字\",{\"1\":{\"249\":1}}],[\"也可以回滚事务\",{\"1\":{\"810\":1}}],[\"也可以存放在独占表空间文件\",{\"1\":{\"770\":1}}],[\"也可以在请求头里明确地要求使用长连接机制\",{\"1\":{\"249\":1}}],[\"也可以使用loadhtmlfiles加载单个html文件\",{\"1\":{\"1031\":1}}],[\"也可以使用以下命令\",{\"1\":{\"835\":2}}],[\"也可以使用普通索引\",{\"1\":{\"817\":1}}],[\"也可以使用\",{\"1\":{\"249\":1}}],[\"也可以不使用\",{\"1\":{\"249\":1}}],[\"也可以写成\",{\"1\":{\"249\":1}}],[\"也可以任意添加自定义头\",{\"1\":{\"249\":1}}],[\"也可以得出\",{\"1\":{\"237\":1}}],[\"也可以自定义其他的\",{\"1\":{\"226\":1}}],[\"也可以反复尝试该i\",{\"1\":{\"226\":1}}],[\"也可以让消费者从follower上读数据\",{\"1\":{\"176\":1}}],[\"也可以理解为就是运行kafka程序的服务器\",{\"1\":{\"157\":1}}],[\"也可以查看到绑定的地址\",{\"1\":{\"118\":1}}],[\"也可以直接改\",{\"1\":{\"3\":1}}],[\"也能产生逃逸\",{\"1\":{\"414\":1}}],[\"也能访问内核空间内存\",{\"1\":{\"220\":1}}],[\"也能发送信号干预系统运行的所有用户进程\",{\"1\":{\"190\":1}}],[\"也就避免了幻读的问题\",{\"1\":{\"820\":2}}],[\"也就意味着成本会更高\",{\"1\":{\"807\":1}}],[\"也就说都有自己的页表\",{\"1\":{\"217\":1}}],[\"也就是beforesleep中\",{\"1\":{\"952\":1}}],[\"也就是尽可能丢失更少的数据\",{\"1\":{\"949\":1}}],[\"也就是不能让删除成为一个关键路径\",{\"1\":{\"930\":1}}],[\"也就是不做任何强制性的磁盘刷新指令\",{\"1\":{\"810\":1}}],[\"也就是前面所说的锁剩余持有时间\",{\"1\":{\"918\":1,\"921\":1}}],[\"也就是前面提到的分段机制\",{\"1\":{\"217\":1}}],[\"也就是3个redis返回成功\",{\"1\":{\"917\":1,\"921\":1}}],[\"也就是哨兵模式\",{\"1\":{\"916\":1,\"921\":1}}],[\"也就是设置了过期时间的\",{\"1\":{\"900\":1}}],[\"也就是默认值为\",{\"1\":{\"900\":1}}],[\"也就是zrevrange命令\",{\"1\":{\"885\":1}}],[\"也就是发生了死锁\",{\"1\":{\"820\":1}}],[\"也就是发送完最后一个ack报文后\",{\"1\":{\"237\":1}}],[\"也就是非唯一索引\",{\"1\":{\"820\":1}}],[\"也就是仅仅把一条记录锁上\",{\"1\":{\"820\":1}}],[\"也就是写锁\",{\"1\":{\"820\":1}}],[\"也就是读锁\",{\"1\":{\"820\":1}}],[\"也就是定位到\",{\"1\":{\"817\":2}}],[\"也就是全表扫描的方式查询\",{\"1\":{\"817\":1}}],[\"也就是结束查询了\",{\"1\":{\"817\":1}}],[\"也就是使用主键索引查询一条记录\",{\"1\":{\"817\":1}}],[\"也就是执行阶段\",{\"1\":{\"817\":1}}],[\"也就是优化阶段\",{\"1\":{\"817\":1}}],[\"也就是预处理阶段\",{\"1\":{\"817\":1}}],[\"也就是无法基于哈希索引的字段做排序\",{\"1\":{\"813\":1}}],[\"也就是按照最左优先的方式进行索引的匹配\",{\"1\":{\"813\":1}}],[\"也就是将\",{\"1\":{\"810\":1}}],[\"也就是各自将\",{\"1\":{\"810\":1}}],[\"也就是主库上执行事务操作的线程不会等待复制\",{\"1\":{\"810\":1}}],[\"也就是记录\",{\"1\":{\"810\":1}}],[\"也就是保存了所有数据变更的情况\",{\"1\":{\"810\":1}}],[\"也就是要生成一条\",{\"1\":{\"810\":4}}],[\"也就是最多能保证\",{\"1\":{\"770\":1}}],[\"也就是一次\",{\"1\":{\"770\":1}}],[\"也就是生成一条\",{\"1\":{\"753\":1}}],[\"也就是kafka\",{\"1\":{\"710\":1}}],[\"也就是进去消息队列之后的数据\",{\"1\":{\"710\":1}}],[\"也就是至少能消费一次\",{\"1\":{\"706\":1}}],[\"也就是会导致两个\",{\"1\":{\"525\":1}}],[\"也就是完整调度了\",{\"1\":{\"374\":1}}],[\"也就是只需要查一个\",{\"1\":{\"813\":1}}],[\"也就是只需要一个进程就能并发处理多个客户端的\",{\"1\":{\"226\":1}}],[\"也就是只有一个\",{\"1\":{\"373\":1}}],[\"也就是\",{\"1\":{\"240\":1,\"243\":1,\"249\":2,\"453\":1,\"770\":2,\"817\":2,\"820\":3,\"864\":1,\"879\":1}}],[\"也就是网络正忙\",{\"1\":{\"240\":1}}],[\"也就是proto3\",{\"1\":{\"229\":1}}],[\"也就是针对每一个连接的i\",{\"1\":{\"226\":1}}],[\"也就是从文件映射区\",{\"1\":{\"217\":1}}],[\"也就是对分段划分出来的连续空间\",{\"1\":{\"217\":1}}],[\"也就是带来了时间上的开销\",{\"1\":{\"217\":1}}],[\"也就是跟不上节奏的副本\",{\"1\":{\"181\":1}}],[\"也就是整体的集合\",{\"1\":{\"181\":1}}],[\"也就是每个周期会提交最新的已处理消息\",{\"1\":{\"163\":1}}],[\"也就是说子线程会一直处于运行状态\",{\"1\":{\"897\":1}}],[\"也就是说如果本线程对学生表加了\",{\"1\":{\"820\":1}}],[\"也就是说在数据表中创建的主键索引和二级索引默认使用的是\",{\"1\":{\"817\":1}}],[\"也就是说一行数据的最大字节数\",{\"1\":{\"770\":1}}],[\"也就是说客户之间不需要依赖\",{\"1\":{\"723\":1}}],[\"也就是说随着系统使用时间的增长\",{\"1\":{\"223\":1}}],[\"也就是说\",{\"1\":{\"98\":1,\"723\":1,\"770\":1,\"810\":3,\"813\":2,\"817\":1,\"912\":1,\"921\":1,\"952\":1}}],[\"也就是取模结果对应的是本机编号\",{\"1\":{\"79\":1}}],[\"tx\",{\"1\":{\"1014\":3,\"1015\":11}}],[\"txt\",{\"1\":{\"113\":2,\"211\":1,\"425\":1,\"542\":1,\"1033\":1}}],[\"t指定生成目录\",{\"1\":{\"969\":1}}],[\"ts\",{\"1\":{\"957\":13}}],[\"tb\",{\"1\":{\"826\":5}}],[\"t3\",{\"1\":{\"794\":1}}],[\"t2\",{\"1\":{\"794\":1,\"820\":4}}],[\"t1\",{\"1\":{\"794\":1}}],[\"tcc\",{\"1\":{\"727\":1}}],[\"tcp建立连接的三次握手\",{\"1\":{\"243\":1}}],[\"tcp和udp都有端口字段\",{\"1\":{\"237\":1}}],[\"tcp保活负责确保底层连接的持续有效性\",{\"1\":{\"237\":1}}],[\"tcp长连接保活\",{\"1\":{\"237\":1}}],[\"tcp长连接\",{\"1\":{\"237\":1}}],[\"tcp四元组确定一条连接\",{\"1\":{\"237\":1}}],[\"tcp挥手过程\",{\"1\":{\"226\":1}}],[\"tcp握手过程\",{\"1\":{\"226\":1}}],[\"tcp\",{\"1\":{\"226\":1,\"237\":11,\"249\":25,\"817\":7,\"976\":2},\"2\":{\"228\":1,\"239\":1,\"251\":1}}],[\"tcp类型\",{\"1\":{\"226\":1}}],[\"t是什么类型\",{\"1\":{\"469\":1}}],[\"tue\",{\"1\":{\"249\":3}}],[\"tutorial\",{\"1\":{\"243\":2}}],[\"tulnp\",{\"1\":{\"198\":1}}],[\"tls\",{\"1\":{\"249\":10}}],[\"tls握手\",{\"1\":{\"240\":1}}],[\"tlb\",{\"1\":{\"217\":2}}],[\"tw\",{\"1\":{\"237\":3}}],[\"ttl\",{\"1\":{\"237\":1,\"900\":1,\"944\":2}}],[\"tty\",{\"1\":{\"147\":1}}],[\"tip\",{\"1\":{\"817\":1,\"820\":1}}],[\"title>\",{\"1\":{\"652\":1}}],[\"title\",{\"1\":{\"229\":2,\"462\":2}}],[\"timekey\",{\"1\":{\"957\":4}}],[\"timerctx在cancelctx的基础上增加了超时功能\",{\"1\":{\"281\":1}}],[\"timerctx\",{\"0\":{\"281\":1}}],[\"timeout=\",{\"1\":{\"976\":1}}],[\"timeout=5\",{\"1\":{\"237\":1,\"249\":1}}],[\"timeout>\",{\"1\":{\"691\":1}}],[\"timeout>30<\",{\"1\":{\"691\":1}}],[\"timeout\",{\"1\":{\"226\":5,\"817\":3,\"820\":1,\"976\":2}}],[\"timeval\",{\"1\":{\"226\":1}}],[\"timestamps参数\",{\"1\":{\"237\":1}}],[\"timestamps\",{\"1\":{\"237\":1}}],[\"timestamp\",{\"1\":{\"92\":1,\"894\":1,\"946\":1}}],[\"time\",{\"1\":{\"33\":3,\"147\":1,\"237\":13,\"515\":3,\"903\":1,\"940\":2,\"957\":11,\"980\":1}}],[\"tee\",{\"1\":{\"957\":5}}],[\"teeoption\",{\"1\":{\"957\":2}}],[\"tees\",{\"1\":{\"957\":2}}],[\"text索引\",{\"1\":{\"813\":1}}],[\"text\",{\"1\":{\"249\":4,\"497\":4,\"500\":2,\"502\":3,\"599\":1,\"652\":1,\"675\":1,\"688\":1,\"770\":4,\"957\":1,\"1056\":1}}],[\"testpanic3\",{\"1\":{\"479\":4}}],[\"testpanic3panic\",{\"1\":{\"479\":1}}],[\"testpanic2\",{\"1\":{\"479\":6}}],[\"testpanic1\",{\"1\":{\"479\":2}}],[\"test\",{\"1\":{\"229\":1,\"391\":1,\"425\":1,\"770\":14,\"794\":2,\"813\":1,\"820\":2,\"957\":5}}],[\"templates\",{\"1\":{\"1031\":3}}],[\"temptable\",{\"1\":{\"813\":4}}],[\"temp变量\",{\"1\":{\"453\":1}}],[\"temporary通常表示查询效率不高\",{\"1\":{\"807\":1}}],[\"temporary\",{\"1\":{\"223\":1,\"807\":1}}],[\"temp\",{\"1\":{\"30\":4,\"226\":6,\"452\":2,\"453\":1}}],[\"tf\",{\"1\":{\"146\":2}}],[\"take的第二个参数\",{\"1\":{\"989\":1}}],[\"take\",{\"1\":{\"988\":1,\"989\":2,\"990\":2,\"991\":1,\"992\":1,\"997\":1,\"998\":1,\"999\":1,\"1014\":2,\"1015\":2}}],[\"tableprefix\",{\"1\":{\"979\":1}}],[\"tables\",{\"1\":{\"820\":7}}],[\"table\",{\"1\":{\"770\":6,\"820\":3,\"826\":6,\"846\":2,\"864\":2,\"944\":1,\"979\":1,\"983\":1,\"1009\":1,\"1010\":1,\"1013\":1}}],[\"table控制的\",{\"1\":{\"770\":1}}],[\"target\",{\"1\":{\"559\":5,\"681\":1,\"682\":1}}],[\"target=\",{\"1\":{\"110\":1,\"113\":1}}],[\"taylor\",{\"1\":{\"229\":1}}],[\"tail\",{\"1\":{\"146\":2}}],[\"tag值\",{\"1\":{\"488\":1}}],[\"tag指定json序列化与反序列化时的行为\",{\"1\":{\"486\":1}}],[\"tag指定序列化与反序列化时的行为\",{\"1\":{\"485\":1}}],[\"tag指定字段名\",{\"0\":{\"485\":1}}],[\"tag在结构体字段的后方定义\",{\"1\":{\"484\":1}}],[\"tag是结构体的元信息\",{\"1\":{\"484\":1}}],[\"tag\",{\"1\":{\"134\":1,\"136\":1,\"487\":1,\"491\":2}}],[\"type自动选择合适的绑定器\",{\"1\":{\"1038\":1,\"1041\":1}}],[\"type为application\",{\"1\":{\"1032\":1}}],[\"type+data\",{\"1\":{\"879\":1}}],[\"type=index\",{\"1\":{\"813\":1}}],[\"type=bind\",{\"1\":{\"113\":1}}],[\"type的值从最好到最差依次是\",{\"1\":{\"807\":1}}],[\"types中的描述\",{\"1\":{\"770\":1}}],[\"type字段解析\",{\"0\":{\"302\":1}}],[\"typedmemmove\",{\"1\":{\"265\":1}}],[\"typedmemclr\",{\"1\":{\"265\":2}}],[\"typedef是语句\",{\"1\":{\"33\":1}}],[\"typedef是编译的一部分\",{\"1\":{\"33\":1}}],[\"typedef\",{\"1\":{\"33\":4}}],[\"type标头\",{\"1\":{\"249\":1}}],[\"type\",{\"1\":{\"33\":2,\"229\":2,\"249\":4,\"302\":3,\"307\":6,\"394\":1,\"410\":1,\"435\":1,\"437\":1,\"440\":2,\"441\":1,\"447\":1,\"460\":1,\"462\":3,\"463\":2,\"464\":2,\"465\":4,\"466\":3,\"468\":2,\"470\":3,\"471\":4,\"472\":1,\"483\":1,\"485\":1,\"486\":1,\"487\":1,\"488\":1,\"489\":5,\"490\":2,\"491\":1,\"516\":3,\"522\":1,\"601\":1,\"770\":1,\"807\":1,\"817\":1,\"820\":3,\"846\":3,\"847\":1,\"873\":1,\"879\":1,\"938\":2,\"940\":2,\"942\":1,\"957\":1,\"979\":1,\"982\":1,\"983\":5,\"1010\":1,\"1013\":1,\"1021\":1,\"1030\":1,\"1032\":2,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1,\"1043\":1}}],[\"tmp\",{\"1\":{\"33\":1,\"223\":6}}],[\"tot\",{\"1\":{\"879\":7}}],[\"total\",{\"1\":{\"458\":3,\"638\":1}}],[\"tomcat\",{\"1\":{\"687\":1}}],[\"toml\",{\"1\":{\"104\":1}}],[\"toupper\",{\"1\":{\"499\":2}}],[\"touch\",{\"1\":{\"113\":2,\"209\":1}}],[\"tolower\",{\"1\":{\"499\":2}}],[\"too\",{\"1\":{\"817\":1}}],[\"tool\",{\"1\":{\"391\":3,\"423\":1}}],[\"took\",{\"1\":{\"33\":1}}],[\"to\",{\"1\":{\"226\":1,\"817\":1,\"840\":2,\"846\":1,\"854\":2,\"940\":1,\"952\":1,\"957\":10}}],[\"tophash就存放高8位\",{\"1\":{\"330\":1}}],[\"tophash机制\",{\"0\":{\"330\":1}}],[\"topica\",{\"1\":{\"177\":3}}],[\"topics\",{\"1\":{\"177\":2}}],[\"topic\",{\"1\":{\"157\":1,\"172\":1,\"177\":1}}],[\"top\",{\"1\":{\"147\":2,\"195\":1}}],[\"token主要由3部分组成\",{\"1\":{\"249\":1}}],[\"token是令牌的意思\",{\"1\":{\"249\":1}}],[\"token防重令牌的方式跟分布式锁的方式很像\",{\"1\":{\"23\":1}}],[\"token的方式虽然绕开了db层面来进行幂等性的校验\",{\"1\":{\"23\":1}}],[\"token\",{\"1\":{\"23\":2,\"249\":3}}],[\"todo\",{\"1\":{\"10\":1}}],[\"t\",{\"1\":{\"23\":1,\"196\":1,\"199\":1,\"469\":2,\"735\":1,\"763\":2,\"770\":11,\"794\":2,\"810\":4,\"813\":10,\"817\":1,\"820\":18,\"957\":1,\"969\":1}}],[\"third\",{\"1\":{\"962\":1}}],[\"this\",{\"1\":{\"559\":1,\"568\":1,\"637\":2,\"699\":1,\"952\":1}}],[\"through时要特别注意的是缓存的有效性管理\",{\"1\":{\"930\":1}}],[\"through的潜在使用场景是银行系统\",{\"1\":{\"930\":1}}],[\"through\",{\"1\":{\"930\":10}}],[\"throwdemo\",{\"1\":{\"543\":1}}],[\"throw关键字\",{\"0\":{\"543\":1}}],[\"throws\",{\"1\":{\"542\":1,\"546\":1,\"559\":1,\"568\":1,\"584\":2,\"590\":1,\"591\":1,\"596\":2,\"598\":1,\"599\":2,\"600\":1,\"601\":1,\"652\":1,\"662\":2,\"683\":2,\"693\":1}}],[\"throwsdemo\",{\"1\":{\"542\":1}}],[\"throws声明\",{\"0\":{\"542\":1}}],[\"throwable\",{\"1\":{\"538\":1,\"545\":2,\"559\":1}}],[\"throw\",{\"1\":{\"265\":1,\"543\":2,\"546\":3,\"568\":1}}],[\"thread1更新缓存为5\",{\"1\":{\"930\":1}}],[\"thread1更新mysql为5\",{\"1\":{\"930\":1}}],[\"thread2更新缓存为3\",{\"1\":{\"930\":1}}],[\"thread2更新mysql为3\",{\"1\":{\"930\":1}}],[\"threads\",{\"1\":{\"897\":1}}],[\"thread来配置\",{\"1\":{\"897\":1}}],[\"thereafter\",{\"1\":{\"957\":1}}],[\"the\",{\"1\":{\"374\":1,\"425\":1,\"957\":1}}],[\"theme\",{\"1\":{\"5\":1}}],[\"thu\",{\"1\":{\"249\":1}}],[\"thunder\",{\"1\":{\"10\":1}}],[\"trx\",{\"1\":{\"742\":2,\"743\":1,\"744\":13,\"756\":5,\"765\":1,\"770\":3,\"787\":3,\"788\":2,\"789\":10,\"793\":1,\"810\":14,\"820\":1}}],[\"trimsuffix\",{\"1\":{\"500\":1}}],[\"trimspace\",{\"1\":{\"500\":2}}],[\"trimprefix\",{\"1\":{\"500\":1}}],[\"trim\",{\"1\":{\"500\":2,\"693\":1}}],[\"tryswap\",{\"1\":{\"531\":2}}],[\"try\",{\"0\":{\"540\":1,\"541\":1},\"1\":{\"374\":1,\"540\":1,\"541\":1,\"542\":1,\"543\":1,\"553\":1,\"556\":1,\"557\":1,\"558\":1,\"568\":1,\"600\":1,\"640\":1}}],[\"transaction\",{\"1\":{\"760\":1,\"785\":4,\"810\":2,\"820\":2,\"1014\":1}}],[\"transfer\",{\"1\":{\"249\":1}}],[\"translation\",{\"1\":{\"217\":2,\"246\":1}}],[\"traceevgoblockrecv\",{\"1\":{\"265\":1}}],[\"trace\",{\"1\":{\"249\":1}}],[\"training\",{\"1\":{\"110\":1,\"113\":1}}],[\"tree\",{\"1\":{\"10\":1,\"734\":1}}],[\"true\",{\"1\":{\"3\":3,\"183\":1,\"226\":1,\"229\":1,\"265\":5,\"469\":1,\"496\":1,\"497\":2,\"514\":1,\"515\":1,\"516\":2,\"531\":9,\"557\":1,\"692\":1,\"957\":3,\"978\":2,\"980\":2,\"983\":2,\"985\":1,\"986\":1,\"1059\":1}}],[\"mget\",{\"1\":{\"873\":1}}],[\"mq\",{\"1\":{\"807\":2}}],[\"mha\",{\"1\":{\"730\":2}}],[\"multi\",{\"1\":{\"743\":1}}],[\"multipartconfig\",{\"1\":{\"693\":1}}],[\"mutex\",{\"1\":{\"516\":1,\"527\":1,\"810\":1,\"897\":2}}],[\"mu\",{\"1\":{\"516\":1,\"529\":2,\"531\":2,\"532\":2}}],[\"must\",{\"1\":{\"374\":1}}],[\"m^d\",{\"1\":{\"249\":1}}],[\"m^e\",{\"1\":{\"249\":4}}],[\"m就是我们发送的原文\",{\"1\":{\"249\":1}}],[\"m的e次方\",{\"1\":{\"249\":1}}],[\"m为原文\",{\"1\":{\"249\":1}}],[\"mdl\",{\"1\":{\"820\":23}}],[\"md\",{\"1\":{\"243\":1,\"962\":6}}],[\"md5或sha\",{\"1\":{\"1054\":1}}],[\"md5\",{\"1\":{\"73\":1,\"75\":1,\"723\":1,\"1054\":1}}],[\"m$\",{\"1\":{\"229\":1}}],[\"mnt\",{\"1\":{\"223\":2}}],[\"mmap\",{\"1\":{\"217\":5}}],[\"mmu\",{\"1\":{\"217\":1}}],[\"m\",{\"1\":{\"210\":1,\"249\":3,\"374\":1,\"381\":9,\"398\":3,\"399\":1,\"409\":1,\"460\":2,\"466\":2,\"471\":2,\"510\":3,\"511\":5,\"514\":6,\"515\":5,\"516\":1,\"529\":9,\"530\":9,\"531\":16,\"532\":11,\"744\":4,\"787\":1,\"789\":3,\"957\":1}}],[\"mvcc多版本并发控制\",{\"1\":{\"801\":1}}],[\"mvcc\",{\"0\":{\"736\":1,\"743\":1,\"786\":1},\"1\":{\"743\":3,\"770\":1,\"775\":1,\"783\":1,\"786\":1,\"793\":1,\"810\":6,\"820\":4}}],[\"mvc框架\",{\"1\":{\"698\":1}}],[\"mvc\",{\"1\":{\"644\":1}}],[\"mv\",{\"1\":{\"202\":1,\"209\":2}}],[\"mkdir\",{\"1\":{\"201\":1}}],[\"mtu\",{\"1\":{\"121\":1}}],[\"money\",{\"1\":{\"1013\":2,\"1014\":6,\"1015\":6}}],[\"most\",{\"1\":{\"705\":1,\"940\":1}}],[\"mosaic\",{\"1\":{\"249\":2}}],[\"moore算法的变体\",{\"1\":{\"497\":1}}],[\"mozilla\",{\"1\":{\"249\":6}}],[\"modifier\",{\"1\":{\"558\":2}}],[\"modifiers\",{\"1\":{\"558\":3}}],[\"modified\",{\"1\":{\"249\":2}}],[\"module=$prefix\",{\"1\":{\"229\":1}}],[\"mod\",{\"1\":{\"226\":2,\"249\":8,\"723\":2,\"962\":1}}],[\"model\",{\"1\":{\"980\":1,\"998\":1,\"1012\":2,\"1014\":2,\"1015\":2}}],[\"mode\",{\"1\":{\"119\":1,\"220\":1,\"820\":21}}],[\"more和less\",{\"1\":{\"209\":1}}],[\"move\",{\"1\":{\"202\":1}}],[\"mount\",{\"1\":{\"110\":2,\"113\":3,\"115\":1}}],[\"mounts\",{\"1\":{\"105\":1}}],[\"mousewheelzoom\",{\"1\":{\"3\":1}}],[\"moby\",{\"1\":{\"104\":2}}],[\"microservices\",{\"0\":{\"1084\":1}}],[\"microsoft\",{\"1\":{\"813\":2}}],[\"mixedlevel多种形式\",{\"1\":{\"930\":1}}],[\"mixed\",{\"1\":{\"810\":2}}],[\"missssss\",{\"0\":{\"530\":1}}],[\"misslocked\",{\"0\":{\"530\":1},\"1\":{\"529\":1,\"530\":2}}],[\"miss\",{\"1\":{\"529\":1,\"530\":1}}],[\"misses++\",{\"1\":{\"530\":1}}],[\"misses\",{\"1\":{\"516\":3,\"530\":5,\"532\":1}}],[\"minmax\",{\"1\":{\"426\":1}}],[\"min\",{\"1\":{\"374\":2,\"426\":4,\"744\":3,\"787\":1,\"789\":2,\"807\":1,\"873\":1}}],[\"mid+1\",{\"1\":{\"46\":1}}],[\"mid\",{\"1\":{\"46\":8}}],[\"milli>\",{\"1\":{\"33\":1}}],[\"metamq\",{\"1\":{\"924\":1}}],[\"methods\",{\"1\":{\"558\":1,\"601\":1}}],[\"method\",{\"1\":{\"558\":4,\"559\":8,\"584\":2,\"600\":3,\"626\":2,\"952\":1}}],[\"methodreflection\",{\"1\":{\"558\":1}}],[\"methodb\",{\"1\":{\"466\":5}}],[\"methoda\",{\"1\":{\"466\":5}}],[\"methodname3\",{\"1\":{\"465\":1}}],[\"methodname2\",{\"1\":{\"465\":1}}],[\"methodname1\",{\"1\":{\"465\":1}}],[\"meilisearch\",{\"1\":{\"813\":1}}],[\"merge\",{\"1\":{\"813\":2}}],[\"messagekey\",{\"1\":{\"957\":4}}],[\"messageprinter\",{\"1\":{\"699\":2}}],[\"messageserviceimpl\",{\"1\":{\"699\":1}}],[\"messageservice\",{\"1\":{\"699\":4}}],[\"message\",{\"1\":{\"229\":14,\"249\":2,\"545\":8,\"924\":1,\"957\":3}}],[\"message会变成对应语言的对象\",{\"1\":{\"229\":1}}],[\"memory\",{\"1\":{\"813\":4,\"817\":1}}],[\"memset\",{\"1\":{\"226\":1}}],[\"memcpy\",{\"1\":{\"33\":1}}],[\"media\",{\"1\":{\"223\":5}}],[\"measure\",{\"1\":{\"33\":3}}],[\"mset\",{\"1\":{\"873\":2}}],[\"msl的时长\",{\"1\":{\"237\":1}}],[\"msl\",{\"1\":{\"237\":1}}],[\"msg=\",{\"1\":{\"966\":2}}],[\"msg=config\",{\"1\":{\"966\":1}}],[\"msg\",{\"1\":{\"226\":6,\"957\":34,\"1021\":3,\"1029\":1}}],[\"ms\",{\"1\":{\"33\":1,\"584\":1,\"600\":2,\"626\":1}}],[\"mycat\",{\"1\":{\"730\":1}}],[\"myclass\",{\"1\":{\"33\":11}}],[\"myisam不支持事务\",{\"1\":{\"1013\":1}}],[\"myisam\",{\"1\":{\"770\":1,\"810\":2,\"813\":1,\"817\":1,\"820\":2}}],[\"myisam等\",{\"1\":{\"734\":1}}],[\"myint\",{\"1\":{\"460\":6}}],[\"myimage\",{\"1\":{\"249\":2}}],[\"myaddr\",{\"1\":{\"226\":5}}],[\"myarr\",{\"1\":{\"30\":1}}],[\"mystudent\",{\"1\":{\"979\":1}}],[\"mystruct\",{\"1\":{\"466\":4,\"471\":4}}],[\"mysg\",{\"1\":{\"265\":11}}],[\"mysocket\",{\"1\":{\"226\":10}}],[\"mysqllogger\",{\"1\":{\"980\":3}}],[\"mysql更新时\",{\"1\":{\"930\":1}}],[\"mysql数据类型详解\",{\"0\":{\"858\":1}}],[\"mysql数据库管理指南\",{\"0\":{\"832\":1}}],[\"mysql权限\",{\"1\":{\"846\":1}}],[\"mysql服务管理\",{\"0\":{\"833\":1}}],[\"mysql索引使用指南\",{\"0\":{\"826\":1}}],[\"mysql索引原理详解\",{\"0\":{\"813\":1}}],[\"mysql锁机制详解\",{\"0\":{\"820\":1}}],[\"mysqldump\",{\"1\":{\"820\":2,\"854\":8}}],[\"mysqld\",{\"1\":{\"817\":1,\"836\":1}}],[\"mysql架构概述\",{\"0\":{\"817\":1}}],[\"mysql逻辑架构详解\",{\"0\":{\"816\":1}}],[\"mysql会对该字段做分词处理\",{\"1\":{\"813\":1}}],[\"mysql会在重启后通过\",{\"1\":{\"810\":1}}],[\"mysql会直接从缓存中返回结果\",{\"1\":{\"734\":1}}],[\"mysql提供一个\",{\"1\":{\"810\":1}}],[\"mysql日志系统原理详解\",{\"0\":{\"810\":1}}],[\"mysql日志系统详解\",{\"0\":{\"733\":1}}],[\"mysql参数优化\",{\"1\":{\"807\":1}}],[\"mysql结构的优化\",{\"1\":{\"807\":1}}],[\"mysql调优篇\",{\"1\":{\"807\":1}}],[\"mysql性能调优指南\",{\"0\":{\"807\":1}}],[\"mysql的主要日志包括\",{\"1\":{\"802\":1}}],[\"mysql的执行器根据优化器选择的执行计划\",{\"1\":{\"734\":1}}],[\"mysql采用客户端\",{\"1\":{\"800\":1}}],[\"mysql采用了多种机制来确保并发安全和一致性\",{\"1\":{\"760\":1}}],[\"mysql原理分类\",{\"0\":{\"799\":1}}],[\"mysql事务是数据库操作的基本单位\",{\"1\":{\"773\":1}}],[\"mysql事务机制详解\",{\"0\":{\"773\":1}}],[\"mysql5\",{\"1\":{\"770\":1}}],[\"mysql>\",{\"1\":{\"770\":11,\"817\":2,\"820\":8}}],[\"mysql之内存篇\",{\"1\":{\"749\":1}}],[\"mysql一条查询语句的执行过程可以概括为\",{\"1\":{\"734\":1}}],[\"mysql使用一种基于成本的优化算法\",{\"1\":{\"734\":1}}],[\"mysql读写分离与主从同步详解\",{\"0\":{\"730\":1}}],[\"mysql分库分表实践\",{\"0\":{\"727\":1}}],[\"mysql\",{\"0\":{\"235\":1,\"783\":1,\"823\":1,\"829\":1},\"1\":{\"136\":2,\"640\":1,\"714\":1,\"715\":1,\"730\":4,\"734\":1,\"739\":2,\"740\":1,\"747\":1,\"748\":3,\"751\":1,\"752\":1,\"755\":1,\"756\":2,\"759\":2,\"760\":2,\"761\":1,\"763\":3,\"765\":4,\"767\":1,\"770\":16,\"776\":1,\"792\":1,\"793\":1,\"807\":8,\"810\":69,\"813\":14,\"817\":43,\"820\":10,\"835\":4,\"836\":8,\"838\":1,\"840\":2,\"841\":3,\"842\":2,\"843\":2,\"846\":1,\"850\":2,\"854\":7,\"855\":1,\"927\":2,\"930\":1,\"975\":3,\"976\":1,\"978\":1,\"979\":1,\"980\":2},\"2\":{\"728\":1,\"729\":1,\"731\":1,\"732\":1,\"768\":1,\"769\":1,\"771\":1,\"772\":1,\"797\":1,\"798\":1,\"805\":1,\"806\":1,\"808\":1,\"809\":1,\"811\":1,\"812\":1,\"814\":1,\"815\":1,\"818\":1,\"819\":1,\"821\":1,\"822\":1,\"824\":1,\"825\":1,\"827\":1,\"828\":1,\"830\":1,\"831\":1,\"856\":1,\"857\":1,\"859\":1,\"860\":1}}],[\"myroot\",{\"1\":{\"209\":1}}],[\"my\",{\"1\":{\"109\":1,\"110\":1,\"111\":1,\"113\":1,\"119\":3,\"462\":1,\"770\":3,\"979\":1}}],[\"myvolname\",{\"1\":{\"107\":1}}],[\"myfunc1\",{\"1\":{\"30\":1}}],[\"mypage\",{\"1\":{\"249\":1}}],[\"myp\",{\"1\":{\"30\":1}}],[\"mb\",{\"1\":{\"20\":1,\"217\":1,\"693\":3,\"755\":1,\"810\":1}}],[\"match\",{\"1\":{\"1059\":4}}],[\"material\",{\"1\":{\"5\":1}}],[\"many\",{\"1\":{\"817\":1}}],[\"management\",{\"1\":{\"817\":1}}],[\"manager\",{\"1\":{\"9\":1}}],[\"mask\",{\"1\":{\"770\":2}}],[\"master\",{\"1\":{\"243\":1,\"249\":5}}],[\"maven或gradle\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"mart\",{\"1\":{\"903\":1}}],[\"marshal\",{\"0\":{\"483\":1},\"1\":{\"483\":2,\"487\":3,\"489\":2,\"490\":2,\"993\":1,\"1021\":1}}],[\"mar\",{\"1\":{\"249\":1}}],[\"male\",{\"1\":{\"229\":2}}],[\"malloc申请内存的时候\",{\"1\":{\"217\":1}}],[\"malloc申请的内存能用delete释放吗\",{\"1\":{\"33\":1}}],[\"malloc\",{\"1\":{\"33\":7,\"217\":6}}],[\"macintosh\",{\"1\":{\"249\":2}}],[\"macos\",{\"1\":{\"217\":1}}],[\"mac\",{\"1\":{\"122\":1,\"249\":2}}],[\"macvlan\",{\"1\":{\"122\":1}}],[\"machine\",{\"1\":{\"92\":1}}],[\"macro\",{\"1\":{\"33\":5}}],[\"makefile\",{\"1\":{\"962\":1}}],[\"makeslice\",{\"1\":{\"412\":2,\"413\":2,\"415\":2}}],[\"makechan有两个参数\",{\"1\":{\"263\":1}}],[\"make\",{\"1\":{\"88\":1,\"201\":1,\"412\":1,\"413\":1,\"415\":1,\"510\":1,\"511\":1,\"969\":1}}],[\"map查询\",{\"0\":{\"1003\":1}}],[\"mapping>元素在web\",{\"1\":{\"595\":1}}],[\"mapping>\",{\"1\":{\"588\":2,\"608\":1,\"658\":2}}],[\"map将被提升为\",{\"1\":{\"516\":1}}],[\"map底层实现原理\",{\"1\":{\"333\":1}}],[\"map底层数据结构\",{\"0\":{\"324\":1}}],[\"map赋值操作\",{\"1\":{\"332\":1}}],[\"map赋值原理\",{\"0\":{\"332\":1}}],[\"map提供两种访问方式\",{\"1\":{\"331\":1}}],[\"map访问原理\",{\"0\":{\"331\":1}}],[\"map会根据每一个key算出一个hash值\",{\"1\":{\"330\":1}}],[\"map工作原理\",{\"0\":{\"329\":1}}],[\"mapextra包含了一些额外的字段\",{\"1\":{\"327\":1}}],[\"mapextra结构体\",{\"0\":{\"327\":1}}],[\"map是一个指向hmap的指针\",{\"1\":{\"325\":1}}],[\"map概念基础\",{\"0\":{\"319\":1}}],[\"map<string\",{\"1\":{\"229\":1,\"670\":1}}],[\"maprequest\",{\"1\":{\"229\":1}}],[\"map\",{\"0\":{\"509\":2,\"510\":1,\"512\":1,\"513\":1,\"516\":1,\"517\":1,\"518\":2,\"519\":2,\"526\":1,\"527\":1,\"528\":1},\"1\":{\"88\":2,\"229\":1,\"333\":1,\"452\":4,\"509\":2,\"510\":4,\"511\":2,\"512\":10,\"515\":1,\"516\":10,\"519\":2,\"520\":5,\"525\":5,\"526\":2,\"527\":4,\"529\":2,\"530\":1,\"531\":2,\"532\":2,\"957\":1,\"1003\":1,\"1021\":1,\"1030\":1},\"2\":{\"335\":1}}],[\"main就会终止\",{\"1\":{\"479\":1}}],[\"main\",{\"1\":{\"30\":4,\"33\":3,\"36\":1,\"226\":3,\"367\":2,\"398\":3,\"399\":1,\"410\":2,\"412\":2,\"413\":2,\"415\":2,\"423\":4,\"438\":1,\"441\":2,\"442\":1,\"447\":1,\"453\":1,\"458\":3,\"460\":2,\"462\":1,\"466\":2,\"468\":1,\"469\":2,\"470\":2,\"471\":2,\"476\":1,\"477\":6,\"479\":2,\"483\":2,\"491\":1,\"510\":2,\"511\":2,\"515\":2,\"540\":1,\"542\":1,\"543\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":1,\"700\":1,\"957\":12,\"962\":1,\"1021\":2,\"1024\":2,\"1031\":1,\"1040\":2}}],[\"maxmemory\",{\"1\":{\"900\":3}}],[\"maxrequestsize\",{\"1\":{\"693\":1}}],[\"maxfilesize\",{\"1\":{\"693\":1}}],[\"max=1000\",{\"1\":{\"249\":1}}],[\"max=100\",{\"1\":{\"237\":1}}],[\"maxevents\",{\"1\":{\"226\":1}}],[\"maxline\",{\"1\":{\"226\":2}}],[\"max+1\",{\"1\":{\"226\":1}}],[\"max\",{\"1\":{\"20\":1,\"36\":1,\"162\":1,\"226\":8,\"249\":1,\"374\":4,\"426\":4,\"601\":1,\"744\":3,\"787\":1,\"789\":2,\"807\":1,\"817\":1,\"873\":1}}],[\"owner\",{\"1\":{\"912\":1,\"913\":2,\"921\":3}}],[\"olduser\",{\"1\":{\"840\":5}}],[\"oldusername\",{\"1\":{\"641\":3}}],[\"o1\",{\"1\":{\"813\":1,\"864\":1,\"870\":1,\"873\":1,\"876\":1,\"879\":3}}],[\"omitkey\",{\"1\":{\"957\":3}}],[\"omitpassworddemo\",{\"1\":{\"490\":1}}],[\"omitempty\",{\"1\":{\"488\":3,\"489\":10,\"490\":1}}],[\"omitemptydemo\",{\"1\":{\"487\":1}}],[\"of\",{\"1\":{\"249\":1,\"374\":1,\"468\":1}}],[\"offset消息偏移示意图\",{\"1\":{\"163\":1}}],[\"offset\",{\"0\":{\"163\":1},\"1\":{\"1008\":5}}],[\"official\",{\"1\":{\"5\":1}}],[\"octet\",{\"1\":{\"1032\":2}}],[\"oct\",{\"1\":{\"249\":1}}],[\"os\",{\"1\":{\"249\":2,\"957\":8,\"980\":1,\"1037\":1}}],[\"osi模型\",{\"2\":{\"251\":1}}],[\"osi模型和tcp\",{\"1\":{\"249\":1}}],[\"osi模型设有会话层和表示层\",{\"1\":{\"249\":1}}],[\"osi模型有7层\",{\"1\":{\"249\":1}}],[\"osi模型的传输层\",{\"1\":{\"249\":1}}],[\"osi\",{\"1\":{\"249\":3}}],[\"osr\",{\"1\":{\"181\":4,\"183\":2}}],[\"o多路复用\",{\"1\":{\"226\":1}}],[\"o模型\",{\"1\":{\"226\":1}}],[\"oom\",{\"1\":{\"217\":1}}],[\"operating\",{\"0\":{\"1078\":1}}],[\"operations\",{\"1\":{\"515\":1}}],[\"openfile\",{\"1\":{\"425\":2,\"957\":2}}],[\"open\",{\"1\":{\"229\":3,\"425\":1,\"976\":2,\"978\":2,\"979\":2,\"980\":4,\"1037\":1}}],[\"opens\",{\"1\":{\"217\":1,\"770\":1,\"817\":1}}],[\"op\",{\"1\":{\"226\":1}}],[\"optimize\",{\"1\":{\"817\":1}}],[\"optimizer\",{\"1\":{\"817\":1}}],[\"options\",{\"1\":{\"249\":1,\"601\":1,\"957\":4,\"1013\":1}}],[\"option\",{\"1\":{\"223\":1,\"229\":2,\"957\":2}}],[\"opt=mprotos\",{\"1\":{\"229\":2}}],[\"opt=paths=source\",{\"1\":{\"229\":1}}],[\"opt标志来提供特定于\",{\"1\":{\"229\":1}}],[\"opt标志位参数\",{\"1\":{\"229\":2}}],[\"opt\",{\"1\":{\"113\":3,\"223\":2,\"770\":2}}],[\"ok\",{\"1\":{\"36\":1,\"249\":4,\"449\":2,\"469\":6,\"514\":2,\"515\":2,\"529\":7,\"531\":8,\"532\":2,\"676\":1,\"770\":8,\"817\":1,\"820\":4,\"1029\":1,\"1037\":2}}],[\"overhead\",{\"1\":{\"770\":3}}],[\"overlay\",{\"1\":{\"119\":2,\"122\":1}}],[\"overload\",{\"1\":{\"33\":1}}],[\"override\",{\"1\":{\"33\":2,\"559\":3,\"584\":3,\"590\":1,\"591\":1,\"592\":1,\"596\":2,\"598\":1,\"599\":2,\"600\":1,\"601\":1,\"624\":2,\"625\":2,\"626\":2,\"633\":3,\"634\":3,\"635\":3,\"637\":2,\"638\":2,\"640\":2,\"641\":5,\"652\":1,\"662\":3,\"683\":3,\"684\":2}}],[\"outputpaths\",{\"1\":{\"957\":7}}],[\"outputstream\",{\"1\":{\"677\":1}}],[\"outofmemoryerror\",{\"1\":{\"538\":1}}],[\"out=out\",{\"1\":{\"229\":1}}],[\"out标志的参数是你希望编译器编写\",{\"1\":{\"229\":1}}],[\"out标志调用\",{\"1\":{\"229\":1}}],[\"out指定的位置\",{\"1\":{\"229\":1}}],[\"out\",{\"1\":{\"33\":1,\"229\":1,\"540\":4,\"541\":2,\"542\":2,\"543\":2,\"555\":9,\"556\":2,\"557\":1,\"558\":3,\"559\":4,\"584\":4,\"590\":1,\"591\":2,\"592\":1,\"596\":4,\"624\":4,\"625\":4,\"626\":2,\"633\":3,\"634\":3,\"635\":6,\"637\":2,\"638\":2,\"640\":2,\"641\":4,\"652\":11,\"662\":3,\"683\":2,\"684\":2,\"699\":1,\"957\":3}}],[\"or条件\",{\"0\":{\"1005\":1}}],[\"ormframework\",{\"0\":{\"1085\":1}}],[\"orm框架\",{\"2\":{\"1016\":1}}],[\"orm\",{\"1\":{\"973\":1},\"2\":{\"1017\":1}}],[\"oracle\",{\"1\":{\"813\":2}}],[\"orange\",{\"1\":{\"502\":3,\"503\":2}}],[\"origin\",{\"1\":{\"601\":1}}],[\"org\",{\"1\":{\"229\":1,\"249\":4,\"658\":4,\"957\":5,\"1058\":1,\"1059\":1}}],[\"or\",{\"1\":{\"33\":2,\"122\":1,\"807\":2,\"813\":8,\"820\":1,\"829\":1,\"940\":1,\"990\":2,\"1001\":1,\"1005\":2}}],[\"order\",{\"1\":{\"23\":1,\"770\":7,\"813\":1,\"820\":43,\"823\":1,\"829\":1,\"988\":2,\"1007\":1}}],[\"object\",{\"0\":{\"1077\":1},\"1\":{\"556\":1,\"557\":1,\"558\":1,\"559\":6,\"633\":4,\"634\":4,\"635\":4,\"846\":2,\"847\":1,\"906\":1,\"939\":2,\"940\":1}}],[\"obj3\",{\"1\":{\"33\":2}}],[\"obj2\",{\"1\":{\"33\":3}}],[\"obj1\",{\"1\":{\"33\":3}}],[\"ob1\",{\"1\":{\"30\":5}}],[\"ob\",{\"1\":{\"30\":2}}],[\"o\",{\"1\":{\"20\":1,\"190\":1,\"226\":2,\"391\":1,\"497\":1,\"527\":1,\"747\":1,\"755\":1,\"760\":3,\"766\":1,\"767\":1,\"770\":5,\"810\":16,\"957\":7}}],[\"on^2\",{\"1\":{\"879\":1}}],[\"once\",{\"1\":{\"705\":3}}],[\"onlineusers\",{\"1\":{\"641\":12}}],[\"onlineusermanager\",{\"1\":{\"641\":1}}],[\"only\",{\"1\":{\"113\":1,\"246\":1,\"952\":1}}],[\"oneof\",{\"1\":{\"229\":3}}],[\"ontainer\",{\"1\":{\"125\":1}}],[\"on\",{\"1\":{\"3\":1,\"714\":1,\"820\":1,\"826\":9,\"846\":1,\"847\":1,\"873\":1,\"879\":3,\"952\":1,\"966\":2}}],[\"1=1\",{\"1\":{\"990\":2}}],[\"1m\",{\"1\":{\"873\":3}}],[\"1mb\",{\"1\":{\"770\":1}}],[\"1的第一条记录\",{\"1\":{\"817\":1}}],[\"1个\",{\"1\":{\"770\":1}}],[\"1个msl后该ack报文在网路中消亡\",{\"1\":{\"237\":1}}],[\"1s\",{\"1\":{\"810\":1,\"957\":1}}],[\"1sq\",{\"1\":{\"770\":1}}],[\"1s内\",{\"1\":{\"20\":1}}],[\"1c\",{\"1\":{\"770\":3}}],[\"1b\",{\"1\":{\"770\":1}}],[\"1表示b+树非叶子节点记录\",{\"1\":{\"770\":1}}],[\"1字节8位\",{\"1\":{\"770\":1}}],[\"1次\",{\"1\":{\"682\":1}}],[\"1l\",{\"1\":{\"637\":1,\"638\":1}}],[\"1<\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"1xx\",{\"1\":{\"249\":2}}],[\"1rtt\",{\"1\":{\"240\":1}}],[\"1就表示主题a得1号分区\",{\"1\":{\"157\":1}}],[\"1t\",{\"1\":{\"79\":1}}],[\"19t22\",{\"1\":{\"957\":2}}],[\"19t21\",{\"1\":{\"957\":5}}],[\"19t19\",{\"1\":{\"957\":2}}],[\"19t15\",{\"1\":{\"957\":1}}],[\"199\",{\"1\":{\"370\":1,\"371\":1}}],[\"1994\",{\"1\":{\"249\":2}}],[\"198\",{\"1\":{\"370\":1,\"371\":1}}],[\"197\",{\"1\":{\"370\":1,\"371\":1}}],[\"196\",{\"1\":{\"370\":1,\"371\":1}}],[\"195\",{\"1\":{\"370\":1,\"371\":1}}],[\"194\",{\"1\":{\"370\":1,\"371\":1}}],[\"193\",{\"1\":{\"370\":1,\"371\":1}}],[\"192\",{\"1\":{\"370\":1,\"371\":1}}],[\"191\",{\"1\":{\"370\":1,\"371\":1,\"983\":1}}],[\"190\",{\"1\":{\"370\":1,\"371\":1}}],[\"19\",{\"1\":{\"33\":1,\"249\":1,\"370\":1,\"371\":1,\"807\":1,\"820\":1,\"957\":6}}],[\"18+08\",{\"1\":{\"957\":2}}],[\"189\",{\"1\":{\"370\":1,\"371\":1}}],[\"188\",{\"1\":{\"370\":1,\"371\":1,\"374\":1}}],[\"187\",{\"1\":{\"370\":1,\"371\":1}}],[\"186\",{\"1\":{\"370\":1,\"371\":1}}],[\"185\",{\"1\":{\"370\":1,\"371\":1}}],[\"184\",{\"1\":{\"370\":1,\"371\":1}}],[\"183\",{\"1\":{\"370\":1,\"371\":1}}],[\"182\",{\"1\":{\"370\":1,\"371\":1}}],[\"181\",{\"1\":{\"370\":1,\"371\":1}}],[\"181422\",{\"1\":{\"147\":1}}],[\"181442\",{\"1\":{\"147\":1}}],[\"1800\",{\"1\":{\"691\":1}}],[\"180\",{\"1\":{\"370\":1,\"371\":1}}],[\"18\",{\"1\":{\"33\":1,\"229\":1,\"249\":1,\"370\":1,\"371\":1,\"483\":3,\"770\":2,\"807\":1,\"813\":1,\"873\":1,\"957\":2}}],[\"179\",{\"1\":{\"370\":1,\"371\":1}}],[\"178\",{\"1\":{\"370\":1,\"371\":1}}],[\"177\",{\"1\":{\"370\":1,\"371\":1}}],[\"176\",{\"1\":{\"370\":1,\"371\":1}}],[\"175\",{\"1\":{\"370\":1,\"371\":1}}],[\"174\",{\"1\":{\"370\":1,\"371\":1}}],[\"173\",{\"1\":{\"370\":1,\"371\":1}}],[\"171\",{\"1\":{\"370\":1,\"371\":1}}],[\"170\",{\"1\":{\"370\":1,\"371\":1}}],[\"172\",{\"1\":{\"121\":2,\"370\":1,\"371\":1}}],[\"17\",{\"1\":{\"33\":1,\"121\":2,\"249\":3,\"370\":1,\"371\":1,\"807\":1}}],[\"16k\",{\"1\":{\"770\":2}}],[\"16kb\",{\"1\":{\"748\":2,\"770\":5,\"810\":2,\"813\":1}}],[\"169\",{\"1\":{\"370\":1,\"371\":1}}],[\"168\",{\"1\":{\"370\":1,\"371\":1}}],[\"1679217743\",{\"1\":{\"957\":4}}],[\"1679212318\",{\"1\":{\"957\":1}}],[\"167\",{\"1\":{\"370\":1,\"371\":1}}],[\"166\",{\"1\":{\"370\":1,\"371\":1}}],[\"165\",{\"1\":{\"370\":1,\"371\":1}}],[\"164\",{\"1\":{\"370\":1,\"371\":1}}],[\"16384字节\",{\"1\":{\"770\":1}}],[\"163\",{\"1\":{\"370\":1,\"371\":1}}],[\"162\",{\"1\":{\"370\":1,\"371\":1}}],[\"161\",{\"1\":{\"370\":1,\"371\":1}}],[\"160\",{\"1\":{\"370\":1,\"371\":1}}],[\"16+请使用下面的命令安装插件\",{\"1\":{\"229\":1}}],[\"16\",{\"1\":{\"33\":1,\"121\":1,\"217\":4,\"370\":1,\"371\":1,\"441\":2,\"755\":1,\"807\":1,\"810\":1,\"873\":1,\"903\":2,\"906\":1,\"940\":1,\"943\":1,\"944\":1,\"957\":1,\"983\":2}}],[\"159\",{\"1\":{\"370\":1,\"371\":1}}],[\"158\",{\"1\":{\"370\":1,\"371\":1}}],[\"157\",{\"1\":{\"370\":1,\"371\":1}}],[\"156\",{\"1\":{\"370\":1,\"371\":1}}],[\"155\",{\"1\":{\"370\":1,\"371\":1}}],[\"154\",{\"1\":{\"370\":1,\"371\":1}}],[\"153\",{\"1\":{\"370\":1,\"371\":1}}],[\"152\",{\"1\":{\"370\":1,\"371\":1}}],[\"151\",{\"1\":{\"370\":1,\"371\":1,\"817\":1}}],[\"150\",{\"1\":{\"370\":1,\"371\":1,\"543\":1}}],[\"1500\",{\"1\":{\"121\":1}}],[\"15\",{\"0\":{\"478\":1,\"479\":1},\"1\":{\"33\":1,\"249\":2,\"370\":1,\"371\":1,\"458\":1,\"807\":1,\"943\":1,\"944\":1,\"957\":1}}],[\"139\",{\"1\":{\"370\":1,\"371\":1}}],[\"138\",{\"1\":{\"370\":1,\"371\":1}}],[\"137\",{\"1\":{\"370\":1,\"371\":1}}],[\"136\",{\"1\":{\"370\":1,\"371\":1}}],[\"135\",{\"1\":{\"370\":1,\"371\":1}}],[\"134\",{\"1\":{\"370\":1,\"371\":1}}],[\"133\",{\"1\":{\"370\":1,\"371\":1}}],[\"132\",{\"1\":{\"370\":1,\"371\":1,\"879\":2}}],[\"1320\",{\"1\":{\"249\":1}}],[\"131\",{\"1\":{\"370\":1,\"371\":1}}],[\"1300000001\",{\"1\":{\"813\":1}}],[\"130\",{\"1\":{\"370\":1,\"371\":1}}],[\"13\",{\"0\":{\"473\":1,\"474\":1,\"475\":1,\"476\":1},\"1\":{\"33\":1,\"249\":2,\"370\":1,\"371\":1,\"807\":1,\"879\":1,\"999\":2}}],[\"129\",{\"1\":{\"370\":1,\"371\":1,\"374\":2}}],[\"126\",{\"1\":{\"370\":1,\"371\":1}}],[\"125\",{\"1\":{\"370\":1,\"371\":1}}],[\"124\",{\"1\":{\"370\":1,\"371\":1,\"1035\":1}}],[\"1234567\",{\"1\":{\"491\":2}}],[\"123456\",{\"1\":{\"490\":1}}],[\"123\",{\"1\":{\"370\":1,\"371\":1,\"438\":2,\"770\":1,\"1035\":2,\"1036\":1}}],[\"122\",{\"1\":{\"370\":1,\"371\":1}}],[\"121\",{\"1\":{\"370\":1,\"371\":1}}],[\"120\",{\"1\":{\"370\":1,\"371\":1}}],[\"128tb\",{\"1\":{\"217\":1}}],[\"128\",{\"1\":{\"217\":2,\"249\":2,\"370\":1,\"371\":1,\"374\":2,\"876\":1,\"897\":1}}],[\"127\",{\"1\":{\"117\":3,\"226\":2,\"370\":1,\"371\":1,\"976\":2,\"1026\":1}}],[\"12\",{\"0\":{\"472\":1},\"1\":{\"33\":1,\"249\":2,\"370\":1,\"371\":1,\"770\":1,\"807\":1,\"813\":7,\"983\":3,\"999\":2}}],[\"119\",{\"1\":{\"370\":1,\"371\":1}}],[\"118\",{\"1\":{\"370\":1,\"371\":1}}],[\"117\",{\"1\":{\"370\":1,\"371\":1}}],[\"116\",{\"1\":{\"370\":1,\"371\":1}}],[\"115\",{\"1\":{\"370\":1,\"371\":1}}],[\"114\",{\"1\":{\"370\":1,\"371\":1}}],[\"113\",{\"1\":{\"370\":1,\"371\":1}}],[\"112\",{\"1\":{\"370\":1,\"371\":1}}],[\"11111110\",{\"1\":{\"879\":2}}],[\"111\",{\"1\":{\"370\":1,\"371\":1,\"440\":1}}],[\"110\",{\"1\":{\"370\":1,\"371\":1}}],[\"11\",{\"0\":{\"465\":1,\"466\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1},\"1\":{\"33\":1,\"210\":2,\"249\":1,\"370\":1,\"371\":1,\"469\":1,\"770\":3,\"807\":1,\"957\":2,\"999\":2}}],[\"1gb\",{\"1\":{\"807\":1}}],[\"1g的内存上能监听约10万个端口\",{\"1\":{\"226\":1}}],[\"1g\",{\"1\":{\"20\":1}}],[\"149\",{\"1\":{\"370\":1,\"371\":1}}],[\"148\",{\"1\":{\"370\":1,\"371\":1}}],[\"147\",{\"1\":{\"370\":1,\"371\":1}}],[\"146\",{\"1\":{\"370\":1,\"371\":1}}],[\"145\",{\"1\":{\"370\":1,\"371\":1}}],[\"144\",{\"1\":{\"370\":1,\"371\":1}}],[\"143\",{\"1\":{\"370\":1,\"371\":1}}],[\"142\",{\"1\":{\"370\":1,\"371\":1}}],[\"141\",{\"1\":{\"370\":1,\"371\":1}}],[\"140\",{\"1\":{\"370\":1,\"371\":1}}],[\"1403\",{\"1\":{\"249\":8}}],[\"14\",{\"0\":{\"477\":1},\"1\":{\"20\":1,\"33\":2,\"370\":1,\"371\":1,\"463\":1,\"470\":1,\"807\":1,\"1059\":2}}],[\"10秒\",{\"1\":{\"976\":1}}],[\"10s\",{\"1\":{\"924\":1,\"976\":1}}],[\"10=\",{\"1\":{\"723\":1}}],[\"1092\",{\"1\":{\"903\":1}}],[\"109\",{\"1\":{\"370\":1,\"371\":1}}],[\"108\",{\"1\":{\"370\":1,\"371\":1}}],[\"107\",{\"1\":{\"370\":1,\"371\":1}}],[\"106\",{\"1\":{\"370\":1,\"371\":1}}],[\"105\",{\"1\":{\"370\":1,\"371\":1}}],[\"104\",{\"1\":{\"370\":1,\"371\":1}}],[\"103\",{\"1\":{\"370\":1,\"371\":1}}],[\"102+0800\",{\"1\":{\"957\":1}}],[\"10218\",{\"1\":{\"957\":1}}],[\"102\",{\"1\":{\"370\":1,\"371\":1}}],[\"1024\",{\"1\":{\"20\":6,\"217\":2,\"226\":1,\"693\":6,\"723\":1,\"864\":1}}],[\"1010\",{\"1\":{\"820\":3}}],[\"101\",{\"1\":{\"370\":1,\"371\":1,\"448\":1}}],[\"1002\",{\"1\":{\"1030\":1}}],[\"100w\",{\"1\":{\"927\":1}}],[\"100ms\",{\"1\":{\"906\":1}}],[\"1005\",{\"1\":{\"820\":3}}],[\"1006\",{\"1\":{\"820\":20}}],[\"1008\",{\"1\":{\"820\":3}}],[\"10086\",{\"1\":{\"735\":1}}],[\"1007\",{\"1\":{\"820\":2}}],[\"100~1000\",{\"1\":{\"810\":2}}],[\"100个汉字占用300个字节\",{\"1\":{\"770\":1}}],[\"100来分\",{\"1\":{\"723\":1}}],[\"1001\",{\"1\":{\"190\":4,\"820\":5,\"1030\":1}}],[\"1000\",{\"1\":{\"505\":3,\"515\":3,\"600\":1,\"864\":2,\"939\":2}}],[\"1000010\",{\"1\":{\"879\":1}}],[\"100000\",{\"1\":{\"817\":6}}],[\"1000000\",{\"1\":{\"33\":2,\"510\":2,\"511\":2}}],[\"10000\",{\"1\":{\"413\":2,\"952\":1}}],[\"1000万字符串\",{\"1\":{\"20\":1}}],[\"100\",{\"1\":{\"30\":2,\"75\":3,\"217\":1,\"370\":1,\"371\":1,\"412\":2,\"442\":1,\"447\":1,\"505\":1,\"770\":3,\"794\":2,\"813\":1,\"957\":5,\"986\":1,\"1014\":3,\"1015\":3}}],[\"10\",{\"0\":{\"369\":1,\"462\":1,\"463\":1,\"464\":1},\"1\":{\"23\":1,\"30\":6,\"33\":5,\"249\":3,\"367\":1,\"369\":1,\"370\":1,\"371\":1,\"373\":2,\"460\":1,\"515\":3,\"540\":1,\"693\":2,\"723\":1,\"770\":7,\"807\":1,\"810\":3,\"813\":6,\"820\":2,\"864\":3,\"940\":1,\"952\":1,\"999\":3,\"1058\":1}}],[\"1\",{\"0\":{\"5\":2,\"6\":1,\"8\":1,\"41\":1,\"43\":1,\"46\":1,\"50\":1,\"51\":2,\"52\":1,\"54\":1,\"59\":1,\"60\":2,\"61\":1,\"62\":1,\"64\":1,\"69\":1,\"70\":2,\"72\":1,\"86\":1,\"88\":1,\"97\":2,\"98\":1,\"99\":1,\"101\":1,\"106\":1,\"117\":1,\"132\":1,\"134\":1,\"139\":1,\"145\":1,\"161\":1,\"170\":1,\"172\":1,\"180\":1,\"194\":1,\"195\":2,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"201\":1,\"204\":1,\"207\":1,\"254\":1,\"256\":1,\"259\":1,\"263\":1,\"270\":1,\"272\":1,\"276\":1,\"279\":1,\"287\":1,\"290\":1,\"298\":1,\"300\":1,\"305\":1,\"310\":1,\"313\":1,\"319\":1,\"320\":2,\"321\":1,\"325\":1,\"330\":1,\"337\":1,\"340\":1,\"344\":1,\"350\":1,\"351\":2,\"352\":1,\"354\":1,\"356\":1,\"363\":1,\"378\":1,\"380\":1,\"383\":1,\"388\":1,\"389\":2,\"391\":1,\"394\":1,\"398\":1,\"404\":1,\"405\":2,\"407\":1,\"409\":1,\"420\":1,\"422\":1,\"425\":1,\"429\":1,\"433\":2,\"434\":1,\"435\":1,\"443\":1,\"447\":1,\"449\":1,\"451\":1,\"454\":1,\"459\":1,\"461\":1,\"462\":1,\"465\":1,\"472\":1,\"473\":1,\"474\":1,\"477\":1,\"478\":1,\"495\":1,\"496\":2,\"497\":1,\"499\":1,\"502\":1,\"505\":1,\"510\":1,\"514\":1,\"518\":1,\"522\":1,\"529\":1,\"536\":1,\"537\":2,\"538\":1,\"540\":1,\"545\":1,\"550\":1,\"551\":2,\"552\":1,\"555\":1,\"564\":2,\"565\":1,\"566\":1,\"568\":1,\"573\":1,\"577\":1,\"578\":2,\"579\":1,\"581\":1,\"583\":1,\"586\":1,\"590\":1,\"594\":1,\"598\":1,\"603\":1,\"607\":1,\"613\":1,\"614\":2,\"615\":1,\"617\":1,\"619\":1,\"623\":1,\"629\":1,\"633\":1,\"637\":1,\"640\":1,\"645\":1,\"646\":2,\"647\":1,\"649\":1,\"651\":1,\"654\":1,\"661\":1,\"664\":1,\"669\":1,\"670\":2,\"671\":1,\"672\":1,\"673\":1,\"675\":1,\"680\":1,\"681\":2,\"682\":1,\"686\":1,\"687\":2,\"688\":1,\"691\":1,\"705\":1,\"708\":1,\"713\":1,\"717\":1,\"719\":1,\"722\":1,\"734\":1,\"737\":1,\"739\":1,\"747\":1,\"751\":1,\"759\":1,\"763\":1,\"774\":1,\"775\":2,\"777\":1,\"780\":1,\"782\":1,\"787\":1,\"791\":1,\"793\":1,\"800\":1,\"817\":1,\"833\":1,\"834\":2,\"835\":3,\"836\":2,\"838\":1,\"846\":1,\"850\":1,\"854\":1,\"911\":1,\"937\":2,\"938\":1,\"939\":1,\"940\":1,\"941\":1,\"943\":1,\"945\":1,\"956\":1,\"961\":1,\"962\":2,\"964\":1,\"968\":1,\"974\":1,\"976\":1,\"978\":1,\"982\":1,\"985\":1,\"988\":1,\"994\":1,\"997\":1,\"1001\":1,\"1002\":2,\"1003\":1,\"1004\":1,\"1005\":1,\"1014\":1,\"1019\":1,\"1020\":2,\"1021\":1,\"1023\":1,\"1029\":1,\"1035\":1,\"1039\":1,\"1047\":1,\"1048\":2,\"1049\":1,\"1051\":1,\"1056\":1,\"1058\":1},\"1\":{\"20\":23,\"23\":8,\"30\":3,\"33\":6,\"36\":5,\"46\":6,\"79\":2,\"117\":3,\"121\":1,\"204\":1,\"211\":1,\"217\":22,\"223\":1,\"226\":15,\"229\":15,\"237\":2,\"240\":7,\"243\":3,\"249\":89,\"344\":7,\"367\":2,\"369\":1,\"370\":1,\"371\":1,\"373\":1,\"374\":8,\"415\":1,\"423\":1,\"432\":1,\"442\":3,\"451\":1,\"452\":2,\"453\":9,\"458\":2,\"468\":1,\"476\":3,\"477\":5,\"496\":1,\"515\":5,\"559\":1,\"654\":1,\"687\":1,\"693\":2,\"710\":1,\"723\":3,\"756\":2,\"757\":1,\"760\":2,\"763\":4,\"765\":2,\"770\":23,\"780\":1,\"807\":4,\"810\":37,\"813\":18,\"817\":5,\"820\":24,\"843\":1,\"864\":12,\"867\":3,\"870\":2,\"873\":4,\"876\":1,\"879\":10,\"885\":1,\"891\":1,\"897\":2,\"903\":1,\"906\":1,\"912\":1,\"921\":3,\"924\":2,\"927\":1,\"930\":5,\"942\":1,\"952\":2,\"957\":3,\"976\":2,\"988\":3,\"990\":1,\"994\":2,\"1008\":2,\"1024\":1,\"1026\":1,\"1037\":1,\"1054\":1}}],[\"类名\",{\"1\":{\"555\":1}}],[\"类对象作为参数传递的时候使用引用\",{\"1\":{\"33\":1}}],[\"类型值的函数即可\",{\"1\":{\"957\":1}}],[\"类型来记录的\",{\"1\":{\"957\":1}}],[\"类型断言都会失败\",{\"1\":{\"469\":1}}],[\"类型断言接口操作\",{\"1\":{\"469\":1}}],[\"类型断言究竟咋\",{\"1\":{\"315\":1}}],[\"类型不安全\",{\"1\":{\"460\":1}}],[\"类型安全可以防止许多常见的编程错误\",{\"1\":{\"459\":1}}],[\"类型安全\",{\"1\":{\"459\":1}}],[\"类型参数\",{\"1\":{\"458\":1}}],[\"类型大小\",{\"1\":{\"302\":1}}],[\"类型等\",{\"1\":{\"249\":1}}],[\"类型\",{\"1\":{\"229\":1,\"433\":1,\"436\":1,\"460\":1,\"469\":1,\"516\":1,\"522\":1,\"817\":1,\"879\":2,\"957\":3}}],[\"类型检查阶段将进行语义分析\",{\"1\":{\"395\":1}}],[\"类型检查\",{\"1\":{\"33\":1,\"394\":1}}],[\"类型的间隙锁\",{\"1\":{\"820\":2}}],[\"类型的意向锁\",{\"1\":{\"820\":2}}],[\"类型的列最多可以存储\",{\"1\":{\"770\":1}}],[\"类型的列\",{\"1\":{\"770\":1}}],[\"类型的字段\",{\"1\":{\"770\":2}}],[\"类型的定义和绑定在它上面的方法的定义可以不放置在同一个文件中\",{\"1\":{\"461\":1}}],[\"类型的一个方法\",{\"1\":{\"460\":1}}],[\"类型的变量i赋值给整形变量b\",{\"1\":{\"468\":1}}],[\"类型的变量\",{\"1\":{\"459\":1}}],[\"类型的\",{\"1\":{\"33\":1}}],[\"类似不允许这个\",{\"1\":{\"897\":1}}],[\"类似红黑树的旋转操作等\",{\"1\":{\"813\":1}}],[\"类似的\",{\"1\":{\"770\":1}}],[\"类似数据库分表\",{\"1\":{\"721\":1}}],[\"类似protected\",{\"1\":{\"433\":1}}],[\"类似于英文可以直接通过符号\",{\"1\":{\"813\":1}}],[\"类似于问你准备好了吗\",{\"1\":{\"764\":1,\"810\":1}}],[\"类似于数组或列表的概念\",{\"1\":{\"229\":1}}],[\"类似于\",{\"1\":{\"223\":1,\"249\":1}}],[\"类似于一个全局锁\",{\"1\":{\"23\":1}}],[\"类似快捷方式\",{\"1\":{\"223\":1}}],[\"类似上面的支付场景\",{\"1\":{\"23\":1}}],[\"类似\",{\"1\":{\"10\":1,\"223\":1,\"249\":1,\"820\":1,\"962\":3}}],[\"类\",{\"0\":{\"4\":1,\"12\":1},\"1\":{\"33\":1,\"568\":1}}],[\"二次开发\",{\"1\":{\"957\":1}}],[\"二娃的园子\",{\"1\":{\"870\":1}}],[\"二级索引走一步\",{\"1\":{\"885\":1}}],[\"二级索引加了\",{\"1\":{\"820\":1}}],[\"二级索引表进行了一个事务操作\",{\"1\":{\"813\":1}}],[\"二级索引通过主键索引进行再一次查询\",{\"1\":{\"813\":1}}],[\"二级索引能有多个\",{\"1\":{\"813\":1}}],[\"二级索引\",{\"1\":{\"813\":5,\"817\":1}}],[\"二级分页\",{\"1\":{\"217\":1}}],[\"二是可用性也很差\",{\"1\":{\"810\":1}}],[\"二进制文件的形式\",{\"1\":{\"952\":1}}],[\"二进制安全\",{\"1\":{\"873\":1}}],[\"二进制日志\",{\"1\":{\"802\":1}}],[\"二进制位的值为0时\",{\"1\":{\"770\":1}}],[\"二进制位的值为1时\",{\"1\":{\"770\":1}}],[\"二进制位按照列的顺序逆序排列\",{\"1\":{\"770\":1}}],[\"二进制数组\",{\"1\":{\"20\":1}}],[\"二元运算待的运算方向均是从左至右\",{\"1\":{\"445\":1}}],[\"二叉树\",{\"1\":{\"813\":1},\"2\":{\"67\":1}}],[\"二叉树详解\",{\"0\":{\"58\":1}}],[\"二叉搜索树\",{\"0\":{\"62\":1}}],[\"二叉堆\",{\"2\":{\"57\":1}}],[\"二叉堆的主要操作包括\",{\"1\":{\"52\":1}}],[\"二叉堆主要分为两类\",{\"1\":{\"51\":1}}],[\"二叉堆和二叉搜索树\",{\"1\":{\"50\":1}}],[\"二叉堆是一种特殊的二叉树\",{\"1\":{\"50\":1}}],[\"二叉堆详解\",{\"0\":{\"49\":1}}],[\"二分查找\",{\"1\":{\"870\":1},\"2\":{\"47\":1,\"48\":1}}],[\"二分红蓝染色法是二分查找的一种实现思路\",{\"1\":{\"41\":1}}],[\"二分红蓝染色法概述\",{\"0\":{\"41\":1}}],[\"二分红蓝染色法详解\",{\"0\":{\"40\":1}}],[\"二\",{\"0\":{\"4\":1,\"100\":1,\"157\":1,\"179\":1,\"368\":1,\"512\":1,\"567\":1,\"707\":1},\"1\":{\"23\":2,\"217\":1,\"226\":1,\"237\":1,\"240\":1,\"243\":1,\"727\":3,\"730\":1}}],[\"fprintln\",{\"1\":{\"1059\":4}}],[\"feature\",{\"0\":{\"1066\":1}}],[\"fengfeng\",{\"1\":{\"1035\":1}}],[\"fetch\",{\"1\":{\"957\":8}}],[\"female\",{\"1\":{\"229\":3}}],[\"ftwrl\",{\"1\":{\"820\":1}}],[\"ftp\",{\"1\":{\"223\":1,\"249\":1}}],[\"fulltext\",{\"1\":{\"826\":2}}],[\"full\",{\"1\":{\"813\":1}}],[\"fun\",{\"1\":{\"33\":6,\"307\":3}}],[\"functionkey\",{\"1\":{\"957\":3}}],[\"function\",{\"1\":{\"33\":5}}],[\"func\",{\"1\":{\"33\":5,\"46\":1,\"88\":1,\"265\":2,\"367\":2,\"374\":1,\"410\":2,\"412\":2,\"413\":2,\"415\":2,\"423\":2,\"425\":1,\"426\":1,\"427\":1,\"429\":2,\"438\":1,\"441\":1,\"442\":1,\"447\":1,\"453\":1,\"458\":2,\"460\":2,\"462\":2,\"463\":1,\"464\":2,\"466\":3,\"467\":1,\"468\":1,\"469\":1,\"470\":4,\"471\":3,\"476\":2,\"477\":9,\"479\":1,\"483\":1,\"487\":1,\"489\":1,\"490\":1,\"491\":1,\"510\":3,\"511\":3,\"514\":1,\"515\":6,\"529\":1,\"530\":1,\"531\":3,\"532\":2,\"957\":17,\"1014\":1,\"1021\":2,\"1024\":2,\"1031\":2,\"1036\":1,\"1037\":1,\"1040\":2,\"1059\":4}}],[\"func1\",{\"1\":{\"30\":2}}],[\"fun1\",{\"1\":{\"30\":1}}],[\"flush就一定会被调用\",{\"1\":{\"952\":1}}],[\"flush\",{\"1\":{\"756\":5,\"765\":1,\"767\":1,\"810\":18,\"820\":1,\"840\":1}}],[\"float64\",{\"1\":{\"463\":3,\"470\":6,\"483\":1,\"485\":1,\"486\":1,\"491\":1}}],[\"float\",{\"1\":{\"455\":1}}],[\"flood\",{\"1\":{\"243\":2}}],[\"flags\",{\"1\":{\"873\":1}}],[\"flag\",{\"1\":{\"226\":2}}],[\"fsync使用后台线程异步刷盘\",{\"1\":{\"952\":1}}],[\"fsync刷盘\",{\"1\":{\"952\":1}}],[\"fsync\",{\"1\":{\"760\":6,\"766\":1,\"767\":1,\"810\":14,\"952\":1}}],[\"fs\",{\"1\":{\"226\":4,\"957\":1}}],[\"fd==listenfd\",{\"1\":{\"226\":1}}],[\"fds\",{\"1\":{\"226\":10}}],[\"fd\",{\"1\":{\"226\":20}}],[\"fdl\",{\"1\":{\"223\":2}}],[\"found\",{\"1\":{\"514\":1,\"676\":1,\"1062\":1}}],[\"foo\",{\"1\":{\"229\":7}}],[\"fox\",{\"1\":{\"190\":1}}],[\"follower节点\",{\"1\":{\"710\":1}}],[\"follower节点同步数据\",{\"1\":{\"710\":1}}],[\"follower副本存储在其他节点上\",{\"1\":{\"174\":1,\"180\":1}}],[\"follower副本\",{\"1\":{\"174\":1}}],[\"follower副本不能直接向分区写入数据\",{\"1\":{\"170\":1}}],[\"follower\",{\"0\":{\"173\":1,\"174\":1},\"1\":{\"173\":1,\"177\":2,\"181\":2,\"810\":1}}],[\"follower是指kafka集群中的一个分区副本\",{\"1\":{\"170\":1}}],[\"folower\",{\"1\":{\"170\":1}}],[\"forward\",{\"1\":{\"681\":1,\"885\":1}}],[\"forname\",{\"1\":{\"553\":2,\"556\":1,\"557\":1,\"558\":1}}],[\"formfile\",{\"1\":{\"1037\":2}}],[\"form\",{\"1\":{\"817\":1,\"1037\":1,\"1041\":2}}],[\"form提交时忽略实体\",{\"1\":{\"488\":1}}],[\"format=statement\",{\"1\":{\"820\":1}}],[\"format变量查看\",{\"1\":{\"770\":1}}],[\"format\",{\"1\":{\"229\":1,\"600\":2,\"770\":6,\"820\":1,\"966\":1}}],[\"fork\",{\"1\":{\"217\":2,\"952\":6}}],[\"forever\",{\"1\":{\"121\":2}}],[\"for\",{\"0\":{\"451\":1,\"452\":1,\"453\":1},\"1\":{\"33\":2,\"46\":1,\"88\":2,\"226\":4,\"367\":1,\"374\":1,\"412\":1,\"413\":1,\"415\":1,\"426\":1,\"450\":1,\"451\":3,\"452\":4,\"453\":7,\"458\":1,\"505\":2,\"510\":2,\"511\":2,\"515\":6,\"531\":1,\"532\":1,\"555\":1,\"568\":1,\"693\":1,\"783\":2,\"794\":1,\"795\":1,\"820\":15,\"848\":1,\"986\":1,\"993\":2}}],[\"f\",{\"1\":{\"137\":3,\"142\":2,\"202\":1,\"209\":1,\"237\":1,\"442\":1,\"532\":2,\"957\":1,\"979\":1}}],[\"ff\",{\"1\":{\"121\":6,\"770\":3}}],[\"fmt包下的print系列\",{\"1\":{\"467\":1}}],[\"fmt\",{\"1\":{\"88\":1,\"367\":2,\"410\":2,\"453\":2,\"458\":3,\"460\":2,\"462\":1,\"464\":2,\"466\":3,\"469\":2,\"470\":2,\"471\":3,\"472\":1,\"476\":1,\"477\":6,\"483\":4,\"487\":2,\"489\":2,\"490\":2,\"491\":2,\"496\":2,\"497\":3,\"499\":2,\"500\":2,\"502\":2,\"503\":2,\"511\":6,\"514\":3,\"515\":7,\"976\":2,\"986\":1,\"989\":2,\"990\":1,\"991\":1,\"992\":2,\"993\":2,\"994\":1,\"1001\":6,\"1002\":1,\"1003\":1,\"1004\":1,\"1005\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":1,\"1014\":2,\"1021\":2,\"1035\":1,\"1036\":1,\"1037\":7,\"1039\":1,\"1040\":2,\"1041\":1,\"1042\":1,\"1059\":5}}],[\"filter执行顺序问题\",{\"0\":{\"608\":1}}],[\"filter类路径错误\",{\"1\":{\"607\":1}}],[\"filter不生效\",{\"0\":{\"607\":1}}],[\"filter不是一个标准的servlet\",{\"1\":{\"578\":1}}],[\"filter链示例\",{\"0\":{\"596\":1}}],[\"filter链的执行顺序由以下因素决定\",{\"1\":{\"595\":1}}],[\"filter链的执行顺序\",{\"0\":{\"595\":1}}],[\"filter链的概念\",{\"0\":{\"594\":1}}],[\"filter链工作原理\",{\"1\":{\"594\":1}}],[\"filter链是指多个filter按照特定顺序依次处理请求和响应的机制\",{\"1\":{\"594\":1}}],[\"filter链\",{\"0\":{\"593\":1}}],[\"filter可以\",{\"1\":{\"591\":1}}],[\"filter可以通过filterconfig获取配置参数\",{\"1\":{\"590\":1}}],[\"filter生命周期\",{\"0\":{\"589\":1}}],[\"filter>\",{\"1\":{\"588\":1}}],[\"filter的生命周期由servlet容器管理\",{\"1\":{\"589\":1}}],[\"filter的url模式匹配规则与servlet相同\",{\"1\":{\"587\":1}}],[\"filter的作用\",{\"0\":{\"579\":1}}],[\"filtername\",{\"1\":{\"586\":1,\"596\":2}}],[\"filter也使用urlpattern来定义哪些请求会被过滤\",{\"1\":{\"585\":1}}],[\"filterchain\",{\"1\":{\"584\":1,\"591\":1,\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"683\":1}}],[\"filterconfig\",{\"1\":{\"584\":2,\"590\":4,\"599\":3,\"683\":2}}],[\"filter快速入门\",{\"0\":{\"580\":1}}],[\"filter在web应用中主要用于以下场景\",{\"1\":{\"579\":1}}],[\"filter具有以下特点\",{\"1\":{\"578\":1}}],[\"filter\",{\"0\":{\"601\":1,\"683\":1},\"1\":{\"578\":2,\"584\":2,\"588\":5,\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"683\":1,\"930\":1},\"2\":{\"611\":1}}],[\"filter概述\",{\"0\":{\"577\":1}}],[\"filter是java\",{\"1\":{\"576\":1}}],[\"filter过滤器的核心概念\",{\"1\":{\"576\":1}}],[\"filter学习笔记\",{\"0\":{\"576\":1}}],[\"fileheader\",{\"1\":{\"1037\":7}}],[\"file>\",{\"1\":{\"854\":2}}],[\"file=<path\",{\"1\":{\"854\":1}}],[\"filepart\",{\"1\":{\"693\":3}}],[\"fileuploadservlet\",{\"1\":{\"693\":1}}],[\"fileupload或servlet\",{\"1\":{\"693\":1}}],[\"filereader\",{\"1\":{\"541\":1,\"542\":1}}],[\"filename是目标路径\",{\"1\":{\"1037\":1}}],[\"filename=\",{\"1\":{\"1032\":2}}],[\"filename\",{\"1\":{\"425\":3,\"693\":3,\"1037\":2}}],[\"file\",{\"1\":{\"6\":1,\"113\":1,\"202\":2,\"229\":1,\"425\":4,\"693\":1,\"770\":2,\"810\":2,\"813\":2,\"817\":1,\"952\":1,\"957\":4,\"1032\":1,\"1037\":4}}],[\"filesort\",{\"1\":{\"813\":1}}],[\"filesort或using\",{\"1\":{\"807\":1}}],[\"filesort和using\",{\"1\":{\"807\":1}}],[\"filesizethreshold\",{\"1\":{\"693\":1}}],[\"files\",{\"1\":{\"3\":1,\"201\":1}}],[\"field\",{\"1\":{\"557\":3,\"957\":4}}],[\"fieldreflection\",{\"1\":{\"557\":1}}],[\"fields\",{\"1\":{\"502\":1,\"557\":1,\"957\":3}}],[\"fieldnumber\",{\"1\":{\"229\":1}}],[\"fieldname\",{\"1\":{\"229\":1}}],[\"first\",{\"1\":{\"265\":1,\"817\":2,\"980\":1,\"988\":1}}],[\"firefox\",{\"1\":{\"249\":2}}],[\"fi\",{\"1\":{\"249\":1}}],[\"fizz\",{\"1\":{\"229\":5}}],[\"fizz的导入路径\",{\"1\":{\"229\":1}}],[\"finishd\",{\"1\":{\"249\":1}}],[\"finduser\",{\"1\":{\"546\":1}}],[\"find\",{\"1\":{\"211\":2,\"992\":2,\"993\":2,\"994\":2,\"995\":1,\"1001\":6,\"1002\":1,\"1003\":1,\"1004\":1,\"1005\":1,\"1006\":1,\"1007\":1,\"1008\":1,\"1012\":1}}],[\"final修饰的变量叫常量\",{\"1\":{\"570\":1}}],[\"final修饰的方法不能被重写\",{\"1\":{\"570\":1}}],[\"final修饰的类不能被继承\",{\"1\":{\"570\":1}}],[\"final关键字的作用\",{\"0\":{\"570\":1}}],[\"finally块总是执行\",{\"1\":{\"540\":1}}],[\"finally\",{\"0\":{\"540\":1},\"1\":{\"540\":1,\"600\":1}}],[\"final\",{\"1\":{\"33\":1,\"568\":1,\"600\":1,\"625\":1,\"637\":1,\"638\":1,\"641\":1}}],[\"failed\",{\"1\":{\"483\":2,\"487\":1,\"489\":1,\"490\":1,\"491\":1,\"957\":10}}],[\"fatal\",{\"0\":{\"510\":1,\"511\":1},\"1\":{\"478\":1,\"509\":1,\"510\":2,\"511\":1,\"956\":1,\"957\":2}}],[\"family\",{\"1\":{\"226\":2}}],[\"factor\",{\"1\":{\"177\":1}}],[\"fasttop\",{\"1\":{\"33\":1}}],[\"false\",{\"1\":{\"3\":1,\"183\":1,\"265\":5,\"374\":1,\"436\":1,\"529\":2,\"531\":4,\"598\":1,\"957\":2,\"979\":2,\"1001\":1,\"1005\":1}}],[\"framework\",{\"0\":{\"1071\":1,\"1083\":1,\"1084\":1}}],[\"fragment\",{\"1\":{\"249\":1}}],[\"frequency\",{\"1\":{\"940\":1}}],[\"free释放内存后就会归还给操作系统\",{\"1\":{\"217\":1}}],[\"free内存后堆内存还存在\",{\"1\":{\"217\":1}}],[\"free不能执行构造函数和析构函数\",{\"1\":{\"33\":1}}],[\"free\",{\"1\":{\"33\":5,\"217\":3}}],[\"frm\",{\"1\":{\"770\":3}}],[\"fruits\",{\"1\":{\"503\":2}}],[\"from\",{\"1\":{\"33\":1,\"374\":1,\"794\":2,\"813\":13,\"817\":6,\"820\":13,\"823\":1,\"826\":1,\"842\":1,\"843\":1,\"847\":1,\"952\":1,\"988\":3,\"990\":1,\"1003\":1,\"1008\":1,\"1011\":1,\"1012\":2}}],[\"skipdefaulttransaction\",{\"1\":{\"978\":1}}],[\"skip\",{\"1\":{\"957\":2}}],[\"skiplist\",{\"1\":{\"876\":3}}],[\"s型锁\",{\"1\":{\"820\":1}}],[\"s锁\",{\"1\":{\"820\":1}}],[\"sg\",{\"1\":{\"265\":3}}],[\"span\",{\"1\":{\"885\":1}}],[\"space\",{\"1\":{\"217\":1}}],[\"springapplication\",{\"1\":{\"700\":1}}],[\"springbootapplication\",{\"1\":{\"700\":1}}],[\"spring\",{\"0\":{\"700\":1},\"1\":{\"699\":1,\"700\":1},\"2\":{\"702\":1}}],[\"spring是java平台的一个开源应用框架\",{\"1\":{\"697\":1}}],[\"spring框架\",{\"0\":{\"696\":1}}],[\"sprintf\",{\"1\":{\"515\":3,\"976\":1,\"986\":1}}],[\"sprintf等\",{\"1\":{\"362\":1}}],[\"splitn\",{\"1\":{\"502\":2}}],[\"split\",{\"1\":{\"502\":3,\"693\":1}}],[\"speaks\",{\"1\":{\"464\":2}}],[\"speak\",{\"1\":{\"464\":2}}],[\"spec\",{\"1\":{\"249\":3}}],[\"smembers\",{\"1\":{\"870\":1}}],[\"smart\",{\"1\":{\"867\":1}}],[\"smtp\",{\"1\":{\"249\":1}}],[\"smooth\",{\"1\":{\"3\":1}}],[\"smoothscrolling\",{\"1\":{\"3\":2}}],[\"sql错误\",{\"1\":{\"992\":1}}],[\"sqliz9879123\",{\"1\":{\"843\":1}}],[\"sqliz2\",{\"1\":{\"843\":1,\"844\":1}}],[\"sqliz\",{\"1\":{\"839\":1,\"843\":1,\"844\":1}}],[\"sql基础\",{\"2\":{\"831\":1}}],[\"sql语法错误\",{\"1\":{\"992\":1}}],[\"sql语法\",{\"2\":{\"831\":1}}],[\"sql语法详解\",{\"0\":{\"829\":1}}],[\"sql语句\",{\"1\":{\"817\":1}}],[\"sql执行顺序详解\",{\"0\":{\"823\":1}}],[\"sql执行流程\",{\"2\":{\"819\":1}}],[\"sql务必要写完整\",{\"1\":{\"807\":1}}],[\"sql优化\",{\"2\":{\"825\":1,\"828\":1}}],[\"sql优化思路+经典案例分析\",{\"1\":{\"807\":1}}],[\"sql优化篇\",{\"1\":{\"807\":2}}],[\"sql解析优化执行\",{\"1\":{\"800\":1}}],[\"sql解析器首先会对查询语句进行语法和词法分析\",{\"1\":{\"734\":1}}],[\"sql解析器\",{\"1\":{\"734\":1}}],[\"sqlexception\",{\"1\":{\"538\":1}}],[\"sql\",{\"0\":{\"1076\":1},\"1\":{\"243\":2,\"730\":1,\"733\":1,\"761\":1,\"807\":5,\"810\":2,\"813\":4,\"817\":27,\"820\":5,\"823\":1,\"826\":1,\"829\":3,\"854\":1,\"855\":2,\"980\":1}}],[\"square\",{\"1\":{\"33\":12}}],[\"salt\",{\"1\":{\"1056\":1}}],[\"samplingconfig\",{\"1\":{\"957\":2}}],[\"sampling\",{\"1\":{\"957\":5}}],[\"samplemessage\",{\"1\":{\"229\":1}}],[\"saveuploadedfile\",{\"1\":{\"1037\":1}}],[\"saveuploadedfile会将上传的文件保存到服务器上的指定路径\",{\"1\":{\"1037\":1}}],[\"save保存所有字段\",{\"0\":{\"997\":1}}],[\"save\",{\"1\":{\"952\":5,\"997\":1,\"998\":2}}],[\"sakila\",{\"1\":{\"855\":2}}],[\"safe\",{\"1\":{\"810\":5}}],[\"safeservlet\",{\"1\":{\"689\":1}}],[\"sadd\",{\"1\":{\"714\":1,\"870\":1}}],[\"sayhello\",{\"1\":{\"33\":1,\"462\":2}}],[\"scrypt和pbkdf2\",{\"1\":{\"1054\":1}}],[\"scroe\",{\"1\":{\"813\":1}}],[\"sc\",{\"1\":{\"676\":2,\"836\":1}}],[\"sce\",{\"1\":{\"624\":4,\"640\":3,\"684\":2}}],[\"scan\",{\"1\":{\"1009\":1,\"1010\":1,\"1011\":1}}],[\"scanner\",{\"1\":{\"394\":1}}],[\"scard\",{\"1\":{\"870\":1}}],[\"scalar\",{\"1\":{\"229\":1}}],[\"schema\",{\"1\":{\"820\":9,\"979\":1}}],[\"schemalocation=\",{\"1\":{\"658\":1}}],[\"scheme\",{\"1\":{\"249\":2}}],[\"sched\",{\"1\":{\"374\":9}}],[\"score\",{\"1\":{\"447\":1,\"491\":4,\"813\":9,\"885\":5}}],[\"scores\",{\"1\":{\"229\":1}}],[\"scope>\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"scope\",{\"1\":{\"121\":1}}],[\"srem\",{\"1\":{\"870\":1}}],[\"sre\",{\"1\":{\"626\":4}}],[\"srtuct\",{\"1\":{\"441\":1}}],[\"srv\",{\"1\":{\"223\":2}}],[\"src=\",{\"1\":{\"249\":1}}],[\"src\",{\"1\":{\"113\":2,\"229\":1}}],[\"sdshdr64\",{\"1\":{\"873\":1}}],[\"sdshdr32\",{\"1\":{\"873\":1}}],[\"sdshdr16\",{\"1\":{\"873\":1}}],[\"sdshdr8\",{\"1\":{\"873\":5}}],[\"sds使用len属性的值\",{\"1\":{\"873\":1}}],[\"sds\",{\"1\":{\"873\":16,\"885\":1}}],[\"sdiff\",{\"1\":{\"870\":1}}],[\"sdb\",{\"1\":{\"223\":1}}],[\"sda\",{\"1\":{\"223\":1}}],[\"sdk\",{\"1\":{\"101\":1}}],[\"sbin是\",{\"1\":{\"223\":1}}],[\"sbin\",{\"1\":{\"223\":8}}],[\"syn\",{\"1\":{\"243\":1}}],[\"syntax\",{\"1\":{\"229\":1}}],[\"synchronizedset\",{\"1\":{\"641\":1}}],[\"synchronized\",{\"1\":{\"568\":1}}],[\"syncmap\",{\"1\":{\"508\":1},\"2\":{\"534\":1}}],[\"syncmap包的源码学习\",{\"0\":{\"508\":1}}],[\"sync\",{\"0\":{\"509\":1,\"512\":1,\"513\":1,\"516\":1,\"526\":1,\"527\":1,\"528\":1},\"1\":{\"204\":1,\"367\":2,\"509\":1,\"512\":3,\"515\":3,\"516\":1,\"520\":1,\"527\":3,\"760\":4,\"765\":1,\"767\":1,\"810\":26,\"956\":1,\"957\":6}}],[\"sys\",{\"1\":{\"223\":3}}],[\"systemctl\",{\"1\":{\"835\":2}}],[\"system和const通常表示已经使用了索引\",{\"1\":{\"807\":1}}],[\"systemd+\",{\"1\":{\"147\":1}}],[\"system\",{\"1\":{\"33\":1,\"113\":1,\"223\":2,\"243\":1,\"540\":4,\"541\":2,\"542\":2,\"543\":2,\"555\":9,\"556\":2,\"557\":1,\"558\":3,\"559\":4,\"584\":6,\"590\":1,\"591\":2,\"592\":1,\"596\":4,\"600\":2,\"624\":4,\"625\":5,\"626\":4,\"633\":3,\"634\":3,\"635\":6,\"637\":2,\"638\":2,\"640\":3,\"641\":4,\"662\":3,\"683\":2,\"684\":2,\"699\":1,\"807\":1,\"817\":1}}],[\"sscan\",{\"1\":{\"870\":1}}],[\"ssd\",{\"1\":{\"807\":1}}],[\"ssa\",{\"1\":{\"394\":1,\"395\":1}}],[\"ssl\",{\"1\":{\"249\":3}}],[\"ss\",{\"1\":{\"199\":1,\"410\":2}}],[\"source\",{\"1\":{\"855\":3}}],[\"source=\",{\"1\":{\"113\":1}}],[\"source=my\",{\"1\":{\"110\":1}}],[\"solr\",{\"1\":{\"813\":1}}],[\"sorted\",{\"1\":{\"876\":1}}],[\"sort\",{\"1\":{\"813\":3}}],[\"sockfd\",{\"1\":{\"226\":7}}],[\"sockaddr结构体\",{\"1\":{\"226\":2}}],[\"sockaddr\",{\"1\":{\"226\":10}}],[\"socket\",{\"1\":{\"226\":43,\"237\":1},\"2\":{\"228\":1}}],[\"sock\",{\"1\":{\"104\":1,\"226\":3}}],[\"slave\",{\"1\":{\"810\":1}}],[\"slowthreshold\",{\"1\":{\"980\":1}}],[\"slots\",{\"1\":{\"723\":1}}],[\"slot\",{\"1\":{\"723\":1}}],[\"slogan\",{\"1\":{\"489\":5}}],[\"slice\",{\"1\":{\"333\":1,\"336\":1,\"337\":1,\"344\":3,\"452\":1,\"458\":1},\"2\":{\"348\":1}}],[\"slidingwindow\",{\"1\":{\"88\":1}}],[\"sleep\",{\"1\":{\"104\":3,\"515\":1}}],[\"semantics\",{\"1\":{\"952\":1}}],[\"segment\",{\"1\":{\"770\":3}}],[\"serialversionuid\",{\"1\":{\"637\":1,\"638\":1}}],[\"serializable\",{\"1\":{\"637\":2,\"638\":2,\"782\":1}}],[\"servlet是单例多线程的\",{\"1\":{\"689\":1}}],[\"servlet是java\",{\"1\":{\"644\":1}}],[\"servlet高级特性\",{\"0\":{\"679\":1}}],[\"servletoutputstream\",{\"1\":{\"677\":1}}],[\"servletpath\",{\"1\":{\"672\":1}}],[\"servlet体系结构\",{\"0\":{\"667\":1}}],[\"servlet接口是所有servlet必须直接或间接实现的接口\",{\"1\":{\"664\":1}}],[\"servlet接口\",{\"0\":{\"664\":1},\"1\":{\"667\":1}}],[\"servlet方法介绍与体系结构\",{\"0\":{\"663\":1}}],[\"servlet实例在容器中通常是单例的\",{\"1\":{\"662\":1}}],[\"servlet销毁中\",{\"1\":{\"662\":1}}],[\"servlet处理请求中\",{\"1\":{\"662\":1}}],[\"servlet处理请求并生成响应\",{\"1\":{\"661\":1}}],[\"servlet初始化中\",{\"1\":{\"662\":1}}],[\"servletconfig\",{\"1\":{\"662\":1,\"664\":1}}],[\"servletcontext属性替换\",{\"1\":{\"633\":1}}],[\"servletcontext属性移除\",{\"1\":{\"633\":1}}],[\"servletcontext属性添加\",{\"1\":{\"633\":1}}],[\"servletcontextattributeevent\",{\"1\":{\"633\":4}}],[\"servletcontextattributelistener\",{\"0\":{\"633\":1},\"1\":{\"619\":1,\"633\":2}}],[\"servletcontextevent\",{\"1\":{\"624\":3,\"640\":2,\"684\":2}}],[\"servletcontextlistener的生命周期与web应用的生命周期紧密相关\",{\"1\":{\"629\":1}}],[\"servletcontextlistener生命周期\",{\"0\":{\"629\":1}}],[\"servletcontextlistener\",{\"1\":{\"619\":1,\"624\":2,\"640\":1,\"684\":1}}],[\"servletcontext相关监听器\",{\"0\":{\"619\":1}}],[\"servletcontext\",{\"1\":{\"590\":1,\"624\":3,\"640\":1}}],[\"servlet的生命周期包含以下阶段\",{\"1\":{\"662\":1}}],[\"servlet的执行流程如下\",{\"1\":{\"661\":1}}],[\"servlet的作用\",{\"0\":{\"647\":1}}],[\"servlet执行流程与生命周期\",{\"0\":{\"660\":1}}],[\"servlet>\",{\"1\":{\"658\":1}}],[\"servlet支持以下几种url模式匹配规则\",{\"1\":{\"655\":1}}],[\"servlet快速入门\",{\"0\":{\"648\":1}}],[\"servlet在web应用中主要承担以下职责\",{\"1\":{\"647\":1}}],[\"servlet在web服务器的地址空间内执行\",{\"1\":{\"646\":1}}],[\"servlet具有以下优势\",{\"1\":{\"646\":1}}],[\"servlet充当web浏览器或其他http客户端与后端数据库或应用程序之间的中间层\",{\"1\":{\"646\":1}}],[\"servlet概述\",{\"0\":{\"645\":1}}],[\"servlet技术的核心概念\",{\"1\":{\"644\":1}}],[\"servlet学习笔记\",{\"0\":{\"644\":1}}],[\"servlet规范定义了多种类型的listener\",{\"1\":{\"618\":1}}],[\"servlet规范中定义的组件\",{\"1\":{\"578\":1,\"614\":1}}],[\"servletresponse\",{\"1\":{\"584\":1,\"591\":1,\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"664\":1,\"683\":1}}],[\"servletrequestattributeevent\",{\"1\":{\"635\":4}}],[\"servletrequestattributelistener\",{\"0\":{\"635\":1},\"1\":{\"621\":1,\"635\":2}}],[\"servletrequestevent\",{\"1\":{\"626\":3}}],[\"servletrequestlistener的生命周期与servletrequest的生命周期相关\",{\"1\":{\"631\":1}}],[\"servletrequestlistener生命周期\",{\"0\":{\"631\":1}}],[\"servletrequestlistener\",{\"1\":{\"621\":1,\"626\":2}}],[\"servletrequest相关监听器\",{\"0\":{\"621\":1}}],[\"servletrequest\",{\"1\":{\"584\":1,\"591\":1,\"596\":2,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"626\":3,\"664\":1,\"683\":1}}],[\"servletexception\",{\"1\":{\"584\":2,\"590\":1,\"591\":1,\"596\":2,\"598\":1,\"599\":2,\"600\":1,\"601\":1,\"652\":2,\"662\":2,\"683\":2,\"693\":1}}],[\"servlet\",{\"1\":{\"583\":2,\"584\":3,\"623\":2,\"624\":4,\"625\":4,\"626\":5,\"633\":3,\"634\":3,\"635\":4,\"637\":2,\"638\":2,\"646\":1,\"651\":2,\"652\":7,\"658\":5,\"681\":1,\"682\":1},\"2\":{\"695\":1}}],[\"servlet<\",{\"1\":{\"583\":1,\"623\":1,\"651\":1,\"652\":1}}],[\"servlet容器根据url找到对应的servlet\",{\"1\":{\"661\":1}}],[\"servlet容器会创建servletrequest\",{\"1\":{\"631\":1}}],[\"servlet容器会创建servletcontext\",{\"1\":{\"629\":1}}],[\"servlet容器会创建httpsession\",{\"1\":{\"630\":1}}],[\"servlet容器会调用所有servletrequestlistener的requestdestroyed\",{\"1\":{\"631\":1}}],[\"servlet容器会调用所有servletcontextlistener的contextdestroyed\",{\"1\":{\"629\":1}}],[\"servlet容器会调用所有httpsessionlistener的sessiondestroyed\",{\"1\":{\"630\":1}}],[\"servlet容器会调用filter的destroy\",{\"1\":{\"592\":1}}],[\"servlet容器会调用filter的dofilter\",{\"1\":{\"591\":1}}],[\"servlet容器会为每个filter创建一个实例\",{\"1\":{\"590\":1}}],[\"servlet容器\",{\"1\":{\"581\":1,\"617\":1,\"649\":1}}],[\"services\",{\"1\":{\"586\":2,\"817\":1}}],[\"service\",{\"1\":{\"223\":1,\"229\":1,\"662\":2,\"664\":1,\"699\":5,\"835\":2,\"962\":2,\"969\":1}}],[\"server层\",{\"1\":{\"737\":1,\"817\":2}}],[\"server\",{\"0\":{\"159\":1},\"1\":{\"147\":1,\"156\":1,\"177\":1,\"249\":10,\"646\":1,\"737\":2,\"747\":1,\"759\":3,\"810\":4,\"813\":12,\"817\":17,\"906\":2,\"962\":3,\"966\":2,\"969\":1}}],[\"se\",{\"1\":{\"625\":4,\"638\":4,\"641\":3}}],[\"sec\",{\"1\":{\"770\":11,\"817\":2,\"820\":7}}],[\"secure\",{\"1\":{\"692\":1}}],[\"secondsdurationencoder\",{\"1\":{\"957\":2}}],[\"seconds\",{\"1\":{\"911\":1}}],[\"second\",{\"1\":{\"515\":1,\"957\":4,\"980\":1}}],[\"secret\",{\"1\":{\"249\":2,\"1059\":2}}],[\"sep\",{\"1\":{\"502\":2,\"503\":1}}],[\"sequential\",{\"1\":{\"254\":1}}],[\"sequence\",{\"1\":{\"92\":1}}],[\"sessiondidactivate方法会被调用\",{\"1\":{\"638\":1}}],[\"sessiondidactivate\",{\"1\":{\"638\":1}}],[\"sessiondestroyed\",{\"1\":{\"625\":1,\"641\":1}}],[\"sessionwillpassivate方法会被调用\",{\"1\":{\"638\":1}}],[\"sessionwillpassivate\",{\"1\":{\"638\":1}}],[\"sessionid\",{\"1\":{\"634\":6,\"637\":4,\"638\":4}}],[\"sessionattributelistener\",{\"1\":{\"634\":1}}],[\"sessioncreated\",{\"1\":{\"625\":1,\"641\":1}}],[\"sessioncountlistener<\",{\"1\":{\"627\":1}}],[\"sessioncountlistener\",{\"1\":{\"625\":1}}],[\"session信息占用的空间就不容忽视\",{\"1\":{\"249\":1}}],[\"session信息是存储在服务端的\",{\"1\":{\"249\":1}}],[\"session的实现主要两种方式\",{\"1\":{\"249\":1}}],[\"session和cookie没有直接的关系\",{\"1\":{\"249\":1}}],[\"session机制将用户的所有活动信息\",{\"1\":{\"249\":1}}],[\"session代表服务器与浏览器的一次会话过程\",{\"1\":{\"249\":1}}],[\"session\",{\"1\":{\"249\":4,\"598\":3,\"625\":5,\"637\":2,\"638\":1,\"641\":2,\"673\":1,\"691\":2,\"820\":11,\"988\":2}}],[\"sex\",{\"1\":{\"229\":5}}],[\"select选择字段\",{\"0\":{\"1006\":1}}],[\"selected\",{\"1\":{\"265\":1}}],[\"select并没有太大的本质区别\",{\"1\":{\"226\":1}}],[\"select调用过程\",{\"1\":{\"226\":1}}],[\"select\",{\"0\":{\"734\":1},\"1\":{\"226\":12,\"510\":1,\"511\":1,\"730\":1,\"735\":1,\"743\":2,\"747\":1,\"759\":1,\"770\":1,\"783\":3,\"785\":1,\"793\":2,\"794\":2,\"795\":1,\"810\":4,\"813\":16,\"817\":9,\"820\":39,\"823\":2,\"829\":2,\"842\":3,\"843\":1,\"846\":1,\"988\":3,\"990\":1,\"998\":1,\"1003\":1,\"1006\":1,\"1008\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":3}}],[\"sendredirect\",{\"1\":{\"598\":1,\"678\":1,\"682\":1}}],[\"senderror\",{\"1\":{\"676\":1}}],[\"sender\",{\"1\":{\"265\":1}}],[\"sendx索引自增1\",{\"1\":{\"264\":1}}],[\"sendq\",{\"1\":{\"265\":2}}],[\"sendq是写操作阻塞在channel的goroutine列表\",{\"1\":{\"261\":1}}],[\"sendq和recvq字段\",{\"0\":{\"259\":1}}],[\"send\",{\"1\":{\"226\":3,\"888\":1}}],[\"searchservice\",{\"1\":{\"229\":2}}],[\"searchrequest\",{\"1\":{\"229\":2}}],[\"searchresponse\",{\"1\":{\"229\":4}}],[\"searchreponse\",{\"1\":{\"229\":1}}],[\"search\",{\"0\":{\"135\":1},\"1\":{\"135\":1,\"229\":2,\"813\":1}}],[\"setlevel\",{\"1\":{\"957\":2}}],[\"setnx\",{\"1\":{\"873\":2,\"910\":1,\"921\":1}}],[\"setname\",{\"1\":{\"558\":1}}],[\"setnamemethod\",{\"1\":{\"558\":2}}],[\"set类型详解\",{\"0\":{\"870\":1}}],[\"setstatus\",{\"1\":{\"676\":1}}],[\"setsize限制\",{\"1\":{\"226\":1}}],[\"set<string>\",{\"1\":{\"641\":2}}],[\"setmode\",{\"1\":{\"1027\":1}}],[\"setmaxinactiveinterval\",{\"1\":{\"691\":1}}],[\"setmaxpoolsize\",{\"1\":{\"640\":1}}],[\"setminpoolsize\",{\"1\":{\"640\":1}}],[\"setpassword\",{\"1\":{\"640\":1}}],[\"setuser\",{\"1\":{\"640\":1}}],[\"setjdbcurl\",{\"1\":{\"640\":1}}],[\"setdriverclass\",{\"1\":{\"640\":1}}],[\"setters\",{\"1\":{\"637\":1}}],[\"settings\",{\"1\":{\"3\":2}}],[\"setattribute\",{\"1\":{\"624\":1,\"625\":1,\"626\":1,\"637\":1,\"638\":1,\"640\":1}}],[\"setaccessible\",{\"1\":{\"557\":1}}],[\"setheader\",{\"1\":{\"601\":4,\"675\":1,\"692\":1}}],[\"setcontenttype\",{\"1\":{\"599\":1,\"652\":1,\"675\":1,\"688\":1}}],[\"setcharacterencoding\",{\"1\":{\"599\":2,\"687\":1,\"688\":1}}],[\"set\",{\"1\":{\"23\":1,\"226\":2,\"249\":2,\"557\":1,\"692\":1,\"714\":1,\"735\":1,\"763\":1,\"770\":5,\"810\":4,\"817\":1,\"820\":4,\"840\":1,\"841\":2,\"870\":3,\"873\":2,\"876\":1,\"911\":1,\"930\":1,\"937\":1,\"939\":1,\"1013\":1},\"2\":{\"872\":1}}],[\"snapshot\",{\"1\":{\"785\":2}}],[\"snmp\",{\"1\":{\"243\":1}}],[\"snippets\",{\"1\":{\"229\":2}}],[\"snippetspreventquicksuggestions\",{\"1\":{\"3\":1}}],[\"snowflake\",{\"1\":{\"92\":1}}],[\"shouldbindjson\",{\"1\":{\"1042\":1}}],[\"shouldbind会根据请求的content\",{\"1\":{\"1041\":1}}],[\"shouldbinduri\",{\"1\":{\"1040\":1}}],[\"shouldbindquery\",{\"1\":{\"1039\":1}}],[\"shouldbindquery会根据结构体字段的form标签从url查询参数中解析数据\",{\"1\":{\"1039\":1}}],[\"shouldbind\",{\"1\":{\"1038\":1,\"1041\":1}}],[\"show\",{\"1\":{\"759\":1,\"770\":2,\"810\":1,\"817\":2,\"826\":1,\"836\":2,\"842\":1,\"848\":1}}],[\"shoppingcart\",{\"1\":{\"638\":3}}],[\"shortcallerencoder\",{\"1\":{\"957\":3}}],[\"short\",{\"1\":{\"226\":1,\"249\":1,\"568\":1}}],[\"shutdown\",{\"1\":{\"204\":3}}],[\"shel\",{\"1\":{\"190\":1}}],[\"shell\",{\"1\":{\"190\":18},\"2\":{\"192\":1,\"213\":1}}],[\"shell用户和组管理详解\",{\"0\":{\"190\":1}}],[\"sh脚本\",{\"1\":{\"177\":1}}],[\"sh\",{\"1\":{\"119\":1,\"177\":1,\"190\":2}}],[\"shim\",{\"1\":{\"103\":1,\"104\":2}}],[\"shrink\",{\"1\":{\"88\":1}}],[\"shape\",{\"1\":{\"463\":1,\"470\":7}}],[\"sha256\",{\"1\":{\"249\":2}}],[\"share\",{\"1\":{\"223\":1,\"820\":4}}],[\"sharedstate\",{\"1\":{\"689\":2}}],[\"shared\",{\"1\":{\"33\":1}}],[\"shadow\",{\"1\":{\"190\":1}}],[\"sha\",{\"1\":{\"73\":1,\"723\":1,\"1054\":2}}],[\"sismember\",{\"1\":{\"870\":1}}],[\"sismember和\",{\"1\":{\"714\":1}}],[\"significant\",{\"1\":{\"940\":2}}],[\"signed\",{\"1\":{\"813\":1}}],[\"signature\",{\"1\":{\"240\":3,\"249\":4}}],[\"site\",{\"1\":{\"489\":4}}],[\"simple\",{\"1\":{\"249\":3}}],[\"singulartable\",{\"1\":{\"979\":1}}],[\"single\",{\"1\":{\"395\":1,\"820\":1}}],[\"sinter\",{\"1\":{\"870\":1}}],[\"sin\",{\"1\":{\"226\":12}}],[\"sink\",{\"1\":{\"52\":1}}],[\"sizemask\",{\"1\":{\"864\":2}}],[\"sizeof参数可以是任何数据的类型或者数据\",{\"1\":{\"33\":1}}],[\"sizeof\",{\"1\":{\"33\":6,\"226\":4,\"441\":4}}],[\"size\",{\"1\":{\"20\":1,\"134\":1,\"211\":1,\"226\":2,\"641\":5,\"755\":1,\"810\":2,\"813\":1,\"864\":3,\"983\":4,\"1037\":1}}],[\"s2\",{\"1\":{\"33\":1,\"496\":1}}],[\"s\",{\"1\":{\"33\":4,\"88\":4,\"100\":1,\"209\":2,\"210\":1,\"226\":10,\"374\":2,\"392\":3,\"410\":5,\"412\":3,\"413\":3,\"423\":2,\"466\":3,\"470\":2,\"483\":1,\"487\":1,\"489\":1,\"490\":1,\"497\":3,\"499\":2,\"500\":4,\"502\":3,\"503\":1,\"514\":2,\"515\":2,\"600\":4,\"817\":1,\"820\":29,\"927\":1,\"952\":1,\"957\":2,\"976\":5,\"983\":4}}],[\"s修改\",{\"1\":{\"33\":1}}],[\"swagger\",{\"1\":{\"962\":2}}],[\"swarm\",{\"1\":{\"119\":1}}],[\"swaplocked\",{\"1\":{\"531\":2}}],[\"swap\",{\"1\":{\"217\":6,\"531\":3}}],[\"swap2\",{\"1\":{\"30\":2}}],[\"swap1\",{\"1\":{\"30\":2}}],[\"swim\",{\"1\":{\"52\":1}}],[\"switch\",{\"0\":{\"450\":1},\"1\":{\"9\":1,\"568\":1,\"992\":1}}],[\"s1\",{\"1\":{\"30\":2,\"33\":2,\"496\":1}}],[\"storage\",{\"1\":{\"770\":3,\"817\":1}}],[\"store\",{\"0\":{\"531\":1},\"1\":{\"514\":3,\"515\":1,\"530\":1,\"531\":3,\"532\":1}}],[\"stop\",{\"1\":{\"143\":1,\"835\":2}}],[\"st\",{\"1\":{\"447\":1,\"448\":1}}],[\"steve\",{\"1\":{\"190\":1}}],[\"sticky\",{\"1\":{\"165\":1}}],[\"stime\",{\"1\":{\"147\":1}}],[\"stacktrace\",{\"1\":{\"957\":1}}],[\"stacktracekey\",{\"1\":{\"957\":2}}],[\"stackoverflowerror\",{\"1\":{\"538\":1}}],[\"sta\",{\"1\":{\"826\":1}}],[\"status\",{\"1\":{\"229\":1,\"820\":2,\"826\":2}}],[\"statement\",{\"1\":{\"810\":7,\"820\":1}}],[\"state\",{\"1\":{\"121\":1,\"689\":2}}],[\"staticfile\",{\"1\":{\"1033\":1}}],[\"static等修饰符所修饰\",{\"1\":{\"571\":1}}],[\"static关键字\",{\"1\":{\"33\":1}}],[\"static\",{\"1\":{\"33\":3,\"249\":1,\"395\":1,\"540\":2,\"541\":1,\"542\":2,\"543\":2,\"555\":1,\"556\":1,\"557\":1,\"558\":2,\"559\":1,\"568\":1,\"600\":1,\"625\":2,\"637\":1,\"638\":1,\"641\":3,\"700\":1,\"1033\":4}}],[\"startswith\",{\"1\":{\"693\":1}}],[\"starttime\",{\"1\":{\"584\":2,\"600\":2,\"626\":3}}],[\"started\",{\"1\":{\"229\":1}}],[\"start\",{\"1\":{\"33\":2,\"143\":1,\"760\":1,\"785\":4,\"810\":1,\"820\":1,\"835\":2,\"836\":1}}],[\"strictfp\",{\"1\":{\"568\":1}}],[\"stringdurationencoder\",{\"1\":{\"957\":1}}],[\"string类型详解\",{\"0\":{\"873\":1}}],[\"string类型零值是\",{\"1\":{\"487\":1}}],[\"stringbuffer\",{\"1\":{\"672\":1}}],[\"strings包\",{\"2\":{\"507\":1}}],[\"strings\",{\"0\":{\"505\":1},\"1\":{\"496\":4,\"497\":6,\"499\":4,\"500\":6,\"502\":5,\"503\":4,\"505\":2}}],[\"stringstruct的使用\",{\"0\":{\"354\":1}}],[\"stringtype\",{\"1\":{\"441\":2}}],[\"stringheader\",{\"1\":{\"441\":1}}],[\"string转化为byte切片\",{\"0\":{\"359\":1}}],[\"string与\",{\"1\":{\"357\":1}}],[\"string可以被重新赋值\",{\"1\":{\"356\":1}}],[\"string和\",{\"0\":{\"356\":1}}],[\"string\",{\"1\":{\"88\":1,\"229\":10,\"410\":2,\"425\":1,\"437\":1,\"440\":1,\"447\":1,\"455\":1,\"462\":3,\"464\":1,\"472\":1,\"483\":3,\"485\":1,\"486\":1,\"487\":4,\"488\":3,\"489\":15,\"490\":2,\"491\":2,\"496\":2,\"497\":3,\"499\":4,\"500\":8,\"502\":6,\"503\":6,\"505\":2,\"540\":1,\"541\":2,\"542\":3,\"543\":1,\"545\":4,\"546\":2,\"553\":3,\"556\":2,\"557\":3,\"558\":4,\"559\":6,\"584\":3,\"590\":1,\"598\":1,\"599\":2,\"600\":4,\"624\":2,\"626\":4,\"633\":3,\"634\":6,\"635\":6,\"637\":8,\"638\":2,\"640\":3,\"641\":10,\"670\":3,\"671\":1,\"672\":3,\"687\":2,\"689\":2,\"693\":5,\"699\":2,\"700\":1,\"770\":7,\"841\":1,\"873\":4,\"879\":1,\"894\":1,\"937\":2,\"946\":1,\"957\":19,\"979\":2,\"982\":2,\"983\":6,\"993\":1,\"995\":1,\"1001\":1,\"1003\":1,\"1013\":1,\"1021\":3,\"1024\":1,\"1028\":1,\"1030\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1,\"1043\":2,\"1059\":4},\"2\":{\"365\":1,\"875\":1}}],[\"str\",{\"1\":{\"483\":2,\"487\":2,\"488\":1,\"489\":5,\"490\":2,\"553\":2}}],[\"stream相对来说在轻量级里相对完善\",{\"1\":{\"924\":1}}],[\"stream功能最全\",{\"1\":{\"924\":1}}],[\"stream\",{\"1\":{\"226\":3,\"924\":2,\"1032\":2}}],[\"strategy这个配置\",{\"1\":{\"165\":1}}],[\"strlen的参数只能是字符指针且结尾是\",{\"1\":{\"33\":1}}],[\"strlen是字符处理的库函数\",{\"1\":{\"33\":1}}],[\"strlen\",{\"1\":{\"33\":2,\"226\":2}}],[\"structure\",{\"0\":{\"1064\":1}}],[\"struct\",{\"1\":{\"30\":3,\"226\":6,\"344\":3,\"410\":1,\"447\":1,\"462\":3,\"463\":1,\"464\":2,\"466\":1,\"470\":2,\"471\":1,\"483\":3,\"485\":1,\"486\":1,\"487\":3,\"488\":1,\"489\":5,\"490\":3,\"491\":1,\"516\":3,\"522\":1,\"940\":1,\"942\":1,\"944\":1,\"957\":1,\"979\":1,\"982\":1,\"983\":2,\"1010\":1,\"1013\":1,\"1021\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":1,\"1043\":1}}],[\"stdlogger\",{\"1\":{\"957\":1}}],[\"stdout\",{\"1\":{\"957\":2,\"980\":1}}],[\"stderr\",{\"1\":{\"957\":5}}],[\"std\",{\"1\":{\"33\":34}}],[\"stuent\",{\"1\":{\"820\":1}}],[\"study\",{\"1\":{\"770\":1}}],[\"studentlist\",{\"1\":{\"986\":4,\"992\":2,\"993\":6,\"994\":4,\"995\":1}}],[\"student这个对象上面就有该记录的信息了\",{\"1\":{\"985\":1}}],[\"studentinfo\",{\"1\":{\"983\":2}}],[\"students\",{\"1\":{\"979\":2,\"983\":1,\"988\":5,\"990\":1,\"1003\":1,\"1008\":1,\"1009\":1,\"1010\":1,\"1011\":1,\"1012\":2}}],[\"studentregister\",{\"1\":{\"410\":2}}],[\"student\",{\"1\":{\"33\":12,\"229\":1,\"410\":3,\"447\":2,\"448\":1,\"820\":2,\"979\":3,\"982\":2,\"983\":1,\"985\":3,\"986\":2,\"988\":5,\"989\":8,\"990\":5,\"991\":6,\"992\":3,\"993\":6,\"994\":1,\"997\":5,\"998\":5,\"999\":5,\"1001\":1,\"1002\":1,\"1006\":2,\"1007\":1,\"1008\":4,\"1011\":4,\"1012\":3}}],[\"stu\",{\"1\":{\"30\":7}}],[\"sugar\",{\"1\":{\"957\":15}}],[\"sugaredlogger\",{\"1\":{\"957\":6}}],[\"suggest\",{\"1\":{\"3\":1}}],[\"sunion\",{\"1\":{\"870\":1}}],[\"supremum\",{\"1\":{\"820\":1}}],[\"super\",{\"1\":{\"545\":6,\"568\":1,\"662\":3}}],[\"supervisor\",{\"1\":{\"220\":1}}],[\"supercharge\",{\"1\":{\"11\":1}}],[\"suffix\",{\"1\":{\"500\":1}}],[\"sum\",{\"1\":{\"458\":6,\"962\":1}}],[\"suite\",{\"1\":{\"249\":1}}],[\"success\",{\"1\":{\"249\":1}}],[\"subscribe\",{\"1\":{\"924\":1}}],[\"substring\",{\"1\":{\"693\":1}}],[\"substr\",{\"1\":{\"497\":2}}],[\"sub\",{\"1\":{\"229\":1,\"924\":2}}],[\"submessage\",{\"1\":{\"229\":1}}],[\"su\",{\"1\":{\"205\":1}}],[\"sudog和goroutine之间存在绑定关系\",{\"1\":{\"261\":1}}],[\"sudog结构\",{\"0\":{\"261\":1}}],[\"sudo\",{\"1\":{\"104\":1,\"223\":2,\"835\":4}}],[\"availability\",{\"0\":{\"1073\":1}}],[\"avg\",{\"1\":{\"944\":1,\"1012\":2}}],[\"a>\",{\"1\":{\"1032\":1}}],[\"a>100\",{\"1\":{\"813\":1}}],[\"a>1\",{\"1\":{\"813\":1}}],[\"aof达到多大会重写\",{\"1\":{\"952\":1}}],[\"aof\",{\"1\":{\"949\":5,\"952\":21},\"2\":{\"951\":1,\"954\":1}}],[\"aof优化\",{\"1\":{\"949\":1}}],[\"aof混合持久化详解\",{\"0\":{\"949\":1}}],[\"aop\",{\"1\":{\"698\":1},\"2\":{\"702\":1}}],[\"a=2\",{\"1\":{\"813\":2}}],[\"a=1\",{\"1\":{\"813\":6}}],[\"a=6\",{\"1\":{\"36\":1}}],[\"a+i+d\",{\"1\":{\"775\":1}}],[\"a++\",{\"1\":{\"33\":4}}],[\"a和a\",{\"1\":{\"770\":1}}],[\"ahead\",{\"1\":{\"751\":1,\"810\":1}}],[\"authentication\",{\"1\":{\"841\":1}}],[\"authenticationfilter\",{\"1\":{\"596\":6,\"598\":1}}],[\"authorization\",{\"1\":{\"601\":1}}],[\"automigrate\",{\"1\":{\"982\":1,\"1013\":1}}],[\"automigrate的逻辑是只新增\",{\"1\":{\"982\":1}}],[\"autoinc\",{\"1\":{\"820\":7}}],[\"autocommit\",{\"1\":{\"739\":1,\"810\":1,\"820\":1}}],[\"auto\",{\"1\":{\"33\":2,\"770\":2,\"820\":16}}],[\"autosave\",{\"1\":{\"3\":1}}],[\"advanced\",{\"0\":{\"1069\":1}}],[\"admin\",{\"1\":{\"546\":3,\"587\":2}}],[\"addstacktrace\",{\"1\":{\"957\":1}}],[\"addcaller\",{\"1\":{\"957\":1}}],[\"addcallerskip\",{\"1\":{\"957\":3}}],[\"additem\",{\"1\":{\"638\":1}}],[\"adding\",{\"1\":{\"559\":1}}],[\"adduser\",{\"1\":{\"559\":3}}],[\"addr\",{\"1\":{\"226\":9,\"983\":3}}],[\"address\",{\"1\":{\"104\":1,\"121\":1,\"246\":1}}],[\"add\",{\"1\":{\"33\":5,\"36\":2,\"226\":2,\"367\":1,\"515\":4,\"641\":2,\"655\":1,\"969\":1}}],[\"amended\",{\"1\":{\"516\":3,\"529\":2,\"531\":2,\"532\":2}}],[\"ae\",{\"1\":{\"897\":1}}],[\"aemain\",{\"1\":{\"897\":2}}],[\"aeiou\",{\"1\":{\"497\":1}}],[\"aes\",{\"1\":{\"73\":1,\"249\":2}}],[\"ab\",{\"1\":{\"813\":2}}],[\"abd\",{\"1\":{\"496\":1}}],[\"ab都为1的位\",{\"1\":{\"446\":1}}],[\"abcd\",{\"1\":{\"1033\":1}}],[\"abc都能走索引\",{\"1\":{\"813\":1}}],[\"abc\",{\"1\":{\"440\":2,\"441\":2,\"496\":1,\"813\":2,\"1033\":1}}],[\"abstract\",{\"1\":{\"568\":1}}],[\"abs\",{\"1\":{\"33\":1}}],[\"asc\",{\"1\":{\"1007\":1}}],[\"ascii\",{\"1\":{\"770\":7}}],[\"async\",{\"1\":{\"952\":1}}],[\"aside也是如此\",{\"1\":{\"930\":1}}],[\"aside中\",{\"1\":{\"930\":1}}],[\"aside一样\",{\"1\":{\"930\":1}}],[\"aside模式的区别主要在于\",{\"1\":{\"930\":1}}],[\"aside模式是一般是先更新数据库\",{\"1\":{\"930\":1}}],[\"aside适用于读多写少的场景\",{\"1\":{\"930\":1}}],[\"aside\",{\"1\":{\"930\":6}}],[\"as\",{\"1\":{\"468\":1,\"813\":1,\"1010\":1}}],[\"ast\",{\"1\":{\"395\":1}}],[\"assertion\",{\"1\":{\"468\":1}}],[\"assertlockheld\",{\"1\":{\"374\":1}}],[\"assignor的策略是一样\",{\"1\":{\"165\":1}}],[\"assignor\",{\"1\":{\"165\":3}}],[\"assignment\",{\"1\":{\"165\":1,\"395\":1}}],[\"attempt\",{\"1\":{\"957\":8}}],[\"attributename\",{\"1\":{\"637\":4}}],[\"attributereplaced\",{\"1\":{\"633\":1,\"634\":1,\"635\":1,\"641\":1}}],[\"attributeremoved\",{\"1\":{\"633\":1,\"634\":1,\"635\":1,\"641\":1}}],[\"attributeadded\",{\"1\":{\"633\":1,\"634\":1,\"635\":1,\"641\":1}}],[\"attachment\",{\"1\":{\"1032\":1}}],[\"attachment表示这是一个附件\",{\"1\":{\"1032\":1}}],[\"attach\",{\"1\":{\"149\":2}}],[\"atomiclevel\",{\"1\":{\"957\":1}}],[\"atomicity\",{\"1\":{\"774\":1,\"810\":1}}],[\"atomicinteger\",{\"1\":{\"625\":3}}],[\"atomic\",{\"1\":{\"265\":2,\"516\":3,\"522\":2,\"625\":1}}],[\"at\",{\"1\":{\"243\":1,\"705\":2,\"756\":5,\"765\":1,\"810\":11}}],[\"always策略\",{\"1\":{\"952\":1}}],[\"always\",{\"1\":{\"952\":1}}],[\"alter\",{\"1\":{\"820\":1,\"829\":1,\"841\":2,\"843\":1,\"844\":1,\"846\":1}}],[\"allkeys\",{\"1\":{\"900\":4,\"906\":2}}],[\"alloc\",{\"1\":{\"873\":4}}],[\"allows\",{\"1\":{\"952\":1}}],[\"allow\",{\"1\":{\"229\":1,\"601\":3}}],[\"all表示全表扫描\",{\"1\":{\"807\":1}}],[\"allmethods\",{\"1\":{\"558\":1}}],[\"allfields\",{\"1\":{\"557\":1}}],[\"all\",{\"1\":{\"515\":1,\"710\":1,\"807\":1,\"817\":3,\"846\":1}}],[\"alice\",{\"1\":{\"557\":1}}],[\"alive\",{\"1\":{\"237\":2,\"249\":4}}],[\"alive头部字段来管理连接的持久性和空闲超时\",{\"1\":{\"237\":1}}],[\"alive和keep\",{\"1\":{\"237\":1}}],[\"alias选项\",{\"1\":{\"229\":1}}],[\"alias\",{\"1\":{\"229\":2}}],[\"algorithm\",{\"1\":{\"92\":1}}],[\"agge\",{\"1\":{\"1010\":3}}],[\"aggegroup\",{\"1\":{\"1010\":2}}],[\"age字段对应请求头中的\",{\"1\":{\"1043\":1}}],[\"age字段对应表单数据或查询参数中的\",{\"1\":{\"1041\":1}}],[\"age字段对应url查询参数中的\",{\"1\":{\"1039\":1}}],[\"age=123\",{\"1\":{\"1035\":1}}],[\"age=315360000\",{\"1\":{\"249\":1}}],[\"agelist\",{\"1\":{\"1009\":3}}],[\"agent\",{\"1\":{\"249\":4,\"671\":1,\"1043\":2}}],[\"age和\",{\"1\":{\"229\":1}}],[\"age和sex三个属性\",{\"1\":{\"229\":1}}],[\"age\",{\"1\":{\"229\":2,\"249\":1,\"410\":4,\"447\":1,\"483\":4,\"485\":1,\"486\":1,\"543\":4,\"601\":1,\"770\":4,\"813\":4,\"817\":7,\"820\":1,\"826\":3,\"873\":2,\"979\":2,\"985\":1,\"986\":1,\"997\":1,\"998\":2,\"1001\":1,\"1002\":2,\"1003\":2,\"1004\":1,\"1006\":1,\"1007\":1,\"1009\":2,\"1012\":4,\"1035\":3,\"1037\":5,\"1039\":5,\"1041\":5,\"1042\":2,\"1043\":3}}],[\"again\",{\"1\":{\"190\":1}}],[\"another\",{\"1\":{\"678\":1}}],[\"annotations\",{\"1\":{\"962\":1}}],[\"annotation\",{\"1\":{\"584\":1,\"624\":1,\"625\":1,\"626\":1,\"633\":1,\"634\":1,\"635\":1,\"652\":1}}],[\"animal\",{\"1\":{\"464\":4}}],[\"anything\",{\"1\":{\"957\":1}}],[\"any\",{\"1\":{\"229\":4,\"516\":4,\"522\":2,\"529\":2,\"531\":5,\"532\":1,\"957\":1,\"1003\":1,\"1021\":2}}],[\"any监听所有网卡的端口\",{\"1\":{\"226\":1}}],[\"and\",{\"1\":{\"23\":1,\"33\":3,\"425\":1,\"510\":1,\"637\":1,\"770\":1,\"807\":1,\"813\":21,\"817\":2,\"829\":1,\"940\":1,\"1001\":1,\"1003\":1}}],[\"affected\",{\"1\":{\"770\":8,\"817\":1,\"820\":4}}],[\"af\",{\"1\":{\"226\":5,\"770\":157}}],[\"after\",{\"1\":{\"33\":2,\"559\":1,\"957\":2}}],[\"afterdelay\",{\"1\":{\"3\":1}}],[\"ack\",{\"1\":{\"924\":2}}],[\"acks参数是否是每次producer发送消息都要携带\",{\"1\":{\"710\":1}}],[\"acks是producer端配置的\",{\"1\":{\"710\":1}}],[\"acks\",{\"1\":{\"180\":1,\"709\":1,\"710\":2}}],[\"account\",{\"1\":{\"838\":1,\"843\":3,\"844\":1,\"846\":2}}],[\"access\",{\"1\":{\"601\":4,\"940\":1}}],[\"accepttcphandeler\",{\"1\":{\"897\":1}}],[\"accept\",{\"1\":{\"226\":3,\"249\":7,\"888\":3}}],[\"ac\",{\"1\":{\"813\":1}}],[\"acb\",{\"1\":{\"813\":1}}],[\"actor\",{\"1\":{\"807\":1}}],[\"activemq\",{\"1\":{\"924\":1}}],[\"activesessions\",{\"1\":{\"625\":4}}],[\"active\",{\"1\":{\"217\":1}}],[\"acid特性\",{\"1\":{\"801\":1}}],[\"acid\",{\"0\":{\"775\":1},\"1\":{\"810\":1},\"2\":{\"798\":1}}],[\"acquiresudog\",{\"1\":{\"265\":1}}],[\"aaaaasaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",{\"1\":{\"770\":1}}],[\"aaaaaa|\",{\"1\":{\"770\":2}}],[\"aaa表空间\",{\"1\":{\"752\":1}}],[\"aaa\",{\"1\":{\"211\":1}}],[\"artifactid>\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"arithmeticexception\",{\"1\":{\"540\":1}}],[\"area\",{\"1\":{\"463\":2,\"470\":7}}],[\"arp\",{\"1\":{\"249\":2}}],[\"architecture\",{\"1\":{\"243\":1}}],[\"args\",{\"1\":{\"540\":1,\"542\":1,\"543\":1,\"556\":1,\"557\":1,\"558\":1,\"559\":3,\"700\":2}}],[\"argv\",{\"1\":{\"226\":1}}],[\"argc\",{\"1\":{\"226\":1}}],[\"ar\",{\"1\":{\"181\":2}}],[\"arr3\",{\"1\":{\"344\":1}}],[\"arr2\",{\"1\":{\"344\":1}}],[\"arraylist<>\",{\"1\":{\"638\":1}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"538\":1}}],[\"array\",{\"1\":{\"344\":3}}],[\"arr1\",{\"1\":{\"344\":1}}],[\"arr\",{\"1\":{\"30\":2,\"426\":4,\"453\":6}}],[\"aq\",{\"1\":{\"137\":1,\"142\":1}}],[\"apache\",{\"1\":{\"249\":2}}],[\"apt\",{\"1\":{\"223\":2}}],[\"appcontextlistener\",{\"1\":{\"684\":1}}],[\"app>\",{\"1\":{\"658\":1}}],[\"appinitlistener<\",{\"1\":{\"627\":1}}],[\"appinitlistener\",{\"1\":{\"624\":1}}],[\"append|os\",{\"1\":{\"957\":2}}],[\"appendfsync\",{\"1\":{\"952\":3}}],[\"append\",{\"1\":{\"453\":4,\"952\":1,\"986\":1}}],[\"applet\",{\"1\":{\"646\":1}}],[\"apple\",{\"1\":{\"449\":1,\"502\":3,\"503\":2}}],[\"applicationresourcemanager\",{\"1\":{\"640\":1}}],[\"application\",{\"0\":{\"1072\":1,\"1079\":1},\"1\":{\"249\":2,\"700\":2,\"962\":1,\"1032\":1}}],[\"applications\",{\"1\":{\"223\":1}}],[\"app\",{\"1\":{\"110\":1,\"113\":1,\"658\":2,\"659\":1}}],[\"api的完整功能集\",{\"1\":{\"646\":1}}],[\"api<\",{\"1\":{\"583\":1,\"623\":1,\"651\":1}}],[\"api依赖\",{\"1\":{\"583\":2,\"623\":2,\"651\":2}}],[\"api\",{\"1\":{\"101\":1,\"226\":1,\"584\":1,\"586\":3,\"588\":1,\"873\":2,\"897\":1,\"957\":2,\"962\":4,\"969\":4}}],[\"api操作\",{\"0\":{\"52\":1}}],[\"a<b\",{\"1\":{\"36\":1}}],[\"a查看\",{\"1\":{\"33\":1}}],[\"a是10的别名\",{\"1\":{\"30\":1}}],[\"a\",{\"1\":{\"30\":16,\"33\":15,\"36\":5,\"46\":6,\"104\":2,\"140\":1,\"142\":1,\"177\":2,\"201\":1,\"229\":2,\"374\":1,\"415\":2,\"423\":5,\"427\":2,\"440\":1,\"441\":4,\"442\":3,\"446\":1,\"460\":2,\"464\":1,\"466\":5,\"467\":1,\"468\":2,\"496\":1,\"540\":2,\"770\":2,\"775\":1,\"793\":8,\"794\":2,\"810\":3,\"813\":21,\"820\":36,\"912\":1,\"921\":1,\"930\":1}}],[\"ai\",{\"0\":{\"12\":1}}],[\"一页多少条\",{\"1\":{\"1008\":1}}],[\"一行代码\",{\"1\":{\"957\":1}}],[\"一行记录除了\",{\"1\":{\"770\":1}}],[\"一行记录是怎么存储的\",{\"1\":{\"770\":2}}],[\"一起批量写入\",{\"1\":{\"930\":1}}],[\"一起使用的时候\",{\"1\":{\"820\":1}}],[\"一起使用进行文本搜索\",{\"1\":{\"211\":1}}],[\"一文带你快速入门\",{\"1\":{\"917\":1,\"921\":1}}],[\"一文go起来\",{\"1\":{\"432\":1}}],[\"一定不会感到满意\",{\"1\":{\"957\":1}}],[\"一定概率增加访问次数\",{\"1\":{\"903\":1}}],[\"一定是\",{\"1\":{\"33\":1}}],[\"一年没访问了\",{\"1\":{\"903\":1}}],[\"一共占了多少字节数\",{\"1\":{\"879\":1}}],[\"一批消息等\",{\"1\":{\"867\":1}}],[\"一批是多少\",{\"1\":{\"374\":1}}],[\"一是性能很差\",{\"1\":{\"810\":1}}],[\"一张表最多最多\",{\"1\":{\"807\":1}}],[\"一致性\",{\"1\":{\"774\":1}}],[\"一致性哈希算法是解决分布式系统中数据分布问题的一种重要方法\",{\"1\":{\"82\":1}}],[\"一致性哈希算法\",{\"0\":{\"82\":1}}],[\"一些大对象如\",{\"1\":{\"770\":1}}],[\"一些疑问\",{\"1\":{\"710\":1}}],[\"一条更新语句执行完成\",{\"1\":{\"810\":1}}],[\"一条查询语句经历的过程\",{\"1\":{\"810\":1}}],[\"一条查询语句执行的过程\",{\"1\":{\"734\":1}}],[\"一条记录更新完了\",{\"1\":{\"810\":2}}],[\"一条记录的过程\",{\"1\":{\"810\":1}}],[\"一条记录的每一次更新操作产生的\",{\"1\":{\"742\":1,\"810\":1}}],[\"一条记录有\",{\"1\":{\"770\":1}}],[\"一条记录时\",{\"1\":{\"741\":3,\"810\":4}}],[\"一条\",{\"0\":{\"734\":1,\"735\":1},\"1\":{\"817\":1}}],[\"一份全量数据给\",{\"1\":{\"520\":1}}],[\"一直是分布式场景的恶龙\",{\"1\":{\"927\":1}}],[\"一直循环\",{\"1\":{\"897\":1}}],[\"一直都是单线程\",{\"1\":{\"891\":1}}],[\"一直重复上述过程\",{\"1\":{\"817\":1}}],[\"一直到\",{\"1\":{\"810\":1}}],[\"一直到提升幅度很小\",{\"1\":{\"807\":1}}],[\"一直跟这个事务启动时看到的数据是一致的\",{\"1\":{\"783\":1}}],[\"一直向上传递\",{\"1\":{\"479\":1}}],[\"一直存在\",{\"1\":{\"104\":1}}],[\"一种是时间上的灵活性\",{\"1\":{\"930\":1}}],[\"一种情况例外\",{\"1\":{\"571\":1}}],[\"一种循环方式\",{\"1\":{\"450\":1}}],[\"一种特殊\",{\"1\":{\"125\":1}}],[\"一次发很多请求过来\",{\"1\":{\"927\":1}}],[\"一次\",{\"1\":{\"810\":1}}],[\"一次最少把内存中的\",{\"1\":{\"770\":1}}],[\"一次最少从磁盘中读取\",{\"1\":{\"770\":1}}],[\"一次是\",{\"1\":{\"766\":1,\"810\":3}}],[\"一次大的操作由多个小操作组成\",{\"1\":{\"727\":1}}],[\"一次编译\",{\"1\":{\"564\":1}}],[\"一次调度流程是怎么样的\",{\"0\":{\"373\":1},\"1\":{\"367\":1}}],[\"一次为当前的hchan结构和buf数组分配一块连续的内存空间\",{\"1\":{\"263\":1}}],[\"一样的\",{\"1\":{\"994\":1}}],[\"一样也是在插入数据的时候\",{\"1\":{\"820\":1}}],[\"一样会被认为事务已经执行成功\",{\"1\":{\"765\":1,\"810\":1}}],[\"一样\",{\"1\":{\"249\":1,\"307\":1}}],[\"一旦新aof文件创建完毕\",{\"1\":{\"952\":1}}],[\"一旦写入缓存\",{\"1\":{\"930\":1}}],[\"一旦出现\",{\"1\":{\"820\":1}}],[\"一旦出现问题\",{\"1\":{\"249\":1}}],[\"一旦消息被写入并确认\",{\"1\":{\"710\":1}}],[\"一旦连接到服务器\",{\"1\":{\"249\":1}}],[\"一旦t类型对象的引用计数为0\",{\"1\":{\"33\":1}}],[\"一发一收\",{\"1\":{\"249\":1}}],[\"一经发现与关键词相匹配的请求则立即伪装成目标域名的服务器\",{\"1\":{\"243\":1}}],[\"一切皆文件\",{\"1\":{\"237\":1}}],[\"一分钟后关机\",{\"1\":{\"204\":1}}],[\"一台机器确定某个关键词是要在自己这里处理\",{\"1\":{\"79\":1}}],[\"一般专指\",{\"1\":{\"1037\":1}}],[\"一般情况linux会每30秒刷一次盘\",{\"1\":{\"952\":1}}],[\"一般指是指热键在过期失效的一瞬间\",{\"1\":{\"930\":1}}],[\"一般而言\",{\"1\":{\"930\":1}}],[\"一般说明是用脚本在跑\",{\"1\":{\"927\":1}}],[\"一般来说\",{\"1\":{\"915\":1,\"921\":1}}],[\"一般来说执行会很快\",{\"1\":{\"891\":1}}],[\"一般来说我们自己在浏览器上下载的软件\",{\"1\":{\"223\":1}}],[\"一般值的区分性要足够高\",{\"1\":{\"813\":1}}],[\"一般我们为了避免日志丢失的风险\",{\"1\":{\"810\":1}}],[\"一般会依托第三方组件实现\",{\"1\":{\"909\":1,\"921\":1}}],[\"一般会\",{\"1\":{\"810\":1}}],[\"一般为赋值表达式\",{\"1\":{\"451\":2}}],[\"一般用于声明全局变量\",{\"1\":{\"437\":1}}],[\"一般用模板实现\",{\"1\":{\"33\":1}}],[\"一般计算器算不出来\",{\"1\":{\"249\":1}}],[\"一般是缓存时间到期\",{\"1\":{\"930\":1}}],[\"一般是前几位表示类型\",{\"1\":{\"879\":1}}],[\"一般是通过业务主键\",{\"1\":{\"727\":1}}],[\"一般是空文件夹\",{\"1\":{\"223\":1}}],[\"一般是\",{\"1\":{\"217\":1}}],[\"一般加override可以确保是重写父类的函数\",{\"1\":{\"33\":1}}],[\"一般主张使用引用传递\",{\"1\":{\"33\":1}}],[\"一个子进程来执行快照\",{\"1\":{\"952\":1}}],[\"一个子进程来专门做\",{\"1\":{\"952\":1}}],[\"一个子进程做快照\",{\"1\":{\"952\":1}}],[\"一个数据库\",{\"1\":{\"930\":1}}],[\"一个数字证书通常包含\",{\"1\":{\"249\":1}}],[\"一个数字证书\",{\"1\":{\"249\":1}}],[\"一个缓存\",{\"1\":{\"930\":1}}],[\"一个线程本身也占据内存大小\",{\"1\":{\"891\":1}}],[\"一个单线程在一次完整的处理中\",{\"1\":{\"888\":1}}],[\"一个特殊的\",{\"1\":{\"879\":1}}],[\"一个特殊的包含问题描述信息的\",{\"1\":{\"249\":1}}],[\"一个拥有间隙锁\",{\"1\":{\"820\":2}}],[\"一个处于空闲状态的连接被服务端主动断开后\",{\"1\":{\"817\":1}}],[\"一个词语来形容就是博大精深\",{\"1\":{\"813\":1}}],[\"一个主库一般跟\",{\"1\":{\"810\":1}}],[\"一个主题可以被分为多个分区\",{\"1\":{\"157\":1}}],[\"一个用户最多只能抢到n份\",{\"1\":{\"927\":1}}],[\"一个用户请求最终会分配一条线程处理\",{\"1\":{\"807\":1}}],[\"一个用户可以同时属于多个组\",{\"1\":{\"190\":1}}],[\"一个复杂查询\",{\"1\":{\"807\":1}}],[\"一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁\",{\"1\":{\"820\":1}}],[\"一个事务要插入订单\",{\"1\":{\"820\":1}}],[\"一个事务在插入一条记录的时候\",{\"1\":{\"820\":1}}],[\"一个事务在持有\",{\"1\":{\"820\":1}}],[\"一个事务持有了范围为\",{\"1\":{\"820\":2}}],[\"一个事务提交后才释放\",{\"1\":{\"820\":1}}],[\"一个事务读到了另一个已修改的数据但是未提交事务\",{\"1\":{\"777\":1}}],[\"一个事务中的所有操作\",{\"1\":{\"774\":1}}],[\"一个事务的\",{\"1\":{\"760\":1,\"810\":1}}],[\"一个字符最多需要三个字节\",{\"1\":{\"770\":1}}],[\"一个页的大小一般是\",{\"1\":{\"770\":1}}],[\"一个页的默认大小为\",{\"1\":{\"748\":1,\"810\":1}}],[\"一个页空间会被划分成许多部分\",{\"1\":{\"748\":1}}],[\"一个接口中包含了其他接口\",{\"1\":{\"471\":1}}],[\"一个接口在多次调用的结果和调用一次的结果相同\",{\"1\":{\"23\":1}}],[\"一个简单的例子\",{\"1\":{\"466\":1}}],[\"一个类型可以实现多个接口\",{\"1\":{\"466\":1}}],[\"一个结构体只要实现了某个接口定义的所有方法\",{\"1\":{\"463\":1}}],[\"一个bmap结构体能存放8个键值对\",{\"1\":{\"325\":1}}],[\"一个包含图片的页面\",{\"1\":{\"249\":1}}],[\"一个\",{\"1\":{\"249\":2,\"378\":1,\"807\":1,\"813\":1,\"927\":1}}],[\"一个是便于精确计算\",{\"1\":{\"237\":1}}],[\"一个protos\",{\"1\":{\"229\":1}}],[\"一个典型的请求流程\",{\"1\":{\"249\":1}}],[\"一个典型的请求看起来就像这样\",{\"1\":{\"249\":1}}],[\"一个典型的\",{\"1\":{\"190\":1}}],[\"一个分区会有多个副本\",{\"1\":{\"181\":1}}],[\"一个消费者组里有多个消费者\",{\"1\":{\"165\":1}}],[\"一个组由一个groupid唯一标识\",{\"1\":{\"164\":1}}],[\"一个构造函数\",{\"1\":{\"33\":1}}],[\"一个非空的unique\",{\"1\":{\"33\":1}}],[\"一个引用含义\",{\"1\":{\"30\":1}}],[\"一个幂等性的接口\",{\"1\":{\"23\":1}}],[\"一\",{\"0\":{\"3\":1,\"96\":1,\"156\":1,\"169\":1,\"367\":1,\"509\":1,\"563\":1,\"704\":1},\"1\":{\"23\":2,\"157\":1,\"217\":1,\"226\":1,\"237\":1,\"240\":1,\"243\":1,\"727\":3,\"730\":1}}]],\"version\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
