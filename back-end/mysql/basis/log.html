<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.18" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.59" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://kryiea.cn/back-end/mysql/basis/log.html"><meta property="og:site_name" content="🧐kryiea"><meta property="og:title" content="MySQL日志系统"><meta property="og:description" content="从理解 SQL 执行过程到理解MySQL 日志系统的工作过程。"><meta property="og:type" content="article"><meta property="og:image" content="http://images.kryiea.cn/img/1717220312018.jpg"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-12-04T10:00:52.000Z"><meta property="article:tag" content="MVCC"><meta property="article:tag" content="日志"><meta property="article:published_time" content="2024-11-23T00:00:00.000Z"><meta property="article:modified_time" content="2024-12-04T10:00:52.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"MySQL日志系统","image":["http://images.kryiea.cn/img/1717220312018.jpg","http://images.kryiea.cn/img/20240601142819.png","http://images.kryiea.cn/img/1.png","http://images.kryiea.cn/img/20240601154137.png","http://images.kryiea.cn/img/mysql-BufferPool.drawio.png","http://images.kryiea.cn/img/mysql-4.drawio.png","http://images.kryiea.cn/img/mysql-1WAL.drawio.png","http://images.kryiea.cn/img/20240602172013.png","http://images.kryiea.cn/img/20240602173429.png","http://images.kryiea.cn/img/20240603001559.png","http://images.kryiea.cn/img/20240603002541.png","http://images.kryiea.cn/img/20240603005031.png","http://images.kryiea.cn/img/20240603010701.png"],"datePublished":"2024-11-23T00:00:00.000Z","dateModified":"2024-12-04T10:00:52.000Z","author":[{"@type":"Person","name":"kryiea","url":"https://github.com/kryiea","email":"kryieaa@outlook.com"}]}</script><title>MySQL日志系统 | 🧐kryiea</title><meta name="description" content="从理解 SQL 执行过程到理解MySQL 日志系统的工作过程。">
    <link rel="preload" href="/assets/style-CT-7IuSv.css" as="style"><link rel="stylesheet" href="/assets/style-CT-7IuSv.css">
    <link rel="modulepreload" href="/assets/app-Du3lVt_7.js"><link rel="modulepreload" href="/assets/log.html-D-VE9SSQ.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-vo6fMdMf.js" as="script"><link rel="prefetch" href="/assets/intro.html-Bige8RnH.js" as="script"><link rel="prefetch" href="/assets/index.html-mZ0g4EU2.js" as="script"><link rel="prefetch" href="/assets/vscode.html-BLxV0k7n.js" as="script"><link rel="prefetch" href="/assets/index.html-Z_kRLwJT.js" as="script"><link rel="prefetch" href="/assets/FrameworkAndcore.html-DfHKiDsf.js" as="script"><link rel="prefetch" href="/assets/index.html-BFHfGPEM.js" as="script"><link rel="prefetch" href="/assets/commands.html-J67Pj-dE.js" as="script"><link rel="prefetch" href="/assets/index.html-CS6f_q5F.js" as="script"><link rel="prefetch" href="/assets/index.html-BNJU7Gv3.js" as="script"><link rel="prefetch" href="/assets/index.html-DMfnpcvD.js" as="script"><link rel="prefetch" href="/assets/index.html-DsjfBX1L.js" as="script"><link rel="prefetch" href="/assets/demoToGmp.html-DVyc75YF.js" as="script"><link rel="prefetch" href="/assets/gmp.html-4MPVH79s.js" as="script"><link rel="prefetch" href="/assets/Compiler.html-CeToLNR7.js" as="script"><link rel="prefetch" href="/assets/memoryEscape.html-BJYg-lCi.js" as="script"><link rel="prefetch" href="/assets/multiReturns.html-CbPiYy6D.js" as="script"><link rel="prefetch" href="/assets/GrammarBasics.html-D8Nr6O0G.js" as="script"><link rel="prefetch" href="/assets/jsonPackage.html-BhBMRpEA.js" as="script"><link rel="prefetch" href="/assets/strings.html-l0xlWl_x.js" as="script"><link rel="prefetch" href="/assets/syncmap.html-DCjkuOhp.js" as="script"><link rel="prefetch" href="/assets/Concurrency.html-DZkxdg9k.js" as="script"><link rel="prefetch" href="/assets/JavaBasics.html-C69wOhHo.js" as="script"><link rel="prefetch" href="/assets/Filter.html-CJJHqe_x.js" as="script"><link rel="prefetch" href="/assets/Listener.html-CgDnw_Zz.js" as="script"><link rel="prefetch" href="/assets/Servlet.html-CVA5SOWY.js" as="script"><link rel="prefetch" href="/assets/Spring.html-BCIMEQW8.js" as="script"><link rel="prefetch" href="/assets/lock.html-DgShFdzC.js" as="script"><link rel="prefetch" href="/assets/dataInMemory.html-BdNCdKIm.js" as="script"><link rel="prefetch" href="/assets/404.html-Cy6PiPu-.js" as="script"><link rel="prefetch" href="/assets/index.html-D-y6LOcw.js" as="script"><link rel="prefetch" href="/assets/index.html-BMgnmUO4.js" as="script"><link rel="prefetch" href="/assets/index.html-BJD1m1w9.js" as="script"><link rel="prefetch" href="/assets/index.html-inZZddko.js" as="script"><link rel="prefetch" href="/assets/index.html-DuthliU6.js" as="script"><link rel="prefetch" href="/assets/index.html-D2YFgMdk.js" as="script"><link rel="prefetch" href="/assets/index.html-BLJJdPWb.js" as="script"><link rel="prefetch" href="/assets/index.html-BMrTp_SV.js" as="script"><link rel="prefetch" href="/assets/index.html-RddU81na.js" as="script"><link rel="prefetch" href="/assets/index.html-mEm6rdIm.js" as="script"><link rel="prefetch" href="/assets/index.html-nMRaxqOa.js" as="script"><link rel="prefetch" href="/assets/index.html-Dyi_9Kln.js" as="script"><link rel="prefetch" href="/assets/index.html-ASEWv5ms.js" as="script"><link rel="prefetch" href="/assets/index.html-DOSx2Rqt.js" as="script"><link rel="prefetch" href="/assets/index.html-CjYkeQWp.js" as="script"><link rel="prefetch" href="/assets/index.html-CuoHmT8a.js" as="script"><link rel="prefetch" href="/assets/index.html-MeSPZtgl.js" as="script"><link rel="prefetch" href="/assets/index.html-DrAykzlS.js" as="script"><link rel="prefetch" href="/assets/index.html-SaIiD97F.js" as="script"><link rel="prefetch" href="/assets/index.html-BT4eBjYf.js" as="script"><link rel="prefetch" href="/assets/index.html-BrkaZ_3N.js" as="script"><link rel="prefetch" href="/assets/index.html-CqNkyv_6.js" as="script"><link rel="prefetch" href="/assets/index.html-BlsG1yIk.js" as="script"><link rel="prefetch" href="/assets/index.html-YHr_vN7g.js" as="script"><link rel="prefetch" href="/assets/index.html-BhTnHIf7.js" as="script"><link rel="prefetch" href="/assets/index.html-D2FGo95X.js" as="script"><link rel="prefetch" href="/assets/index.html-CFLwGsOt.js" as="script"><link rel="prefetch" href="/assets/index.html-FkgLfy8L.js" as="script"><link rel="prefetch" href="/assets/index.html-Bq9eWDmp.js" as="script"><link rel="prefetch" href="/assets/index.html-Dnkwmqek.js" as="script"><link rel="prefetch" href="/assets/index.html-CAhCXe2-.js" as="script"><link rel="prefetch" href="/assets/index.html-BbZNKjAj.js" as="script"><link rel="prefetch" href="/assets/index.html-CWxCSAg6.js" as="script"><link rel="prefetch" href="/assets/index.html-DzokmZ3s.js" as="script"><link rel="prefetch" href="/assets/index.html-B-yrsBgs.js" as="script"><link rel="prefetch" href="/assets/index.html-xE1qcabx.js" as="script"><link rel="prefetch" href="/assets/index.html-DOYn7Zmz.js" as="script"><link rel="prefetch" href="/assets/index.html-BAic6nyb.js" as="script"><link rel="prefetch" href="/assets/index.html-BsW6F5ci.js" as="script"><link rel="prefetch" href="/assets/index.html-GC1V5Doe.js" as="script"><link rel="prefetch" href="/assets/index.html-UIrdIAXD.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-GXRgw7eJ.js" as="script"><link rel="prefetch" href="/assets/SearchResult-BNVUz7ZB.js" as="script"><link rel="prefetch" href="/assets/setupDevtools-7MC2TMWH-B9_iEMmB.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><!----><!----><span class="vp-site-name">🧐kryiea</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="首页"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->首页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="后端"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-yin-yang" style=""></span>后端<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/back-end/go/" aria-label="Go"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-golang" style=""></span><!--]-->Go<!----></a></li><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/back-end/mysql/" aria-label="MySQL"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-database" style=""></span><!--]-->MySQL<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/back-end/docker/" aria-label="Docker"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-docker" style=""></span><!--]-->Docker<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/back-end/redis/" aria-label="Redis"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-database" style=""></span><!--]-->Redis<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/back-end/java/" aria-label="Java"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-java" style=""></span><!--]-->Java<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/front-end/" aria-label="前端"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-masks-theater" style=""></span><!--]-->前端<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/devConfig/" aria-label="配置&amp;插件"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><!--]-->配置&amp;插件<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/intro.html" aria-label="关于"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-user" style=""></span><!--]-->关于<!----></a></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://kryiea.github.io/" target="_blank" rel="noopener noreferrer" aria-label="Source"><svg xmlns="http://www.w3.org/2000/svg" class="icon source-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="source icon" name="source" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M601.92 475.2c0 76.428-8.91 83.754-28.512 99.594-14.652 11.88-43.956 14.058-78.012 16.434-18.81 1.386-40.392 2.97-62.172 6.534-18.612 2.97-36.432 9.306-53.064 17.424V299.772c37.818-21.978 63.36-62.766 63.36-109.692 0-69.894-56.826-126.72-126.72-126.72S190.08 120.186 190.08 190.08c0 46.926 25.542 87.714 63.36 109.692v414.216c-37.818 21.978-63.36 62.766-63.36 109.692 0 69.894 56.826 126.72 126.72 126.72s126.72-56.826 126.72-126.72c0-31.086-11.286-59.598-29.7-81.576 13.266-9.504 27.522-17.226 39.996-19.206 16.038-2.574 32.868-3.762 50.688-5.148 48.312-3.366 103.158-7.326 148.896-44.55 61.182-49.698 74.25-103.158 75.24-187.902V475.2h-126.72zM316.8 126.72c34.848 0 63.36 28.512 63.36 63.36s-28.512 63.36-63.36 63.36-63.36-28.512-63.36-63.36 28.512-63.36 63.36-63.36zm0 760.32c-34.848 0-63.36-28.512-63.36-63.36s28.512-63.36 63.36-63.36 63.36 28.512 63.36 63.36-28.512 63.36-63.36 63.36zM823.68 158.4h-95.04V63.36h-126.72v95.04h-95.04v126.72h95.04v95.04h126.72v-95.04h95.04z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:none;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:block;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon" name="search"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fa-brands fa-golang" style=""></span><span class="vp-sidebar-title">Go</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fa-solid fa-database" style=""></span><span class="vp-sidebar-title">MySQL</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><span class="font-icon icon fa-fw fa-sm fa-solid fa-layer-group" style=""></span><span class="vp-sidebar-title">基础概念</span><!----></p><ul class="vp-sidebar-links"><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/back-end/mysql/basis/log.html" aria-label="MySQL日志系统"><!---->MySQL日志系统<!----></a></li></ul></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fa-brands fa-docker" style=""></span><span class="vp-sidebar-title">Docker</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fa-solid fa-database" style=""></span><span class="vp-sidebar-title">Redis</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fa-brands fa-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->MySQL日志系统</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/kryiea" target="_blank" rel="noopener noreferrer">kryiea</a></span><span property="author" content="kryiea"></span></span><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2024年11月23日</span><meta property="datePublished" content="2024-11-23T00:00:00.000Z"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon" name="category"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item color1 clickable" role="navigation">mysql</span><!--]--><meta property="articleSection" content="mysql"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon" name="tag"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item color1 clickable" role="navigation">MVCC</span><span class="page-tag-item color1 clickable" role="navigation">日志</span><!--]--><meta property="keywords" content="MVCC,日志"></span><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc" vp-toc><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#一、-一条-select-语句的执行过程">一、 一条 select 语句的执行过程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#二、一条-update-语句的执行过程">二、一条 update 语句的执行过程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#三、三种日志、mvcc、bufferpool-之间的相互配合">三、三种日志、MVCC、BufferPool 之间的相互配合</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-1-三种日志的主要作用">3.1 三种日志的主要作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-2-undolog-回滚日志">3.2 UndoLog 回滚日志</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-2-1-为什么需要-undolog">3.2.1 为什么需要 UndoLog</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-2-2-认识-undolog-机制">3.2.2 认识 Undolog 机制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-2-3-undolog-如何记录和回滚">3.2.3 Undolog 如何记录和回滚</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-2-4-undolog-日志的格式">3.2.4 Undolog 日志的格式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-2-5-undolog-readview-实现-mvcc">3.2.5 Undolog + ReadView 实现 MVCC</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-2-6-readview-机制">3.2.6 ReadView 机制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-2-7-undolog-如何刷盘的">3.2.7 UndoLog 如何刷盘的</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-3-buffer-pool-缓冲池">3.3 Buffer Pool 缓冲池</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-3-1-buffer-pool-的意义">3.3.1 Buffer Pool 的意义</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-3-2-buffer-pool-缓存什么">3.3.2 Buffer Pool 缓存什么</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-3-3-buffer-pool-刷盘策略">3.3.3 Buffer Pool 刷盘策略</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-4-redolog-重做日志">3.4 RedoLog 重做日志</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-4-1-为什么需要-redolog">3.4.1 为什么需要 Redolog</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-4-2-认识-redolog-机制">3.4.2 认识 Redolog 机制</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-4-3-redolog-与-undolog-的配合">3.4.3 Redolog 与 Undolog 的配合</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-4-4-redolog与数据分开写入磁盘的必要性">3.4.4 Redolog与数据分开写入磁盘的必要性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-4-5-redolog-的刷盘策略">3.4.5 Redolog 的刷盘策略</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-4-6-redolog-buffer-的刷盘时机">3.4.6 redolog buffer 的刷盘时机：</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-4-7-redolog-日志重写">3.4.7 Redolog 日志重写</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-5-binlog-重做日志">3.5 BinLog 重做日志</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-5-1-binlog-的作用">3.5.1 Binlog 的作用</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-5-2-binlog-刷盘策略">3.5.2 Binlog 刷盘策略</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-5-3-binlog-主从同步模型">3.5.3 Binlog - 主从同步模型</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-6-两阶段提交">3.6 两阶段提交</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-6-1-两阶段提交的提出">3.6.1 两阶段提交的提出</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-6-2-两阶段提交的概念">3.6.2 两阶段提交的概念</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-6-3-两阶段提交的过程">3.6.3 两阶段提交的过程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-6-4-两阶段提交有什么问题">3.6.4 两阶段提交有什么问题</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level4" href="#_3-6-5-对两阶段提交加强-加入组提交">3.6.5 对两阶段提交加强：加入组提交</a></li><!----><!--]--></ul></li><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content" vp-content><p>从理解 SQL 执行过程到理解MySQL 日志系统的工作过程。</p><!-- more --><h2 id="一、-一条-select-语句的执行过程" tabindex="-1"><a class="header-anchor" href="#一、-一条-select-语句的执行过程"><span>一、 一条 select 语句的执行过程</span></a></h2><p>一条查询语句执行的过程，属于<strong>读</strong>一条记录的过程，大致可以分为以下几个步骤：</p><ol><li><p><strong>建立客户端/服务器通信</strong>：</p><ul><li>客户端发起的连接请求，通过MySQL<code>连接器</code>处理后，客户端将SQL查询语句发送到服务器。</li></ul></li><li><p><strong>查询解析</strong>：</p><ul><li><strong>SQL解析器</strong>：<code>SQL解析器</code>首先会对查询语句进行语法和词法分析，生成一个解析树（Parse Tree）。</li><li><strong>预处理器</strong>：<code>预处理器</code>进一步检查解析树的合法性，包括表和列是否存在、名称是否正确等。</li></ul></li><li><p><strong>查询优化</strong>：</p><ul><li><strong>查询重写</strong>：<code>优化器</code>可能会对解析树进行重写，例如将子查询转换为连接（JOIN），或者进行某些常见的SQL重写优化。</li><li><strong>选择执行计划</strong>：<code>优化器</code>会生成多个执行计划，并选择其中的最优计划。这里会考虑索引的使用、表扫描的方式（全表扫描或索引扫描）等。</li><li><strong>成本估算</strong>：MySQL使用一种<code>基于成本的优化算法</code>，通过估算不同执行计划的代价，选择成本最低的计划。</li></ul></li><li><p><strong>查询执行</strong>：</p><ul><li><strong>存储引擎接口</strong>：MySQL的<code>执行器</code>根据优化器选择的执行计划，通过存储引擎接口调用具体的存储引擎（如InnoDB、MyISAM等）。</li><li><strong>存储引擎操作</strong>：存储引擎根据执行器的请求进行数据的读取、写入等操作。</li></ul></li><li><p><strong>结果返回</strong>：</p><ul><li><strong>结果集处理</strong>：执行器将存储引擎返回的数据进行处理，生成最终的<code>结果集</code>。</li><li><strong>结果发送</strong>：最终的结果集通过网络传输返回给客户端。</li></ul></li><li><p><strong>缓存处理（可选）</strong>：</p><ul><li><strong>查询缓存</strong>：如果查询缓存开启且命中缓存，MySQL会直接从缓存中返回结果，而不经过上述大部分步骤。需要注意的是，MySQL <strong>8.0 版本已移除查询缓存</strong>这一特性。</li></ul></li></ol><p>总结来说，MySQL一条查询语句的执行过程可以概括为：<code>客户端发送SQL语句 -&gt; 解析语句 -&gt; 优化查询 -&gt; 执行查询 -&gt; 返回结果</code>。每个步骤中都有许多细节和优化点，使得MySQL能够高效地处理各种查询请求。</p><p>引用小林图解的一张图： <img src="http://images.kryiea.cn/img/1717220312018.jpg" alt="1717220312018" loading="lazy"></p><h2 id="二、一条-update-语句的执行过程" tabindex="-1"><a class="header-anchor" href="#二、一条-update-语句的执行过程"><span>二、一条 update 语句的执行过程</span></a></h2><p><strong>比如这条待执行的 update 语句：</strong><code>UPDATE t_user SET name = &#39;kryiea&#39; WHERE id = 10086;</code></p><p><strong>待执行的语句执行过程：</strong></p><ol><li><code>select</code> 语句的那一套流程，<code>update</code> 语句也是同样会走一遍</li><li>查询到目标记录后，执行更新操作的同时会涉及对三种日志的改动，<code>undolog、redolog、binlog</code>。</li></ol><h2 id="三、三种日志、mvcc、bufferpool-之间的相互配合" tabindex="-1"><a class="header-anchor" href="#三、三种日志、mvcc、bufferpool-之间的相互配合"><span>三、三种日志、MVCC、BufferPool 之间的相互配合</span></a></h2><h3 id="_3-1-三种日志的主要作用" tabindex="-1"><a class="header-anchor" href="#_3-1-三种日志的主要作用"><span>3.1 三种日志的主要作用</span></a></h3><ul><li><strong>UndoLog 回滚日志：</strong> 是Innodb存储引擎层生成的日志，保证了事务中的原子性，主要用于事务回滚和MVCC。（撤销已经执行的修改，保证事务的原子性和一致性）</li><li><strong>RedoLog 重做日志：</strong> 是Innodb存储引擎层生成的日志，保证了事务中的持久性，主要用于掉电等故障恢复。（重做已经提交的修改，保证事务的持久性）</li><li><strong>BinLog 归档日志：</strong> 是 Server层 生成的日志，主要用于数据备份和主从复制。（记录和重放SQL语句，用于数据的复制和恢复）</li></ul><p><strong>⬇️辅助理解：</strong> InnoDB 存储引擎的日志：</p><ul><li>UndoLog 记录了此次事务 <code>开始前</code> 的数据状态，记录的是 <code>更新 之前 的值</code>；</li><li>RedoLog 记录了此次事务 <code>完成后</code> 的数据状态，记录的是 <code>更新 之后 的值</code>；</li></ul><p>Server 层的日志：</p><ul><li>BinLog 记录了完成一条更新操作后，Server 层还会生成一条 <code>binlog</code>，等之后事务提交的时候，会将该事物执行过程中产生的所有 <code>binlog</code> 统一写入 <code>binlog文件</code>。</li></ul><h3 id="_3-2-undolog-回滚日志" tabindex="-1"><a class="header-anchor" href="#_3-2-undolog-回滚日志"><span>3.2 UndoLog 回滚日志</span></a></h3><h4 id="_3-2-1-为什么需要-undolog" tabindex="-1"><a class="header-anchor" href="#_3-2-1-为什么需要-undolog"><span>3.2.1 为什么需要 UndoLog</span></a></h4><p><strong>先了解隐式事务：</strong> Innodb 引擎在执行一条<code>增删改</code>语句的时候，即使没有显式输入<code>begin开启事务</code>和<code>commit提交事务</code>，也会<strong>自动隐式开启事务</strong>。 而且执行一条 <code>update</code> 语句是否自动提交事务，是由 <code>autocommit</code> 参数决定，默认开启。</p><p><strong>试想以下场景：</strong> 在一个事务在执行过程中，在还没有提交事务之前，如果 MySQL 发生了崩溃，要怎么回滚到事务之前的数据呢？</p><p><strong>如何解决：</strong> 如果每次在事务执行过程中，都记录下回滚时需要的信息到一个日志（undolog）里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据。</p><h4 id="_3-2-2-认识-undolog-机制" tabindex="-1"><a class="header-anchor" href="#_3-2-2-认识-undolog-机制"><span>3.2.2 认识 Undolog 机制</span></a></h4><p>在事务没提交之前，MySQL 会<code>先记录更新前的数据到 undolog日志文件</code>，当事务需要回滚时，可以利用 <code>undolog</code> 来进行回滚。</p><p>过程如下图: <img src="http://images.kryiea.cn/img/20240601142819.png" alt="20240601142819" loading="lazy"></p><h4 id="_3-2-3-undolog-如何记录和回滚" tabindex="-1"><a class="header-anchor" href="#_3-2-3-undolog-如何记录和回滚"><span>3.2.3 Undolog 如何记录和回滚</span></a></h4><p>每当 InnoDB 引擎对一条记录进行操作时，要把回滚时需要的信息都记录到 <code>undolog</code> 里，比如：</p><ol><li>在 <code>插入</code> 一条记录时，要把这条记录的<strong>主键值</strong>记下来，这样<code>回滚</code>时只需要把这个主键值对应的记录 <code>delete</code> 就好了；</li><li>在 <code>删除</code> 一条记录时，要把这条<strong>记录中的内容</strong>都记下来，这样<code>回滚</code>时再把由这些内容组成的记录 <code>insert</code> 到表中就好了；</li><li>在 <code>更新</code> 一条记录时，要把<strong>被更新的列的旧值</strong>记下来，这样<code>回滚</code>时再把这些列<code> update</code> 为旧值就好了。</li></ol><h4 id="_3-2-4-undolog-日志的格式" tabindex="-1"><a class="header-anchor" href="#_3-2-4-undolog-日志的格式"><span>3.2.4 Undolog 日志的格式</span></a></h4><p><strong>需要了解一条记录在innodb引擎中的存储格式。</strong></p><p>一条记录的每一次更新操作产生的 <code>undolog</code> 中，都有一个 <code>roll_pointer 指针</code>和一个 <code>trx_id 事务id</code>：</p><ul><li>通过 <code>trx_id</code> 可以知道该记录是被哪个事务修改的。</li><li>通过 <code>roll_pointer</code> 指针可以将这些 <code>undolog</code> 串成一个链表，这个链表就被称为<strong>版本链</strong>。</li></ul><p><strong>版本链如下图：</strong><img src="http://images.kryiea.cn/img/1.png" alt="1" loading="lazy"></p><h4 id="_3-2-5-undolog-readview-实现-mvcc" tabindex="-1"><a class="header-anchor" href="#_3-2-5-undolog-readview-实现-mvcc"><span>3.2.5 Undolog + ReadView 实现 MVCC</span></a></h4><p><strong>MVCC - Multi-version concurrency control</strong> 多版本并发控制（MVCC）是一种数据库管理技术，通过维护数据的多个版本来实现并发访问，从而提高读写操作的性能和一致性。</p><p><strong>并发访问的多个版本通过快照控制：</strong> 对于<code>读提交</code>和<code>可重复读</code>隔离级别的事务来说，它们的<code>快照读</code>（普通 <code>select</code> 语句）是通过 <code>ReadView + undolog</code> 来实现的。 <code>读提交</code> 和 <code>可重复读</code> 的 <code>快照读</code> 区别在于创建 ReadView 的时机不同：</p><ul><li><code>读提交隔离级别</code>：<strong>每次执行 select 都会生成一个新的 ReadView</strong>，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li><code>可重复读隔离级别</code>：在启动事务时生成一个 ReadView，然后<strong>整个事务期间都在用这个 ReadView</strong>，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p><strong>如何知道版本的可见性，参考 <code>3.2.6</code> ：</strong> 通过 <code>事务的 ReadView 里的字段 </code>和 <code>记录中的两个隐藏列 trx_id 和 roll_pointer</code> 的比对，如果不满足可见行，就会顺着 <code>undolog 版本链</code>里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）</p><h4 id="_3-2-6-readview-机制" tabindex="-1"><a class="header-anchor" href="#_3-2-6-readview-机制"><span>3.2.6 ReadView 机制</span></a></h4><p><strong>ReadView 的四个字段：</strong><img src="http://images.kryiea.cn/img/20240601154137.png" alt="20240601154137" loading="lazy"> ReadView 可以理解为记录<code>当前事务id</code>创建时，整个数据库还有哪些其他活着的事务，记录下来，以便于判断数据的可见性。</p><ul><li><code>creator_trx_id</code>：代表创建当前这个 ReadView 的事务ID。</li><li><code>m_ids</code>：表示在生成当前 ReadView 时，系统内活跃且未提交的事务ID列表。</li><li><code>min_trx_id</code>：活跃的事务列表中最小的事务ID。</li><li><code>max_trx_id</code>：表示在生成当前 ReadView 时，系统中要给下一个事务分配的ID值</li></ul><p><strong>如何判断可见性：</strong> 判定方法：<code>事务 readview 里的字段</code> 与 <code>记录中的两个隐藏列</code> 进行对比：</p><ul><li>如果<code>事务ReadView 中的 min_trx_id 值</code> <strong>&gt;=</strong> <code>记录的 trx_id 值</code>，表示这个版本的记录是在创建 ReadView 前 已经提交的事务生成的，所以该版本的记录对当前事务 <strong>可见</strong> 。</li><li>如果<code>事务ReadView 中的 max_trx_id 值</code> <strong>&lt;=</strong> <code>记录的 trx_id 值</code>，表示这个版本的记录是在创建 ReadView 后 才启动的事务生成的，所以该版本的记录对当前事务 <strong>不可见</strong> 。</li><li>如果 <code>事务ReadView 中的 min_trx_id</code> <strong>&lt;</strong> <code>记录的 trx_id 值</code> <strong>&lt;</strong> <code>事务ReadView 中的 max_trx_id</code>，需要判断 <code>trx_id</code> 是否在 <code>m_ids</code> 列表中： <ul><li>如果<code>记录的 trx_id</code> 在 <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务 <strong>不可见</strong> 。</li><li>如果<code>记录的 trx_id</code> 不在 <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务 <strong>可见</strong> 。</li></ul></li></ul><h4 id="_3-2-7-undolog-如何刷盘的" tabindex="-1"><a class="header-anchor" href="#_3-2-7-undolog-如何刷盘的"><span>3.2.7 UndoLog 如何刷盘的</span></a></h4><ul><li><code>Undolog</code> 和 <code>数据页</code> 的刷盘策略是一样的，都需要<strong>通过 Redolog 保证持久化</strong>。</li><li><code>Buffer pool</code> 中有 <code>Undo 页</code>，对 <code>Undo 页</code>的修改也都会<strong>记录到 Redolog</strong>。</li><li><code>Redolog</code> 会每秒刷盘，提交事务时也会刷盘，<code>数据页</code>和 <code>Undo 页</code>都是靠这个机制保证持久化的。</li></ul><h3 id="_3-3-buffer-pool-缓冲池" tabindex="-1"><a class="header-anchor" href="#_3-3-buffer-pool-缓冲池"><span>3.3 Buffer Pool 缓冲池</span></a></h3><h4 id="_3-3-1-buffer-pool-的意义" tabindex="-1"><a class="header-anchor" href="#_3-3-1-buffer-pool-的意义"><span>3.3.1 Buffer Pool 的意义</span></a></h4><p><strong>场景：</strong> MySQL 的数据都是存在磁盘中的，那么我们要更新一条记录的时候，得先要从磁盘读取该记录，然后在<strong>内存中</strong>修改这条记录。</p><p><strong>那修改完这条记录是选择直接写回到磁盘，还是选择缓存起来呢：</strong> 这也是<code> Buffer Pool</code> 的意义。 当然是缓存起来好，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。</p><p><strong>有了Buffer Pool后：</strong></p><ul><li>当读取数据时，如果数据存在于 <code>BufferPool</code> 中，客户端就会直接读取 <code>BufferPool</code> 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 <code>Buffe Pool</code> 中，那直接修改 <code>BufferPool</code> 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘<code>I/O</code>，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul><p><strong>Buffer Pool 属于哪一层：</strong> 属于：Innodb引擎层。 区别：不是本文开头讨论 <code>select</code> 语句执行过程中提到的缓存，那个是在 server 层的。</p><h4 id="_3-3-2-buffer-pool-缓存什么" tabindex="-1"><a class="header-anchor" href="#_3-3-2-buffer-pool-缓存什么"><span>3.3.2 Buffer Pool 缓存什么</span></a></h4><p><strong>InnoDB中磁盘与内存的交互基本单位：</strong> InnoDB 会把存储的数据划分为若干个<code>页</code>，以<strong>页作为磁盘和内存交互的基本单位</strong>，一个页的默认大小为 <code>16KB</code>。因此，<code>BufferPool</code> 同样需要按页来划分，使用与存储引擎一样的基本单位。</p><p><strong>在 MySQL 启动的时候：</strong> InnoDB 会为 BufferPool 申请一片连续的内存空间，然后按照默认的 <code>16KB</code> 的大小划分出一个个的页， BufferPool 中的页就叫做<strong>缓存页</strong>。 此时这些缓存页都是空闲的，之后随着程序的运行，会有磁盘上的页被加载缓存到 BufferPool 中的缓存页。</p><p><strong>在 MySQL 启动完成的时候：</strong> 由于是先申请了一片连续的内存空间但没写入具体数据，所以可以观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小。 这是因为只有这些虚拟内存被访问后，操作系统才会触发<code>缺页中断</code>，申请物理内存，接着将虚拟地址和物理地址建立映射关系。</p><p><strong>BufferPool 可以缓存的数据类型：</strong><img src="http://images.kryiea.cn/img/mysql-BufferPool.drawio.png" alt="mysql-BufferPool.drawio" loading="lazy"></p><p><strong>Undo 页是记录什么的</strong> 开启事务后，InnoDB 会在<strong>更新记录之前</strong>，先记录相应操作的 <code>undolog</code> 来保证事务的<strong>原子性</strong>。</p><p>比如：如果是 <code>update</code> 操作，需要把被更新的列的旧值记下来，旧值作为一条 <code>undolog</code>，然后把这条 <code>undolog</code> 写入 <code>BufferPool</code> 中的 <code>Undo页</code></p><p><strong>查询一条记录，只需要缓存一条记录吗？</strong> 刚刚提到了 InnoDB 存储引擎以<code>16KB大小的页</code>作为磁盘与内存交互的基本单位，所以查询一条记录的时候，会将整个页加载进 BufferPool 中，再通过页的<code>页目录</code>去定位到某条具体的记录.</p><p><strong>上面提到的 页目录 是什么？</strong> 简单来说：<code>页目录</code>类似于<code>字典的目录</code>，用于快速定位某条记录的大致位置。</p><p>这个问题需要了解一个 <code>页</code> 内部是如何组织数据的。小林图解也有提到，这里附上一张更具体的图来辅助理解。</p><ul><li>一个页空间会被划分成许多部分，有：<code>文件头、页头、最大最小记录、用户记录、空闲空间、文件尾</code>等。</li><li>主要关注<code>用户记录</code>：存储的一行行记录会被存放在这里，记录还会进一步被分成一个个<code>组</code>，每一个组内部都有一些数据记录。</li><li>再看到左边的<code>页目录</code>：有一个个的<code>槽位</code>，其指向每一个分组内的最后一条记录。</li></ul><figure><img src="http://images.kryiea.cn/img/mysql-4.drawio.png" alt="mysql-4.drawio" tabindex="0" loading="lazy"><figcaption>mysql-4.drawio</figcaption></figure><h4 id="_3-3-3-buffer-pool-刷盘策略" tabindex="-1"><a class="header-anchor" href="#_3-3-3-buffer-pool-刷盘策略"><span>3.3.3 Buffer Pool 刷盘策略</span></a></h4><p><strong>深入学习文章推荐：</strong><a href="https://juejin.cn/post/7159071309354254373?searchId=202406022326056D88E4CF0875DE59F736#heading-7" target="_blank" rel="noopener noreferrer">(十二)MySQL之内存篇：深入探寻数据库内存与Buffer Pool的奥妙！ - 竹子爱熊猫</a></p><h3 id="_3-4-redolog-重做日志" tabindex="-1"><a class="header-anchor" href="#_3-4-redolog-重做日志"><span>3.4 RedoLog 重做日志</span></a></h3><h4 id="_3-4-1-为什么需要-redolog" tabindex="-1"><a class="header-anchor" href="#_3-4-1-为什么需要-redolog"><span>3.4.1 为什么需要 Redolog</span></a></h4><p><strong>试想以下场景：</strong> Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p><strong>解决方案：</strong> 采用 <code>WAL (Write-Ahead Logging)</code> 技术。</p><ul><li>MySQL 的写操作并不是立刻写到磁盘上，而是先写日志文件，然后在合适的时间再将新的记录写到磁盘上。</li><li>在事务提交时，数据库系统只需确保 redolog 已经写入磁盘，而数据页可以稍后再写入。</li></ul><p><strong>解决方案的场景：</strong> 当有一条记录需要更新的时候，InnoDB 引擎会先更新 <code>Buffer Pool</code> 中的数据页，同时将该页标记为<code>脏页</code>。然后，将本次对<code>这个页修改后的数据状态</code>以 <code>redo log</code> 的形式记录下来并写入 <code>redo log</code> 文件，这时更新操作就算完成了。</p><p>到这里，只是完成了 <code>redo log</code> 文件的刷盘，但还未完成将<strong>最新的数据记录</strong>（脏的数据页）刷盘到存储表数据的文件 <code>xxx.ibd</code> 中。简而言之：日志文件是最新的，但数据库文件还不是最新的，还需要完成最后的 <code>Buffer Pool --&gt; 磁盘</code> 操作，才能完成持久化存储。</p><p>后续，InnoDB 引擎会在适当的时候，由<code>后台线程</code>将缓存在 <code>Buffer Pool</code> 的脏页刷新到磁盘里，这就是 WAL 的核心思想。</p><p><strong>图示，第4步的细节参考 <code>3.4.5</code>：</strong><img src="http://images.kryiea.cn/img/mysql-1WAL.drawio.png" alt="mysql-1WAL.drawio" loading="lazy"></p><h4 id="_3-4-2-认识-redolog-机制" tabindex="-1"><a class="header-anchor" href="#_3-4-2-认识-redolog-机制"><span>3.4.2 认识 Redolog 机制</span></a></h4><p>redolog 是物理日志，记录了某个数据页做了什么修改</p><p><strong>如何记录这个 “修改”：</strong> 格式：<code>AAA表空间 中的 BBB数据页 的 CCC偏移量 的地方做了 DDD的更新</code>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p><strong>WAL：</strong> 在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><p><strong>如何保证事务的持久性：</strong> 当系统崩溃时，虽然脏页数据没有持久化，但是 redolog 已经持久化，MySQL 能在重启后根据 redolog 的日志内容，将所有数据恢复到最新的状态。</p><h4 id="_3-4-3-redolog-与-undolog-的配合" tabindex="-1"><a class="header-anchor" href="#_3-4-3-redolog-与-undolog-的配合"><span>3.4.3 Redolog 与 Undolog 的配合</span></a></h4><p><strong>配合场景：</strong> 开启事务后，InnoDB 在进行更新操作之前，首先会记录相应的 undolog。</p><p>如果是更新操作，InnoDB 需要将被更新的列的旧值记下来，也就是生成一条 undolog。这个 undolog 会被写入 Buffer Pool 中的 Undo 页面。 然后在 BufferPool 中完成数据页的更新，标记该页为脏页，并且记录对于的 redolog。</p><p><strong>具体的配合过程：</strong></p><ol><li><strong>记录 undolog：</strong></li></ol><ul><li>当事务对数据库中的记录进行更新时，InnoDB 会先生成一条 <code>undolog</code>，记录被修改前的数据。这个操作是为了保证在事务回滚时能够恢复到原始状态。</li><li>生成的 undolog 会被写入 BufferPool 中的 <code>Undo 页面</code>，并在内存中进行修改。</li></ul><ol start="2"><li><strong>记录 redolog：</strong></li></ol><ul><li>在内存中修改 <code>Undo 页面</code>后，InnoDB 还需要记录对应的 <code>redo log</code>。<code>redo log</code> 记录的是对数据页的物理修改操作，是用来在系统崩溃后进行数据恢复的。</li><li>具体来说，<code>redo log</code> 会记录对数据页的修改操作细节，包括何时修改、修改了哪些数据等。这些信息会先写入 <code>redolog buffer</code> 中，并在适当的时机（例如事务提交时）刷写到磁盘上的 <code>redo log</code> 文件中。</li></ul><p><strong>Redolog Buffer 与 Buffer Pool</strong> 不一样! Redolog Buffer 是 redolog 自己的缓存 具体细节往下看。</p><h4 id="_3-4-4-redolog与数据分开写入磁盘的必要性" tabindex="-1"><a class="header-anchor" href="#_3-4-4-redolog与数据分开写入磁盘的必要性"><span>3.4.4 Redolog与数据分开写入磁盘的必要性</span></a></h4><p><strong>能提高数据库的写性能：</strong></p><ul><li><strong>顺序写入：</strong><ul><li><code>redo log</code> 的写入是顺序写入，采用在文件尾部追加写入文件的方式，这样可以减少磁盘的寻道时间和旋转延迟，从而提高写入速度。</li><li>顺序写入的性能通常比随机写入高</li></ul></li><li><strong>随机写入：</strong><ul><li><code>数据页</code>的写入通常是随机写入。随机写入是指数据写入磁盘的不同位置，写入速度较慢。</li><li>通过将<code>数据页</code>首先写入缓冲池（Buffer Pool），然后在适当时机批量写入磁盘，可以减少随机写入的频率和次数。</li></ul></li></ul><h4 id="_3-4-5-redolog-的刷盘策略" tabindex="-1"><a class="header-anchor" href="#_3-4-5-redolog-的刷盘策略"><span>3.4.5 Redolog 的刷盘策略</span></a></h4><p>执行一个事务的过程中，产生的 <code>redo log</code> 也不是直接写入磁盘的，因为这样会产生大量的 <code>I/O</code> 操作，而且磁盘的运行速度远慢于内存。 所以，<code>redo log</code> 也有自己的缓存 <code>redo log buffer</code> ，每当产生一条 <code>redo log</code> 时，会先写入到 <code>redo log buffer</code>，后续再持久化到磁盘.</p><p><code>redo log buffer</code> 默认大小 <code>16 MB</code>，可以通过 <code>innodb_log_Buffer_size</code> 参数动态的调整大小，增大它的大小可以让 MySQL 处理大事务时不必写入磁盘（提高了写入磁盘的阈值），进而提升写 <code>IO</code> 性能。</p><p><code>redo log buffer</code> 的持久化如下图： <img src="http://images.kryiea.cn/img/20240602172013.png" alt="20240602172013" loading="lazy"></p><h4 id="_3-4-6-redolog-buffer-的刷盘时机" tabindex="-1"><a class="header-anchor" href="#_3-4-6-redolog-buffer-的刷盘时机"><span>3.4.6 redolog buffer 的刷盘时机：</span></a></h4><p><strong>主要的几个刷盘时机：</strong></p><ol><li>MySQL 正常关闭时。</li><li>当 <code>redo log buffer</code> 中记录的写入量<code>大于 redo log buffer 内存空间的一半</code>时，会触发落盘。</li><li>InnoDB 的<code>后台线程每隔 1 秒</code>，将 <code>redo log buffer</code> 持久化到磁盘。</li><li><code>每次事务提交时</code>都将缓存在 <code>redo log buffer</code> 里的 <code>redo log</code> 直接持久化到磁盘（这个策略可由 <code>innodb_flush_log_at_trx_commit</code> 参数控制）。</li></ol><p><strong>了解一个主要参数 <code>innodb_flush_log_at_trx_commit</code>:</strong></p><ul><li><code>innodb_flush_log_at_trx_commit = 0</code> 每次事务提交时 ，还是将 <code>redo log</code> 留在 <code>redo log buffer</code> 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li><li><code>innodb_flush_log_at_trx_commit = 1</code> 这是默认值。 每次事务提交时，都 将缓存在 <code>redo log buffer</code> 里的 <code>redo log</code> 直接持久化到磁盘 ，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li><code>innodb_flush_log_at_trx_commit = 2</code> 每次事务提交时，都只是缓存在 <code>redo log buffer</code> 里的 <code>redo log</code> 写到 <code>redo log 文件</code>，注意并不意味着写入到了磁盘 ，因为操作系统的文件系统中有个 <code>Page Cache</code>（Page Cache 是专门用来缓存文件数据的，所以写入 <code>redo log文件</code>意味着写入到了操作系统的文件缓存。</li></ul><h4 id="_3-4-7-redolog-日志重写" tabindex="-1"><a class="header-anchor" href="#_3-4-7-redolog-日志重写"><span>3.4.7 Redolog 日志重写</span></a></h4><p><strong>问题背景：</strong> redolog 文件写满了/文件过大怎么办？</p><p><strong>解决方案 - 日志重写：</strong> 默认情况下，InnoDB 存储引擎有 1 个<code>重做日志文件组 redo log Group</code>，由 2 个 <code>redolog 文件</code> 组成，分别是：<code>ib_logfile0</code> 和 <code>ib_logfile1</code>。</p><p><strong>日志重写方式：循环写</strong><code>重做日志文件组</code>是以 <code>循环写</code> 的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。 先写 <code>ib_logfile0</code> 文件，当 <code>ib_logfile0</code> 文件被写满的时候，会切换至 <code>ib_logfile1</code> 文件，当 <code>ib_logfile1</code> 文件也被写满时，会切换回 <code>ib_logfile0</code> 文件。</p><p>图示： <img src="http://images.kryiea.cn/img/20240602173429.png" alt="20240602173429" loading="lazy"></p><h3 id="_3-5-binlog-重做日志" tabindex="-1"><a class="header-anchor" href="#_3-5-binlog-重做日志"><span>3.5 BinLog 重做日志</span></a></h3><h4 id="_3-5-1-binlog-的作用" tabindex="-1"><a class="header-anchor" href="#_3-5-1-binlog-的作用"><span>3.5.1 Binlog 的作用</span></a></h4><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用，用于备份恢复、主从复制等；</li><li>binlog 文件是记录了<code>所有数据库表结构变更和表数据修改</code>的日志，<strong>不会记录查询类的操作</strong>，比如 <code>SELECT</code> 和 <code>SHOW</code> 操作。</li><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，<strong>不会覆盖</strong>以前的日志，保存的是全量的日志。</li></ul><p><strong>产生 binlog 的场景：</strong> MySQL 在完成一条更新操作后，Server 层会生成一条 <code>binlog</code>，将其写到 <code>binlog cache</code>（Server 层的 cache），等之后<strong>事务提交的时候</strong>，会将该事务执行过程中产生的所有 <code>binlog</code> 统一写入 <code>binlog 文件</code>。</p><h4 id="_3-5-2-binlog-刷盘策略" tabindex="-1"><a class="header-anchor" href="#_3-5-2-binlog-刷盘策略"><span>3.5.2 Binlog 刷盘策略</span></a></h4><p><strong>MySQL 给每一个处理线程分配了一片内存用于缓冲 binlog，该内存叫 <code>binlog cache</code>。</strong></p><p>事务执行过程中，先把日志写到 <code>binlog cache</code>，事务提交的时候，再把 <code>binlog cache</code> 写到 <code>binlog 文件</code>中。</p><p><strong>关键点1：</strong> 一个事务的 <code>binlog</code> 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。</p><p>MySQL 设定一个处理线程只能同时有一个事务在执行，所以每当执行一个 <code>begin/start transaction</code> 的时候，就会默认提交上一个事务。</p><p><strong>关键点2：</strong> 场景：什么时候 <code>binlog cache</code> 会写到 <code>binlog 文件</code>？</p><p>回答：在<strong>事务提交的时候</strong>，执行器把 <code>binlog cache</code> 里的完整事务写入到 <code>binlog 文件</code>中，并<strong>清空</strong> <code>binlog cache</code>。</p><p><strong>关键点3：</strong> 每一个线程都有自己的<code>binlog cache</code>，最终写入<strong>同一个</strong><code>Binlog文件</code></p><p><strong>关键点4：</strong> 场景：如<code>关键点3</code>所提到的 最终写入同一个<code>Binlog文件</code>，那这里的并发问题如何解决？</p><p>回答：MySQL采用了多种机制来确保并发安全和一致性</p><ol><li>锁机制</li><li>顺序写入</li><li>组提交 Group Commit</li></ol><p><strong>关键点5：</strong> 场景：写入binlog文件的过程还可以继续拆分。</p><ul><li>系统调用 <code>write()</code>后，会先写入内核的缓冲区 <code>page cache</code>，这里不涉及磁盘<code>I/O</code></li><li>内核再通过 <code>fsync()</code> 持久化到磁盘，这里涉及磁盘<code>I/O</code>。频繁的 <code>fsync()</code> 会导致磁盘的<code>I/O</code> 升高。</li></ul><figure><img src="http://images.kryiea.cn/img/20240603001559.png" alt="20240603001559" tabindex="0" loading="lazy"><figcaption>20240603001559</figcaption></figure><p><strong>关键点6：</strong><code>fsync()</code> 的频率由参数 <code>sync_binlog</code> 控制</p><ul><li><code>sync_binlog = 0</code> 是默认值 表示每次提交事务都只 <code>write</code>，不 <code>fsync</code>，后续交由操作系统决定何时将数据持久化到磁盘。</li><li><code>sync_binlog = 1</code> 表示每次提交事务都会 <code>write</code>，然后马上执行 <code>fsync</code>，最多丢失一个事务的 <code>binlog</code>。</li><li><code>sync_binlog &gt; 1</code> 表示每次提交事务都 <code>write</code>，但累积 <code>N</code> 个事务后才 <code>fsync</code>。</li></ul><h4 id="_3-5-3-binlog-主从同步模型" tabindex="-1"><a class="header-anchor" href="#_3-5-3-binlog-主从同步模型"><span>3.5.3 Binlog - 主从同步模型</span></a></h4><p><strong>主从同步过程：</strong></p><ol><li><strong>写入 binlog：</strong> 主库修改数据后，写入 <code>binlog 日志</code>，提交事务，更新本地存储的数据。</li><li><strong>同步 binlog：</strong> 从库连接到主库后，主库会创建一个 <code>dump 线程</code>，把 <code>binlog</code> 同步到所有从库，每个从库把 <code>binlog</code> 写到暂存日志中。</li><li><strong>回放 binlog：</strong> 从库启动一个 <code>sql 线程</code>去回放 <code>binlog</code>，去读 <code>relay log 中继日志</code>然后回放 <code>binlog</code> 更新数据。 <img src="http://images.kryiea.cn/img/20240603002541.png" alt="20240603002541" loading="lazy"></li></ol><p><strong>三种主从同步模式：</strong> MySQL 默认的同步模式：异步模式</p><ul><li><strong>同步模式：</strong> 主库提交事务的线程要等待所有从库的同步成功，才返回客户端结果。性能最差了。</li><li><strong>异步模式：</strong> 主库提交事务的线程不会等待 binlog 同步完成就返回客户端结果，性能最好，但是主库宕机，数据就会丢失。</li><li><strong>半同步模式：</strong> 比如一主二从的集群，只要成功同步到一个从库，就立即返回数据给客户端。即使主库宕机，仍有一个从库有最新数据。</li></ul><h3 id="_3-6-两阶段提交" tabindex="-1"><a class="header-anchor" href="#_3-6-两阶段提交"><span>3.6 两阶段提交</span></a></h3><h4 id="_3-6-1-两阶段提交的提出" tabindex="-1"><a class="header-anchor" href="#_3-6-1-两阶段提交的提出"><span>3.6.1 两阶段提交的提出</span></a></h4><p><strong>思考以下问题：</strong> 事务提交后，<code>redo log</code> 和 <code>binlog</code> 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p><strong>问题的场景复现：</strong></p><p>原数据：表名 <code>t_user</code>，某行记录 <code>id = 1；name = jay</code> 执行SQL：<code>UPDATE t_user SET name = &#39;kryiea&#39; WHERE id = 1</code> 事务提交后：进行持久化 <code>redolog</code>和 <code>binlog</code>。</p><p>这两个日志的刷盘<strong>先后顺序</strong>可能会导致下面两种情况：</p><ul><li>如果在将 <code>redo log</code> 刷入到磁盘之后， MySQL 突然宕机了，而 <code>binlog</code> 还没有来得及写入。 <ul><li>MySQL 重启后，通过 <code>redo log</code> 能将 <code>Buffer Pool</code> 中 <code>id = 1</code> 这行数据的 <code>name</code> 字段恢复到新值 <code>kryiea</code>。</li><li>但是 <code>binlog</code> 里面没有记录这条更新语句，在主从架构中，<code>binlog</code> 会被复制到从库，由于 <code>binlog</code> 丢失了这条更新语句，从库的这一行 <code>name</code> 字段是旧值 <code>jay</code>，与主库的值不一致。</li></ul></li><li>如果在将 <code>binlog</code> 刷入到磁盘之后， MySQL 突然宕机了，而 <code>redo log</code> 还没有来得及写入 。 <ul><li>由于 <code>redo log</code> 还没写，崩溃恢复以后这个事务无效，所以 <code>id = 1</code> 这行数据的 <code>name</code> 字段还是旧值 <code>jay</code>。</li><li>而 <code>binlog</code> 里面记录了这条更新语句，在主从架构中，<code>binlog</code> 会被复制到从库，从库执行了这条更新语句，那么这一行 <code>name</code> 字段是新值 <code>kryiea</code>，与主库的值不一致。</li></ul></li></ul><p><strong>问题的解决方案：</strong> 两阶段提交</p><h4 id="_3-6-2-两阶段提交的概念" tabindex="-1"><a class="header-anchor" href="#_3-6-2-两阶段提交的概念"><span>3.6.2 两阶段提交的概念</span></a></h4><p>两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p>两阶段提交把<strong>单个事务</strong>的提交拆分成了 2 个阶段，分别是<code>准备（Prepare）阶段</code>和<code>提交（Commit）阶段</code> ，每个阶段都由<code>协调者（Coordinator）</code>和<code>参与者（Participant）</code>共同完成。</p><p><strong>协调者与参与者之间的协作：</strong> 例子来自小林图解。</p><p>举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？</p><ul><li><strong>准备阶段 ：</strong> 裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。</li><li><strong>提交阶段 ：</strong> 如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。</li></ul><h4 id="_3-6-3-两阶段提交的过程" tabindex="-1"><a class="header-anchor" href="#_3-6-3-两阶段提交的过程"><span>3.6.3 两阶段提交的过程</span></a></h4><p>在 MySQL 的 InnoDB 存储引擎中，开启 <code>binlog</code> 的情况下，MySQL 会同时维护 <code>binlog</code>与 <code>redolog</code>，为了保证这两个日志的一致性，MySQL 事务提交时使用 <code>内部 XA 事务</code> 来保证一致性。</p><p><code>内部 XA 事务</code>由 <code>binlog 作为协调者</code>，<code>存储引擎是参与者</code>。</p><p>（是的，也有外部 XA 事务）</p><p>当客户端执行 <code>commit</code> 语句或者在<code>自动提交</code>的情况下，MySQL 内部开启一个<code> XA 事务</code>， 分两阶段来完成 <code>XA 事务</code>的提交 。</p><p><strong>场景举例：</strong> 事务的提交过程有两个阶段：将 <code>redolog</code> 的写入拆成了两个步骤 <code>prepare</code> 和 <code>commit</code>，中间再<strong>穿插</strong>写入 <code>binlog</code>。</p><p><strong>具体如下：</strong></p><ul><li><p><code>prepare 阶段</code> ：将 <code>XID（内部 XA 事务的 ID）</code> 写入到 <code>redo log</code>，同时将 <code>redo log</code> 对应的事务状态设置为 <code>prepare</code>，然后将 <code>redo log</code> 持久化到磁盘（<code>innodb_flush_log_at_trx_commit = 1</code> 的作用）</p></li><li><p><code>commit 阶段</code> ：把 <code>XID</code> 写入到 <code>binlog</code>，然后将 <code>binlog</code> 持久化到磁盘（<code>sync_binlog = 1</code> 的作用），接着调用引擎的提交事务接口，将 <code>redo log</code> 状态设置为 <code>commit</code>，此时该状态并不需要持久化到磁盘，只需要 <code>write</code> 到文件系统的 <code>page cache</code> 中就够了。因为只要 <code>binlog</code> 写磁盘成功，就算 <code>redo log</code> 的状态还是 <code>prepare</code> 也没有关系，一样会被认为<strong>事务已经执行成功</strong>；</p></li></ul><figure><img src="http://images.kryiea.cn/img/20240603005031.png" alt="20240603005031" tabindex="0" loading="lazy"><figcaption>20240603005031</figcaption></figure><h4 id="_3-6-4-两阶段提交有什么问题" tabindex="-1"><a class="header-anchor" href="#_3-6-4-两阶段提交有什么问题"><span>3.6.4 两阶段提交有什么问题</span></a></h4><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差。</p><p><strong>主要有两个方面的影响：</strong></p><ul><li><strong>磁盘 I/O 次数高 ：</strong> 对于“双1”配置，每个事务提交都会进行两次 <code>fsync</code>（刷盘），一次是 <code>redo log 刷盘</code>，另一次是 <code>binlog 刷盘</code>。</li><li><strong>锁竞争激烈 ：</strong> 两阶段提交虽然能够保证<code>单事务</code>两个日志的内容一致，但在<code>多事务</code>的情况下，却<strong>不能保证两者的提交顺序一致</strong>，因此，在两阶段提交的流程基础上，还需要加一个<code>锁</code>来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><h4 id="_3-6-5-对两阶段提交加强-加入组提交" tabindex="-1"><a class="header-anchor" href="#_3-6-5-对两阶段提交加强-加入组提交"><span>3.6.5 对两阶段提交加强：加入组提交</span></a></h4><p>MySQL 引入了<code>组提交（group commit）</code>机制，当有<strong>多个事务提交</strong>的时候，会将多个 <code>binlog</code> 刷盘操作合并成<code>1</code>个，从而减少磁盘 <code>I/O</code> 的次数。</p><p>引入了组提交机制后，<code>prepare 阶段</code>不变，只针对 <code>commit 阶段</code>，将 <code>commit 阶段</code>拆分为<code>3</code>个过程： ● <strong>flush 阶段 ：</strong> 多个事务<strong>按进入的顺序</strong>将 <code>binlog</code> 从 <code>cache</code> 写入文件（不刷盘）； ● <strong>sync 阶段 ：</strong> 对 <code>binlog</code> 文件做 <code>fsync</code> 操作（多个事务的 <code>binlog</code> 合并一次刷盘）； ● <strong>commit 阶段 ：</strong> 各个事务<strong>按顺序</strong>做 <code>InnoDB commit 操作</code>；</p><figure><img src="http://images.kryiea.cn/img/20240603010701.png" alt="20240603010701" tabindex="0" loading="lazy"><figcaption>20240603010701</figcaption></figure></div><!----><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><span class="vp-meta-info" data-allow-mismatch="text">2024/12/4 10:00:52</span></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 1582877056@qq.com">kryiea</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><!----><div class="vp-copyright">Copyright © 2025 kryiea </div></footer></div><!--]--><!--[--><!----><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-Du3lVt_7.js" defer></script>
  </body>
</html>
